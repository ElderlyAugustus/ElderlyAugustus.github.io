<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY | xα&#39;s blog</title>
<meta name="keywords" content="基于物理的动画">
<meta name="description" content="注：本篇由同组同学LLY编写，本人代完成格式化
刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。
刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \(\mathbf x\) 和速度 \(\mathbf v\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。
质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \(\mathbf x\) 和 方向 \(R\) 。局部坐标为 \(\mathbf p_0\) 的点，世界坐标系下的坐标为：\(\mathbf p = \mathbf x &#43; R \mathbf p_0\)
物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = &#43; R &#43; p_0 $
因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v &#43; p_0 $
所以我们只需要求出每个时间的 \(\mathbf v\) 和 $ $ 就可以描述刚体随时间的运动状态了。
为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。
角速度 我们知道 \(R\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \[ \displaystyle\dot{R} = [\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ] \] 于是 \(\dot{R}\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \(\mathbf x\) ，旋转点位置是 \(\mathbf p\) ，旋转中心到位置 \(\mathbf p\) 的向量为 \(r\) 。我们的目的是测定 \(r\) 的变化率。由于 \(\mathbf p\) 以角速度 \(\omega\) 旋转，所以其瞬时速度与 \(r\) 和 \(\omega\) 垂直。瞬时速度方向由 \(\omega\times r\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$">
<meta name="author" content="xα">
<link rel="canonical" href="//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly.html">
<link crossorigin="anonymous" href="../assets/css/stylesheet.min.css" rel="preload stylesheet" as="style">
<link rel="icon" href="//elderlyaugustus.github.io/icons/favicon.ico">
<link rel="apple-touch-icon" href="//elderlyaugustus.github.io/icons/apple-touch-icon.png">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY | xα&#39;s blog" />
<meta name="twitter:description" content="注：本篇由同组同学LLY编写，本人代完成格式化
刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。
刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \(\mathbf x\) 和速度 \(\mathbf v\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。
质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \(\mathbf x\) 和 方向 \(R\) 。局部坐标为 \(\mathbf p_0\) 的点，世界坐标系下的坐标为：\(\mathbf p = \mathbf x &#43; R \mathbf p_0\)
物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = &#43; R &#43; p_0 $
因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v &#43; p_0 $
所以我们只需要求出每个时间的 \(\mathbf v\) 和 $ $ 就可以描述刚体随时间的运动状态了。
为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。
角速度 我们知道 \(R\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \[ \displaystyle\dot{R} = [\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ] \] 于是 \(\dot{R}\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \(\mathbf x\) ，旋转点位置是 \(\mathbf p\) ，旋转中心到位置 \(\mathbf p\) 的向量为 \(r\) 。我们的目的是测定 \(r\) 的变化率。由于 \(\mathbf p\) 以角速度 \(\omega\) 旋转，所以其瞬时速度与 \(r\) 和 \(\omega\) 垂直。瞬时速度方向由 \(\omega\times r\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$" />
<meta property="og:title" content="2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY | xα&#39;s blog" />
<meta property="og:description" content="注：本篇由同组同学LLY编写，本人代完成格式化
刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。
刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \(\mathbf x\) 和速度 \(\mathbf v\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。
质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \(\mathbf x\) 和 方向 \(R\) 。局部坐标为 \(\mathbf p_0\) 的点，世界坐标系下的坐标为：\(\mathbf p = \mathbf x &#43; R \mathbf p_0\)
物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = &#43; R &#43; p_0 $
因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v &#43; p_0 $
所以我们只需要求出每个时间的 \(\mathbf v\) 和 $ $ 就可以描述刚体随时间的运动状态了。
为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。
角速度 我们知道 \(R\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \[ \displaystyle\dot{R} = [\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ] \] 于是 \(\dot{R}\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \(\mathbf x\) ，旋转点位置是 \(\mathbf p\) ，旋转中心到位置 \(\mathbf p\) 的向量为 \(r\) 。我们的目的是测定 \(r\) 的变化率。由于 \(\mathbf p\) 以角速度 \(\omega\) 旋转，所以其瞬时速度与 \(r\) 和 \(\omega\) 垂直。瞬时速度方向由 \(\omega\times r\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$" />
<meta property="og:type" content="article" />
<meta property="og:url" content="//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly.html" />
    <meta property="og:image" content="//elderlyaugustus.github.io/cover.png"/>
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2021-12-05T00:00:00&#43;08:00" />
  <meta property="article:modified_time" content="2021-12-05T00:00:00&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY",
      "item": "//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly.html"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY | xα's blog",
  "name": "2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY",
  "description": "注：本篇由同组同学LLY编写，本人代完成格式化\n刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。\n刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \\(\\mathbf x\\) 和速度 \\(\\mathbf v\\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。\n质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \\(\\mathbf x\\) 和 方向 \\(R\\) 。局部坐标为 \\(\\mathbf p_0\\) 的点，世界坐标系下的坐标为：\\(\\mathbf p = \\mathbf x + R \\mathbf p_0\\)\n物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = + R + p_0 $\n因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $\n所以我们只需要求出每个时间的 \\(\\mathbf v\\) 和 $ $ 就可以描述刚体随时间的运动状态了。\n为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。\n角速度 我们知道 \\(R\\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \\[ \\displaystyle\\dot{R} = [\\dot{\\hat{u_x}}\\quad\\dot{\\hat{u_y}}\\quad\\dot{\\hat{u_z}} ] \\] 于是 \\(\\dot{R}\\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \\(\\mathbf x\\) ，旋转点位置是 \\(\\mathbf p\\) ，旋转中心到位置 \\(\\mathbf p\\) 的向量为 \\(r\\) 。我们的目的是测定 \\(r\\) 的变化率。由于 \\(\\mathbf p\\) 以角速度 \\(\\omega\\) 旋转，所以其瞬时速度与 \\(r\\) 和 \\(\\omega\\) 垂直。瞬时速度方向由 \\(\\omega\\times r\\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$",
  "keywords": [
    "基于物理的动画"
  ],
  "wordCount" : "740",
  "inLanguage": "en",
  "datePublished": "2021-12-05T00:00:00+08:00",
  "dateModified": "2021-12-05T00:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "xα"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "xα's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "//elderlyaugustus.github.io/favicon.ico"
    }
  }
}
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>


<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//elderlyaugustus.github.io/" accesskey="h" title="xα&#39;s blog (Alt + H)">xα&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="//elderlyaugustus.github.io/about/" title="About"
                >About
                </a>
            </li>
            <li>
                <a href="//elderlyaugustus.github.io/archives/" title="Archives"
                >Archives
                </a>
            </li>
            <li>
                <a href="//elderlyaugustus.github.io/search/" title="Search (Alt &#43; /)"data-no-instant accesskey=/
                >Search
                </a>
            </li>
            <li>
                <a href="//elderlyaugustus.github.io/tags/" title="Tags"
                >Tags
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="//elderlyaugustus.github.io/">Home</a></div><h1 class="post-title">2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2021-12-05</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="//elderlyaugustus.github.io/tags/%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB.html">基于物理的动画</a></span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%88%9a%e4%bd%93" aria-label="刚体">刚体</a><ul>
                        
                <li>
                    <a href="#%e5%88%9a%e4%bd%93%e5%b1%9e%e6%80%a7%e4%b8%8e%e8%a1%a8%e8%be%be" aria-label="刚体属性与表达">刚体属性与表达</a></li>
                <li>
                    <a href="#%e5%88%9a%e4%bd%93%e8%bf%90%e5%8a%a8" aria-label="刚体运动">刚体运动</a><ul>
                        
                <li>
                    <a href="#%e5%b9%b3%e7%a7%bb%e8%bf%90%e5%8a%a8" aria-label="平移运动">平移运动</a></li>
                <li>
                    <a href="#%e6%97%8b%e8%bd%ac%e8%bf%90%e5%8a%a8" aria-label="旋转运动">旋转运动</a><ul>
                        
                <li>
                    <a href="#%e6%83%af%e6%80%a7%e5%bc%a0%e9%87%8f" aria-label="惯性张量">惯性张量</a></li>
                <li>
                    <a href="#%e5%8a%9b%e7%9f%a9" aria-label="力矩">力矩</a></li>
                <li>
                    <a href="#%e8%a1%a8%e7%a4%ba%e6%97%8b%e8%bd%ac%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="表示旋转的方法">表示旋转的方法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%88%9a%e4%bd%93%e7%9a%84%e7%a2%b0%e6%92%9e%e4%b8%8e%e6%8e%a5%e8%a7%a6" aria-label="刚体的碰撞与接触">刚体的碰撞与接触</a><ul>
                        
                <li>
                    <a href="#shape-matching" aria-label="Shape Matching">Shape Matching</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ba%a6%e6%9d%9f" aria-label="约束">约束</a><ul>
                        
                <li>
                    <a href="#%e7%bd%9a%e5%87%bd%e6%95%b0" aria-label="罚函数">罚函数</a><ul>
                        
                <li>
                    <a href="#p%e6%af%94%e4%be%8b%e6%8e%a7%e5%88%b6%e5%99%a8" aria-label="P（比例）控制器">P（比例）控制器</a></li>
                <li>
                    <a href="#pd%e6%af%94%e4%be%8b%e5%be%ae%e5%88%86%e6%8e%a7%e5%88%b6%e5%99%a8" aria-label="PD（比例微分）控制器">PD（比例微分）控制器</a></li>
                <li>
                    <a href="#pid%e6%af%94%e4%be%8b%e7%a7%af%e5%88%86%e5%be%ae%e5%88%86%e6%8e%a7%e5%88%b6%e5%99%a8" aria-label="PID（比例积分微分）控制器">PID（比例积分微分）控制器</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ba%a6%e6%9d%9f%e5%8a%a8%e5%8a%9b%e5%ad%a6" aria-label="约束动力学">约束动力学</a></li></ul>
                </li>
                <li>
                    <a href="#vfx%e4%b8%ad%e7%9a%84%e5%88%9a%e4%bd%93%e6%a8%a1%e6%8b%9f" aria-label="VFX中的刚体模拟">VFX中的刚体模拟</a></li>
                <li>
                    <a href="#destruction" aria-label="Destruction">Destruction</a><ul>
                        
                <li>
                    <a href="#rbs%e6%96%b9%e6%b3%95" aria-label="RBS方法">RBS方法</a></li>
                <li>
                    <a href="#destruction-%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93" aria-label="Destruction 方法总结">Destruction 方法总结</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>注：本篇由同组同学LLY编写，本人代完成格式化</p>
</blockquote>
<h2 id="刚体">刚体</h2>
<p>在物理学里，<strong>刚体</strong>是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。</p>
<h3 id="刚体属性与表达">刚体属性与表达</h3>
<p>为了表示一个刚体，我们首先需要知道刚体的<strong>质心</strong>。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标
<span class="math inline">\(\mathbf x\)</span> 和速度 <span
class="math inline">\(\mathbf v\)</span>
。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为<strong>局部坐标系</strong>。刚体及模拟的其他对象被放置在<strong>世界坐标系</strong>中。</p>
<figure>
<img src="../images/filmtechanalysis-PBA/质心.png" alt="质心" />
<figcaption aria-hidden="true">质心</figcaption>
</figure>
<p>为了指定刚体在世界坐标系中的放置方式，我们指定其位置 <span
class="math inline">\(\mathbf x\)</span> 和 方向 <span
class="math inline">\(R\)</span> 。局部坐标为 <span
class="math inline">\(\mathbf p_0\)</span>
的点，世界坐标系下的坐标为：<span class="math inline">\(\mathbf p =
\mathbf x + R \mathbf p_0\)</span></p>
<figure>
<img src="../images/filmtechanalysis-PBA/物体坐标系和世界坐标系.png"
alt="物体坐标系和世界坐标系" />
<figcaption aria-hidden="true">物体坐标系和世界坐标系</figcaption>
</figure>
<p>我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出：
$ = + R + p_0 $</p>
<p>因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $</p>
<p>所以我们只需要求出每个时间的 <span class="math inline">\(\mathbf
v\)</span> 和 $ $ 就可以描述刚体随时间的运动状态了。</p>
<p>为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。</p>
<figure>
<img src="../images/filmtechanalysis-PBA/角速度.png" alt="角速度" />
<figcaption aria-hidden="true">角速度</figcaption>
</figure>
<p>我们知道 <strong><span class="math inline">\(R\)</span>
的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标</strong>，因此，
$ $ 由这些方向向量的导数组成： <span class="math display">\[
\displaystyle\dot{R} =
[\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ]
\]</span> 于是 <span class="math inline">\(\dot{R}\)</span>
就被简化成为求旋转矢量的导数的问题。旋转中心位置是 <span
class="math inline">\(\mathbf x\)</span> ，旋转点位置是 <span
class="math inline">\(\mathbf p\)</span> ，旋转中心到位置 <span
class="math inline">\(\mathbf p\)</span> 的向量为 <span
class="math inline">\(r\)</span> 。我们的目的是测定 <span
class="math inline">\(r\)</span> 的变化率。由于 <span
class="math inline">\(\mathbf p\)</span> 以角速度 <span
class="math inline">\(\omega\)</span> 旋转，所以其瞬时速度与 <span
class="math inline">\(r\)</span> 和 <span
class="math inline">\(\omega\)</span> 垂直。瞬时速度方向由 <span
class="math inline">\(\omega\times r\)</span>
表示，大小与向量积大小一致。于是我们可以得到： $ = r$</p>
<figure>
<img src="../images/filmtechanalysis-PBA/半径的变化率.png"
alt="半径的变化率" />
<figcaption aria-hidden="true">半径的变化率</figcaption>
</figure>
<p>将结果应用到旋转矩阵中，我们能写出旋转矩阵按时间的导数： <span
class="math display">\[
\dot R=[\omega\times\hat{\mathbf u}_x,\ \omega\times\hat{\mathbf u}_y,\
\omega\times\hat{\mathbf u}_z]
\]</span> 根据向量积表示法，我们可以化简得到： <span
class="math display">\[
\dot
R=\omega^*R\quad其中a^*=\begin{bmatrix}0&amp;-a_z&amp;a_y\\a_z&amp;0&amp;-a_x\\-a_y&amp;a_x&amp;0\end{bmatrix}
\]</span> 现在，我们只需要知道 <span class="math inline">\(\mathbf
v\)</span> 和 <span class="math inline">\(\omega\)</span>
就能表示描述刚体的运动状态了。</p>
<h3 id="刚体运动">刚体运动</h3>
<p>前面我们讲到，刚体有线性状态（ <span class="math inline">\(\mathbf
v\)</span> ）和角度状态（ <span class="math inline">\(\omega\)</span>
）。在模拟刚体时，必须更新这两种状态。刚体的运动可以拆分称平移运动和旋转运动。</p>
<h4 id="平移运动">平移运动</h4>
<p>平移运动非常简单。根据牛顿第二定律 <span
class="math inline">\(F=ma\)</span>
，逐时间步地更新我们的加速度、速度和位置即可。我们用前面提到过的时间积分方法迭代计算即可。</p>
<h4 id="旋转运动">旋转运动</h4>
<h5 id="惯性张量">惯性张量</h5>
<p><strong>线性动量</strong> <span class="math inline">\(P=mv\)</span>
，在有角度的情况下，有一个接近的类比，其中<strong>角动量 <span
class="math inline">\(L\)</span> </strong>
被定义为<strong>惯性张量</strong> <span class="math inline">\(I\)</span>
和<strong>角速度</strong> <span class="math inline">\(\omega\)</span>
的乘积： <span class="math inline">\(L=I\omega\)</span>
。惯性张量<em>I</em>描述质量如何在物体中分布，是一个 <span
class="math inline">\(3\times 3\)</span> 的矩阵。 <span
class="math inline">\(I\)</span>
的矩阵形式描述了惯性因方向而变化。局部坐标系中惯性张量的公式如下： <span
class="math display">\[
\mathbf I_{ref}=\sum m_i(\mathbf R_i^T\mathbf R_i\mathbf 1-\mathbf
R_i\mathbf R_i^T)
\]</span> 刚体在局部坐标系中的惯性张量 <span
class="math inline">\(I_0\)</span>
不会改变，但在世界坐标系中，惯性张量却会随着物体当前的方向而发生变化。根据线性空间转换可得，在世界坐标系中，物体的惯性张量为：
<span class="math display">\[
\mathbf I=\mathbf R\mathbf I_0\mathbf R^T
\]</span> 线性运动与旋转运动中，有这样的对应关系：</p>
<p><img src="../images/filmtechanalysis-PBA/线运动和角运动物理量对比.png" alt="线运动和角运动物理量对比" style="zoom:75%;" /></p>
<h5 id="力矩">力矩</h5>
<p><strong>线性动量</strong> <span class="math inline">\(P=mv\)</span>
，对于 <span class="math inline">\(F\)</span> ，有 $ F = ma = m = $ ，即
<span class="math inline">\(F\)</span>
是线性动量的时间变化率。角动量变化有类似的过程，角动量的时间变化率是<strong>力矩
</strong> <span class="math inline">\(\tau\)</span>。</p>
<p>力矩对应力的旋转 <span class="math inline">\(\tau =
\dot{L}\)</span></p>
<p><img src="../images/filmtechanalysis-PBA/力矩_1.png" alt="力矩_1" style="zoom:67%;" /></p>
<p>已知质心为 <span class="math inline">\(\mathbf x\)</span> ，假定在点
<span class="math inline">\(\mathbf p\)</span> 施加力 <span
class="math inline">\(F\)</span>
。任何不作用于刚体质心的力都将产生力矩。为测定力矩，首先计算<strong>力臂</strong>
<span class="math inline">\(r\)</span> ，<span
class="math inline">\(\tau = r \times f\)</span>
。力矩是一个矢量，方向同时垂直于力臂及作用力。方向为物体因力矩旋转时围绕的轴的方向。</p>
<p>力矩作用于整个刚体，可理解为力矩通过了质心。力矩的叠加满足矢量加法。</p>
<p><img src="../images/filmtechanalysis-PBA/力矩_2.png" alt="力矩_2" style="zoom: 80%;" /></p>
<p>于是，我们很容易就能得出 <span
class="math inline">\(\displaystyle\Delta \omega = \frac{\Delta L}{I} =
\Delta t \frac{\tau}{I}\)</span></p>
<h5 id="表示旋转的方法">表示旋转的方法</h5>
<p>我们到此为止一直在使用旋转矩阵来表示旋转。但其实旋转有很多种表示方式。</p>
<ul>
<li><p><strong>旋转矩阵</strong></p>
<ol type="1">
<li>会有太多数据冗余：表示旋转矩阵需要九个元素，但是只表示了三个自由度。</li>
<li>表示方法不符合直觉。</li>
<li>定义它的时间导数很困难。</li>
</ol></li>
<li><p><strong>欧拉角</strong></p>
<ul>
<li>优势：表示是符合直觉的。它用三个轴的旋转角度来表达一个旋转。</li>
<li>劣势：可能会导致万向锁问题，并且定义它的时间导数也很困难。</li>
</ul></li>
<li><p><strong>四元数：</strong>
一个四元数的第一位表示旋转角度，后三位表示旋转轴方向。
<img src="../images/filmtechanalysis-PBA/旋转的四元数表示_1.png" alt="旋转的四元数表示_1" style="zoom: 45%;" /></p>
<p>并且四元数可以和旋转矩阵互相转换：
<img src="../images/filmtechanalysis-PBA/旋转的四元数表示_2.png" alt="旋转的四元数表示_2" style="zoom: 50%;" /></p>
<p>于是我们用四元数来表示旋转的状态更新方程可以表示为：
<img src="../images/filmtechanalysis-PBA/旋转的四元数表示_3.png" alt="旋转的四元数表示_3" style="zoom: 50%;" /></p></li>
</ul>
<p>总结一下，我们的刚体运动模拟过程由下图所示：线性运动和角度运动的物理量都有相互对应的关系。</p>
<p><img src="../images/filmtechanalysis-PBA/线性运动与角度运动的对比.png" alt="线性运动与角度运动的对比" style="zoom:50%;" /></p>
<h3 id="刚体的碰撞与接触">刚体的碰撞与接触</h3>
<h4 id="rigid-collision-detection-and-response-by-impulse">Rigid
Collision Detection and Response by Impulse</h4>
<p>之前我们在粒子系统中已经介绍了一个点与面的两种碰撞方式，在Mesh表达的刚体碰撞处理中，我们一般采用Impulse的碰撞响应方式。</p>
<p>当物体有许多点构成时，我们可以检测每个点是否发生碰撞。</p>
<p><img src="../images/filmtechanalysis-PBA/碰撞_1.png" alt="碰撞_1" style="zoom:50%;" /></p>
<p><img src="../images/filmtechanalysis-PBA/碰撞_2.png" alt="碰撞_2" style="zoom:50%;" /></p>
<p>每一个点由 $x_i $ 表示，计算点到表面的距离 $ (x) $
是否小于0。若大于零，说明没有发生碰撞。若小于零，则发生碰撞。</p>
<p>然后将线性速度与角速度合成为此时该点的速度，若速度方向远离刚体内部，则不需要改变力，碰撞结束。若方向继续深入刚体内部，则继续运算。</p>
<p>首先强行创造一个离 $ x_i $ 最近的接触点 $ x_i^{new} $
，然后计算出当前速度的 <span class="math inline">\(xyz\)</span>
分量。新的点的垂直速度反向，并且乘以衰减参数 $ _N $
；平行速度乘以摩擦衰减参数 $ a $ 。将速度分量重新合成为 $ v_i^{new} $
此速度即为当前点的速度。 <span class="math display">\[
{\rm collision}\quad\mathbf x^{new}\leftarrow\mathbf x+|\phi(\mathbf
x)|\mathbf N=\mathbf x=\phi(\mathbf x)\nabla\phi(\mathbf x)
\]</span>
<img src="../images/filmtechanalysis-PBA/Impulse碰撞.png" alt="Impulse碰撞" style="zoom:67%;" /></p>
<p>又因为刚体的属性中只有线性速度和角速度，求得的点速度无法用于更新，所以引入冲量
<span class="math inline">\(j\)</span> 。因为冲量 $ j = Ft $</p>
<p>易得 $ v = t = j $ ， $ = t= t = I^{-1}(r j)$</p>
<p>列出方程组： <span class="math inline">\(\begin{array}{l}\mathbf
v^{new}=\mathbf v+\dfrac{1}{M}\mathbf j\\\mathbf \omega^{new}=\mathbf
\omega+\mathbf I^{-1}(\mathbf Rr_i\times \mathbf j)\\\mathbf
v_i^{new}=\mathbf v^{new}+\omega^{new}\times\mathbf R\mathbf
r_i\end{array}\)</span></p>
<p>即可求出 $ v^{new} $ 与 $ ^{new} $ 。</p>
<h4 id="shape-matching">Shape Matching</h4>
<p>Shape Matching
方法将物体上的点当作粒子进行状态更新，允许点有自己的速度，点与点之间没有任何相互作用力，然后再强行将其约束成为一个刚体。将点云的质心作为下一时刻刚体的质心，然后让刚体尽可能接近点云的形态。但是因为实际应用不多，具体方法不再赘述。</p>
<p><img src="../images/filmtechanalysis-PBA/ShapeMatching.png" alt="ShapeMatching" style="zoom:75%;" /></p>
<h3 id="约束">约束</h3>
<p>到目前为止，我们都讨论的是无约束系统的动力学。意思就是说，粒子或者刚体可以沿任何方向运动，仅受外力影响。但在基于物理的动画中，存在许多内在和约束有关的问题。比如轨道上的列车，车轮因为钢轨施加的作用力受到约束，沿轨道运行。轨道产生向上的作用力，支撑列车的重量，在转弯时，轨道也会产生横向作用力，保证车轮沿轨道前行。</p>
<p>我们把约束视为减少运动的<strong>自由度</strong>。没有约束的刚体存在6个自由度——3个平移自由度和3个旋转自由度。刚体可以沿
<span class="math inline">\(xyz\)</span> 方向移动、旋转。</p>
<h4 id="罚函数">罚函数</h4>
<p>罚函数法是维持约束最简单的方法。这种方法本质上就是先让刚体自由运动，当运动和约束有偏差的时候，再施加一个外力，使运动回到约束。因为这种方法是基于偏差而产生的校正力，所以不能维持<strong>刚性约束</strong>。刚性约束指永远不可能违反的约束。实现刚性约束需要使用其他方法（之后会讲到）。但很多例子中会使用暂时允许产生小幅偏差的<strong>柔性约束</strong>。</p>
<h5 id="p比例控制器">P（比例）控制器</h5>
<p><strong>P控制器</strong>是罚函数法使用的最简单的控制系统。这张图表示的是灰珠受到约束而沿线运动的例子。细线表示线的约束路径，粗线表示灰珠的实际路径。灰珠的中心位置为
<span class="math inline">\(\mathbf x(t)\)</span>
，约束路径上离灰珠最近的点为 <span class="math inline">\(\mathbf
c(\mathbf x)\)</span> 表示和约束误差的向量为 <span
class="math inline">\(\mathbf e(\mathbf x)=\mathbf c(\mathbf x)-\mathbf
x(t)\)</span> 。强度常量为 $ k_p $
的<strong>P控制器</strong>将施加以下校正力： <span
class="math display">\[
\mathbf F_p=-k_p\mathbf e
\]</span>
使用这种方法，灰珠会沿着约束路径运动，但两者之间仍存在较大的偏差，灰珠会在约束路径附近振动。并且当灰珠趋于静止时，和路径有一个恒定的偏差，此时控制器施加的力正好与重力抵消。</p>
<p><img src="../images/filmtechanalysis-PBA/P控制器.png" alt="P控制器" style="zoom: 25%;" /></p>
<h5 id="pd比例微分控制器">PD（比例微分）控制器</h5>
<p>给P控制器加一个微分项可以预防未来的误差变化。施加一个误差向量方向上的力，该力正比于误差变化率，因此控制器合力为：
<span class="math display">\[
\mathbf F_{pd}=-[k_p\mathbf e+k_d(\dot{\mathbf e}\cdot\hat{\mathbf
e})\hat{\mathbf e}]
\]</span> $ k_d $ 为误差微分的可调增益。一般而言误差函数 <span
class="math inline">\(\mathbf e(\mathbf x)\)</span>
没有直接的解析式，只要我们能计算 <span class="math inline">\(\mathbf
e\)</span> ，即可用两个时间步的误差估计当前时步的误差变化率： <span
class="math display">\[
\dot{\mathbf e}^{[n]}\approx(\mathbf e^{[n]}-\mathbf e^{[n-1]})/h
\]</span>
使用PD控制器仍然解决不了当灰珠趋于静止时，和路径有一个恒定的偏差。因为除非误差在一直变化，否则微分项不会施加力。</p>
<p><img src="../images/filmtechanalysis-PBA/PD控制器.png" alt="PD控制器" style="zoom:25%;" /></p>
<h5 id="pid比例积分微分控制器">PID（比例积分微分）控制器</h5>
<p>静止状态下的误差问题可以通过添加积分项解决。这意味着只要灰珠与约束路径存在误差，就会施加作用力：
<span class="math display">\[
\mathbf F_{pid}=-\left[k_p\mathbf e+k_d(\dot{\mathbf e}\cdot\hat{\mathbf
e})\hat{\mathbf e}+k_i\int_0^t\mathbf edt\right]
\]</span>
<img src="../images/filmtechanalysis-PBA/PID控制器.png" alt="PID控制器" style="zoom:25%;" /></p>
<p>使用PID控制器的小球运动如图所示。最初小球的运动路径与PD控制器基本一致，担当小球减速，其运动轨迹更接近约束路径。当小球最终静止时，几乎完全符合约束。这是因为只要未回到约束，积分项将一直施加逐渐变大的力，使其刚好抵消重力。</p>
<h4 id="约束动力学">约束动力学</h4>
<p>约束动力学通过产生作用力来抵消所施加的力，防止违反约束从而确保维持刚性约束。</p>
<p>我们首先关注模拟平面内运动钟摆的约束动力学问题。钟摆轴位置为 $ x_0 $
，因此所有的运动都应围绕该位置旋转。质量为 m 的摆球安装在长度为 r
的杆末端，杆是刚性的且质量忽略不计。摆球中心记为变量 $ x $
，所有施加在摆球上的合外力为 $ f_a $ 。我们的目标是产生一个刚好可以抵消
$ f_a $ 中可能导致杆长度发生变化的约束力 $ f_c $ 。</p>
<p><img src="../images/filmtechanalysis-PBA/约束动力学_1.png" alt="约束动力学_1" style="zoom: 33%;" /></p>
<p>约束动力学的关键是创建一个约束函数。这个函数是一个判定函数，当满足约束条件时，该函数值
=
0。我们想要让系统永远满足约束条件，也就是约束函数恒为0。故该函数对时间的一阶导数始终为0。同时，我们还必须确保该函数的变化率也恒为0，也就是没有发生变化的趋势，所以我们需要该函数对时间的二阶导数也为0。对于钟摆问题，我们选择一个最为明显的约束函数：
<span class="math display">\[
\mathbf c(\mathbf x)=\|\mathbf x-\mathbf x_0\|-r
\]</span> 该函数计算导数非常困难，故我们使用该约束函数： <span
class="math display">\[
\mathbf c(\mathbf x)=\dfrac{1}{2}[(\mathbf x-\mathbf x_0)^2-r^2]
\]</span> 当x与 $ x_0 $
的距离刚好为r时，约束函数为0。约束函数对x的一阶导数为: $ x - x_0 $
，根据链式法则，约束函数对时间的一阶导数为： <span
class="math display">\[
\dot {\mathbf c}=(\mathbf x-\mathbf x_0)\cdot\dot {\mathbf x}
\]</span> 二阶导数为： <span class="math display">\[
\ddot {\mathbf c}=\dot{\mathbf x}^2+(\mathbf x-\mathbf x_0)\cdot\ddot
{\mathbf x}
\]</span> 施加在摆球上的合力是外力与约束力的总和。根据牛顿第二定律：
<span class="math display">\[
\ddot{\mathbf x}=\dfrac{1}{m}{\mathbf f_a + \mathbf f_c}
\]</span> 因为联立以上三式，又因为 $ = 0,   = 0 $ ，经整理得： <span
class="math display">\[
\dfrac{1}{m}(\mathbf x - \mathbf x_0)\cdot \mathbf f_c = -\dot{\mathbf
x}^2-\dfrac{1}{m}(\mathbf x-\mathbf x_0)\cdot\mathbf f_a
\]</span> 又因为约束力必须与杆平行，可得： <span class="math display">\[
\mathbf f_c=\lambda(\mathbf x - \mathbf x_0)
\]</span> 其中，<span class="math inline">\(\lambda\)</span>
为待定的比例因子。再联立以上两式，即可求解 <span
class="math inline">\(\lambda\)</span> ： <span class="math display">\[
\displaystyle\lambda=-\frac{m\dot{\mathbf x}^2+(\mathbf x-\mathbf
x_0)\cdot\mathbf f_a}{(\mathbf x-\mathbf x_0)^2}
\]</span> 因此钟摆的系统动力学函数首先要求计算作用于钟摆的外力 $ f_a
$，然后计算出比例因子 <span
class="math inline">\(\lambda\)</span>，再计算出约束力 $ f_c $ 。已知 $
f_a <span class="math inline">\(，\)</span> f_c $
，在计算出摆球的总加速度。</p>
<p>该单一约束的问题也可以推广到多约束的复杂系统。设定多个约束函数来求解多个约束力。由于篇幅限制，所以我们不再过多介绍。</p>
<p><strong>总结</strong></p>
<p>约束会减少系统的自由度。</p>
<p>罚函数法先不考虑任何约束，直接计算运动，当运动与约束有所偏差时，再添加外力抵消。</p>
<p>约束动力学通过计算约束力来维持刚性约束。</p>
<p>以上，我们讲解了刚体的表示方法、表示刚体运动的方法、如何更新刚体运动状态、如何处理刚体运动的碰撞，以及如何对刚体创建约束。相信大家对刚体模拟都有了更深层次的了解。</p>
<h3 id="vfx中的刚体模拟">VFX中的刚体模拟</h3>
<p>刚才，我们从底层原理的角度讲述了刚体的表示和模拟的计算方法，那么，这节课我们就来详细讲讲我们该如何实际使用刚体模拟来实现我们想要的一些效果。在VFX中，刚体模拟最常用的地方，就是创建物体毁灭的效果，英文中这个效果叫做Destruction。</p>
<h3 id="destruction">Destruction</h3>
<p>电影《2012》是大范围的破坏视觉效果的分水岭，直到那时，还没有人看到过如此大规模的毁灭影像。这部电影加速了Bullet作为主要物理引擎的重要性和行业接受度。自2009年以后，视觉特效工作室、学术机构和开源项目继续为destruction工具做出贡献。</p>
<h4
id="实现destruction效果的两种方法">实现Destruction效果的两种方法</h4>
<p><strong>RBS方法。</strong>这种方法主要有两种实现形式。</p>
<p>第一种叫标准的RBS方法，最为广泛使用。此方法围绕现有物理库（如Bullet、PhysX或ODE）定制。其中，Bullet库最受欢迎。SPI、Frameworks、Weta和Dneg等公司是使用此方法的代表。这个方法还被众多商业软件和引擎如Houdini等使用。</p>
<p>还有一种RBS方法是使用专业物理库的RBS方法，主要使用此方法的公司有：皮克斯、迪士尼、Industrial
Light &amp;
Magic等。这种方法与标准RBS方法的区别体现在碰撞检测中，他们使用了水平集方法。</p>
<p><strong>有限元分析（FEA）</strong>。这种方法又被称为传统的大规模真实世界工程方法。这种方法目前只被MPC公司在电影视效中广泛使用。虽然这种方法在影视中不常见，但有许多游戏已经开始使用这种方法。</p>
<h4 id="rbs方法">RBS方法</h4>
<ul>
<li><strong>RBS的三个阶段</strong>
<ul>
<li>第一阶段：分解RBS对象（预破碎）</li>
<li>第二阶段：设置约束和设计编排</li>
<li>第三阶段：运行模拟并进行碰撞检测</li>
</ul></li>
</ul>
<p><strong>第一阶段：分解RBS对象（预破碎）</strong></p>
<p>在RBS中，物体不会受力自行发生破碎，而是在进行模拟前需要先人为的破碎成小块，再在模拟中进行解算。RBS的第一阶段是准备几何体，换句话说，就是研究如何将几何体分解为“小块”。埃尔文·库曼斯（Erwin
Coumans）在加拿大温哥华SIGGRAPH提出了四种分解几何体的方法：</p>
<ul>
<li><p>A. 维诺图 Voronoi Diagrams</p></li>
<li><p>B.CSG constructive solid
geometry：使用布尔运算切割几何图形。</p></li>
<li><p>C.凸分解 Convex
Decomposition：这可以由艺术家手工或使用自动工具执行。</p></li>
<li><p>D.四面体化，也可以通过将3D模型转换为tetras来实现。</p></li>
</ul>
<p><strong>A.维诺图 Voronoi Diagrams </strong></p>
<p>维诺图是一个数学概念，广泛用于生成看起来自然的断裂形状。这个原理非常简单，看起来非常自然。在两个点之间画一条等距离的线，与两点连线成直角。初始点（或称粒子）可以通过多种方式生成，包括随机生成。
这有效地将对象简化为点云，然后生成一组多边形的破碎子几何体。这一概念是RBS/刚体动力学<strong>程序化破碎的核心</strong>。</p>
<p><strong>B.CSG Constructive Solid Geometry</strong></p>
<p>这是一种已经存在多年的技术。它使用简单加法、减法和异或运算。这些数学运算称为<strong><em>布尔运算</em></strong>，这个方法称为<em>构造立体几何或CSG</em>。它可以在三维模型之间执行体积运算，使几个简单的几何图形或对象构建为更复杂、更自然的细分形状。可以将两个体积相加，或计算两个对象之间的差值，或求它们的交集。这些操作可以将原始三维模型分解为更小的部分，类似于饼干切割器。这个方法的<strong>优点</strong>是可以精确控制物体破碎后的几何形状，<strong>缺点</strong>是操作繁琐，不够程序化，并且在多边形中进行布尔运算容易出现问题。</p>
<p><strong>C.凸分解 Convex Decomposition</strong></p>
<p>“convex”一词的意思是向外弯曲或凸出，与向内弯曲的concave相反。凸分解是一种通常用于将复杂模型简化为更易于处理的较小子模型的技术。凸分解<strong><em>将一个复杂多面体划分为多个凸面几何体</em></strong>。由于凸对象的重要性质，许多算法在凸对象上比在非凸对象上更有效。因此，此种方法处理的几何体<strong>主要用于计算碰撞检测</strong>。艺术家可以使用简单的凸面图元（如长方体、球体和胶囊）手动创建凸面分解。也可以自动创建凸分解。</p>
<p><strong>D.四面体化 Tetrahedralization</strong></p>
<p>这种处理几何体的方法用于<strong>有限元分析</strong>，在传统的RBS流程中不会使用。但因这也是预处理几何体的方法之一，故在此做简单介绍。一个mesh可以使用<strong><em>德洛内（Delaunay）三角剖分</em></strong>分解为<strong>四面体网格</strong>。有一些开源软件实现可用，包括Netgen和Tetgen。Pixelux的Maya
2012 DMM数字分子物质插件在内部使用Netgen执行四面体化。</p>
<p><strong>第二阶段：设置约束并控制约束力的大小</strong></p>
<p>在几何体准备好并分解为预破碎的小块后，如果直接进行模拟，它们就是一个个独立的碎块，还没来得及发生外力的碰撞，就在重力的作用下发生坍塌了。因此，在预破碎几何体后，还需要一个方式将它们约束在一起。直到外力超过了约束的限制时，约束才会消失，从而看起来发生了破碎。</p>
<ul>
<li><strong>设置约束的两种方法</strong>
<ul>
<li><strong>A.定义每个部件和其他部件之间的连接。</strong></li>
<li><strong>B.基于碰撞检测自动计算连接。</strong></li>
</ul></li>
</ul>
<p><strong>A.定义每个部件和其他部件之间的连接。</strong></p>
<p>这提供了最多的控制，但如果连接太多，性能可能会比较慢。如果使用维诺图的方法进行预破碎，可以自然而然地得到各个子几何体的连接。因为维诺图使用的是代表子几何体的点云，每个点的连接就是子几何体的连接。因此很容易对连接进行程序化约束。</p>
<p>现在，如果艺术家想要控制建筑的哪一侧倒塌，他们可以在约束上进行“绘制”，这是RBS设置的一部分。约束基本上是指导模拟的，比如说我们可以手动添加metaball来控制某一个区域的约束力大小，来削弱这个对象在这一帧这个区域内的所有约束。</p>
<p><strong>B.基于碰撞检测自动计算连接。</strong></p>
<p>计算相邻碎块之间的接触点，并且仅在存在接触点时创建连接。然后，你可以为这些连接创建中断阈值。一旦我们将这些片段粘合成一个刚体，我们就可以执行运行时断裂。如果发生碰撞，我们计算其冲量。如果该冲量大于所选阈值，我们将通过连接来传播该冲量。这些连接可能会减弱或断开。在此之后，需要确定断开连接的碎块，然后为每个单独的碎块创建新刚体。</p>
<p>放射状破碎就是一个很好的例子。某些类型的玻璃在破裂时会出现维诺图无法立即提供的径向图案。此效果可以通过蒙版或break
maps提供。径向裂纹是需要解决的较为典型的特殊情况之一。它们既有从碰撞点辐射的裂纹，也有围绕碰撞点的圆形裂纹。Dneg使用Dn-crack，这是一种程序化表面破碎器。它不像voronoi破碎器那样进行固体体积破碎，而是进行多边形表面破碎。</p>
<p>它的工作原理是用户提供一组用脚本编写的规则，这些规则描述裂纹如何出现在表面上，如何传播到子裂纹，以及每个裂纹如何生成，然后底层代码根据这些规则在表面上生成这些裂纹，将它们相交，重要的是在裂缝交汇处终止，等等。然后最终的设定是它将所有几何体分割为最终的破碎碎块。</p>
<p><strong>第三阶段：运行模拟和碰撞检测</strong></p>
<p>碰撞检测最简单形式是Bounding
Box。如果所有对象都包含在简单的boxes中，则避免boxes重叠从而避免物体碰撞。问题是，虽然这非常快，但大多数简单的长方体通常会生成过大的形状，无法生成高质量的模拟。显然，肉眼看起来不太靠近的物体似乎仍然会相互反弹。那么我们该怎么做才能使碰撞看起来尽可能精准，并且不太消耗算力呢？</p>
<p>大多数碰撞检测管道中分为两个主要阶段，分别是<strong>broad-phase</strong>和<strong>narrow-phase</strong>。</p>
<p><strong>Broad-phase:</strong></p>
<p>Broad-phase阶段根据<strong>边界体积重叠</strong>（bounding volume
overlap）减少潜在交互对象的总数。Bullet中有各种不同用途的broad-phase实现。最通用的broad-phase实现是基于<strong>动态边界体积层次结构</strong>（dynamic
bounding volume
hierarchies）：移动、添加或删除对象时更新<strong>轴对齐包围盒</strong>（axis
aligned bounding box）。</p>
<p>总的来说，就是先使用一个算法找到可能发生碰撞的物体，从而减少不必要的计算。</p>
<p><strong>Narrow-phase:</strong></p>
<p>Narrow-phase阶段处理的是<strong>成对碰撞对象之间精确接触点的生成</strong>。</p>
<p><strong>A.标准RBS方法</strong></p>
<p>最流行的解决方案是将<em>主对象细分为一组较小的对象，但都是单独凸面的</em>。这称为<strong>凸壳碰撞检测</strong>（Convex
hull collision detection）。</p>
<p>Bullet使用了一些通用算法，如GJK（Gilbert–Johnson–Keerthi）来实现<strong>两个凸面形状之间的快速距离</strong>，并处理各种碰撞形状类型。支持计算移动和旋转对象之间碰撞时间的连续碰撞检测，但默认情况下Bullet计算离散时间点的最近距离和穿透深度，以生成接触点信息或进行碰撞检测。</p>
<p>在确定可能发生碰撞的物体对后，将物体替换为它的凸壳，计算两个凸壳之间的距离以生成接触点信息。使用凸壳来计算是为了加快计算的速度，是模拟质量和模拟速度妥协的结果。</p>
<p><strong>B.水平集方法</strong></p>
<p><strong>有向距离场的概念</strong></p>
<p><strong>水平集的基本概念</strong></p>
<p>水平集数据结构用于表示<strong><em>离散采样的动态水平集函数</em></strong>。这种形式的数据结构通常用于高效的图像渲染。基本方法是构造一个从边界延伸的有向距离场，并可用于解算该场中边界的运动。</p>
<p>“术语‘LSV’（level set
value，水平集值）实际上是一个隐式曲面，用于模拟中的碰撞对象的倾向。PhysBAM使用水平集数据结构来实现它的<strong>narrow-phase
碰撞检测</strong>。当查询粒子与几何曲面的距离时，水平集具有<strong>快速查找</strong>的良好特性。PhysBAM使用的水平集数据结构将几何体的空域划分为box
cells，每个cell存储其到曲面的距离（φ）。从附近cells的集合中，我们可以计算梯度场，该梯度场产生指向几何体表面的法向量。通过水平集上的法向量和φ函数，我们可以计算到几何体表面的精确距离。”</p>
<p>通过查看这些向量和法线，可以判断你是在碰撞检测对象的内部还是外部。然后，ILM进一步利用这一点，使用水平集进行破碎。使用水平集可以轻松完成的一件事是在物体表面行走。我已经将所有空间分割成一个网格，在任何一点我都可以显示”我离表面有多近“，如果我不知道，那么我可以使用网格查找信息直接到达表面。”</p>
<p>对于单个物体，当粒子进入碰撞检测包围盒时，为物体设置一个水平集，很容易确定粒子是位于物体的内部还是外部，因此，粒子从物体上更精确地反弹，而不仅仅是从包围盒上反弹。但在破碎中，ILM并没有以同样的方式使用水平集，水平集不是表示单个对象，而是表示一组或一组称之为zero
iso contours的点，这些点在水平集中实际位于曲面上。</p>
<p>Zero iso
contours与voronoi等破碎工具非常相关。Voronoi点是用来破碎对象的，但ILM获取Voronoi点，然后找到刚好在模型曲面上的点，因为Voronoi种子点云通常不知道表面在哪，它只是负责将空间分割开，但在ILM中，水平集将这种分割带到下一个级别，不基于水平集创建子几何体，而是直接使用水平集分割高分辨率的几何图形。</p>
<p>斯坦福大学PhyBAM模拟软件的<strong>碰撞检测</strong>都基于水平集方法，基于SIGGRAPH
2003中Eran Guendelman的Nonconvex Rigid Bodies with
Stacking（非凸刚体的堆叠）。他们的RBS要求你有一个体积，以便对象正确碰撞，因此他们在模拟开始时使用水平集方法生成此体积数据结构，在模拟期间，他们将使用刚体表面的粒子来测试它们可能与之交互的对象的水平集的深度。它的分析查找速度很快，水平集的<strong>优点</strong>是，在空间中的任何一点，我都可以快速且准确地告诉你离曲面有多远，因此它是一个很好的碰撞查找模型。但<strong>缺点</strong>是它需要<em>很长的时间生成</em>，并且水平集的<em>存储空间</em>以立方方式增加。</p>
<p>幸运的是，水平集可以更改分辨率，ILM可以轻松控制此级别的精度。当你想让事情变得更复杂时，你必须不断增加水平集的存储空间。因此，与其他方法一样，ILM的艺术家和TD需要非常谨慎地在时间和准确性之间进行权衡。</p>
<h4 id="有限元分析-finite-element-analysis">3.有限元分析 Finite Element
Analysis</h4>
<p>FEA是一种物理上更精确的制作Destruction的方法，它使用<strong>有限元方法</strong>(finite
element
method)来求解控制弹性材料的动力学的偏微分方程。FEA是模拟变形的一种<em>物理上更正确</em>的方法，破碎是基于<strong>连续介质力学</strong>的。一个3D
mesh是用一组元素来近似的，通常是<strong>四面体</strong>。应变、应力和刚度矩阵用于计算力和变形的影响。</p>
<p><strong>有限元法</strong></p>
<p>有限元法最初被称为矩阵近似方法，应用于航空器的结构强度计算，并由于其方便性、实用性和有效性而引起从事力学研究的科学家的浓厚兴趣。经过短短数十年的努力，随着计算机技术的快速发展和普及，有限元方法迅速从结构工程强度分析计算扩展到几乎所有的科学技术领域，成为一种丰富多彩、应用广泛并且实用高效的数值分析方法。</p>
<p>FEA由R.Courant于1943年首次开发，并在20世纪70年代和80年代用于制造业，但直到21世纪10年代才找到了实现视觉效果的方法。MPC是FEA在视觉效果工作中的主要公司之一。“有可能这项技术现在才足够快，可以使用，别忘了RBS在VFX中花了相当长的时间才被采用。”</p>
<p>FEA使用一个称为<strong>节点</strong>的复杂点系统，该节点构成称为mesh的三维网格。该网格被设计并<strong>包含材料和结构属性</strong>，这些属性定义了结构如何对特定荷载条件作出反应。根据特定区域的预期应力水平，在整个材料中以特定密度指定节点。承受大量应力的区域通常比承受很少或没有应力的区域具有更高的节点密度。网格就像一张网络，每个节点都延伸一个网格单元到每个相邻节点。这张矢量网将材质属性带到对象上，创建了许多单元。</p>
<p><strong>DMM系统 Digital Molecular Matter system</strong></p>
<p>问题是，有限元分析曾经的计算非常昂贵。但一个新的系统诞生了。Pixelux是DMM数字分子物质系统的开发者，该系统使用基于有限元的方法处理柔体，使用四面体网格，并将应力张量直接转换为节点力。通过一些非常聪明的假设和技巧，DMM是可以是实时的。</p>
<p>DMM是从2004年开始，在六年半的时间里为<strong><em>电子游戏</em></strong>设计的。从2005年到2008年，作为《星球大战：原力释放计划》的一部分，Pixelux
DMM技术是卢卡斯艺术娱乐公司的独家技术。DMM中的有限元系统利用了加利福尼亚大学伯克利教授，James
F. O’Brien博士论文中的破碎和变形算法。Pixelux首席技术官Eric
Parker领导的团队对O’Brien算法进行了改进、优化，并将其应用到DMM中间件中，Pixelux首席执行官Mitchell
Bunnell领导的团队设计了DMM工具流程。</p>
<p>与传统的基于刚体运动学的实时仿真引擎不同，FEA允许DMM<strong>非常快速地模拟大量的物理特性</strong>。开发人员可以给给定的对象分配物理属性，从而允许对象像在现实世界中一样行为。此外，对象的属性可以在运行时更改，从而产生更多有趣的效果(参见下面的“chopping”)。</p>
<p><strong>MPC的Kali destruction tool</strong></p>
<p>《美少女特工队》中，巨武士战役中有大量木头破碎的镜头，木头的破碎不同于刚体，木头具有大量的形变能力。传统的RBS并不能达到预期的效果。MPC看到在SIGGRAPH中使用四面体FEA进行实时应用的文章，他们认为，如果FEA可以通过实时实现，那么如果再深入研究一下，说不定在VFX中就可以实现。”MPC直接与Pixelux合作，在他们自己的代码中使用Pixelux的解算器。</p>
<p>碰撞检测通常是由包围盒或凸面外壳（和水平集体积）实现的，但在FEA中，实际上完全使用网格，然后执行“tet-collision
detection（<strong>四面体网格碰撞检测</strong>）”。原始对象完全包围在<strong>固定大小或分辨率</strong>的四面体网格（
tetrahedral
mesh）中，这是一种基于速度/效率原因的非自适应网格解决方案。一个tet和另一个tet之间的碰撞检测比任意凸面和凸面的检测简单得多。</p>
<p>tet网格与物体几何体不同，但它很接近。但由于tet的数量是固定的，因此必须将细节放在你认为可能需要的地方。你可以做一个自适应解决方案，使解算器在物体破裂时切换并添加更多细节，但实际上，在帧间进行比较是相当困难的。但是如果你知道tet的数量是固定的，你可以使用它进行比较。MPC使用该技巧进行render
time chopping。“render time
chopping”指的是模拟使用固定分辨率的网格，在渲染时将几何体替换为完全不同的几何体的能力。</p>
<p><strong>在FEA中没有预破碎，没有voronoi或切割，从某种意义上说，这是一个更纯粹的解决方案。</strong>tet连接在一起，形成一个大的组，其中有一个共同的节点。该点被定义为具有一定的强度、结构鲁棒性，如果超过阈值，则会断开该连接。用tet填充体积的算法具有一定的随机性，足以满足需要。艺术家可以控制tet的密度，但精确的顶点在材质内部。</p>
<p><strong>FEA的优点：</strong>基于材料属性破碎。</p>
<p>破碎将取决于物体受力的方式。这是基于材料属性的，在传统的RBS方法中，在模拟发生前物体就已经被破碎了。你不需要使用FEA来实现这一点，因为你有明确的内力，因此碎块会按照你想要的方式，以及它应该的方式断裂。</p>
<p><strong>FEA的控制</strong>：</p>
<p>MPC有一个大小限制，它可以控制最小碎片的大小，以免物体变成粉末。</p>
<p>仍然可以预先破坏某些物体。MPC的TD基于voronoi贴图制作密度贴图，可以影响节点的密度云，但系统仍然基于实际材质断裂。</p>
<p><strong>FEA的附加效果：</strong></p>
<p>模拟的物体可以发生符合物理的塑性变形。结构蠕变、塑性或弹性变形可以作为标准系统的一部分进行，不需要任何造假和技巧。在MPC，艺术家可以通过对具有塑性变形的“钢”施加力来弯曲钢梁。</p>
<p>MPC系统更简单，弯曲效果不需要单独进行设置，传统的RBS需要对每一个不同的材质进行特殊的绑定和预破碎。而MPC将所有物体都放在一个tet网格框架中。所有模拟都可以统一进行，并且通过rendertime
chopping，随时可以替换框架中的几何体。这种抽象级别非常强大。</p>
<p>这个概念与传统的<strong>自由变形晶格</strong>（Free Form Deformation
lattice,
FFD）类似。FFD框架可以使其内部的任何几何体变形，因此很容易想象弯曲框架然后交换内部的几何体——可以从低模转换为高模。虽然将高分辨率几何体切分为与tet网格相对应的碎块非常昂贵，但因为tet网格不会改变，只需在最后一帧执行一次，然后就可以在整个模拟过程中将其应用到每一帧的动画中。</p>
<p><strong>为什么其他公司没有使用有限元分析</strong></p>
<p>1.员工和整个软件系统需要重新培训和重建。目前为止，还没有发现需要改变。</p>
<p>2.虽然传统RBS需要更多的设置，但是性能比FEA强很多。</p>
<h4 id="destruction-方法总结">Destruction 方法总结</h4>
<p>所有方法都是为了获得银幕上真实的效果。只要结果达到了，使用什么方法都是可行的。但随着计算力的发展，更符合物理的方法是必然的趋势。但就目前而言，是特效TD和动画师的技术、艺术以及经验使得影片的真实感达到了如此高的水平。</p>

  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C%E4%B8%AD%E7%9A%84fx%E6%B5%81%E7%A8%8B-bylly.html">
    <span class="title">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline></svg>&nbsp;Prev Page</span>
    <br>
    <span>2021-12-25-影片技术分析Pre-基于物理的动画-影视制作中的FX流程-byLLY</span>
  </a>
  <a class="next" href="//elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8.html">
    <span class="title">Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg>
    </span>
    <br>
    <span>2021-12-05-影片技术分析Pre-基于物理的动画-最新进展与应用</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2022 <a href="//elderlyaugustus.github.io/">xα&#39;s blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '1' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="../js/medium-zoom.min.js" data-no-instantintegrity=""
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied!';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>
<script>
  mediumZoom('.entry-cover img');
  mediumZoom('.post-content img:not([no-zoom])');
</script>

<script src="../js/instantclick.min.js" data-no-instantintegrity=""
></script>
<script data-no-instant>
  
  
  
  
  
  
  InstantClick.init();
</script>
</body>

</html>
