<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字 | xα&#39;s blog</title>
<meta name="keywords" content="Misc">
<meta name="description" content="开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧
虚幻引擎5.0新功能为电影虚拟化制作助力 2021年5月26日，Epic Games推出虚幻引擎5.0 Early Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。
电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。
新功能概览 虚幻引擎中的电影虚拟化制作模块In-Camera VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera VFX系统。更新5.0正式版后，In-Camera VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。
在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。
但由于In-Camera VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera VFX系统的电影虚拟化制作能力将达到一个新高度。
可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，
Lumen Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在Engine/Source/Runtime/Renderer/Private/Lumen中。
Lumen的整体思路是以SDF(Signed Distance Field) Trace为主的混合Tracing框架，同时用重新设计的Surface Cache场景表达，Radiance Cache作为最终的渲染结果收集。
混合的Tracing方案 在Lumen中，也可以先尝试调用基于硬件的RTX Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh SDF Trace、Voxel Trace(Global SDF Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。
Screen Space Trace 首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen Space Global Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。
世界空间的SDF Trace 屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF Trace。
对于近处的场景（例如1.8m内），Lumen采用Mesh SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF Trace。
在Mesh SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。
而远景则将每一个物体的Mesh SDF合并为全局的Global SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。
Global SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。
最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。
这样，SDF Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。
Surface Cache 在Surface Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface Cache作一次查询即可获得相对好的结果，提高Tracing效率。
Mesh Card SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh Card的方式参数化存储场景表达。Mesh Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。">
<meta name="author" content="xα">
<link rel="canonical" href="https://elderlyaugustus.github.io/posts/2022-04-10-ue5.0%E6%97%B6%E7%BB%99%E7%B3%BB%E9%87%8C%E5%86%99%E7%9A%84lumen%E5%92%8Cnanite%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D%E6%80%A7%E6%96%87%E5%AD%97/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://elderlyaugustus.github.io/icons/favicon.ico">
<link rel="apple-touch-icon" href="https://elderlyaugustus.github.io/icons/apple-touch-icon.png">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字 | xα&#39;s blog" />
<meta name="twitter:description" content="开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧
虚幻引擎5.0新功能为电影虚拟化制作助力 2021年5月26日，Epic Games推出虚幻引擎5.0 Early Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。
电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。
新功能概览 虚幻引擎中的电影虚拟化制作模块In-Camera VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera VFX系统。更新5.0正式版后，In-Camera VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。
在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。
但由于In-Camera VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera VFX系统的电影虚拟化制作能力将达到一个新高度。
可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，
Lumen Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在Engine/Source/Runtime/Renderer/Private/Lumen中。
Lumen的整体思路是以SDF(Signed Distance Field) Trace为主的混合Tracing框架，同时用重新设计的Surface Cache场景表达，Radiance Cache作为最终的渲染结果收集。
混合的Tracing方案 在Lumen中，也可以先尝试调用基于硬件的RTX Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh SDF Trace、Voxel Trace(Global SDF Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。
Screen Space Trace 首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen Space Global Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。
世界空间的SDF Trace 屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF Trace。
对于近处的场景（例如1.8m内），Lumen采用Mesh SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF Trace。
在Mesh SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。
而远景则将每一个物体的Mesh SDF合并为全局的Global SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。
Global SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。
最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。
这样，SDF Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。
Surface Cache 在Surface Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface Cache作一次查询即可获得相对好的结果，提高Tracing效率。
Mesh Card SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh Card的方式参数化存储场景表达。Mesh Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。" />
<meta property="og:title" content="2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字 | xα&#39;s blog" />
<meta property="og:description" content="开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧
虚幻引擎5.0新功能为电影虚拟化制作助力 2021年5月26日，Epic Games推出虚幻引擎5.0 Early Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。
电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。
新功能概览 虚幻引擎中的电影虚拟化制作模块In-Camera VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera VFX系统。更新5.0正式版后，In-Camera VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。
在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。
但由于In-Camera VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera VFX系统的电影虚拟化制作能力将达到一个新高度。
可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，
Lumen Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在Engine/Source/Runtime/Renderer/Private/Lumen中。
Lumen的整体思路是以SDF(Signed Distance Field) Trace为主的混合Tracing框架，同时用重新设计的Surface Cache场景表达，Radiance Cache作为最终的渲染结果收集。
混合的Tracing方案 在Lumen中，也可以先尝试调用基于硬件的RTX Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh SDF Trace、Voxel Trace(Global SDF Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。
Screen Space Trace 首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen Space Global Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。
世界空间的SDF Trace 屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF Trace。
对于近处的场景（例如1.8m内），Lumen采用Mesh SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF Trace。
在Mesh SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。
而远景则将每一个物体的Mesh SDF合并为全局的Global SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。
Global SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。
最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。
这样，SDF Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。
Surface Cache 在Surface Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface Cache作一次查询即可获得相对好的结果，提高Tracing效率。
Mesh Card SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh Card的方式参数化存储场景表达。Mesh Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://elderlyaugustus.github.io/posts/2022-04-10-ue5.0%E6%97%B6%E7%BB%99%E7%B3%BB%E9%87%8C%E5%86%99%E7%9A%84lumen%E5%92%8Cnanite%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D%E6%80%A7%E6%96%87%E5%AD%97/" />
    <meta property="og:image" content="https://elderlyaugustus.github.io/papermod-cover.png"/>
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2021-04-10T10:00:00&#43;08:00" />
  <meta property="article:modified_time" content="2021-04-10T10:00:00&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://elderlyaugustus.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字",
      "item": "https://elderlyaugustus.github.io/posts/2022-04-10-ue5.0%E6%97%B6%E7%BB%99%E7%B3%BB%E9%87%8C%E5%86%99%E7%9A%84lumen%E5%92%8Cnanite%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D%E6%80%A7%E6%96%87%E5%AD%97/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字 | xα's blog",
  "name": "2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字",
  "description": "开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧\n虚幻引擎5.0新功能为电影虚拟化制作助力 2021年5月26日，Epic Games推出虚幻引擎5.0 Early Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。\n电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。\n新功能概览 虚幻引擎中的电影虚拟化制作模块In-Camera VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera VFX系统。更新5.0正式版后，In-Camera VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。\n在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。\n但由于In-Camera VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera VFX系统的电影虚拟化制作能力将达到一个新高度。\n可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，\nLumen Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在Engine/Source/Runtime/Renderer/Private/Lumen中。\nLumen的整体思路是以SDF(Signed Distance Field) Trace为主的混合Tracing框架，同时用重新设计的Surface Cache场景表达，Radiance Cache作为最终的渲染结果收集。\n混合的Tracing方案 在Lumen中，也可以先尝试调用基于硬件的RTX Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh SDF Trace、Voxel Trace(Global SDF Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。\nScreen Space Trace 首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen Space Global Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。\n世界空间的SDF Trace 屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF Trace。\n对于近处的场景（例如1.8m内），Lumen采用Mesh SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF Trace。\n在Mesh SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。\n而远景则将每一个物体的Mesh SDF合并为全局的Global SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。\nGlobal SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。\n最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。\n这样，SDF Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。\nSurface Cache 在Surface Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface Cache作一次查询即可获得相对好的结果，提高Tracing效率。\nMesh Card SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh Card的方式参数化存储场景表达。Mesh Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。",
  "keywords": [
    "Misc"
  ],
  "wordCount" : "228",
  "inLanguage": "en",
  "datePublished": "2021-04-10T10:00:00+08:00",
  "dateModified": "2021-04-10T10:00:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "xα"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://elderlyaugustus.github.io/posts/2022-04-10-ue5.0%E6%97%B6%E7%BB%99%E7%B3%BB%E9%87%8C%E5%86%99%E7%9A%84lumen%E5%92%8Cnanite%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D%E6%80%A7%E6%96%87%E5%AD%97/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "xα's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://elderlyaugustus.github.io/favicon.ico"
    }
  }
}
</script>
<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://elderlyaugustus.github.io/" accesskey="h" title="xα&#39;s blog (Alt + H)">xα&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://elderlyaugustus.github.io/archives/" title="Archives"
                >Archives
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/tags/" title="Tags"
                >Tags
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/about/" title="Me &amp; Friends"
                >Me &amp; Friends
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/search/" title="Search (Alt &#43; /)"data-no-instant accesskey=/
                >Search
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://elderlyaugustus.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://elderlyaugustus.github.io/posts/">Posts</a></div><h1 class="post-title">2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 10, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/misc/">Misc</a></span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%96%b0%e5%8a%9f%e8%83%bd%e6%a6%82%e8%a7%88" aria-label="新功能概览">新功能概览</a><ul>
                        
                <li>
                    <a href="#lumen" aria-label="Lumen">Lumen</a><ul>
                        
                <li>
                    <a href="#%e6%b7%b7%e5%90%88%e7%9a%84tracing%e6%96%b9%e6%a1%88" aria-label="混合的Tracing方案">混合的Tracing方案</a><ul>
                        
                <li>
                    <a href="#screen-space-trace" aria-label="Screen Space Trace">Screen Space Trace</a></li>
                <li>
                    <a href="#%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4%e7%9a%84sdf-trace" aria-label="世界空间的SDF Trace">世界空间的SDF Trace</a></li></ul>
                </li>
                <li>
                    <a href="#surface-cache" aria-label="Surface Cache">Surface Cache</a><ul>
                        
                <li>
                    <a href="#mesh-card" aria-label="Mesh Card">Mesh Card</a></li>
                <li>
                    <a href="#voxel-lighting-cache" aria-label="Voxel Lighting Cache">Voxel Lighting Cache</a></li></ul>
                </li>
                <li>
                    <a href="#radiance-cache" aria-label="Radiance Cache">Radiance Cache</a><ul>
                        
                <li>
                    <a href="#%e5%b1%8f%e5%b9%95%e7%a9%ba%e9%97%b4%e7%9a%84radiance-cache" aria-label="屏幕空间的Radiance Cache">屏幕空间的Radiance Cache</a></li>
                <li>
                    <a href="#%e4%b8%96%e7%95%8c%e7%a9%ba%e9%97%b4%e7%9a%84radiance-cache" aria-label="世界空间的Radiance Cache">世界空间的Radiance Cache</a></li>
                <li>
                    <a href="#%e6%9c%80%e7%bb%88" aria-label="最终">最终</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#nanite" aria-label="Nanite">Nanite</a><ul>
                        
                <li>
                    <a href="#cluster%e7%94%9f%e6%88%90" aria-label="Cluster生成">Cluster生成</a></li>
                <li>
                    <a href="#%e8%a3%81%e5%89%aa%e5%92%8clod%e9%80%89%e6%8b%a9" aria-label="裁剪和LoD选择">裁剪和LoD选择</a></li>
                <li>
                    <a href="#%e5%85%89%e6%a0%85%e5%8c%96%e4%b8%8e%e6%9d%90%e8%b4%a8" aria-label="光栅化与材质">光栅化与材质</a></li>
                <li>
                    <a href="#%e4%b8%b2%e6%b5%81%e5%92%8c%e5%8e%8b%e7%bc%a9" aria-label="串流和压缩">串流和压缩</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%8a%a9%e5%8a%9b%e7%94%b5%e5%bd%b1%e8%99%9a%e6%8b%9f%e5%8c%96%e5%88%b6%e4%bd%9c" aria-label="如何助力电影虚拟化制作">如何助力电影虚拟化制作</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e6%95%88%e6%9e%9c" aria-label="效果">效果</a></li>
                <li>
                    <a href="#%e6%95%88%e7%8e%87" aria-label="效率">效率</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧</p>
</blockquote>
<h1
id="虚幻引擎5.0新功能为电影虚拟化制作助力">虚幻引擎5.0新功能为电影虚拟化制作助力</h1>
<p>2021年5月26日，Epic Games推出虚幻引擎5.0 Early
Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic
Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。</p>
<p>电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。</p>
<h2 id="新功能概览">新功能概览<a hidden class="anchor" aria-hidden="true" href="#新功能概览">¶</a></h2>
<p>虚幻引擎中的电影虚拟化制作模块In-Camera
VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera
VFX系统。更新5.0正式版后，In-Camera
VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。</p>
<p>在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。</p>
<p>但由于In-Camera
VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera
VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera
VFX系统的电影虚拟化制作能力将达到一个新高度。</p>
<p>可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，</p>
<h3 id="lumen">Lumen<a hidden class="anchor" aria-hidden="true" href="#lumen">¶</a></h3>
<p>Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在<code>Engine/Source/Runtime/Renderer/Private/Lumen</code>中。</p>
<p>Lumen的整体思路是以SDF(Signed Distance Field)
Trace为主的混合Tracing框架，同时用重新设计的Surface
Cache场景表达，Radiance Cache作为最终的渲染结果收集。</p>
<h4 id="混合的tracing方案">混合的Tracing方案<a hidden class="anchor" aria-hidden="true" href="#混合的tracing方案">¶</a></h4>
<p>在Lumen中，也可以先尝试调用基于硬件的RTX
Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh
SDF Trace、Voxel Trace(Global SDF
Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。</p>
<h5 id="screen-space-trace">Screen Space Trace<a hidden class="anchor" aria-hidden="true" href="#screen-space-trace">¶</a></h5>
<p>首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen
Space Global
Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical
Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。</p>
<center>
<img src="/images/misc/ue5.0/screen-traces-enabled.webp" alt="screen-traces-enabled" style="zoom: 18%;" /><img src="/images/misc/ue5.0/screen-traces-disabled.webp" alt="screen-traces-disabled" style="zoom: 18%;" />
<center/>
<h5 id="世界空间的sdf-trace">世界空间的SDF Trace<a hidden class="anchor" aria-hidden="true" href="#世界空间的sdf-trace">¶</a></h5>
<p>屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF
Trace。</p>
<p>对于近处的场景（例如1.8m内），Lumen采用Mesh
SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF
Trace。</p>
<p><img src="/images/misc/ue5.0/vis-mesh-distance-fields.webp" alt="vis-mesh-distance-fields" style="zoom: 30%;" /></p>
<p>在Mesh
SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。</p>
<p><img src="/images/misc/ue5.0/mdfresolution-chandelier.png" alt="mdfresolution-chandelier" style="zoom:30%;" /></p>
<p>而远景则将每一个物体的Mesh SDF合并为全局的Global
SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。</p>
<p><img src="/images/misc/ue5.0/vis-global-distance-field.webp" alt="vis-global-distance-field" style="zoom:30%;" /></p>
<p>Global
SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。</p>
<p>最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。</p>
<p>这样，SDF
Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。</p>
<h4 id="surface-cache">Surface Cache<a hidden class="anchor" aria-hidden="true" href="#surface-cache">¶</a></h4>
<p>在Surface
Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface
Cache作一次查询即可获得相对好的结果，提高Tracing效率。</p>
<p><img src="/images/misc/ue5.0/lumen-surface-cache-visualization.png" alt="lumen-surface-cache-visualization" style="zoom:30%;" /></p>
<h5 id="mesh-card">Mesh Card<a hidden class="anchor" aria-hidden="true" href="#mesh-card">¶</a></h5>
<p>SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh
Card的方式参数化存储场景表达。Mesh
Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。</p>
<p>在运行时，基于Mesh
Card对场景做光栅化生成各种所需的G-Buffer，合并到Surface
Cache贴图中，此处的光栅化在Nanite
Mesh上计算效率极高。Trace时根据Cone开角选择对应的Card的MIPMAP，最后根据法线和深度加权并修正结果。</p>
<p>在直接光照中，可以选择其中的部分卡片单独更新光照，并利用Global
SDF做离屏部分的阴影Trace，可以实现非常好的动态光照效果。间接光照依然通过每帧选择部分Card，由Card的Texel发出Global
SDF Trace来计算，并与前帧数据合并得到较好的间接光照效果。</p>
<p><img src="/images/misc/ue5.0/mesh-card-placement-visualization-alt.webp" alt="mesh-card-placement-visualization-alt" style="zoom:30%;" /></p>
<h5 id="voxel-lighting-cache">Voxel Lighting Cache<a hidden class="anchor" aria-hidden="true" href="#voxel-lighting-cache">¶</a></h5>
<p>对于Global SDF Trace，只有空间位置而没有Mesh
Card信息时，Lumen的做法是利用Mesh Card生成一个体素化的场景，从而做Voxel
Trace。每一帧的体素化都需要重新生成，动态地获取体素精度。对每一个Tracing的结果，再分散到周围的Voxel中，以完成最后的Radiance收集。</p>
<h4 id="radiance-cache">Radiance Cache<a hidden class="anchor" aria-hidden="true" href="#radiance-cache">¶</a></h4>
<p>而Radiance
Cache则在屏幕空间做了降采样，用更低的分辨率存储更多方向的Tracing结果，减少了降噪的压力，同时支持跨帧的缓存以减少重复计算。</p>
<h5 id="屏幕空间的radiance-cache">屏幕空间的Radiance Cache<a hidden class="anchor" aria-hidden="true" href="#屏幕空间的radiance-cache">¶</a></h5>
<p>在屏幕空间，例如以16个像素为一个Probe、每个Probe做8*8半球均匀方向分布的Trace，则减少了3/4的计算量，最后在全分辨率上计算BRDF着色。在室内环境能够得到很好的结果。</p>
<p>在实际应用中，还会根据深度平面自适应的Probe细化方式。最后以Probe到像素平面的距离为权重计算。同时利用前帧的重投影，可以根据前一帧较亮的部分、BRDF的值大小做重要性采样（若失败则转用世界空间的Radiance
Cache）。最后在Probe上做空间滤波，以深度判定滤波权重。</p>
<h5 id="世界空间的radiance-cache">世界空间的Radiance Cache<a hidden class="anchor" aria-hidden="true" href="#世界空间的radiance-cache">¶</a></h5>
<p>在世界空间则用更低的分辨率，64*64为一个Probe放置在屏幕空间的Probe周围，来补充屏幕空间Radiance
Cache针对远处小体积高亮物体表现不佳的问题。</p>
<p>世界空间的Radiance
Cache可以有效复用长距离的Trace，提高一致性，从而带来了更高的方向精度，也可以跨帧缓存远距离的Tracing结果。</p>
<p><img src="/images/misc/ue5.0/lumen-far-field.webp" alt="lumen-far-field" style="zoom:100%;" /></p>
<p>世界空间的Radiance
Cache依然用稀疏的体素结构存储。还可以依据屏幕空间累计的结果，做BRDF的重要性采样。</p>
<p>世界空间的Radiance
Cache也用于引导屏幕空间的重要性采样，并用在头发、半透等前向渲染材质，多次反弹等特殊情景的渲染中。</p>
<h5 id="最终">最终<a hidden class="anchor" aria-hidden="true" href="#最终">¶</a></h5>
<p>最后回到屏幕空间全分辨率处理。把屏幕空间的Probe Radiance
Cache转换成三阶球面谐波函数来提高插值质量。用全分辨率的BentNormal获得接触阴影。</p>
<p><img src="/images/misc/ue5.0/lumen-overview-viewmode.png" alt="lumen-overview-viewmode" style="zoom:100%;" /></p>
<p>相比较基于NVIDIA
RTX显卡的RTXGI，Lumen是一个不依赖硬件加速支持、平台统一的全局光照解决方案，由于实时光线追踪在部分场景下降噪困难的局限性，Lumen在大世界的显存占用、室内照明的稳定性上具有很大优势。</p>
<p>Lumen带来了大场景下的优秀的动态全局光照表现，针对间接光阴影、室内漏光、室内高质量间接光、镜面反射、多次反弹的漫反射等实时渲染难题都做了相应的优化，使得实时渲染的质量达到的新的台阶。</p>
<p>因此，Lumen的追求也正符合影视创作对质量的追求，使得实时渲染的影视制作方法得到了更多的应用可能。当然在基于LED背景墙的电影虚拟化制作方式中，作为核心的nDisplay多屏渲染方式暂时还不支持Lumen的渲染管线，但相信不久的将来，会带来广泛的应用。</p>
<h3 id="nanite">Nanite<a hidden class="anchor" aria-hidden="true" href="#nanite">¶</a></h3>
<p>Nanite是虚幻引擎5.0的新的几何体表示方式，目的是为了渲染更多的模型和模型细节，其代码存放在<code>Engine\Source\Runtime\Renderer\Private\Nanite</code>中。</p>
<p>借助Nanite，虚幻引擎5.0可以直接处理高精度扫描、雕刻创作等各种高精度的模型，而不再像过去的实时渲染引擎一样需要手工的LoD(Level
of Detail)处理，并且可以达到像素级别的模型渲染精度。</p>
<p><img src="/images/misc/ue5.0/nanite-in-unreal-engine.webp" alt="nanite-in-unreal-engine" style="zoom: 100%;" /></p>
<p>Nanite的核心理念是在自动的LoD减面时，不损失模型的拓扑精度，且在LoD切换时能够避免跳变。</p>
<h4 id="cluster生成">Cluster生成<a hidden class="anchor" aria-hidden="true" href="#cluster生成">¶</a></h4>
<p>Nanite是基于Cluster的几何表示方案，将模型上的一定数量的面标记为一个Cluster，在GPU处理每一个Cluster时就可以访问等量的内存，带来了更高的效率。</p>
<p>Nanite的Cluster生成利用METIS库的Graph
Partition算法，在最高精度的原始模型（LoD0）上进行处理，并将Cluster组成面积均匀和边界最少的Group。而LoD时则锁定Group的边界，在每一个Group内重新生成Cluster，并将减面误差额外存储。最后对所有LoD层的Cluster分别生成BVH(Bounding
Volume Hierarchy)。</p>
<p><img src="/images/misc/ue5.0/level-viewport-show-nanite-visualizations-overview.webp" alt="level-viewport-show-nanite-visualizations-overview" style="zoom:30%;" /></p>
<h4 id="裁剪和lod选择">裁剪和LoD选择<a hidden class="anchor" aria-hidden="true" href="#裁剪和lod选择">¶</a></h4>
<p>在渲染时，利用前一帧的HZB做裁剪，依次做模型和Cluster的剔除，然后光栅化得到当前帧的HZB再对场景做一次当前帧的裁剪，得到更加精准的裁剪结果。</p>
<p>利用GPU并行和Cluster的类BVH加速结构，可以很快地精确地对细节程度匹配的LoD做剔除和选择。用额外存储的误差进行判断，可以保证被选中的Cluster
Group误差最小，而Group与Group之间边界保持锁定，因此可以保证模型的连接。</p>
<center>
<img src="/images/misc/ue5.0/fallback-mesh-comparison-high-detail-nanite-mesh.webp" alt="fallback-mesh-comparison-high-detail-nanite-mesh" style="zoom:21%;" /><img src="/images/misc/ue5.0/fallback-mesh-comparison-high-detail-nanite-mesh.webp" alt="fallback-mesh-comparison-high-detail-nanite-mesh" style="zoom:21%;" />
<center/>
<h4 id="光栅化与材质">光栅化与材质<a hidden class="anchor" aria-hidden="true" href="#光栅化与材质">¶</a></h4>
<p>传统的光栅化管线对Nanite这样的小于单个像素的三角形并不友好，因此在Nanite重新设计了软件光栅化管线，根据Cluster的粒度来决定使用自定义软件光栅还是硬件光栅。最后输出实例ID、三角形ID、深度定义的Visibility
Buffer。</p>
<p>利用Visibility
Buffer，可以很好地解耦材质的复杂度。在每个Cluster上，可以支持存储32位的材质信息，每个模型最多可以支持64种材质。最后基于Tile，每种材质做一次Draw进行渲染。</p>
<h4 id="串流和压缩">串流和压缩<a hidden class="anchor" aria-hidden="true" href="#串流和压缩">¶</a></h4>
<p>此外，由于Nanite庞大的数据结构，在串流和压缩上也做了相应的优化。</p>
<p>在GPU端存储裁剪的层级结构，而串流采用类似Virtual
Texture的处理逻辑，根据渲染的需要，以Cluster
Group为粒度传输相应的几何数据。</p>
<p>利用通用的硬件压缩，根据数据的特征调整后的压缩方法，也实现了非常好的压缩效果。</p>
<p>基于Nanite，还可以实现虚拟阴影贴图等新特性。虽然目前支持的材质和几何类型并不完全，关于前向渲染和光线追踪等渲染方式的尚不支持，但Nanite已经为实时渲染带来了非常高的几何细节，也带来了更高的创作效率。</p>
<center>
<img src="/images/misc/ue5.0/nanite-facetfaces-gameview.png" alt="nanite-facetfaces-gameview" style="zoom:33%;" /><img src="/images/misc/ue5.0/nanite-facetfaces-trianglevis.png" alt="nanite-facetfaces-trianglevis" style="zoom:33%;" />
<center/>
<p>此外，虚幻引擎5.0在大世界构成上的世界分区系统、角色动画创作上更友好的工具、更多材质效果支持的路径追踪器以及更丰富的Chaos系统等等主要针对游戏、离线动画创作的新功能，也可以在一定程度上助力电影虚拟化制作，带来各种各样的可能性。</p>
<h2 id="如何助力电影虚拟化制作">如何助力电影虚拟化制作<a hidden class="anchor" aria-hidden="true" href="#如何助力电影虚拟化制作">¶</a></h2>
<p>实时渲染引擎是电影虚拟化制作技术发展的基石之一，Lumen和Nanite为代表的虚幻引擎5.0重点新功能对于电影虚拟化制作的意义巨大，主要可以从效果和效率两方面来考虑。</p>
<h4 id="效果">效果<a hidden class="anchor" aria-hidden="true" href="#效果">¶</a></h4>
<p>电影虚拟化制作的最终服务目标是电影，影院的观影环境决定了电影质量的要求是要比小屏幕影像高得多的。而实时渲染的结果却从客观条件上就受限于“实时”的条件，很难达到离线渲染的精度。因此，目前电影虚拟化制作的应用也大多集中在广告、剧集领域，其渲染效果距离电影尚存在一定差距。</p>
<p>虚幻引擎5.0的渲染方面新功能，无疑将实时渲染的画面质量提高了一个台阶，一些条件下甚至可以一定程度地接近离线渲染效果。例如Lumen带来的动态全局光照、Nanite带来的像素级几何细节，都为实时渲染在影视制作中的应用提供了巨大的助力，使得电影虚拟化制作的影像效果得到了很大提升。</p>
<h4 id="效率">效率<a hidden class="anchor" aria-hidden="true" href="#效率">¶</a></h4>
<p>目前，电影虚拟化制作的创作瓶颈主要在于，它将传统影视制作的流程顺序改变之后，数字资产的制作主要在拍摄之前完成、美术置景也大量通过数字方式完成，且需要以实时渲染的方式来实现。这对传统影视制作领域的美术创作者、视效创作者来说是相对陌生的，各制作机构的制作流程管线也尚在探索与搭建中。因此电影虚拟化制作场景制作尚不能达到传统影视制作的效率。</p>
<p>在实时渲染引擎中的美术创作则更贴合游戏美术制作的思路，需要更多地考虑性能开销、资产优化等问题。而虚幻引擎5.0的许多编辑器更多则带来了更自动化的优化方式和可视化方案。例如Nanite可以完全解放传统美术生产管线中的手工LoD环节，Lumen的各种可视化功能也有助于美术工作者更方便地看到资产的各种信息从而加以优化。</p>
<p>实时渲染引擎加持的影视制作是近年来影视行业非常关注的新技术，电影虚拟化制作作为其中的主流应用方案，也得到了广泛的研究与应用。虚幻引擎5.0的发布展现了CG创作呈现工具的发展趋势与新型技术方案，为电影虚拟化制作也带来了更多的动力，相信更多的创作工具、制作技术也会受之启发或借助其力量诞生、发展。</p>
<p><strong>图片来源</strong></p>
<p>[1] Epic Games. Lumen Technical Details.
https://docs.unrealengine.com/5.0/en-US/lumen-technical-details-in-unreal-engine/
[2] Epic Games. Nanite Virtualized Geometry.
https://docs.unrealengine.com/5.0/en-US/nanite-virtualized-geometry-in-unreal-engine/</p>
<p><strong>参考文献</strong></p>
<p>[1] Epic Games. Unreal Engine 5.0 Release Notes.
https://docs.unrealengine.com/5.0/en-US/unreal-engine-5-0-release-notes/
[2] Epic Games. Lumen Technical Details.
https://docs.unrealengine.com/5.0/en-US/lumen-technical-details-in-unreal-engine/
[3] 王祢. [UOD2021]虚幻引擎5渲染特性解析 Lumen | Epic Games 王祢.
https://www.bilibili.com/video/BV1fu411272a [4] Unreal Engine. Lumen |
Inside Unreal. https://www.youtube.com/channel/UCBobmJyzsJ6Ll7UbfhI4iwQ
[5] Epic Games. Nanite Virtualized Geometry.
https://docs.unrealengine.com/5.0/en-US/nanite-virtualized-geometry-in-unreal-engine/
[6] 王祢. [UnrealCircle]Nanite技术简介 | Epic Games China 王祢.
https://www.bilibili.com/video/BV1MP4y1a7Hh [7] Unreal Engine. Nanite |
Inside Unreal. https://www.youtube.com/watch?v=TMorJX3Nj6U</p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://elderlyaugustus.github.io/posts/2022-03-01-2023%E5%B1%8A%E6%A0%A1%E6%8B%9B%E7%AE%80%E5%8E%86/">
    <span class="title">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline></svg>&nbsp;Prev Page</span>
    <br>
    <span>2022-03-01-2023年校招简历</span>
  </a>
  <a class="next" href="https://elderlyaugustus.github.io/posts/2021-04-05-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture3-4-softshadow/">
    <span class="title">Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg>
    </span>
    <br>
    <span>2021-04-05-GAMES202高质量实时渲染-Lecture3-4-Soft Shadow</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2024 <a href="https://elderlyaugustus.github.io/">xα&#39;s blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instantintegrity=""
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied!';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>
