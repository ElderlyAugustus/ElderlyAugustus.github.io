<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数值分析 on xα&#39;s blog</title>
    <link>http://localhost:1313/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 数值分析 on xα&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 11 Mar 2021 17:00:00 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021-03-11-数值分析-Day14-RungeKutta方法-线性多步方法</title>
      <link>http://localhost:1313/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 11 Mar 2021 17:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/</guid>
      <description>7.5 - 7.7 Runge-Kutta方法 单步高阶方法构造思路 设 \(y(x)\) 是一阶常微分方程初值问题的精确解，Taylor展开得： \[ \begin{aligned} \displaystyle y(x_{n+1})&amp;amp;=y(x_n)+y&amp;#39;(x_n)h+\frac{y&amp;#39;&amp;#39;(x_n)}{2!}h^2+\dots+\frac{y^{(p)}(x_n)}{p!}h^p+\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\ &amp;amp;=y(x_n)+hf(x_n,y(x_n))+\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\end{aligned} \] 因此可建立节点处近似值 \(y_n\) 满足的差分公式： \[ \left\{\begin{array}{l}\displaystyle y_{n+1}=y_n+hf(x_n,y_n)+\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\y_0=\alpha,\quad n=0,1,\dots,N-1\end{array}\right. \] 称之为 \(\mathbf p\) 阶Taylor展开方法。 其中： \(\begin{array}{l}\displaystyle f^{(1)}(x,y)=\frac{\partial f(x,y)}{\partial x}+\frac{\partial f(x,y)}{\partial y}f(x,y)\\\displaystyle f^{(2)}(x,y)=\frac{\partial^2f}{\partial x^2}+2\frac{\partial^2f}{\partial x\partial y}f+\frac{\partial^2 f}{\partial y^2}f^2+\frac{\partial f}{\partial x}\frac{\partial f}{\partial y}+\left(\frac{\partial f}{\partial y}\right)^2f\\\dots\end{array}\)
计算过于复杂，很少直接使用
减少Taylor展开次数得： \[ y(x_{n+1})=y(x_n)+hy&amp;#39;(\xi)=y(x_n)+hf(\xi,y(\xi)),\quad x_n\le\xi\le x_{n+1} \] 构造差分方法即利用适当的函数值来近似计算 \(f(\xi,y(\xi))\) 。
Euler方法用 \(K_1\) 作为其近似，其 \(y_{n+1}\) 表达式与精确解的Taylor展式前 \(2\) 项一致。为 \(1\) 阶方法。 改进Euler方法用 \(K_1,K_2\) 的线性组合作为其近似，其 \(y_{n+1}\) 表达式与精确解的Taylor展式前 \(3\) 项一致。为 \(2\) 阶方法。 能否增加计算 \(f(x,y)\) 的次数来提高方法阶数？ Runge-Kutta方法 \[ \left\{\begin{array}{l} y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2+\dots+\lambda_pK_p)\\ K_1=f(x_n,y_n)\\ K_2=f(x_n+\alpha_2h,y_n+h\beta_{21}K_1)\\ \dots\\ K_p=f(x_n+\alpha_ph,y_n+h\sum\limits_{i=1}^{p-1}\beta_{pi}K_i) \end{array}\right.</description>
      <content:encoded><![CDATA[<h3 id="runge-kutta方法">7.5 - 7.7 Runge-Kutta方法</h3>
<h4 id="单步高阶方法构造思路">单步高阶方法构造思路</h4>
<p>设 <span class="math inline">\(y(x)\)</span>
是一阶常微分方程初值问题的精确解，Taylor展开得： <span
class="math display">\[
\begin{aligned}
\displaystyle
y(x_{n+1})&amp;=y(x_n)+y&#39;(x_n)h+\frac{y&#39;&#39;(x_n)}{2!}h^2+\dots+\frac{y^{(p)}(x_n)}{p!}h^p+\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\
&amp;=y(x_n)+hf(x_n,y(x_n))+\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\end{aligned}
\]</span> 因此可建立节点处近似值 <span
class="math inline">\(y_n\)</span> 满足的差分公式： <span
class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_n+hf(x_n,y_n)+\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\y_0=\alpha,\quad
n=0,1,\dots,N-1\end{array}\right.
\]</span> 称之为 <span class="math inline">\(\mathbf p\)</span>
<strong>阶Taylor展开方法</strong>。 其中： <span
class="math inline">\(\begin{array}{l}\displaystyle
f^{(1)}(x,y)=\frac{\partial f(x,y)}{\partial x}+\frac{\partial
f(x,y)}{\partial y}f(x,y)\\\displaystyle
f^{(2)}(x,y)=\frac{\partial^2f}{\partial
x^2}+2\frac{\partial^2f}{\partial x\partial y}f+\frac{\partial^2
f}{\partial y^2}f^2+\frac{\partial f}{\partial x}\frac{\partial
f}{\partial y}+\left(\frac{\partial f}{\partial
y}\right)^2f\\\dots\end{array}\)</span></p>
<blockquote>
<p>计算过于复杂，很少直接使用</p>
</blockquote>
<p>减少Taylor展开次数得： <span class="math display">\[
y(x_{n+1})=y(x_n)+hy&#39;(\xi)=y(x_n)+hf(\xi,y(\xi)),\quad x_n\le\xi\le
x_{n+1}
\]</span> 构造差分方法即利用适当的函数值来近似计算 <span
class="math inline">\(f(\xi,y(\xi))\)</span> 。</p>
<ul>
<li>Euler方法用 <span class="math inline">\(K_1\)</span> 作为其近似，其
<span class="math inline">\(y_{n+1}\)</span>
表达式与精确解的Taylor展式前 <span class="math inline">\(2\)</span>
项一致。为 <span class="math inline">\(1\)</span> 阶方法。</li>
<li>改进Euler方法用 <span class="math inline">\(K_1,K_2\)</span>
的线性组合作为其近似，其 <span class="math inline">\(y_{n+1}\)</span>
表达式与精确解的Taylor展式前 <span class="math inline">\(3\)</span>
项一致。为 <span class="math inline">\(2\)</span> 阶方法。</li>
<li>能否增加计算 <span class="math inline">\(f(x,y)\)</span>
的次数来提高方法阶数？</li>
</ul>
<h4 id="runge-kutta方法-1">Runge-Kutta方法</h4>
<p><span class="math display">\[
\left\{\begin{array}{l}
y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2+\dots+\lambda_pK_p)\\
K_1=f(x_n,y_n)\\
K_2=f(x_n+\alpha_2h,y_n+h\beta_{21}K_1)\\
\dots\\
K_p=f(x_n+\alpha_ph,y_n+h\sum\limits_{i=1}^{p-1}\beta_{pi}K_i)
\end{array}\right.
\]</span> 其中 <span
class="math inline">\(\{\lambda_i,\alpha_i,\beta_{ij}\}\)</span>
为待定系数，此公式称为 <span class="math inline">\(\mathbf p\)</span>
<strong>级Runge-Kutta方法</strong>。 若该公式局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> ，则称其为 <span
class="math inline">\(\mathbf p\)</span>
<strong>阶Runge-Kutta方法</strong>。</p>
<ul>
<li><span class="math inline">\(\mathbf{p=2}\)</span> 时，二级R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2)\\
  K_1=f(x_n,y_n)\\
  K_2=f(x_n+\alpha h,y_n+h\beta K_1)\\
  \end{array}\right.
  \]</span> Taylor展开分析易得，只要令 <span
class="math inline">\(\lambda_1+\lambda_2=1,\ \alpha\lambda_2=1/2,\
\beta\lambda_2=1/2\)</span> 即可使局部截断误差达到 <span
class="math inline">\(O(h^3)\)</span>
，为二阶R-K公式。该条件有多组解：</li>
<li><span class="math inline">\(\alpha=1,\ \lambda_1=\lambda_2=1/2,\
\beta=1\)</span> 时即为改进Euler公式。</li>
<li><span class="math inline">\(\lambda_1=0,\ \lambda_2=1,\
\alpha=\beta=1/2\)</span> 时为<strong>中点公式</strong>。</li>
<li><span class="math inline">\(\mathbf{p=3}\)</span> 时，三阶R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  \displaystyle y_{n+1}=y_n+\frac{h}{6}(K_1+4K_2+K_3)\\
  \displaystyle K_1=f(x_n,y_n)\\
  \displaystyle K_2=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_1)\\
  \displaystyle K_3=f(x_n+h,y_n-hK_1+2hK_2)
  \end{array}\right.
  \]</span></li>
<li><span class="math inline">\(\mathbf{p=4}\)</span> 时，四阶R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  \displaystyle y_{n+1}=y_n+\frac{h}{6}(K_1+2K_2+2K_3+K_4)\\
  \displaystyle K_1=f(x_n,y_n)\\
  \displaystyle K_2=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_1)\\
  \displaystyle K_3=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_2)\\
  \displaystyle K_4=f(x_n+h,y_n+hK_3)
  \end{array}\right.
  \]</span></li>
</ul>
<h5 id="隐式runge-kutta方法">隐式Runge-Kutta方法</h5>
<p>一般形式： <span class="math display">\[
\left\{\begin{array}{l}
\displaystyle y_{n+1}=y_n+h\sum_{r=1}^p\lambda_rK_r\\
\displaystyle
K_r=f(x_n+\alpha_rh,y_n+h\sum_{i=1}^r\lambda_{ri}K_i),\quad
r=1,2,\dots,p
\end{array}\right.
\]</span> 称为 <span class="math inline">\(\mathbf p\)</span>
<strong>级隐式Runge-Kutta方法</strong>。（如梯形公式就是二级隐式R-K方法。）</p>
<p>缺点是计算量较大，优点是数值稳定性好。</p>
<h5 id="变步长runge-kutta方法">变步长Runge-Kutta方法</h5>
<p>设从 <span class="math inline">\(x_n\)</span> 以步长 <span
class="math inline">\(h\)</span> 计算 <span
class="math inline">\(y(x_{n+1})\)</span> 的近似值为 <span
class="math inline">\(y_{n+1}^{(h)}\)</span> ，设有局部截断误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}^{(h)}=Ch^{p+1}\)</span> 。</p>
<p>设从 <span class="math inline">\(x_n\)</span> 以步长 <span
class="math inline">\(\frac{h}{2}\)</span> 计算 <span
class="math inline">\(y(x_{n+1})\)</span> 的近似值为 <span
class="math inline">\(y_{n+1}^{(\frac{h}{2})}\)</span>
，则有局部截断误差 <span class="math inline">\(\displaystyle
y(x_{n+1})-y_{n+1}^{(\frac{h}{2})}\approx \frac{1}{2^p}Ch^{p+1}\)</span>
。</p>
<p>两式相除得 <span
class="math inline">\(\displaystyle\frac{y(x_{n+1})-y_{n+1}^{(\frac{h}{2})}}{y(x_{n+1})-y_{n+1}^{(h)}}\approx\frac{1}{2^p}\)</span>
，从而得事后误差估计 <span class="math inline">\(\displaystyle
y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)}\approx\frac{1}{2^p-1}(y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)})\)</span>
。</p>
<p>因此当 <span
class="math inline">\(\displaystyle\left|y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)}\right|\le\varepsilon\)</span>
时，可取 <span class="math inline">\(\displaystyle
y_{n+1}^{(\frac{h}{2})}\approx y_{n+1}^{(h)}\)</span>
，否则将步长减半计算，直至满足精度要求。</p>
<h3 id="单步方法的性质">7.7 - 7.11 单步方法的性质</h3>
<h4 id="收敛性">收敛性</h4>
<p>求解初值问题的单步显式方法可统一写为如下形式： <span
class="math display">\[
y_{n+1}=y_n+h\Phi(x_n,y_n,h)
\]</span> 其中 <span class="math inline">\(\Phi(x,y,h)\)</span>
称为<strong>增量函数</strong>。不同方法对应着不同的增量函数。</p>
<p><strong>定义</strong>：设 <span class="math inline">\(y(x)\)</span>
是一阶常微分方程初值问题的精确解， <span
class="math inline">\(y_n\)</span>
是某单步方法产生的近似解，如任一固定点 <span
class="math inline">\(x_n\)</span> ，均有： <span
class="math display">\[
\displaystyle\lim_{h\to0}y_n=y(x_n)
\]</span> 则称此单步方法<strong>收敛</strong>。因为此时 <span
class="math inline">\(y(x_n)-y_n\)</span> 不仅与 <span
class="math inline">\(y_{n+1}\)</span> 一步计算有关，而与前面的 <span
class="math inline">\(n\)</span>
步计算均有关，故称之为<strong>整体截断误差</strong>。（该定义也适用于单步隐式方法和多步方法。）</p>
<p><strong>定理</strong>：若某单步显式方法满足： + 是 <span
class="math inline">\(p\)</span> 阶方法，也即局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> ； + 增量函数 <span
class="math inline">\(\Phi(x,y,h)\)</span> 在区域 <span
class="math inline">\(\{a\le x\le b,-\infty&lt;y&lt;+\infty,0\le h\le
h_0\}\)</span> 上连续，且关于 <span class="math inline">\(y\)</span>
满足Lipschitz条件，即存在常数 <span
class="math inline">\(L&gt;0\)</span> 使 <span
class="math inline">\(|\Phi(x,y,h)-\Phi(x,\bar{y},h)|\le
L|y-\bar{y}|\)</span> ； + 初始近似 <span
class="math inline">\(y_0=y(\alpha)=\alpha\)</span> 。
则此单步方法收敛，且存在与 <span class="math inline">\(h\)</span>
无关的常数 <span class="math inline">\(C\)</span> ，使得 <span
class="math inline">\(|y(x_n)-y_n|\le Ch^p\)</span> 。</p>
<p>易证，Euler方法、改进Euler方法均是收敛的。</p>
<p>（注意，此处差分方法的收敛性与前面构造改进Euler方法时所用到的“校正步骤的收敛性不同。）</p>
<h4 id="稳定性">稳定性</h4>
<blockquote>
<p>收敛性反映截断误差，稳定性反映舍入误差。</p>
</blockquote>
<p>下面用 <span class="math inline">\(y(x_n)\)</span> 表示精确值， <span
class="math inline">\(y_n\)</span> 表示理论计算值（只考虑截断误差），
<span class="math inline">\(\bar{y}_n\)</span>
表示实际计算值（还考虑舍入误差）。</p>
<p>讨论数值方法稳定性通常仅限于典型试验方程： <span
class="math inline">\(\displaystyle\frac{dy}{dx}=\lambda y\)</span>
，其中 <span class="math inline">\(\lambda\)</span> 为复数且 <span
class="math inline">\(Re(\lambda)&lt;0\)</span> 。</p>
<p><strong>定义1</strong>：对于某给定初值问题（试验方程），假设只在一个节点值
<span class="math inline">\(y_n\)</span> 上产生计算误差 <span
class="math inline">\(\delta\)</span>
，若该误差引起之后各节点的计算值变化均不超过 <span
class="math inline">\(\delta\)</span>
，则称此差分方法<strong>绝对稳定</strong>。（对一般差分方法。）</p>
<p><strong>定义2</strong>：将单步方法应用于解试验方程，假设得 <span
class="math inline">\(y_{n+1}=E(\lambda h)y_n\)</span> ，若满足条件
<span class="math inline">\(|E(\lambda h)|&lt;1\)</span>
，则称此单步方法<strong>绝对稳定</strong>。在复平面上，变量 <span
class="math inline">\(\lambda h\)</span> 满足 <span
class="math inline">\(|E(\lambda h)|&lt;1\)</span>
的区域称为该方法的<strong>绝对稳定域</strong>，其与实轴的交集称为<strong>绝对稳定区间</strong>。（
<span class="math inline">\(|E(\lambda h)|=1\)</span>
时也可认为误差没有增长，方法稳定。）（对单步方法。）</p>
<ul>
<li>Euler方法：绝对稳定域 <span class="math inline">\(|1+\lambda
h|&lt;1\)</span> ，绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>梯形公式：绝对稳定域 <span class="math inline">\(Re(\lambda
h)&lt;0\)</span> ，绝对稳定区间 <span
class="math inline">\((-\infty,0)\)</span> 。</li>
<li>改进Euler方法：绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>二阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>三阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2.51,0)\)</span> 。</li>
<li>四阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2.78,0)\)</span> 。</li>
</ul>
<p>综上，单步显式方法的稳定性与步长密切相关。步长过小时又会导致计算量过大。</p>
<h3 id="线性多步方法">7.12 - 7.13 线性多步方法</h3>
<blockquote>
<p>单步方法计算简便，但精度较低。精度较高的单步方法（如四阶R-K方法），计算量较大。</p>
</blockquote>
<h4 id="待定参数法构造线性多步方法">待定参数法构造线性多步方法</h4>
<p><span class="math display">\[
\displaystyle
y_{n+1}=\sum_{i=0}^r\alpha_iy_{n-i}+h\sum_{i=-1}^r\beta_if_{n-1}
\]</span></p>
<p>若 <span class="math inline">\(\beta_{-1}\neq0\)</span>
公式为隐式，反之为显式。</p>
<p>参数 <span class="math inline">\(\{\alpha_i,\beta_i\}\)</span>
的选择原则是使方法局部截断误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}=O(h^{r+2})\)</span> 。（指在
<span class="math inline">\(y(x_{n-i})=y_{n-i}\)</span>
前提下的截断误差。）</p>
<h4 id="数值积分构造线性多步方法">数值积分构造线性多步方法</h4>
<p>由 <span class="math display">\[
\displaystyle y(x_{n+1})=y(x_n)+\int_{x_n}^{x_{n+1}}f(x,y(x))dx
\]</span> 设 <span class="math inline">\(p_r(x)\)</span> 为函数 <span
class="math inline">\(f(x,y(x))\)</span> 的某个 <span
class="math inline">\(r\)</span> 次插值多项式，则有 <span
class="math display">\[
\displaystyle y(x_{n+1})=y(x_n)+\int_{x_n}^{x_{n+1}}p_r(x)dx+R_n
\]</span> 其中 <span
class="math inline">\(R_n=\int_{x_n}^{x_{n+1}}(f(x,y(x))-p_r(x))dx\)</span>
。由此可建立差分公式： <span class="math display">\[
\displaystyle y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}p_r(x)dx
\]</span></p>
<h5 id="adams显式公式">Adams显式公式</h5>
<p>设精确解 <span class="math inline">\(y(x)\)</span> 在步长为 <span
class="math inline">\(h\)</span> 的等距节点 <span
class="math inline">\(x_{n-r},\dots,x_n\)</span> 上的近似值 <span
class="math inline">\(y_{n-r},\dots,y_n\)</span> 。 记 <span
class="math inline">\(f_k=f(x_k,y_k)\)</span> ，利用 <span
class="math inline">\(r+1\)</span> 个数据 <span
class="math inline">\((x_{n-r},f_{n-r}),\dots,(x_n,f_n)\)</span> 构造
<span class="math inline">\(r\)</span> 次Lagrange插值多项式： <span
class="math display">\[
\displaystyle p_r(x)=\sum_{j=0}^rl_{n-j}(x)f_{n-j}
\]</span> 其中: <span class="math display">\[
\displaystyle l_{n-j}(x)=\prod_{k=0,k\neq
j}^r\frac{x-x_{n-k}}{x_{n-j}-x_{n-k}},\quad j=0,1,\dots,r
\]</span> 由此建立差分公式： <span class="math display">\[
\displaystyle
y_{n+1}=y_n+\sum_{j=0}^r\left(\int_{x_n}^{x_{n+1}}l_{n-j}(x)dx\right)f_{n-j}
\]</span></p>
<p>由此整理得差分公式的具体形式： <span class="math display">\[
\begin{array}{c}\displaystyle
y_{n+1}=y_n+h\sum_{j=0}^r\beta_{rj}f_{n-j}\\
令x=x_n+th,\displaystyle\quad\beta_{rj}=\frac{(-1)^j}{j!(r-j)!}\int_0^1\prod_{k=0,k\neq
j}^r(t+k)dt,\quad j=0,1,\dots,r\end{array}
\]</span> 称之为 <span class="math inline">\(\mathbf{r+1}\)</span>
<strong>步Adams显式公式</strong>。</p>
<ul>
<li><span class="math inline">\(r=0,\quad\displaystyle
y_{n+1}=y_n+hf_n+\frac{1}{2}h^2y&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=1,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{2}(3f_n-f_{n-1})+\frac{5}{12}h^3y&#39;&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=2,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{12}(23f_n-16f_{n-1}+5f_{n-2})+\frac{3}{8}h^4y^{(4)}(x_n)\)</span></li>
<li><span class="math inline">\(r=3,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{24}(55f_n-59f_{n-1}+37f_{n-2}-9f_{n-3})+\frac{251}{720}h^5y^{(5)}(x_n)\)</span></li>
</ul>
<h5 id="adams隐式公式">Adams隐式公式</h5>
<p>利用 <span class="math inline">\(r+1\)</span> 个数据 <span
class="math inline">\((x_{n-r+1},f_{n-r+1}),\dots,(x_{n+1},f_{n+1})\)</span>
，则可到处数值稳定性较好的隐式公式，其一般形式为： <span
class="math display">\[
\begin{array}{c}\displaystyle
y_{n+1}=y_n+h\sum_{j=0}^r\beta_{rj}^*f_{n-j+1}\\
令x=x_n+th,\displaystyle\quad\beta_{rj}^*=\frac{(-1)^j}{j!(r-j)!}\int_{-1}^0\prod_{k=0,k\neq
j}^r(t+k)dt,\quad j=0,1,\dots,r\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(r=0,\quad\displaystyle
y_{n+1}=y_n+hf_{n+1}+\frac{1}{2}h^2y&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=1,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{2}(f_{n+1}+f_n)-\frac{1}{12}h^3y&#39;&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=2,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{12}(5f_{n+1}-8f_n-f_{n-1})-\frac{1}{24}h^4y^{(4)}(x_n)\)</span></li>
<li><span class="math inline">\(r=3,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{24}(9f_{n+1}+19f_n-5f_{n-1}+f_{n-2})-\frac{19}{720}h^5y^{(5)}(x_n)\)</span></li>
</ul>
<h5 id="adams预估-校正公式">Adams预估-校正公式</h5>
<p>由显式公式提供一个预估值，再用隐式公式校正一次得到数值解，称为预估-校正方法。
一般预估公式和校正公式都采用同阶公式（ <span
class="math inline">\(r\)</span> 相等）。</p>
<p>如使用四阶Adams显式公式和隐式公式则： <span class="math display">\[
\bar{f}_{n+1}=f(x_{n+1},\bar{y}_{n+1}),\ n=3,4,\dots
\]</span>
称为<strong>四阶Adams预估校正公式</strong>，实际计算中通常用四阶单步方法（如四阶R-K公式）为其提供起始值
<span class="math inline">\(y_1,y_2,y_3\)</span> 。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-10-数值分析-Day13-差分公式</title>
      <link>http://localhost:1313/posts/2021-03-10-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day13-%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Wed, 10 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-10-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day13-%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F/</guid>
      <description>7.1 - 7.4 差分公式 一阶常微分方程初值问题 一阶常微分方程初值问题的一般形式为：
\[ \left\{\begin{array}{l}\displaystyle\frac{dy}{dx}=f(x,y),\quad a\le x\le b\\y(a)=\alpha\end{array}\right. \] 其中 \(f(x,y)\) 为已知函数， \(\alpha\) 为给定的值。
在许多数学模型中，上述方程通常以 \(x\) 描述时间，而定解条件 \(y(a)=\alpha\) 则给出了函数 \(y(x)\) 在初始时刻的取值。因此称为初值问题。
问题： + 上述方程何时存在唯一解 + 如何计算 \(y(x)\)
Lipschitz条件： 若函数 \(f(x,y)\) 在区域 \(\{a\le x\le b,\ m&amp;lt;y&amp;lt;M\}\) 上连续，满足 \[ \forall y,\bar{y},\ |f(x,y)-f(x,\bar{y})|\le L|y-\bar{y}| \] 其中 \(L&amp;gt;0\) 为Lipschitz常数（此处Lipschitz常数可以 \(\ge1\) ），则初值问题在初始时刻 \(a\) 的某个邻域上存在唯一解。 （不满足Lipschitz条件时，不一定存在唯一解。）
构造一阶常微分方程初值问题数值解法 假设初值问题的解 \(y=y(x)\) 唯一存在且足够光滑。对求解区域 \([a,b]\) 做等距剖分 \(a=x_0&amp;lt;x_1&amp;lt;x_2&amp;lt;\dots&amp;lt;x_n&amp;lt;\dots&amp;lt;x_N=b\) 。称 \(h=(b-a)/N\) 为剖分步长， \(x_n=a+nh,\ n=0,1,\dots,N\) 为剖分节点。数值解法即求精确解 \(y(x)\) 在剖分节点 \(x_n\) 上的值 \(y(x_n)\) 的近似值 \(y_n\) 。</description>
      <content:encoded><![CDATA[<h3 id="差分公式">7.1 - 7.4 差分公式</h3>
<blockquote>
<h4 id="一阶常微分方程初值问题">一阶常微分方程初值问题</h4>
<p>一阶常微分方程初值问题的一般形式为：<br />
<span class="math display">\[
\left\{\begin{array}{l}\displaystyle\frac{dy}{dx}=f(x,y),\quad a\le x\le
b\\y(a)=\alpha\end{array}\right.
\]</span> 其中 <span class="math inline">\(f(x,y)\)</span> 为已知函数，
<span class="math inline">\(\alpha\)</span> 为给定的值。</p>
<p>在许多数学模型中，上述方程通常以 <span
class="math inline">\(x\)</span> 描述时间，而定解条件 <span
class="math inline">\(y(a)=\alpha\)</span> 则给出了函数 <span
class="math inline">\(y(x)\)</span>
在初始时刻的取值。因此称为<strong>初值问题</strong>。</p>
<p><strong>问题</strong>： + 上述方程何时存在唯一解 + 如何计算 <span
class="math inline">\(y(x)\)</span></p>
<p><strong>Lipschitz条件</strong>： 若函数 <span
class="math inline">\(f(x,y)\)</span> 在区域 <span
class="math inline">\(\{a\le x\le b,\ m&lt;y&lt;M\}\)</span>
上连续，满足 <span class="math display">\[
\forall y,\bar{y},\ |f(x,y)-f(x,\bar{y})|\le L|y-\bar{y}|
\]</span> 其中 <span class="math inline">\(L&gt;0\)</span>
为Lipschitz常数（此处Lipschitz常数可以 <span
class="math inline">\(\ge1\)</span> ），则初值问题在初始时刻 <span
class="math inline">\(a\)</span> 的某个邻域上存在唯一解。
（不满足Lipschitz条件时，不一定存在唯一解。）</p>
</blockquote>
<h4
id="构造一阶常微分方程初值问题数值解法">构造一阶常微分方程初值问题数值解法</h4>
<p>假设初值问题的解 <span class="math inline">\(y=y(x)\)</span>
唯一存在且足够光滑。对求解区域 <span
class="math inline">\([a,b]\)</span> 做等距剖分 <span
class="math inline">\(a=x_0&lt;x_1&lt;x_2&lt;\dots&lt;x_n&lt;\dots&lt;x_N=b\)</span>
。称 <span class="math inline">\(h=(b-a)/N\)</span>
为<strong>剖分步长</strong>， <span class="math inline">\(x_n=a+nh,\
n=0,1,\dots,N\)</span> 为<strong>剖分节点</strong>。数值解法即求精确解
<span class="math inline">\(y(x)\)</span> 在剖分节点 <span
class="math inline">\(x_n\)</span> 上的值 <span
class="math inline">\(y(x_n)\)</span> 的近似值 <span
class="math inline">\(y_n\)</span> 。</p>
<p><strong>差分公式</strong>：在区间 <span
class="math inline">\([x_n,x_{n+1}]\)</span>
上对微分方程两端同时积分有： <span class="math display">\[
\displaystyle y(x_{n+1})-y(x_n)=\int_{x_n}^{x_{n+1}}f(x,y(x))dx
\]</span>
对该式右边积分部分应用不同的数值积分公式（参考前一章）做逼近，就得到相应不同的差分公式。</p>
<ul>
<li><strong>Euler公式</strong>：对右边积分应用左矩形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx(b-a)f(a)\)</span>
，得到Euler差分公式： <span class="math display">\[
\left\{\begin{array}{l}y_{n+1}=y_n+hf(x_n,y_n)\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span></li>
<li><strong>梯形公式</strong>：对右边积分应用梯形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{(b-a)}{2}[f(a)+f(b)]\)</span>
，得到梯形差分公式： <span class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_n+\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span></li>
<li><strong>Euler中点公式</strong>：将积分范围扩大为 <span
class="math inline">\([x_{n-1},x_{n+1}]\)</span> ，有 <span
class="math display">\[
\displaystyle y(x_{n+1})-y(x_{n-1})=\int_{x_{n-1}}^{x_{n+1}}f(x,y(x))dx
\]</span> 对右边积分应用中矩形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx(b-a)[f(\frac{a+b}{2})]\)</span>
，得到Euler中点公式（或称<strong>双步Euler公式</strong>）： <span
class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_{n-1}+2hf(x_n,y_n)\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span> 该公式属于多步方法，需要更多初值信息。</li>
</ul>
<p>其中，Euler公式和Euler中点公式为<strong>显式方法</strong>，梯形公式为<strong>隐式方法</strong>。</p>
<h4 id="改进euler方法">改进Euler方法</h4>
<blockquote>
<p>梯形公式计算精度好，但属于隐式公式，不便计算。</p>
</blockquote>
<p>根据非线性方程迭代法的思想，进行如下近似计算： <span
class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;y_{n+1}^{[0]}=y_n+hf(x_n)\\
\displaystyle&amp;y_{n+1}^{[k+1]}=y_n+\frac{h}{2}[f(x_n,y_n),f(x_{n+1},y_{n+1}^{[k]})]\\
&amp;&amp;k=0,1,\dots\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span> 即首先应用Euler公式提供 <span
class="math inline">\(y_{n+1}\)</span>
的初始值（<strong>预估</strong>），然后采用梯形公式框架进行关于 <span
class="math inline">\(y_{n+1}\)</span>
值的迭代计算（<strong>校正</strong>）。</p>
<blockquote>
<p>校正过程中迭代计算是否一定收敛？</p>
</blockquote>
<p>考察迭代格式，迭代函数为 <span class="math display">\[
\displaystyle\varphi(x)=y_n+\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y)]
\]</span></p>
<blockquote>
<p><strong>压缩映射原理</strong>：设函数 <span
class="math inline">\(f\)</span> 定义域和值域均为 <span
class="math inline">\([a,b]\)</span> ，并存在一个常数 <span
class="math inline">\(L\)</span> ，满足 <span
class="math inline">\(0&lt;L&lt;1\)</span> ，使得对 <span
class="math inline">\(\forall x,y\in[a,b]\)</span> ，都有 <span
class="math inline">\(|f(x)-f(y)|\le L|x-y|\)</span> ，则称 <span
class="math inline">\(f\)</span> 是 <span
class="math inline">\([a,b]\)</span> 上的一个压缩映射，称常数 <span
class="math inline">\(L\)</span>
为<strong>Lipschitz常数</strong>（压缩常数）。</p>
</blockquote>
<p>假设 <span class="math inline">\(\displaystyle\frac{\partial
f}{\partial y}\)</span> 存在，则当 <span
class="math inline">\(|\varphi&#39;(y)|\le L&lt;1\)</span> 也即 <span
class="math inline">\(\displaystyle\frac{h}{2}\left|\frac{\partial
f}{\partial y}\right|\le L&lt;1\)</span>
时，迭代必然收敛。理论上只需令剖分步长 <span
class="math inline">\(h\)</span> 足够小即可满足条件。 计算中，当 <span
class="math inline">\(\left|y_{n+1}^{[k+1]}-y_{n+1}^{[k]}\right|&lt;\varepsilon\)</span>
，取 <span class="math inline">\(y_{n+1}=y_{n+1}^{[k+1]}\)</span></p>
<p>若仅迭代一步则有： <span class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;\bar{y}_{n+1}=y_n+hf(x_n)\\
\displaystyle&amp;y_{n+1}=y_n+\frac{h}{2}[f(x_n,y_n),f(x_{n+1},\bar{y}_{n+1})]\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span>
称之为<strong>改进Euler方法</strong>，属于单步显式方法。也可写作： <span
class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;y_{n+1}=y_n+h(K_1+K_2)\\
&amp;K_1=f(x_n,y_n)\\
&amp;K_2=f(x_n+h,y_n+hK_1)\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span></p>
<h4 id="误差分析">误差分析</h4>
<p>在节点 <span class="math inline">\(x_{n+1}\)</span> 处的误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}\)</span> ，不仅与 <span
class="math inline">\(y_{n+1}\)</span> 这一步计算，而且与前 <span
class="math inline">\(n\)</span>
步均有关。为简化误差分析，着重研究一步计算时产生的截断误差，假设 <span
class="math inline">\(y_n=y(x_n)\)</span> ，称 <span
class="math inline">\(y(x_{n+1})-y_{n+1}\)</span>
为<strong>局部截断误差</strong>。</p>
<p>若单步差分公式的局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> （同阶无穷小），则称该公式为
<span class="math inline">\(p\)</span> 阶方法。 <span
class="math inline">\(p\)</span> 为非负整数，阶数越高精度越好。</p>
<blockquote>
<p>由一元Taylor公式： <span class="math display">\[
\displaystyle
y(x_{n+1})=y(x_n+h)=y(x_n)+y&#39;(x_n)h+\frac{y&#39;&#39;(x_n)}{2!}h^2+\frac{y&#39;&#39;&#39;(x_n)}{3!}h^3+O(h^4)
\]</span> 由二元Taylor公式： <span class="math display">\[
\displaystyle\begin{aligned}f(x_n+h,y_n+k)=&amp;f(x_n,y_n)+\frac{\partial
f(x_n,y_n)}{\partial x}h+\frac{\partial f(x_n,y_n)}{\partial y}k\\
&amp;+\frac{1}{2!}\left[\frac{\partial^2f(x_n,y_n)}{\partial
x^2}h^2+2\frac{\partial^2 f(x_n,y_n)}{\partial x \partial
y}hk+\frac{\partial^2f(x_n,y_n)}{\partial y^2} k^2\right]\\
&amp;+\dots+\frac{1}{k!}\left[h\frac{\partial}{\partial
x}+k\frac{\partial}{\partial y}\right]^kf(x_n,y_n)+\dots
\end{aligned}
\]</span></p>
</blockquote>
<p><strong>常见差分公式的局部截断误差</strong> + Euler公式： <span
class="math display">\[
  \displaystyle
y(x_{n+1})-y_{n+1}=\frac{y&#39;&#39;(x_n)}{2!}h^2+O(h^3)=O(h^2)
  \]</span> 因此Euler公式为 <span class="math inline">\(1\)</span>
阶方法。 + 改进Euler公式： <span class="math display">\[
  y(x_{n+1})-y_{n+1}=O(h^3)
  \]</span> 因此Euler公式为 <span class="math inline">\(2\)</span>
阶方法。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-09-数值分析-Day12-续数值积分-数值微分</title>
      <link>http://localhost:1313/posts/2021-03-09-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day12-%E7%BB%AD%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/</link>
      <pubDate>Tue, 09 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-09-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day12-%E7%BB%AD%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/</guid>
      <description>续：6.1 - 6.11 数值积分 复化求积公式 Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数 \(\ge8\) 时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即复化求积公式的基本思想。
在区间 \([a,b]\) 上，取等距节点 \(x_k=a+kh,\ k=0,1,\dots,n\) ，
由定积分的区间可加性得 \(\displaystyle\int_a^bf(x)dx=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}f(x)dx\) 。
若在每个小区间 \(x_{k-1},x_k\) 用梯形公式，则有复化梯形公式 \(T_n\) ：
\[ \displaystyle I=\int_a^bf(x)dx\approx T_n=\frac{h}{2}\sum_{k=1}^n\left[f(x_{k-1})+f(x_k)\right]=\frac{h}{2}\left[2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right] \]
复化梯形公式的的误差为：
\[ \begin{array}{l}\displaystyle I-T_n=-\frac{h^3}{12}[f&amp;#39;&amp;#39;(\xi_1)+\dots+f&amp;#39;&amp;#39;(\xi_n)]=-\frac{h^2(b-a)}{12}f&amp;#39;&amp;#39;(\eta),\quad\eta\in(a,b)\\\displaystyle \left|I-T_n\right|\le\frac{(b-a)^3}{12n^2}\max_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|\end{array} \]
可知复化梯形公式收敛，且要使得误差 \(\le\varepsilon\) ，只要 \(\left|I-T_n\right|\le\varepsilon\) 或 \(\displaystyle n&amp;gt;\sqrt{\frac{(b-a)^3\max_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|}{12\varepsilon}}\) 。 同理，复化Simpson公式 \(S_n\) ：
\[ \displaystyle I=\int_a^bf(x)dx\approx S_n=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right] \]
复化Simpson公式的误差为：
\[ \begin{array}{l}\displaystyle I-S_n=-\frac{h^4(b-a)}{2880}f^{4}(\eta),\quad\eta\in(a,b)\\\displaystyle \left|I-S_n\right|\le\frac{(b-a)^5}{2880n^4}\max_{a\le x\le b}|f^{(4)}(x)|\end{array} \]
可知收敛，且要使得误差 \(\le\varepsilon\) ，只要 \(\left|I-S_n\right|\le\varepsilon\) 或 \(\displaystyle n&amp;gt;\sqrt[4]{\frac{(b-a)^5\max_{a\le x\le b}|f^{(4)}(x)|}{2880\varepsilon}}\) 。 同理，复化Cotes公式 \(C_n\) ：</description>
      <content:encoded><![CDATA[<h3 id="续6.1---6.11-数值积分">续：6.1 - 6.11 数值积分</h3>
<h4 id="复化求积公式">复化求积公式</h4>
<blockquote>
<p>Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数
<span class="math inline">\(\ge8\)</span>
时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即<strong>复化求积公式</strong>的基本思想。</p>
</blockquote>
<p>在区间 <span class="math inline">\([a,b]\)</span> 上，取等距节点
<span class="math inline">\(x_k=a+kh,\ k=0,1,\dots,n\)</span> ，<br />
由定积分的区间可加性得 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}f(x)dx\)</span>
。</p>
<ul>
<li>若在每个小区间 <span class="math inline">\(x_{k-1},x_k\)</span>
用梯形公式，则有<strong>复化梯形公式</strong> <span
class="math inline">\(T_n\)</span> ：<br />
<span class="math display">\[
\displaystyle I=\int_a^bf(x)dx\approx
T_n=\frac{h}{2}\sum_{k=1}^n\left[f(x_{k-1})+f(x_k)\right]=\frac{h}{2}\left[2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]
\]</span><br />
复化梯形公式的的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-T_n=-\frac{h^3}{12}[f&#39;&#39;(\xi_1)+\dots+f&#39;&#39;(\xi_n)]=-\frac{h^2(b-a)}{12}f&#39;&#39;(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-T_n\right|\le\frac{(b-a)^3}{12n^2}\max_{a\le x\le
b}|f&#39;&#39;(x)|\end{array}
\]</span><br />
可知复化梯形公式收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-T_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle n&gt;\sqrt{\frac{(b-a)^3\max_{a\le
x\le b}|f&#39;&#39;(x)|}{12\varepsilon}}\)</span> 。</li>
<li>同理，<strong>复化Simpson公式</strong> <span
class="math inline">\(S_n\)</span> ：<br />
<span class="math display">\[
\displaystyle I=\int_a^bf(x)dx\approx
S_n=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]
\]</span><br />
复化Simpson公式的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-S_n=-\frac{h^4(b-a)}{2880}f^{4}(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-S_n\right|\le\frac{(b-a)^5}{2880n^4}\max_{a\le x\le
b}|f^{(4)}(x)|\end{array}
\]</span><br />
可知收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-S_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle
n&gt;\sqrt[4]{\frac{(b-a)^5\max_{a\le x\le
b}|f^{(4)}(x)|}{2880\varepsilon}}\)</span> 。</li>
<li>同理，<strong>复化Cotes公式</strong> <span
class="math inline">\(C_n\)</span> ：<br />
<span class="math display">\[
\begin{aligned}\displaystyle I&amp;=\int_a^bf(x)dx\approx
C_n\\&amp;=\frac{h}{90}\left\{32\sum_{k=1}^n\left[f(x_{k-\frac{3}{4}})+f(x_{k-\frac{1}{4}})\right]+12\sum_{k=1}^nf(x_{k-\frac{1}{2}})+14\sum_{k=1}^{n-1}f(x_k)+7f(a)+7f(b)\right\}\end{aligned}
\]</span><br />
复化Cotes公式的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-S_n=-\frac{h^6(b-a)}{1935360}f^{6}(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-S_n\right|\le\frac{(b-a)^7}{1935360n^6}\max_{a\le x\le
b}|f^{(6)}(x)|\end{array}
\]</span><br />
可知收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-S_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle
n&gt;\sqrt[6]{\frac{(b-a)^7\max_{a\le x\le
b}|f^{(6)}(x)|}{1935360\varepsilon}}\)</span> 。</li>
</ul>
<h4 id="romberg求积公式">Romberg求积公式</h4>
<blockquote>
<p>复化求积公式对步长有较高要求。</p>
</blockquote>
<p><strong>由复化梯形公式推导</strong> 由梯形公式 <span
class="math inline">\(\begin{array}{l}\displaystyle
I-T_n=-\frac{(b-a)^3}{12n^2}f&#39;&#39;(\eta)\quad\eta\in(a,b)\\\displaystyle
I-T_{2n}=-\frac{(b-a)^3}{36n^2}f&#39;&#39;(\tilde{\eta})\quad\tilde{\eta}\in(a,b)\end{array}\)</span>
，视 <span class="math inline">\(f&#39;&#39;(\eta)\approx
f&#39;&#39;(\tilde{\eta})\)</span> ，<br />
得 <span class="math inline">\(\displaystyle
I\approx\frac{4T_{2n}-T_n}{3}\)</span> 或 <span
class="math inline">\(\displaystyle
I-T_{2n}\approx\frac{T_{2n}-T_n}{3}\)</span> 。</p>
<p>该二式表述精度更高，代入有 <span
class="math inline">\(\displaystyle\frac{4T_{2n}-T_n}{3}=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]=S_n\)</span>
，即为Simpson公式。且 <span class="math inline">\(\displaystyle
T_{2n}=\frac{T_n}{2}+\frac{h}{2}\sum_{k=1}^nf(x_{k-\frac{1}{2}})\)</span>
。</p>
<ul>
<li>由此得逐次分半的复化梯形公式的递推公式： <span
class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots
\end{array}\right.
\]</span> 且要使得 <span
class="math inline">\(|I-T_{2^k}|&lt;\varepsilon\)</span> ，只要 <span
class="math inline">\(|T_{2^k}-T_{2^{k-1}}|&lt;3\varepsilon\)</span>
。</li>
<li>同理得逐次分半的复化Simpson公式的递推公式： <span
class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots\\
\displaystyle S_{2^{k-1}}=\frac{4T_{2^k}-T_{2^{k-1}}}{3},\quad
k=1,2,\dots
\end{array}\right.
\]</span></li>
</ul>
<p><strong>由复化Simpson公式推导</strong> 类似的推法得到 <span
class="math inline">\(\displaystyle
I\approx\frac{16S_{2n}-S_n}{15}\)</span> 或 <span
class="math inline">\(\displaystyle
I-S_{2n}\approx\frac{S_{2n}-S_n}{15}\)</span> 。且有 <span
class="math inline">\(\displaystyle\frac{16S_{2n}-S_n}{15}=C_n\)</span>
。</p>
<p><strong>由复化Cotes公式推导</strong></p>
<p>同理得 <span class="math inline">\(\displaystyle
I\approx\frac{64C_{2n}-C_n}{63}\)</span> 或 <span
class="math inline">\(\displaystyle
I-C_{2n}\approx\frac{C_{2n}-C_n}{63}\)</span> 。记 <span
class="math inline">\(\displaystyle R_n=\frac{64C_{2n}-C_n}{63}\)</span>
，即为<strong>Romberg求积公式</strong>。</p>
<h5 id="一般化推论">一般化推论</h5>
<p>令 <span class="math inline">\(T_{2^k}^{(1)}=T_{2^k},\
T_{2^k}^{(1)}=S_{2^k},\ T_{2^k}^{(2)}=C_{2^k},\
T_{2^k}^{(3)}=R_{2^k}\)</span> ，则有： <span class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}^{(0)}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots\\
\displaystyle
T_{2^k}^{(m)}=\frac{4^mT_{2^{k+1}}^{(m-1)}-T_{2^k}^{(m-1)}}{4^m-1},\quad
k=1,2,\dots,\ m=1,2,\dots
\end{array}\right.
\]</span> 且要使得 <span
class="math inline">\(|I-T_{2^k}^{(m)}|&lt;\varepsilon\)</span> ，只要
<span
class="math inline">\(|T_{2^k}^{(m)}-T_{2^{k-1}}^{(m)}|&lt;(4^{m+1}-1)\varepsilon,\
m=0,1,\dots\)</span> 。</p>
<blockquote>
<h4 id="正交多项式">正交多项式</h4>
<p><strong>函数内积</strong>：若 <span
class="math inline">\(f(x),g(x)\in C[a,b]\)</span> ，则称 <span
class="math inline">\(\displaystyle\int_a^bf(x)g(x)dx\)</span> 为 <span
class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(g(x)\)</span> 的内积，记为： <span
class="math inline">\((f,g)\)</span> ，其满足： + <span
class="math inline">\((f,g)=(g,f)\)</span> + <span
class="math inline">\((cf,g)=c(f,g)\)</span> + <span
class="math inline">\((f_1+f_2,g)=(f_1,g)+(f_2,g)\)</span> 若 <span
class="math inline">\((f,g)=0\)</span> ，则称 <span
class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> <strong>正交</strong>，记为 <span
class="math inline">\(f\perp g\)</span> 。</p>
<p>利用内积可定义函数的<strong>平方模</strong> <span
class="math inline">\(\displaystyle\|f\|_2=\sqrt{(f,f)}=\sqrt{\int_a^bf^2(x)dx}\)</span>
，其满足： + <span class="math inline">\(\|f\|_2\ge0,\
\|f\|_2=0\Leftrightarrow f(x)=0\)</span> + <span
class="math inline">\(\|cf\|_2=|c|\|f\|_2\)</span> + <span
class="math inline">\(\|f,g\|_2\le\|f\|_2+\|g\|_2\)</span> + <span
class="math inline">\(\|(f,g)\|_2\le\|f\|_2\|g\|_2\)</span></p>
<p>常引进加权形式定义： <span
class="math inline">\(\displaystyle(f,g)=\int_a^b\rho(x)f(x)g(x)dx\)</span>
，则 <span
class="math inline">\(\displaystyle\|f\|_2=\sqrt{\int_a^b\rho(x)f^2(x)dx}\)</span>
。</p>
<p><strong>定理1</strong>：若 <span
class="math inline">\(f_0(x),f_1(x),\dots,f_n(x)\)</span> 为 <span
class="math inline">\(C[a,b]\)</span> 上的一组线性无关函数，则由 <span
class="math inline">\(f_k(x)\)</span> 线性组合可得到 <span
class="math inline">\(C[a,b]\)</span> 上的一组两两正交的函数组 <span
class="math inline">\(g_0(x),g_1(x),\dots,g_n(x)\)</span>
，单位化（平方模变为 <span class="math inline">\(1\)</span>
）为<strong>规范正交组</strong> <span
class="math inline">\(e_0(x),r_1(x),\dots,r_n(x)\)</span>
。（Schemite正交化）</p>
<p>将 <span class="math inline">\(P_n\)</span> 上由线性无关函数 <span
class="math inline">\(1,x,x^2,\dots,x^n\)</span>
经过Schemite正交化得到的多项式 <span
class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 称为 <span
class="math inline">\([a,b]\)</span>
上的<strong>正交多项式</strong>。</p>
<p>若 <span class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 为
<span class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式，则满足： + <span
class="math inline">\(p_k(x)\)</span> 时首项系数不为零的 <span
class="math inline">\(k\)</span> 次多项式 + <span
class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 构成 <span
class="math inline">\(P_n\)</span> 上的一组正交基 + <span
class="math inline">\(p_n(x)\)</span> 与不高于 <span
class="math inline">\(n-1\)</span> 次的多项式正交, <span
class="math inline">\(p_n(x)\perp P_{n-1}\)</span> + 方程 <span
class="math inline">\(p_n(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上有 <span
class="math inline">\(n\)</span> 个单根 + 方程 <span
class="math inline">\(p_{n-1}(x)=0\)</span> 的根与方程 <span
class="math inline">\(p_n(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上交错分布</p>
<p><strong>常用正交多项式系</strong></p>
<ol type="1">
<li><strong>Legendre多项式</strong> <span
class="math inline">\(\displaystyle
L_n(x)=\frac{1}{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n\quad x\in[-1,1],\
n=0,1,\dots\)</span> ，权函数 <span
class="math inline">\(\displaystyle\rho(x)=1\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;\frac{2}{2n+1}&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
(n+1)L_{n+1}(x)=(2n+1)xL_n(x)-nL_{n-1}(x),\quad n\ge1\\L_0(x)=1,\
L_1(x)=x\end{array}\right.\)</span></li>
</ul></li>
<li><strong>Chebyshev多项式</strong> <span
class="math inline">\(T_n(x)=\cos(n\arccos x)\quad x\in[-1,1],\
n=0,1,\dots\)</span> ，权函数 <span
class="math inline">\(\displaystyle\rho(x)=\frac{1}{\sqrt{1-x^2}}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(T_m,T_n)=\left\{\begin{array}{l}0\quad\quad m\neq n\\\pi\quad\quad
m=n=0\\\pi/2\quad m=n\neq0\end{array}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
T_{n+1}(x)=2xT_n(x)-nT_{n-1}(x),\quad n=1,2,\dots\\T_0(x)=1,\
T_1(x)=x\end{array}\right.\)</span></li>
<li><span class="math inline">\(T_n(x)\)</span> 在 <span
class="math inline">\([-1,1]\)</span> 上的 <span
class="math inline">\(n\)</span> 个零点为 <span
class="math inline">\(\displaystyle
x_k^{(n)}=\cos\frac{2k-1}{2n}\pi,\quad k=1,2,\dots,n\)</span></li>
</ul></li>
<li><strong>Laguere多项式</strong> <span
class="math inline">\(\displaystyle
L_n(x)=e^x\frac{d^n}{dx^n}(x^ne^{-x}),\quad0&lt;x&lt;+\infty,\quad
n=0,1,2,\dots\)</span> ，权函数 <span
class="math inline">\(\rho(x)=e^{-x}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;(n!)^2&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
L_{n+1}(x)=(2n+1-x)L_n(x)-n^2L_{n-1}(x),\quad n=1,2,\dots\\L_0(x)=1,\
L_1(x)=1-x\end{array}\right.\)</span></li>
</ul></li>
<li><strong>Hermite多项式</strong> <span
class="math inline">\(\displaystyle
H_n(x)=(-1)^ne^{x^2}\frac{d^n}{dx^n}(e^{-x^2}),\quad-\infty&lt;x&lt;+\infty,\quad
n=0,1,2,\dots\)</span> ，权函数 <span
class="math inline">\(\rho(x)=e^{-x^2}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;2^nn!\pi&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
H_{n+1}(x)=2xH_n(x)-nH_{n-1}(x),\quad n\ge1\\H_0(x)=1,\
H_1(x)=2x\end{array}\right.\)</span></li>
</ul></li>
</ol>
</blockquote>
<h4 id="gauss型求积公式">Gauss型求积公式</h4>
<blockquote>
<p>对一个求积公式而言，若不固定节点位置，节点数不变的情况下，代数精度如何提高。</p>
</blockquote>
<p><strong>定理1</strong>：区间 <span
class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的具有 <span
class="math inline">\(n\)</span> 个节点的数值积分公式代数精度不超过
<span class="math inline">\(2n-1\)</span> 次。</p>
<p><strong>Gauss型求积公式</strong>：使求积公式具有 <span
class="math inline">\(2n-1\)</span> 次代数精度的节点 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span>
称为<strong>Gauss点</strong>，此时的插值型求积公式称为<strong>Gauss型求积公式</strong>：
<span
class="math inline">\(I\approx\displaystyle\sum_{i=1}^nA_if(x_i)\)</span>
。</p>
<p><strong>定理2</strong>：取区间 <span
class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式 <span
class="math inline">\(p_n(x)\)</span> 的 <span
class="math inline">\(n\)</span> 个零点 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span> 恰为Gauss点。</p>
<p>因此构造Gauss型求积公式的方法为：</p>
<ul>
<li>求出区间 <span class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式 <span
class="math inline">\(p_n(x)\)</span> ；</li>
<li>求出 <span class="math inline">\(p_n(x)\)</span> 的 <span
class="math inline">\(n\)</span> 个零点；</li>
<li>计算积分系数 <span
class="math inline">\(A_i=\displaystyle\int_a^bl_i(x)\rho(x)dx\)</span>
。</li>
</ul>
<p><strong>定理3</strong>：设 <span class="math inline">\(f(x)\in
C^{2n}[a,b]\)</span> ，则Gauss公式的误差为： <span
class="math inline">\(\displaystyle
R[f]=\int_a^bf(x)\rho(x)dx-\sum_{i=1}^nA_if(x_i)=\frac{f^{(2n)}(\eta)}{(2n)!}\int_a^b\rho(x)\omega^2(x)dx,\quad
\eta\in(a,b)\)</span></p>
<p><strong>常见Gauss型求积公式</strong></p>
<ul>
<li><p><strong>Gauss-Legendre求积公式</strong>：区间 <span
class="math inline">\([-1,1]\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_{-1}^1f(x)dx\approx\displaystyle\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Legendre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{2^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\eta),\quad\eta\in(-1,1)\)</span>
。</p>
<p>利用积分变换 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\frac{b-a}{2}\int_{-1}^1(\frac{a+b}{2}+\frac{b-a}{2}t)dt,\quad(x=\frac{(a+b)+(b-a)t}{2})\)</span><br />
可用Gauss-Legendre求积公式求任意区间的数值积分，其在 <span
class="math inline">\([a,b]\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span> 的求积公式为 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{2}\sum_{i=1}^{n}A_if(\frac{a+b}{2}+\frac{b-a}{2}x_i)\)</span>
。余项为 <span class="math inline">\(\displaystyle
R[f]=\frac{(b-a)^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\eta),\quad\eta\in(a,b)\)</span>
。</p></li>
<li><p><strong>Gauss-Laguerre求积公式</strong>：区间 <span
class="math inline">\([0,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=e^{-x}\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_0^\infty
e^{-x}f(x)dx\approx\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Laguerre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{(n!)^2}{(2n)!}f^{(2n)}(\eta),\quad\eta\in(0,+\infty)\)</span>
。</p>
<p>对 <span class="math inline">\([0,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span>
的积分，也可构造Gauss-Laguerre求积公式（再乘一个 <span
class="math inline">\(e^x\)</span> ）： <span
class="math inline">\(\displaystyle\int_0^\infty
f(x)dx\approx\sum_{i=1}^nA_ie^{x_i}f(x_i)\)</span> 。</p></li>
<li><p><strong>Gauss-Hermite求积公式</strong>：区间 <span
class="math inline">\((-\infty,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=e^{-x^2}\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_{-\infty}^\infty
e^{-x^2}f(x)dx\approx\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Herimite多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{n!\sqrt\pi}{2^n(2n)!}f^{(2n)}(\eta),\quad\eta\in(-\infty,+\infty)\)</span>
。</p>
<p>同理，对 <span class="math inline">\((-\infty,+\infty)\)</span>
上权函数 <span class="math inline">\(\rho(x)=1\)</span>
的积分，也可构造Gauss-Hermite求积公式（再乘一个 <span
class="math inline">\(e^{x^2}\)</span> ）： <span
class="math inline">\(\displaystyle\int_{-\infty}^\infty
f(x)dx\approx\sum_{i=1}^nA_ie^{x_i^2}f(x_i)\)</span> 。</p></li>
</ul>
<h3 id="数值微分">6.12 - 6.13 数值微分</h3>
<p><strong>数值微分</strong>是指用函数值的线性组合近似函数在某点的导数值。</p>
<h4 id="差商型数值微分">差商型数值微分</h4>
<ul>
<li><p><strong>向前差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0+h)-f(x_0)}{h}\)</span></p>
<p>Taylor展开得 <span class="math inline">\(\displaystyle
f(x_0+h)=f(x_0)+f&#39;(x_0)h+\frac{h^2}{2}f&#39;&#39;(x_0+\theta
h)\quad0\le\theta\le1\)</span><br />
可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-f(x_0)}{h}=-\frac{h}{2}f&#39;&#39;(x_0+\theta
h)\quad0\le\theta\le1\)</span></p></li>
<li><p><strong>向后差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0)-f(x_0-h)}{h}\)</span></p>
<p>Taylor展开得 <span class="math inline">\(\displaystyle
f(x_0-h)=f(x_0)-f&#39;(x_0)h+\frac{h^2}{2}f&#39;&#39;(x_0-\theta
h)\quad0\le\theta\le1\)</span><br />
可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0)-f(x_0-h)}{h}=\frac{h}{2}f&#39;&#39;(x_0-\theta
h)\quad0\le\theta\le1\)</span></p></li>
<li><p><strong>中心差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0+h)-f(x_0-h)}{2h}\)</span></p>
<p>可得误差 <span class="math inline">\(\begin{aligned}\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-f(x_0-h)}{2h}&amp;=-\frac{h^2}{12}[f&#39;&#39;&#39;(x_0+\theta_1
h)+f&#39;&#39;&#39;(x_0-\theta_2
h)]\\&amp;=-\frac{h^2}{6}f&#39;&#39;&#39;(x_0+\theta
h)\quad\quad-1\le\theta\le1\end{aligned}\)</span></p></li>
<li><p><strong>二阶中心差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;&#39;(x_0)\approx\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}\)</span></p>
<p>Taylor展开得 <span
class="math inline">\(\begin{array}{l}\displaystyle
f(x_0+h)=f(x_0)+hf&#39;(x_0)+\frac{h^2}{2}f&#39;&#39;(x_0)+\frac{h^3}{6}f&#39;&#39;&#39;(x_0)+\frac{h^4}{24}f^{(4)}(x_0+\theta_1
h)\\\displaystyle
f(x_0-h)=f(x_0)-hf&#39;(x_0)+\frac{h^2}{2}f&#39;&#39;(x_0)-\frac{h^3}{6}f&#39;&#39;&#39;(x_0)+\frac{h^4}{24}f^{(4)}(x_0-\theta_2
h)\end{array}\)</span><br />
两式相加可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}=-\frac{h^2}{12}f^{(4)}(x_0+\theta
h)\quad\theta\in(-1,1)\)</span></p></li>
</ul>
<p>从截断误差的角度看，步长 <span class="math inline">\(h\)</span>
越小，计算越精确；但是 <span class="math inline">\(h\)</span>
过小时，计算过程中有相近的数相减，会严重损失数值精度。实际应用中，可采用步长逐次减半的方法确定最终补偿。记
<span class="math inline">\(G(h),\ G(h/2)\)</span>
分别为对应步长取值时的差商公式，对给定精度 <span
class="math inline">\(\varepsilon&gt;0\)</span> ，若 <span
class="math inline">\(|G(h)-G(h/2)|&lt;\varepsilon\)</span> 就取步长为
<span class="math inline">\(h/2\)</span> ，反之取 <span
class="math inline">\(h\)</span> 。</p>
<h4 id="插值型数值微分">插值型数值微分</h4>
<p>建立插值多项式 <span class="math inline">\(L_n(x)\)</span> ，取 <span
class="math inline">\(L_n&#39;(x)\)</span> 作为 <span
class="math inline">\(f&#39;(x)\)</span> 的近似。误差余项 <span
class="math inline">\(\displaystyle
f&#39;(x_k)-L_n&#39;(x_k)=\frac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x_k)\)</span>
（ <span class="math inline">\(x\neq x_k\)</span> 时难以分析）</p>
<p>仅考察节点处的导数值，假定所给节点等距。</p>
<ul>
<li><p><strong>两点公式</strong>：线性插值函数 <span
class="math inline">\(\displaystyle
L_1(x)=\frac{x-x_1}{x_0-x_1}f(x_0)+\frac{x-x_0}{x_1-x_0}f(x_1)\)</span>
，对公式两端求导，记 <span class="math inline">\(x_1-x_0=h\)</span>
，有：<br />
<span class="math inline">\(\displaystyle
L_1&#39;(x)=\frac{1}{h}[f(x_1)-f(x_0)]\)</span> ，<br />
得到两个两点公式： <span class="math inline">\(\displaystyle
L_1&#39;(x_0)=L_1&#39;(x_1)=\frac{1}{h}[f(x_1)-f(x_0)]\)</span></p></li>
<li><p><strong>三点公式</strong>：二次插值函数 <span
class="math inline">\(L_2(x)\)</span> ，对其求导，记 <span
class="math inline">\(x=x_0+th\)</span> ，有：<br />
<span class="math inline">\(\displaystyle
L_2&#39;(x)=\frac{1}{2h}[(2t-3)f(x_0)-(4t-4)f(x_1)+(2t-1)f(x_2)]\)</span><br />
得到三个三点公式： <span
class="math inline">\(\begin{array}{l}\displaystyle
L_2&#39;(x_0)=\frac{1}{2h}[-3f(x_0)+4f(x_1)-f(x_2)]\\L_2&#39;(x_1)=\frac{1}{2h}[-f(x_0)+f(x_2)]\\L_2&#39;(x_2)=\frac{1}{2h}[f(x_0)-4f(x_1)+3f(x_2)]\end{array}\)</span></p>
<p>再次求导，可以得到更高阶的数值微分公式 <span
class="math inline">\(\displaystyle
L_2&#39;&#39;(x)=\frac{1}{h^2}[f(x_0)-2f(x_1)+f(x_2)]\)</span></p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-08-数值分析-Day11-插值型数值积分</title>
      <link>http://localhost:1313/posts/2021-03-08-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day11-%E6%8F%92%E5%80%BC%E5%9E%8B%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</link>
      <pubDate>Mon, 08 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-08-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day11-%E6%8F%92%E5%80%BC%E5%9E%8B%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</guid>
      <description>6.1 - 6.11 数值积分 牛顿-莱布尼茨公式： \(\displaystyle\int_a^bf(x)dx=F(b)-F(a)\)
问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。
【例】弧长积分： \(L=\displaystyle\int_a^b\sqrt{1+(f&amp;#39;(x))^2}dx\)
由定积分的定义 \(\displaystyle I=\int_a^bf(x)dx=F(b)-F(a)=\lim_{\Delta x\to0}\sum_{i=0}^nf(x_i)\Delta x_i\) ，可以想到利用被积函数在区间 \([a,b]\) 上一些离散节点 \(x_k\) 处的函数值 \(f(x_k)\) 的线性组合来得到近似积分值： \(\displaystyle I=\sum_{k=0}^nA_kf(x_k)\) 。则得求积公式的一般形式： \(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\) ，其中 \(\{x_k\}\) 为求积点， \(A_k\) 为求积系数。或表示为 \(\displaystyle\int_a^bf(x)dx=\sum_{k=0}^nA_kf(x_k)+R[f]\) ，其中 \(R[f]\) 为求积公式的误差或余项。
积分中值定理：在 \([a,b]\) 内存在一点 \(\xi\) ，有 \(\displaystyle\int_a^bf(x)dx=(b-a)f(\xi)\) 。
问题： \(\xi\) 未知
取特殊点为 \(\xi\) 求近似解：
左矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(a)(b-a),\quad R[f]=\frac{(b-a)^2}{2}f&amp;#39;(\xi)\ (\xi\in(a,b))\)
右矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(b)(b-a),\quad R[f]=-\frac{(b-a)^2}{2}f&amp;#39;(\eta)\ (\eta\in(a,b))\)
中矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(\frac{a+b}{2})(b-a),\quad R[f]=-\frac{(b-a)^3}{24}f&amp;#39;&amp;#39;(\eta)\ (\eta\in(a,b))\)
代数精度 若求积公式 \(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\) 对 \(f(x)=x^j\ (j=0,1,\dots,m)\) 都精确成立，但对 \(f(x)=x^{m+1}\) 不精确成立。即： \(\left\{\begin{array}{l}\displaystyle\int_a^bx^jdx=\sum_{k=0}^nA_kx_k^j\quad j=0,1,\dots,m\\\displaystyle\int_a^bx^{m+1}dx\approx\sum_{k=0}^nA_kx_k^{m+1}\end{array}\right.</description>
      <content:encoded><![CDATA[<h3 id="数值积分">6.1 - 6.11 数值积分</h3>
<blockquote>
<p>牛顿-莱布尼茨公式： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=F(b)-F(a)\)</span></p>
<p>问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。</p>
<p>【例】弧长积分： <span
class="math inline">\(L=\displaystyle\int_a^b\sqrt{1+(f&#39;(x))^2}dx\)</span></p>
</blockquote>
<p>由定积分的定义 <span class="math inline">\(\displaystyle
I=\int_a^bf(x)dx=F(b)-F(a)=\lim_{\Delta x\to0}\sum_{i=0}^nf(x_i)\Delta
x_i\)</span> ，可以想到利用被积函数在区间 <span
class="math inline">\([a,b]\)</span> 上一些离散节点 <span
class="math inline">\(x_k\)</span> 处的函数值 <span
class="math inline">\(f(x_k)\)</span> 的线性组合来得到近似积分值： <span
class="math inline">\(\displaystyle I=\sum_{k=0}^nA_kf(x_k)\)</span>
。则得<strong>求积公式</strong>的一般形式： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
，其中 <span class="math inline">\(\{x_k\}\)</span>
为<strong>求积点</strong>， <span class="math inline">\(A_k\)</span>
为<strong>求积系数</strong>。或表示为 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\sum_{k=0}^nA_kf(x_k)+R[f]\)</span>
，其中 <span class="math inline">\(R[f]\)</span>
为求积公式的<strong>误差</strong>或<strong>余项</strong>。</p>
<blockquote>
<p>积分中值定理：在 <span class="math inline">\([a,b]\)</span>
内存在一点 <span class="math inline">\(\xi\)</span> ，有 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=(b-a)f(\xi)\)</span>
。</p>
<p>问题： <span class="math inline">\(\xi\)</span> 未知</p>
</blockquote>
<p>取特殊点为 <span class="math inline">\(\xi\)</span> 求近似解：</p>
<ul>
<li><p><strong>左矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx f(a)(b-a),\quad
R[f]=\frac{(b-a)^2}{2}f&#39;(\xi)\ (\xi\in(a,b))\)</span></p></li>
<li><p><strong>右矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx f(b)(b-a),\quad
R[f]=-\frac{(b-a)^2}{2}f&#39;(\eta)\ (\eta\in(a,b))\)</span></p></li>
<li><p><strong>中矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx
f(\frac{a+b}{2})(b-a),\quad R[f]=-\frac{(b-a)^3}{24}f&#39;&#39;(\eta)\
(\eta\in(a,b))\)</span></p></li>
</ul>
<h4 id="代数精度">代数精度</h4>
<p>若求积公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
对 <span class="math inline">\(f(x)=x^j\ (j=0,1,\dots,m)\)</span>
都精确成立，但对 <span class="math inline">\(f(x)=x^{m+1}\)</span>
不精确成立。即： <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle\int_a^bx^jdx=\sum_{k=0}^nA_kx_k^j\quad
j=0,1,\dots,m\\\displaystyle\int_a^bx^{m+1}dx\approx\sum_{k=0}^nA_kx_k^{m+1}\end{array}\right.\)</span>
，则称此公式具有 <span class="math inline">\(\mathbf m\)</span>
<strong>次代数精度</strong>。</p>
<p>可见，具有 <span class="math inline">\(m\)</span>
次代数精度的求积公式对最高次 <span class="math inline">\(\le m\)</span>
的多项式函数均是精确成立的。由由于，所有函数均可由多项式函数逼近，因此代数精度越高，求积公式的精度就越高。</p>
<p><strong>利用代数精度求求积公式</strong>：若求积公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
具有 <span class="math inline">\(n\)</span> 次代数精度，则： <span
class="math display">\[
\begin{array}{c}\left\{\begin{array}{l}A_0+A_1+\dots+A_n=b-a\\
\displaystyle x_0A_0+x_1A_1+\dots+x_nA_n=\frac{b^2-a^2}{2}\\
\dots\\\displaystyle
x_0^n+x_1^n+\dots+x_n^nA_n=\frac{b^{n+1}-a^{n+1}}{n+1}
\end{array}\right.\\
即\begin{pmatrix}
1  &amp;1  &amp;\cdots  &amp;1 \\
x_0  &amp;x_1  &amp;\cdots  &amp;x_n \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
x_0^n  &amp;x_1^n  &amp;\cdots  &amp;x_n^n
\end{pmatrix}
\begin{pmatrix}
A_0 \\
A_1 \\
\vdots \\
A_n
\end{pmatrix}=
\begin{pmatrix}
b-a \\
(b^2-a^2)/2 \\
\vdots \\
(b^{n+1}-a^{n+1})/(n+1)
\end{pmatrix}\\
D=\begin{vmatrix}
1  &amp;1  &amp;\cdots  &amp;1 \\
x_0  &amp;x_1  &amp;\cdots  &amp;x_n \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
x_0^n  &amp;x_1^n  &amp;\cdots  &amp;x_n^n
\end{vmatrix}=\displaystyle\prod_{0\le i&lt;j\le n}(x_j-x_i)\neq0
\end{array}
\]</span> 因此该方程组有唯一解。</p>
<h4 id="插值型数值求积公式">插值型数值求积公式</h4>
<p><strong>定义</strong>：已知定积分 <span
class="math inline">\(I=\displaystyle \int_a^bf(x)dx\)</span> 的被积函数
<span class="math inline">\(f(x)\)</span> 在节点 <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span>
上的函数值 <span class="math inline">\(y_k=f(x_k),\
k=0,1,\dots,n\)</span> 。则可构造 <span class="math inline">\(n\)</span>
次Lagrange插值多项式 <span
class="math inline">\(L_n(x)=\displaystyle\sum_{k=0}^nf(x_k)l_k(x)\)</span>
，其中 <span class="math inline">\(l_k(x)\)</span>
为Lagrange插值的基函数。因此<br />
<span class="math inline">\(\displaystyle
I_n=\int_a^bf(x)dx\approx\int_a^bL_n(x)dx=\int_a^b\left[\sum_{k=0}^nf(x_k)l_k(x)\right]dx=\sum_{k=0}^n\left[\int_a^bl_k(x)dx\right]f(x_k)\)</span>
。<br />
记 <span
class="math inline">\(A_k=\displaystyle\int_a^bl_k(x)dx\)</span>
，称之为<strong>求积系数</strong>，则有 <span
class="math inline">\(\int_a^bL_n(x)dx=\sum_{k=0}^nA_kf(x_k)\)</span>
，称之为<strong>插值型求积公式</strong>。</p>
<p><strong>误差</strong>：若 <span class="math inline">\(f(x)\)</span>
在 <span class="math inline">\([a,b]\)</span> 有 <span
class="math inline">\(n+1\)</span>
阶连续导数，则Lagrange插值余项为：<br />
<span class="math inline">\(\displaystyle
f(x)-L_n(x)=\frac{f^{(n+1)}(\xi_x)}{(n+1)!}\omega_{n+1}(x),\
\xi_x\in(a,b)\)</span><br />
从而得到插值型求积公式的误差如下 <span
class="math inline">\(\displaystyle
R[f]=\int_a^b[f(x)-L_n(x)]dx=\frac{1}{(n+1)!}\int_a^bf^{n+1}(\xi_x)\omega_{n+1}(x)dx,\
\xi_x\in(a,b)\)</span></p>
<p>加入权函数项非负连续函数 <span class="math inline">\(\rho(x)\)</span>
（物理意义为密度函数），则求积系数 <span
class="math inline">\(\displaystyle A_k=\int_a^b\rho(x)l_k(x)dx\)</span>
，误差表达式 <span class="math inline">\(\displaystyle
R[f]=\frac{1}{(n+1)!}\int_a^b\rho(x)f^{n+1}(\xi_x)\omega_{n+1}(x)dx,\
\xi_x\in(a,b)\)</span> 。</p>
<h4 id="newton-cotes公式">Newton-Cotes公式</h4>
<p><strong>定义</strong>：为简化计算，取等距节点 <span
class="math inline">\(x_k=a+kh\ (k=0,1,\dots,n,\ h=(b-a)/n)\)</span>
，则： <span class="math display">\[
\begin{array}{c}
\displaystyle A_k=\int_a^bl_k(x)dx=\int_a^b\left[\prod_{i=0,i\neq
k}^n\right]dx\xlongequal{令x=a+th}\frac{(-1)^{n-k}h}{k!(n-k)!}\int_0^n\left[\prod_{i=0,i\neq
k}^n(t-i)\right]dt\\
令\
C_k^{(n)}=\displaystyle\frac{1}{b-a}A_k=\frac{(-1)^{n-k}}{nk!(n-k)!}\int_0^n\left[\prod_{i=0,i\neq
k}^n(t-i)\right]dt,\quad k=0,1,\dots,n\\
则有\ \displaystyle\int_a^bf(x)dx\approx(b-a)\sum_{k=0}^nC_k^{(n)}f(x_k)
\end{array}
\]</span> 称最后一行式为<strong>Newton-Cotes公式</strong>， <span
class="math inline">\(C_k^{(n)}\)</span>
为<strong>Cotes系数</strong>。</p>
<ul>
<li>设 <span class="math inline">\(f(x)\in C^2[a,b]\)</span> ，则 <span
class="math inline">\(n=1\)</span> 时，Newton-Cotes公式为：<br />
<span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{2}[f(a)+f(b)]\)</span>
，<br />
误差为 <span
class="math inline">\(R[f]=\displaystyle-\frac{(b-a)^3}{12}f&#39;&#39;(\eta)\le\frac{\max\limits_{a\le
x\le b}|f&#39;&#39;(x)|}{12}(b-a)^3,\ \eta\in(a,b)\)</span> 。<br />
由于图像为梯形，称为<strong>梯形公式</strong>，记为 <span
class="math inline">\(\mathbf T\)</span> 。</li>
<li>设 <span class="math inline">\(f(x)\in C^4[a,b]\)</span> ，则 <span
class="math inline">\(n=2\)</span> 时，Newton-Cotes公式为：<br />
<span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{6}\left[f(a)+4f\left(\frac{a+b}{2}\right)+f(b)\right]\)</span>
，<br />
误差为 <span
class="math inline">\(R[f]=\displaystyle-\frac{(b-a)^5}{2880}f^{(4)}(\eta)\le\frac{\max\limits_{a\le
x\le b}|f^{(4)}(x)|}{2880}(b-a)^5,\ \eta\in(a,b)\)</span> 。<br />
由于图像为抛物线，称为<strong>抛物线公式</strong>或<strong>Simpson公式</strong>，记为
<span class="math inline">\(\mathbf S\)</span> 。其代数精度为 <span
class="math inline">\(3\)</span> 。</li>
<li>依次，Cotes系数可查<strong>【Cotes系数表】</strong>。当Cotes系数出现相反数时，公式数值不稳定，因此高次Newton-Cotes公式没有实用价值。</li>
</ul>
<p>Newton-Cotes公式的截断误差为： <span
class="math inline">\(\begin{array}{r}R[f]=\left\{\begin{array}{l}\displaystyle\frac{f^{(n+1)}(\eta)}{(n+1)!}\int_a^b\omega_{n+1}(x)dx\quad
n为奇数\\\displaystyle\frac{f^{(n+2)}(\eta)}{(n+2)!}\int_a^b\omega_{n+1}(x)dx\quad
n为偶数\end{array}\right.\\\eta\in(a,b)\end{array}\)</span> 。</p>
<p><span class="math inline">\(n+1\)</span>
个节点的插值型求积公式至少具有 <span class="math inline">\(n\)</span>
次代数精度， <span class="math inline">\(n\)</span>
是偶数时Newton-Cotes公式具有 <span class="math inline">\(n+1\)</span>
次代数精度。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-07-数值分析-Day10-三次样条插值-最小二乘拟合</title>
      <link>http://localhost:1313/posts/2021-03-07-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day10-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/</link>
      <pubDate>Sun, 07 Mar 2021 15:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-07-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day10-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/</guid>
      <description>续：5.8 - 5.10 三次样条插值 三转角方法 考虑第一种一般边界条件： \(S&amp;#39;(x_0)=f_0&amp;#39;,\ S&amp;#39;(x_n)=f_n&amp;#39;\) ，即已知两端点一阶导数值。
令 \(m_i=S&amp;#39;(x_i),\ i=0,1,\dots,n\) ，利用三次Hermite插值，得到 \(S(x)=\displaystyle \sum_{j=0}^n[y_j\alpha_j(x)+m_j\beta_j(x)]\) ，其中 \(\alpha_j(x),\ \beta_j(x)\) 为分段三次Hermite插值的基函数。再由边界条件得 \(S&amp;#39;(x_0)=f_0&amp;#39;,\ S&amp;#39;(x_n)=f_n&amp;#39;\) 即可解出 \(m_i\) 在各插值点的取值。记
\(\displaystyle \lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}},\ \mu_i=1-\lambda_i=\frac{h_i}{h_i+h_{i+1}},\ g_i=3(\lambda_if[x_{i-1},x_i]+\mu_if[x_i,x_{i+1}])\) ，
最终解得： \[ \begin{array}{c}\lambda_im_{i-1}+2m_i+\mu_im_{i+1}=g_i\\ \begin{pmatrix} 2 &amp;amp;\mu_1 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ \lambda_2 &amp;amp;2 &amp;amp;\mu_2 &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp;\ddots &amp;amp;\ddots &amp;amp;\ddots &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp;\ddots &amp;amp;\ddots &amp;amp;\ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp;\lambda_{n-2} &amp;amp;2 &amp;amp;\mu_{n-2} \\ &amp;amp; &amp;amp; &amp;amp; &amp;amp;\lambda_{n-1} &amp;amp;2 \end{pmatrix} \begin{pmatrix} m_1 \\ m_2 \\ \vdots \\ \vdots \\ m_{n-2} \\ m_{n-1} \end{pmatrix}= \begin{pmatrix} g_1-\lambda_iy_0&amp;#39; \\ g_2 \\ \vdots \\ \vdots \\ g_{n-2} \\ g_{n-1}-\mu_{n-1}y_n&amp;#39; \end{pmatrix} \end{array} \] 利用大型稀疏矩阵线性方程数值解法，解出 \(m_i\) ，即解得 \(x\in[x_{i-1},x_i]\) 时，有：</description>
      <content:encoded><![CDATA[<h3 id="续5.8---5.10-三次样条插值">续：5.8 - 5.10 三次样条插值</h3>
<h4 id="三转角方法">三转角方法</h4>
<p>考虑第一种一般边界条件： <span
class="math inline">\(S&#39;(x_0)=f_0&#39;,\
S&#39;(x_n)=f_n&#39;\)</span> ，即已知两端点一阶导数值。</p>
<p>令 <span class="math inline">\(m_i=S&#39;(x_i),\
i=0,1,\dots,n\)</span> ，利用三次Hermite插值，得到 <span
class="math inline">\(S(x)=\displaystyle
\sum_{j=0}^n[y_j\alpha_j(x)+m_j\beta_j(x)]\)</span> ，其中 <span
class="math inline">\(\alpha_j(x),\ \beta_j(x)\)</span>
为分段三次Hermite插值的基函数。再由边界条件得 <span
class="math inline">\(S&#39;(x_0)=f_0&#39;,\
S&#39;(x_n)=f_n&#39;\)</span> 即可解出 <span
class="math inline">\(m_i\)</span> 在各插值点的取值。记<br />
<span class="math inline">\(\displaystyle
\lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}},\
\mu_i=1-\lambda_i=\frac{h_i}{h_i+h_{i+1}},\
g_i=3(\lambda_if[x_{i-1},x_i]+\mu_if[x_i,x_{i+1}])\)</span> ，<br />
最终解得： <span class="math display">\[
\begin{array}{c}\lambda_im_{i-1}+2m_i+\mu_im_{i+1}=g_i\\
\begin{pmatrix}
2  &amp;\mu_1  &amp;  &amp;  &amp;  &amp; \\
\lambda_2  &amp;2  &amp;\mu_2  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\lambda_{n-2}  &amp;2  &amp;\mu_{n-2} \\
  &amp;  &amp;  &amp;  &amp;\lambda_{n-1}  &amp;2
\end{pmatrix}
\begin{pmatrix}
m_1 \\
m_2 \\
\vdots \\
\vdots \\
m_{n-2} \\
m_{n-1}
\end{pmatrix}=
\begin{pmatrix}
g_1-\lambda_iy_0&#39; \\
g_2 \\
\vdots \\
\vdots \\
g_{n-2} \\
g_{n-1}-\mu_{n-1}y_n&#39;
\end{pmatrix}
\end{array}
\]</span> 利用大型稀疏矩阵线性方程数值解法，解出 <span
class="math inline">\(m_i\)</span> ，即解得 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> 时，有：<br />
<span class="math inline">\(\begin{aligned}\displaystyle
S(x)&amp;=\frac{
(2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i
}{h_i^3}\\ &amp;+\frac{
(x-x_{i-1})(x-x_i)[(x-x_i)m_{i-1}+(x-x_{i-1})m_i] }{h_i^2}
\end{aligned}\)</span></p>
<p>其他边界条件也可用类似方法解得，计算方法较复杂。</p>
<h4 id="三弯矩方法">三弯矩方法</h4>
<blockquote>
<p>二阶导数 <span class="math inline">\(S&#39;&#39;(x)=M_j\
(j=0,1,\dots,n)\)</span> 在力学上解释为细梁在 <span
class="math inline">\(x_j\)</span> 截面处的<strong>弯矩</strong>。</p>
</blockquote>
<p>令 <span class="math inline">\(M_i=S&#39;&#39;(x_i),\
i=0,1,\dots,n\)</span> ，则对 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> ，有：<br />
<span class="math inline">\(\displaystyle
S&#39;&#39;(x)=\frac{x-x_i}{x_{i-1}-x_i}M_{i-1}+\frac{x-x_{i-1}}{x_i-x_{i-1}}M_i\)</span>
，对此连续积分两次，记 <span class="math inline">\(S(x_i)=y_i\)</span>
，得：<br />
<span class="math inline">\(\begin{aligned}\displaystyle
S(x)&amp;=\frac{1}{6h_i}\left[(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i\right]\\&amp;+\left(\frac{y_{i-1}}{h_i}-\frac{h_iM_{i-1}}{6}\right)(x_i-x)+\left(\frac{y_i}{h_i}-\frac{h_iM_i}{6}\right)(x-x_{i-1})\\&amp;=\frac{(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i+(6y_{i-1}-h_i^2M_{i-1})(x_i-x)+(6y_i-h_i^2M_i)(x-x_{i-1})}{6h_i}\end{aligned}\)</span><br />
利用 <span class="math inline">\(S&#39;(x_i-0)=S&#39;(x_i+0)\)</span>
求出 <span class="math inline">\(M_i\)</span> ，记<br />
<span class="math inline">\(\displaystyle
\lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}}=,\ \mu_i=\frac{h_i}{h_i+h_{i+1}},\
d_i=6f[x_{i-1},x_i,x_{i+1}]\)</span> ，<br />
则有： <span
class="math inline">\(\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\)</span><br />
结合边界条件 <span
class="math inline">\(M_0=S&#39;&#39;(x_0)=y&#39;&#39;_0,\
M_n=S&#39;&#39;(x_n)=y&#39;&#39;_n\)</span> ，可得： <span
class="math display">\[
\begin{array}{c}\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\\
\begin{pmatrix}
2  &amp;\mu_1  &amp;  &amp;  &amp;  &amp; \\
\mu_2  &amp;2  &amp;\lambda_2  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\mu_{n-2}  &amp;2  &amp;\lambda_{n-2} \\
  &amp;  &amp;  &amp;  &amp;\mu_{n-1}  &amp;2
\end{pmatrix}
\begin{pmatrix}
M_1 \\
M_2 \\
\vdots \\
\vdots \\
M_{n-2} \\
M_{n-1}
\end{pmatrix}=
\begin{pmatrix}
d_1-\mu_iy_0&#39; \\
d_2 \\
\vdots \\
\vdots \\
d_{n-2} \\
d_{n-1}-\lambda_{n-1}y_n&#39;&#39;
\end{pmatrix}
\end{array}
\]</span> 或结合边界条件 <span
class="math inline">\(S&#39;(x_0)=y_0&#39;,\
S&#39;(x_n)=y_n&#39;\)</span> ，得： <span class="math display">\[
\begin{array}{c}\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\\2M_0+M_1=d+0\\M_{n-1}+2M_n=d_n\\
\begin{pmatrix}
2  &amp;_1  &amp;  &amp;  &amp;  &amp; \\
\mu_1  &amp;2  &amp;\lambda_1  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\mu_{n-1}  &amp;2  &amp;\lambda_{n-1} \\
  &amp;  &amp;  &amp;  &amp;1  &amp;2
\end{pmatrix}
\begin{pmatrix}
M_1 \\
M_2 \\
\vdots \\
\vdots \\
M_{n-2} \\
M_{n-1}
\end{pmatrix}=
\begin{pmatrix}
d_0 \\
d_1 \\
\vdots \\
\vdots \\
d_{n-1} \\
d_n
\end{pmatrix}
\end{array}
\]</span> 或结合周期边界条件 <span
class="math inline">\(S&#39;(x_0)=S&#39;(x_n),\
S&#39;&#39;(x_0)=S&#39;&#39;(x_n)\)</span> ，同样得到稀疏矩阵线性方程。
采用稀疏矩阵线性方程解法即可。</p>
<p><strong>综上</strong>，当边界条件为第一类（已知一阶导数值）时，适合采用三转角方法；当边界条件为第二类（已知二阶导数值）时适合采用三弯矩方法；对周期边界条件，两种方法计算量一致。</p>
<h3 id="最小二乘法">最小二乘法</h3>
<h4 id="数据拟合问题">数据拟合问题</h4>
<p>经由观察或测试得到 <span class="math inline">\(y(x)\)</span>
的一组离散数据，在给定的函数类 <span class="math inline">\(\Phi\)</span>
上根据这组离散数据做出逼近曲线，要求逼近曲线在 <span
class="math inline">\(x_i\)</span> 处与离散数据尽可能接近。</p>
<p>对函数 <span class="math inline">\(\varphi(x)\in\Phi\)</span>
，要求以 <span class="math inline">\(\varphi(x)\)</span> 在离散点的误差
<span class="math inline">\(\delta_i=\phi(x_i)-y_i,\
i=0,1,\dots,m\)</span> 为分量的误差向量 <span
class="math inline">\(\delta=(\delta_0,\delta_1,\dots,\delta_m)^T\)</span>
，使某一向量范数 <span class="math inline">\(\|\delta\|\)</span>
达到最小。对不同的范数，可以构造出不同意义下的拟合函数。</p>
<p>函数类 <span class="math inline">\(\Phi\)</span> 通常取为 <span
class="math inline">\(\Phi=Span\{\varphi_0(x),\varphi_1(x),\dots,\varphi_n(x)\}\)</span>
，其中函数系 <span
class="math inline">\(\varphi_0(x),\varphi_1(x),\dots,\varphi_n(x)\)</span>
在包含节点 <span class="math inline">\(\{x_i\}\)</span> 的区间 <span
class="math inline">\([a,b]\)</span> 上线性无关， <span
class="math inline">\(\Phi\)</span> 中任一函数 <span
class="math inline">\(\varphi(x)\)</span> 可表示为： <span
class="math inline">\(\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+\dots+a_n\varphi_n(x)\)</span>
。</p>
<p>常用函数系包括幂函数系 <span class="math inline">\(\{x^j\}\)</span>
，三角函数系 <span class="math inline">\(\{\sin jx\}\ \{\cos
jx\}\)</span> ，指数函数系 <span
class="math inline">\(\{e^{\lambda_jx}\}\)</span> ，正交函数系等。</p>
<p>在求误差向量 <span class="math inline">\(\delta\)</span>
的范数时，常用 <span class="math inline">\(2\)</span>
-范数，对应的曲线拟合方法就称为<strong>最小二乘法</strong>。</p>
<p><strong>推导</strong>：在函数类 <span
class="math inline">\(\Phi\)</span> 中找到函数 <span
class="math inline">\(y=\varphi^*(x)\)</span> ，使误差向量 <span
class="math inline">\(\delta\)</span> 的 <span
class="math inline">\(2\)</span>
-范数达到最小值。（通常取误差向量的加权形式 <span
class="math inline">\(\rho(x)\varphi(x)\)</span> 求 <span
class="math inline">\(2\)</span> -范数的平方 <span
class="math inline">\(\|\delta\|_2^2\)</span> ）。该范数为关于 <span
class="math inline">\((a_0,a_1,\dots,a_n)\)</span> 的函数，记其为 <span
class="math inline">\(G(a_0,a_1,\dots,a_n)\)</span>
，则问题转换为求该函数最小值问题。<br />
记 <span
class="math inline">\(\left\{\begin{array}{l}\varphi_j=(\varphi_j(x_0),\varphi_j(x_1),\dots,\varphi_j(x_m))^T,\
j=0,1,2,\dots,n\\f=(y_0,y_1,\dots,y_m)^T\\(\varphi_j,\varphi_k)=\displaystyle\sum_{i=0}^m\rho(x_i)\varphi_j(x_i)\varphi_k(x_i)\\(f,\varphi_k)=\displaystyle\sum_{i=0}^m\rho(x_i)y_i\varphi_k(x_i)\end{array}\\\right.\)</span><br />
得到关于系数向量 <span
class="math inline">\((a_0,a_1,\dots,a_n)^T\)</span> 的线性方程组：
<span class="math display">\[
\begin{array}{c}\displaystyle\sum_{j=0}^n(\varphi_j,\varphi_k)a_j=(f,\varphi_k)\quad
k=0,1,\dots,n\\
\begin{pmatrix}
(\varphi_0,\varphi_0)  &amp;(\varphi_0,\varphi_1)  &amp;\cdots  &amp;(\varphi_j,\varphi_k)
\\
(\varphi_1,\varphi_0)  &amp;(\varphi_1,\varphi_1)  &amp;\cdots  &amp;(\varphi_1,\varphi_n)
\\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
(\varphi_n,\varphi_0)  &amp;(\varphi_n,\varphi_1)  &amp;\cdots  &amp;(\varphi_n,\varphi_n)
\end{pmatrix}
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{pmatrix}
=\begin{pmatrix}
(f,\varphi_0) \\
(f,\varphi_1) \\
\vdots \\
(f,\varphi_n)
\end{pmatrix}\end{array}
\]</span>
称之为<strong>正则方程组</strong>或<strong>法方程组</strong>。<br />
正则方程组的系数矩阵为对称矩阵。若向量组 <span
class="math inline">\(\varphi_0,\varphi_1,\dots,\varphi_n\)</span>
线性无关，则其为对称正定矩阵，可以通过迭代法求得唯一解 <span
class="math inline">\(a_j^*\)</span> ，从而得到拟合函数 <span
class="math inline">\(\varphi^*(x)\)</span> 。</p>
<h4 id="取函数类">取函数类</h4>
<p>取函数类为幂函数系，则正则方程组为：<br />
<span class="math display">\[
\begin{pmatrix}
\sum\rho_i  &amp;\sum\rho_i x_i  &amp;\cdots  &amp;\sum\rho_i x_i^n \\
\sum\rho_i x_i  &amp;\sum\rho_i x_i^2  &amp;\cdots  &amp;\sum\rho_i
x_i^{n+1} \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
\sum\rho_i x_i^n  &amp;\sum\rho_i
x_i^{n+1}  &amp;\cdots  &amp;\sum\rho_i x_i^{2n}
\end{pmatrix}
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{pmatrix}
=\begin{pmatrix}
\sum\rho_iy_i \\
\sum\rho_ix_iy_i \\
\vdots \\
\sum\rho_ix_i^ny_i
\end{pmatrix}
\]</span> 其中 <span class="math inline">\(\rho_i=\rho(x_i),\
\sum=\sum\limits_{i=0}^m\)</span> 。此时拟合曲线 <span
class="math inline">\(\varphi^*(x)=p_n^*(x)=a_0^*+a_1^*x+\dots+a_n^*x^n\)</span>
，称之为<strong>多项式拟合曲线</strong>。</p>
<p>取函数类为正交函数系，则 <span
class="math inline">\((\varphi_i,\varphi_j)=0,\ (i\neq j)\)</span>
，正则方程组的系数矩阵为对角矩阵， <span
class="math inline">\(a_k^*=(f,\varphi_k)/(\varphi_k,\varphi_k),\
k=0,1,\dots,n\)</span> 。</p>
<h3
id="代码本节计算主要过程为解线性方程组列出对应元计算式调用对应函数即可线性方程组解法在之前章节已给出不再重复">代码：本节计算主要过程为解线性方程组，列出对应元计算式，调用对应函数即可。线性方程组解法在之前章节已给出，不再重复。</h3>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-06-数值分析-Day09-分段插值-三次样条函数</title>
      <link>http://localhost:1313/posts/2021-03-06-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day09-%E5%88%86%E6%AE%B5%E6%8F%92%E5%80%BC-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 06 Mar 2021 17:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-06-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day09-%E5%88%86%E6%AE%B5%E6%8F%92%E5%80%BC-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/</guid>
      <description>5.6 - 5.7 分段插值 Runge现象：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。
分段Lagrange插值 分段线性插值 通过相邻两个插值点作线性插值。已知节点 \(a=x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n=b\) ，记 \(h_k=x_{k+1}-x_k,\ h=\max\limits_{0\le k\le n-1}h_k\) ，记分段插值函数为 \(I_h(x)\) ，为 \(n-1\) 段折线。
余项估计有 \(|f(x)-I_h(x)|\le \displaystyle\frac{\max\limits_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|}{8}h^2\) ，说明分段线性插值函数具有一致收敛性。
分段二次插值 相邻三个插值点作二次插值。
课程中以线性插值中两邻点中间值，作为补充条件，即取 \(x_{i-0.5}=(x_i+x_{i-1})/2\) 作为每组中的第三个插值点，使得两点间距为 \(h_k/2\) 。按照这种方式得到余项估计 \(|f(x)-I_h(x)|\le \displaystyle\frac{\max\limits_{a\le x\le b}|f&amp;#39;&amp;#39;&amp;#39;(x)|}{72\sqrt{3}}h^3\) 。
PS：个人认为应直接取连续三个插值点，即 \(\{x_0,x_1,x_2\}\ \{x_2,x_3,x_4\}\ \{x_4,x_5,x_6\}\ \dots\) 作为插值点进行二次插值。
分段Lagrange插值的问题：区间内出现不可导点 分段Hermite插值 设节点 \(a\le x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n\le b,\ h_i=x_i-x_{i-1}\ (i=1,2,\dots,n)\) ，给出插值条件： \(y_k=f(x_k),\ y&amp;#39;_k=f&amp;#39;(x_k),\ (k=0,1,\dots,n)\) 。则每区间 \([x_{i-1},x_i]\) 具有四个插值条件。构造三次多项式 \(H_3^{(i)}(x)\) ： \[ \begin{array}{c}H_3^{(i)}(x)=\varphi_{i-1}(x)y_{i-1}+\varphi_i(x)y_i+\psi_{i-1}(x)y&amp;#39;_{i-1}+\psi_i(x)y&amp;#39;_i\\ \left\{\begin{aligned} &amp;amp;\varphi_{i-1}(x_{i-1})=1 &amp;amp;&amp;amp;\varphi_{i-1}(x_i)=0 &amp;amp;&amp;amp;\varphi&amp;#39;_{i-1}(x_{i-1})=0 &amp;amp;&amp;amp;\varphi&amp;#39;_{i-1}(x_i)=0\\ &amp;amp;\varphi_i(x_{i-1})=0 &amp;amp;&amp;amp;\varphi_i(x_i)=1 &amp;amp;&amp;amp;\varphi&amp;#39;_i(x_{i-1})=0 &amp;amp;&amp;amp;\varphi&amp;#39;_i(x_i)=0\\ &amp;amp;\psi_{i-1}(x_{i-1})=0 &amp;amp;&amp;amp;\psi_{i-1}(x_i)=0 &amp;amp;&amp;amp;\psi&amp;#39;_{i-1}(x_{i-1})=1 &amp;amp;&amp;amp;\psi&amp;#39;_{i-1}(x_i)=0\\ &amp;amp;\psi_i(x_{i-1})=0 &amp;amp;&amp;amp;\psi_i(x_i)=0 &amp;amp;&amp;amp;\psi&amp;#39;_i(x_{i-1})=0 &amp;amp;&amp;amp;\psi&amp;#39;_i(x_i)=1\\ \end{aligned}\right.</description>
      <content:encoded><![CDATA[<h3 id="分段插值">5.6 - 5.7 分段插值</h3>
<p><strong>Runge现象</strong>：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。</p>
<h4 id="分段lagrange插值">分段Lagrange插值</h4>
<h5 id="分段线性插值">分段线性插值</h5>
<p>通过相邻两个插值点作线性插值。已知节点 <span
class="math inline">\(a=x_0&lt;x_1&lt;\dots&lt;x_n=b\)</span> ，记 <span
class="math inline">\(h_k=x_{k+1}-x_k,\ h=\max\limits_{0\le k\le
n-1}h_k\)</span> ，记分段插值函数为 <span
class="math inline">\(I_h(x)\)</span> ，为 <span
class="math inline">\(n-1\)</span> 段折线。</p>
<p>余项估计有 <span class="math inline">\(|f(x)-I_h(x)|\le
\displaystyle\frac{\max\limits_{a\le x\le
b}|f&#39;&#39;(x)|}{8}h^2\)</span>
，说明分段线性插值函数具有一致收敛性。</p>
<h5 id="分段二次插值">分段二次插值</h5>
<p>相邻三个插值点作二次插值。</p>
<p>课程中以线性插值中两邻点中间值，作为补充条件，即取 <span
class="math inline">\(x_{i-0.5}=(x_i+x_{i-1})/2\)</span>
作为每组中的第三个插值点，使得两点间距为 <span
class="math inline">\(h_k/2\)</span> 。按照这种方式得到余项估计 <span
class="math inline">\(|f(x)-I_h(x)|\le
\displaystyle\frac{\max\limits_{a\le x\le
b}|f&#39;&#39;&#39;(x)|}{72\sqrt{3}}h^3\)</span> 。</p>
<p>PS：个人认为应直接取连续三个插值点，即 <span
class="math inline">\(\{x_0,x_1,x_2\}\ \{x_2,x_3,x_4\}\ \{x_4,x_5,x_6\}\
\dots\)</span> 作为插值点进行二次插值。</p>
<h5
id="分段lagrange插值的问题区间内出现不可导点">分段Lagrange插值的问题：区间内出现不可导点</h5>
<h4 id="分段hermite插值">分段Hermite插值</h4>
<p>设节点 <span class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le
b,\ h_i=x_i-x_{i-1}\ (i=1,2,\dots,n)\)</span> ，给出插值条件： <span
class="math inline">\(y_k=f(x_k),\ y&#39;_k=f&#39;(x_k),\
(k=0,1,\dots,n)\)</span> 。则每区间 <span
class="math inline">\([x_{i-1},x_i]\)</span>
具有四个插值条件。构造三次多项式 <span
class="math inline">\(H_3^{(i)}(x)\)</span> ： <span
class="math display">\[
\begin{array}{c}H_3^{(i)}(x)=\varphi_{i-1}(x)y_{i-1}+\varphi_i(x)y_i+\psi_{i-1}(x)y&#39;_{i-1}+\psi_i(x)y&#39;_i\\
\left\{\begin{aligned}
&amp;\varphi_{i-1}(x_{i-1})=1 &amp;&amp;\varphi_{i-1}(x_i)=0
&amp;&amp;\varphi&#39;_{i-1}(x_{i-1})=0
&amp;&amp;\varphi&#39;_{i-1}(x_i)=0\\
&amp;\varphi_i(x_{i-1})=0 &amp;&amp;\varphi_i(x_i)=1
&amp;&amp;\varphi&#39;_i(x_{i-1})=0 &amp;&amp;\varphi&#39;_i(x_i)=0\\
&amp;\psi_{i-1}(x_{i-1})=0 &amp;&amp;\psi_{i-1}(x_i)=0
&amp;&amp;\psi&#39;_{i-1}(x_{i-1})=1 &amp;&amp;\psi&#39;_{i-1}(x_i)=0\\
&amp;\psi_i(x_{i-1})=0 &amp;&amp;\psi_i(x_i)=0
&amp;&amp;\psi&#39;_i(x_{i-1})=0 &amp;&amp;\psi&#39;_i(x_i)=1\\
\end{aligned}\right.\\\Longrightarrow\quad\left\{\begin{aligned}
&amp;H_3^{(i)}(x_{i-1})=y_{i-1}&amp;&amp;H_3^{(i)}(x_i)=y_i\\
&amp;H_3&#39;^{(i)}(x_{i-1})=y&#39;_{i-1}&amp;&amp;H_3&#39;^{(i)}(x_i)=y&#39;_i
\end{aligned}\right.\end{array}
\]</span> 其中，称 <span class="math inline">\(\varphi_{i-1}(x),\
\varphi_i(x),\ \psi_{i-1}(x),\ \psi_i(x)\)</span>
为<strong>三次Hermite插值基函数</strong>。<br />
求得： <span class="math display">\[
\begin{array}{c}\left\{\begin{aligned}\displaystyle
&amp;\varphi_{i-1}(x_{i-1})=\frac{1}{h_i^3}(2x-3x_{i-1}+x_i)(x-x_i)^2\\
&amp;\varphi_i(x_{i-1})=\frac{1}{h_i^3}(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2\\
&amp;\psi_{i-1}(x_{i-1})=\frac{1}{h_i^2}(x-x_{i-1})(x-x_i)^2\\
&amp;\psi_i(x_{i-1})=\frac{1}{h_i^2}(x-x_{i-1})^2(x-x_i)
\end{aligned}\right.\\
\begin{aligned}\displaystyle H_3^{(i)}(x)&amp;=\frac{
(2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i
}{h_i^3}\\
&amp;+\frac{
(x-x_{i-1})(x-x_i)[(x-x_i)y&#39;_{i-1}+(x-x_{i-1})y&#39;_i]
}{h_i^2}
\end{aligned}\end{array}
\]</span></p>
<p><strong>余项分析</strong>：若 <span class="math inline">\(f(x)\in
C^4[a,b]\)</span> （四阶连续可微），则当 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> 时，有： <span
class="math display">\[
\begin{array}{c}\displaystyle
f(x)-H_3^{(i)}(x)=\frac{f^{(4)}(\xi_i)}{4!}(x-x_{i-1})^2(x-x_i)^2,\quad\xi\in[x_{i-1},x_i]\\
\displaystyle |f(x)-H_3(x)|\le\frac{\max\limits_{a\le x\le
b}|f^{(4)}(x)|\times h^4}{4!\times16}=\frac{\max\limits_{a\le x\le
b}|f^{(4)}(x)|\times h^4}{384}\end{array}
\]</span> 可知 <span class="math inline">\(H_3(x)\)</span>
是收敛的，且在 <span class="math inline">\([a,b]\)</span>
内具有一阶连续导数。</p>
<h3 id="三次样条插值">5.8 - 5.10 三次样条插值</h3>
<p>Hermite分段插值只能保证一阶连续可导，引入三次样条插值保证二阶连续可导。</p>
<p><strong>三次样条函数</strong>：若函数 <span
class="math inline">\(S(x)\in C^2[a,b]\)</span> ，且在每个小区间 <span
class="math inline">\([x_j,x_{j+1}]\)</span> 上是三次多项式，其中 <span
class="math inline">\(a=x_0&lt;x_1&lt;\dots&lt;x_n=b\)</span>
是给定节点，则称 <span class="math inline">\(S(x)\)</span> 是节点 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span>
上的<strong>三次样条函数</strong>。</p>
<p><strong>分段三次多项式</strong>： <span
class="math inline">\(S(x)=a_jx^3+b_jx^2+c_jx+d_j,\
j=0,1,2,\dots,n-1\)</span> ，其中 <span class="math inline">\(a_j\ b_j\
c_j\ d_j\)</span> 为待定系数，因此函数共有 <span
class="math inline">\(4n\)</span> 个待定参数。函数满足关系： <span
class="math inline">\(\left\{\begin{array}{l}S(x_j-0)=S(x_j+0)\\S&#39;(x_j-0)=S&#39;(x_j+0)\\S&#39;&#39;(x_j-0)=S&#39;&#39;(x_j+0)\end{array}\right.\)</span>
，共 <span class="math inline">\(3n-3\)</span> 个条件，加上插值条件
<span class="math inline">\(S(x_j)=f_j,\ j=0,1,\dots,n\)</span> 共 <span
class="math inline">\(4n-2\)</span>
个条件。在此基础上在区间端点处添加一对<strong>边界条件</strong>即可满足唯一确定
<span class="math inline">\(4n\)</span> 个待定参数的 <span
class="math inline">\(4n\)</span> 个条件。</p>
<p><strong>边界条件</strong>：一般来说有两种边界条件，即两端点的一阶导数值或二阶导数值。</p>
<p><strong>周期边界条件</strong>：当 <span
class="math inline">\(f(x)\)</span> 是以 <span
class="math inline">\(x_n-x_0\)</span> 为周期的周期函数时，要求 <span
class="math inline">\(S(x)\)</span> 也是周期函数，此时边界条件满足：
<span
class="math inline">\(\left\{\begin{array}{l}S(x_0+0)=S(x_n-0)\\S&#39;(x_0+0)=S&#39;(x_n-0)\\S&#39;&#39;(x_0+0)=S&#39;&#39;(x_n-0)\end{array}\right.\)</span>
，且端点二阶导数值均为 <span class="math inline">\(0\)</span>
。称这样的样条函数为<strong>周期样条函数</strong>。</p>
<h3 id="代码hermite插值">代码：Hermite插值</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-06.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_im1<span class="op">;</span> <span class="dt">double</span> x_i<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y_im1<span class="op">;</span> <span class="dt">double</span> y_i<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y_1_im1<span class="op">;</span> <span class="dt">double</span> y_1_i<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">// x, y, y_1</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> array<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> H<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> <span class="va">array_</span> <span class="op">{{</span><span class="dv">100</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">20</span><span class="op">},</span> <span class="op">{</span><span class="dv">121</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">22</span><span class="op">},</span> <span class="op">{</span><span class="dv">144</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">24</span><span class="op">},</span> <span class="op">{</span><span class="dv">169</span><span class="op">,</span> <span class="dv">13</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">26</span><span class="op">}};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    array<span class="op">.</span>assign<span class="op">(</span><span class="va">array_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">array_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> H<span class="op">(</span><span class="dv">125</span><span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> H<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>array<span class="op">.</span>begin<span class="op">(),</span> array<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">});</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span> x <span class="op">&lt;</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            x_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span> x_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            y_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span> y_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            y_1_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">2</span><span class="op">];</span> y_1_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h_i <span class="op">=</span> x_i <span class="op">-</span> x_im1<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h <span class="op">=</span> <span class="op">(</span> <span class="op">(</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x_im1 <span class="op">+</span> x_i<span class="op">)</span> <span class="op">*</span> pow<span class="op">((</span>x <span class="op">-</span> x_i<span class="op">),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> y_im1</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                 <span class="op">+</span> <span class="op">(-</span> <span class="dv">2</span> <span class="op">*</span> x <span class="op">-</span> x_im1 <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> x_i<span class="op">)</span> <span class="op">*</span> pow<span class="op">((</span>x <span class="op">-</span> x_im1<span class="op">),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> y_i <span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>             <span class="op">+</span> h_i <span class="op">*</span> <span class="op">(</span>x <span class="op">-</span> x_im1<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>x <span class="op">-</span> x_i<span class="op">)</span> <span class="op">*</span> <span class="op">((</span>x <span class="op">-</span> x_i<span class="op">)</span> <span class="op">*</span> y_1_im1 <span class="op">+</span> <span class="op">(</span>x <span class="op">-</span> x_im1<span class="op">)</span> <span class="op">*</span> y_1_i <span class="op">)</span> <span class="op">)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>             <span class="op">/</span> pow<span class="op">(</span>h_i<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-05-数值分析-Day08-Lagrange插值-Newton插值</title>
      <link>http://localhost:1313/posts/2021-03-05-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day08-lagrange%E6%8F%92%E5%80%BC-newton%E6%8F%92%E5%80%BC/</link>
      <pubDate>Fri, 05 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-05-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day08-lagrange%E6%8F%92%E5%80%BC-newton%E6%8F%92%E5%80%BC/</guid>
      <description>5.1 - 5.3 插值的引入与Lagrange插值 插值的定义 设函数 \(y=f(x)\) 在区间 \([a,b]\) 上连续，给定 \(n+1\) 个点： \(a\le x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n\le b\) 。
已知 \(f(x_k)=y_k(k=0,1,\dots,n)\) ，在函数类 \(P\) 中寻找一函数 \(\varphi(x)\) 作为 \(f(x)\) 的近似表达式，使满足：
$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 \(y=f(x)\) 为被插值函数，称 \(\varphi(x)\) 为插值函数。称 \(x_0,x_1,\dots,x_n\) 为插值节点； \(\varphi(x_k)=f(x_k)=y_k,\ k=0,1,2,\dots,n\) 为插值条件，寻求插值函数的方法称为插值方法。
在构造插值函数时，函数类 \(P\) 的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即多项式插值。若用 \(P_n\) 表示所有次数不超过 \(n\) 的多项式函数类，则若 \(p_n(x)\in P_n\) ，则 有\(p_n(x)=a_0+a_1x+\dots+a_nx^n\) ，由 \(n+1\) 个系数唯一确定。若 \(p_n(x)\) 满足插值条件，即 \(\left\{\begin{array}{l}a_0+a_1x_1+\dots+a_nx_1^n\\a_0+a_1x_2+\dots+a_nx_2^n\\\dots\\a_0+a_1x_n+\dots+a_nx_n^n\end{array}\right.\) 。令 \(\{a_0,a_1,\dots,a_n\}\) 为元，则该方程系数行列式为 \(\begin{vmatrix}1&amp;amp;x_0&amp;amp;\cdots&amp;amp;x_0^n\\1&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_1^n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;x_n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}\) ，由范德蒙行列式得: \(\begin{vmatrix}1&amp;amp;x_0&amp;amp;\cdots&amp;amp;x_0^n\\1&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_1^n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;x_n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}=\begin{vmatrix}1&amp;amp;1&amp;amp;\cdots&amp;amp;1\\x_0&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\x_0^n&amp;amp;x_2^n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}=\prod\limits_{0\le&amp;lt;j\le n}(x_j-x_i)\neq0\) ，因此该方程有解。
由此得定理：满足上述条件的插值问题， \(p_n(x)\) 存在且唯一。
Lagrange插值 线性插值 最简单的插值问题：已知两点 \((x_0,y_0)\ (x_1,y_1)\) 。通过此两点的插值多项式是一条直线，即两点式： \(\displaystyle L_1(x)=\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1\) 。称 \(L_1(x)\) 为线性插值函数。</description>
      <content:encoded><![CDATA[<h3 id="插值的引入与lagrange插值">5.1 - 5.3
插值的引入与Lagrange插值</h3>
<h4 id="插值的定义">插值的定义</h4>
<p>设函数 <span class="math inline">\(y=f(x)\)</span> 在区间 <span
class="math inline">\([a,b]\)</span> 上连续，给定 <span
class="math inline">\(n+1\)</span> 个点： <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span>
。<br />
已知 <span class="math inline">\(f(x_k)=y_k(k=0,1,\dots,n)\)</span>
，在函数类 <span class="math inline">\(P\)</span> 中寻找一函数 <span
class="math inline">\(\varphi(x)\)</span> 作为 <span
class="math inline">\(f(x)\)</span> 的近似表达式，使满足：<br />
$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 <span
class="math inline">\(y=f(x)\)</span> 为<strong>被插值函数</strong>，称
<span class="math inline">\(\varphi(x)\)</span>
为<strong>插值函数</strong>。称 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span>
为<strong>插值节点</strong>； <span
class="math inline">\(\varphi(x_k)=f(x_k)=y_k,\ k=0,1,2,\dots,n\)</span>
为<strong>插值条件</strong>，寻求插值函数的方法称为<strong>插值方法</strong>。</p>
<p>在构造插值函数时，函数类 <span class="math inline">\(P\)</span>
的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即<strong>多项式插值</strong>。若用
<span class="math inline">\(P_n\)</span> 表示所有次数不超过 <span
class="math inline">\(n\)</span> 的多项式函数类，则若 <span
class="math inline">\(p_n(x)\in P_n\)</span> ，则 有<span
class="math inline">\(p_n(x)=a_0+a_1x+\dots+a_nx^n\)</span> ，由 <span
class="math inline">\(n+1\)</span> 个系数唯一确定。若 <span
class="math inline">\(p_n(x)\)</span> 满足插值条件，即 <span
class="math inline">\(\left\{\begin{array}{l}a_0+a_1x_1+\dots+a_nx_1^n\\a_0+a_1x_2+\dots+a_nx_2^n\\\dots\\a_0+a_1x_n+\dots+a_nx_n^n\end{array}\right.\)</span>
。令 <span class="math inline">\(\{a_0,a_1,\dots,a_n\}\)</span>
为元，则该方程系数行列式为 <span
class="math inline">\(\begin{vmatrix}1&amp;x_0&amp;\cdots&amp;x_0^n\\1&amp;x_1&amp;\cdots&amp;x_1^n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;x_n&amp;\cdots&amp;x_n^n\end{vmatrix}\)</span>
，由范德蒙行列式得: <span
class="math inline">\(\begin{vmatrix}1&amp;x_0&amp;\cdots&amp;x_0^n\\1&amp;x_1&amp;\cdots&amp;x_1^n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;x_n&amp;\cdots&amp;x_n^n\end{vmatrix}=\begin{vmatrix}1&amp;1&amp;\cdots&amp;1\\x_0&amp;x_1&amp;\cdots&amp;x_n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_0^n&amp;x_2^n&amp;\cdots&amp;x_n^n\end{vmatrix}=\prod\limits_{0\le&lt;j\le
n}(x_j-x_i)\neq0\)</span> ，因此该方程有解。<br />
由此得定理：满足上述条件的插值问题， <span
class="math inline">\(p_n(x)\)</span> 存在且唯一。</p>
<h4 id="lagrange插值">Lagrange插值</h4>
<h5 id="线性插值">线性插值</h5>
<p>最简单的插值问题：已知两点 <span class="math inline">\((x_0,y_0)\
(x_1,y_1)\)</span> 。通过此两点的插值多项式是一条直线，即两点式： <span
class="math inline">\(\displaystyle
L_1(x)=\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1\)</span> 。称
<span class="math inline">\(L_1(x)\)</span>
为<strong>线性插值函数</strong>。<br />
令 <span class="math inline">\(\left\{\begin{array}{l}\displaystyle
l_0(x)=\frac{x-x_1}{x_0-x_1}\\\displaystyle
l_1(x)=\frac{x-x_0}{x_1-x_0}\end{array}\right.\)</span> ，则有 <span
class="math inline">\(\left\{\begin{array}{l}L_1(x)=y_0l_0(x)+y_1l_1(x)\\l_0(x_0)=1\quad
l_0(x_1)=0\\l_1(x_0)=0\quad l_1(x_1)=1\end{array}\right.\)</span> ，称
<span class="math inline">\(l_0(x),\ l_1(x)\)</span> 为关于 <span
class="math inline">\(x_0,\ x_1\)</span>
的<strong>线性插值基函数</strong>。</p>
<h5 id="抛物插值">抛物插值</h5>
<p>已知三点 <span class="math inline">\((x_0,y_0)\ (x_1,y_1)\
(x_2,y_2)\)</span> 。构造插值函数 <span
class="math inline">\(L_2(x)\)</span> 。称 <span
class="math inline">\(L_2(x)\)</span>
为<strong>抛物插值函数</strong>。<br />
设 <span
class="math inline">\(L_2(x)=y_0l_0(x)+y_1l_1(x)+y_2l_2(x)\)</span>
，则由插值条件可知 <span
class="math inline">\(\left\{\begin{array}{l}l_0(x_0)=1\quad
l_0(x_1)=0\quad l_2(x_2)=0\\l_0(x_0)=0\quad l_0(x_1)=1\quad
l_2(x_2)=0\\l_0(x_0)=0\quad l_0(x_1)=0\quad
l_2(x_2)=1\end{array}\right.\)</span> ，可解得 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
l_0(x)=\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}\\\displaystyle
l_1(x)=\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}\\\displaystyle
l_2(x)=\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\end{array}\right.\)</span>
，称为<strong>二次插值基函数</strong>。<br />
得到 <span class="math inline">\(\displaystyle
L_2(x)=y_0\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}+y_1\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}+y_2\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\)</span>
。</p>
<h5 id="mathbf-n-次插值"><span class="math inline">\(\mathbf n\)</span>
次插值</h5>
<p>推广到一般形式：考虑已知 <span class="math inline">\(n+1\)</span>
个点 <span class="math inline">\((x_i,y_i)(i=0,1,2,\dots,n)\)</span>
，构造插值多项式 <span class="math inline">\(L_n(x)\)</span> 。<br />
设 <span class="math inline">\(\displaystyle
L_n(x)=\sum_{i=0}^{n}y_il_i(x)\)</span> ，则 <span
class="math inline">\(l_i(x_j)=\left\{\begin{array}{l}1,\ j=i\\0,\ j\neq
i\end{array}\right.\ i,j=0,1,\dots,n\)</span> ，解得 <span
class="math inline">\(\displaystyle l_i(x)=\prod_{j=0,j\neq
i}^{n}\frac{x-x_j}{x_i-x_j}\)</span> 。 &gt; 引入记号： <span
class="math inline">\(\displaystyle
\omega_{n+1}(x)=\prod_{i=0}^{n}(x-x_i)\)</span> 则有： <span
class="math display">\[
\begin{aligned}L_n&amp;=\displaystyle\sum_{i=0}^n\left(\prod_{j=0,j\neq
i}^n\frac{x-x_j}{x_i-x_j}\right)y_i\\
&amp;=\displaystyle\sum_{i=0}^n\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}y_i\end{aligned}
\]</span> 称这两式为 <span class="math inline">\(\mathbf n\)</span>
<strong>次插值多项式</strong>，也称为<strong>Lagrange插值多项式</strong>。</p>
<h5 id="lagrange插值余项">Lagrange插值余项</h5>
<p>若在 <span class="math inline">\([a,b]\)</span> 上用 <span
class="math inline">\(L_n(x)\)</span> 近似 <span
class="math inline">\(f(x)\)</span> ，则其<strong>截断误差</strong>为
<span class="math inline">\(R_n(x)=f(x)-L_n(x)\)</span>
，也称其为插值多项式的<strong>余项</strong>。</p>
<p>设 <span class="math inline">\(f^{(n)}(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上连续， <span
class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 内存在，节点 <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span> ，
<span class="math inline">\(L_n(x)\)</span> 是插值多项式，则 <span
class="math inline">\(\forall x\in [a,b],\
R_n=\displaystyle\frac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)\)</span>
，其中 <span class="math inline">\(a&lt;\xi&lt;b\)</span> 且依赖于 <span
class="math inline">\(x\)</span> 。</p>
<p>插值多项式 <span class="math inline">\(L_n(x)\)</span> 逼近 <span
class="math inline">\(f(x)\)</span> 的截断误差限为 <span
class="math inline">\(\left|R_n(x)\right|\le\displaystyle\frac{\max_{a&lt;x&lt;b}\left|f^{(n+1)}(x)\right|}{(n+1)!\left|\omega_{n+1}(x)\right|}\)</span>
。</p>
<p>当被插值函数未知时，无法用上述插值余项估计误差。</p>
<h5 id="事后误差估计">事后误差估计</h5>
<p>求 <span class="math inline">\(L_n(x)\)</span> 为 <span
class="math inline">\(f(x)\)</span> 以 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span> 为节点的 <span
class="math inline">\(n\)</span> 次插值多项式；<br />
求 <span class="math inline">\(L_n^{(1)}(x)\)</span> 为 <span
class="math inline">\(f(x)\)</span> 以 <span
class="math inline">\(x_1,x_2,\dots,x_n,x_{n+1}\)</span> 为节点的 <span
class="math inline">\(n\)</span> 次插值多项式；<br />
认为两者较 <span class="math inline">\(f(x)\)</span> 误差相近，则有：
<span class="math display">\[
\begin{array}{c}
\displaystyle\frac{f(x)-L_n(x)}{f(x)-L_n^{(1)}}\approx\frac{x-x_0}{x-x_{n+1}}\\
\displaystyle
f(x)\approx\frac{x-x_{n+1}}{x_0-x_{n+1}}L_n(x)+\frac{x-x_0}{x_{n+1}-x_0}L_n^{(1)}(x)\\
\displaystyle
f(x)-L_n(x)\approx\frac{x-x_0}{x_0-x_{n+1}}(L_n(x)-L_n^{(1)}(x))
\end{array}
\]</span></p>
<p>则第三式可用于事后误差估计，第二式可用于较精确的插值多项式。</p>
<h3 id="差商与newton插值">5.4 - 5.5 差商与Newton插值</h3>
<blockquote>
<h4 id="差商或称均差">差商（或称均差）</h4>
<p><strong>定义</strong>：</p>
<ul>
<li>称 <span
class="math inline">\(f[x_0,x_k]=\displaystyle\frac{f(x_k)-f(x_0)}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的一阶差商；</li>
<li>称 <span
class="math inline">\(f[x_0,x_1,x_k]=\displaystyle\frac{f[x_1,x_k]-f[x_0,x_1]}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的二阶差商；</li>
<li>称 <span
class="math inline">\(f[x_0,x_1,\dots,x_k]=\displaystyle\frac{f[x_1,\dots,x_{k-1},x_{k}]-f[x_0,x_1,\dots,x_{k-1}]}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的 <span
class="math inline">\(k\)</span> 阶差商。</li>
</ul>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(\displaystyle
f[x_0,\dots,x_k]=\sum_{j=0}^k\frac{f(x_j)}{(x_j-x_0)\cdots(x_j-x_{j-1})(x_j-x_{j+1})\cdots(x_j-x_k)}=\sum_{j=0}^k\frac{f(x_j)}{\omega_{k+1}(x_j)}\)</span></li>
<li>差商与节点的排列次序无关；</li>
<li>若 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上存在 <span
class="math inline">\(n\)</span>
阶导数，且差商节点位于区间内，则：<br />
<span
class="math inline">\(f[x_0,\dots,x_n]=\displaystyle\frac{f^{(n)}(\xi)}{n!},\quad\xi\in[a,b]\)</span>
。</li>
</ul>
</blockquote>
<h4 id="newton插值">Newton插值</h4>
<ul>
<li><p>由直线方程点斜式得到线性插值函数： <span class="math display">\[
L_1(x)=y_0+a_1(x-x_0),\quad a_1=\frac{y_1-y_0}{x_1-x_0}
\]</span></p></li>
<li><p>推广至三点情况得到二次插值函数： <span class="math display">\[
\begin{array}{c}
L_2(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)\\
\left\{\begin{array}{l}
a_0=y_0\\
a_1=\displaystyle\frac{y_1-y_0}{x_1-x_0}\\
a_2=\displaystyle\frac{\displaystyle\frac{y_2-y_0}{x_2-x_0}-\frac{y_1-y_0}{x_1-x_0}}{x_2-x_1}
\end{array}\right.
\end{array}
\]</span></p></li>
<li><p>推广至 <span class="math inline">\(n+1\)</span> 点情况得到 <span
class="math inline">\(n+1\)</span> 次插值函数： <span
class="math display">\[
\begin{aligned}
L_n(x)&amp;=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+\dots+a_n(x-x_0)\dots(x-x_{n-1})\\
&amp;=\displaystyle\sum_{i=0}^{n}\left[a_i\left(\prod_{j=0}^{i-1}(x-x_j)\right)\right]\end{aligned}
\]</span> 由前面的推导和差商的定义可知 <span
class="math inline">\(a_i=f[x_0,x_1,\dots,x_i]\)</span>
；或进行如下推导： <span class="math display">\[
\begin{aligned}
&amp;\quad\left\{\begin{array}{l}
f(x)=f(x_0)+f[x,x_0](x-x_0)\\
f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1])(x-x_1)\\
f[x,x_0,\dots,x_{n-1}]=f[x_0,x_1,\dots,x_n]+f[x,x_0,\dots,x_n]\end{array}\right.\\
&amp;\begin{aligned}\Rightarrow\
f(x)&amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\
&amp;+\dots+f[x_0,x_1,\dots,x_n](x-x_0)\cdots(x-x_{n-1})+f[x,x_0,\dots,x_n]\omega_{n+1}(x)\\
&amp;\equiv N_n(x) + R_n(x)\\\end{aligned}\\
&amp;\begin{aligned}
N_n(x)&amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\
&amp;+\dots+f[x_0,x_1,\dots,x_n](x-x_0)\cdots(x-x_{n-1})\\
R_n(x)&amp;=f[x,x_0,\dots,x_n]\omega_{n+1}(x)
\end{aligned}\end{aligned}
\]</span> 其中 <span class="math inline">\(N_n(x)\)</span>
就称作<strong>Newton插值多项式</strong>，其与Lagrange插值多项式是等价的。
<span class="math inline">\(R_n(x)\)</span>
为Newton插值多项式的余项，它比Lagrange插值多项式的余项更具有一般性，对于离散函数
<span class="math inline">\(f\)</span> 或 <span
class="math inline">\(f\)</span> 导数不存在时均适用。</p>
<blockquote>
<p>Lagrange插值多项式的缺陷：当节点发生改变时，所有计算需要重新计算。</p>
</blockquote></li>
</ul>
<h3 id="代码lagrange插值">代码：Lagrange插值</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-05.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> L<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> sqrt_xy <span class="op">{{</span><span class="dv">100</span><span class="op">,</span> <span class="dv">10</span><span class="op">},</span> <span class="op">{</span><span class="dv">121</span><span class="op">,</span> <span class="dv">11</span><span class="op">},</span> <span class="op">{</span><span class="dv">144</span><span class="op">,</span> <span class="dv">12</span><span class="op">}};</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> L<span class="op">(</span>sqrt_xy<span class="op">,</span> <span class="dv">120</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> L<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> prod <span class="op">*=</span> <span class="op">(</span>x<span class="op">-</span>xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="op">/</span> <span class="op">(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> prod  <span class="op">*</span> xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="代码newton插值含生成差商表">代码：Newton插值（含生成差商表）</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-05.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> DD<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshDD<span class="op">();</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printDD<span class="op">();</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> N<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> sqrt_xy <span class="op">{{-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">},</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">17</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">21</span><span class="op">}};</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> N<span class="op">(</span>sqrt_xy<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">//获取Divided Difference 差商表</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshDD<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> tmp<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> DD<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">)</span> tmp<span class="op">.</span>push_back<span class="op">((</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> tmp<span class="op">.</span>push_back<span class="op">((</span>DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>tmp<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">-</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            DD<span class="op">.</span>push_back<span class="op">(</span>tmp<span class="op">);</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            tmp<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> DD<span class="op">.</span>size<span class="op">()+</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">)</span> tmp<span class="op">.</span>push_back<span class="op">((</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                tmp<span class="op">.</span>push_back<span class="op">((</span>DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>tmp<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">-</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        DD<span class="op">.</span>push_back<span class="op">(</span>tmp<span class="op">);</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        tmp<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    printDD<span class="op">();</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printDD<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&lt;</span> DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&lt;</span> DD<span class="op">.</span>back<span class="op">().</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> DD<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> DD<span class="op">[</span>i<span class="op">].</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DD<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> N<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> <span class="va">xy_array_</span><span class="op">,</span> <span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    xy_array<span class="op">.</span>assign<span class="op">(</span><span class="va">xy_array_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">xy_array_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    refreshDD<span class="op">();</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sum <span class="op">=</span> xy_array<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span> <span class="dt">double</span> prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> prod <span class="op">*=</span> x <span class="op">-</span> xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">].</span>back<span class="op">()</span> <span class="op">*</span> prod<span class="op">;</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-04-数值分析-Day07-Newton迭代法</title>
      <link>http://localhost:1313/posts/2021-03-04-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day07-newton%E8%BF%AD%E4%BB%A3%E6%B3%95/</link>
      <pubDate>Thu, 04 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-04-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day07-newton%E8%BF%AD%E4%BB%A3%E6%B3%95/</guid>
      <description>4.11 - 15 牛顿迭代法 Newton迭代法 泰勒级数： \(\displaystyle f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(a)}{n!}(x-a)^n\)
泰勒展开公式： \(\displaystyle f(x)=\sum_{n=0}^n\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\)
皮亚诺型余项： \(R_n(x)=o[(x-a)^n]\) ，即当 \(x\to a\) 时，余项为 \((x-a)^n\) 的高阶无穷小 拉格朗日型余项： \(R_n(x)=\displaystyle\frac{f^{(n+1)}(\theta)}{(n+1)!}(x-a)^{(n+1)},\ \theta\in(a,x)\)
积分型余项： \(R_{n}(x)=\displaystyle\int_{a}^{x}{\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\,dt\) 原理：将非线性方程线性化——Taylor展开
取 \(x_0\) 作为初始近似值，将 \(f(x)\) 在 \(x_0\) 处做一阶Taylor展开： \[ \begin{array}{c}f(x)=f(x_0)+f&amp;#39;(x_0)(x-x_0)+\displaystyle{f&amp;#39;&amp;#39;(\xi)}{2!}(x-x_0)^2,\quad \xi\in(x_0,x)\\ 0=f(x^*)\approx f(x_0)+f&amp;#39;(x_0)(x-x_0)\quad\Rightarrow\quad x^*\approx x_0-\displaystyle\frac{f(x_0)}{f&amp;#39;(x_0)}\\ \left\{\begin{array}{l}x_1=x_0-\displaystyle\frac{f(x_0)}{f&amp;#39;(x_0)}\\ x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f&amp;#39;(x_k)}\quad\leftarrow\ \textbf{Newton迭代公式}\end{array}\right.\end{array} \]
Newton迭代法的收敛性 定理：设 \(f\in C^2[a,b]\) （二阶连续可微），若 \(x^*\) 为 \(f(x)=0\) 在 \([a,b]\) 上的根，且 \(f&amp;#39;(x^*)\neq0\) ，则Newton迭代法是二阶收敛的，且有 \(\displaystyle\lim_{k\to\infty}\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\frac{f&amp;#39;&amp;#39;(x^*)}{2f&amp;#39;(x^*)}\) 。
初值的选取：令 \(c=\displaystyle\frac{\max|f&amp;#39;&amp;#39;(x)|}{2\min|f&amp;#39;(x)|}\) ，则有： \[ c|x_{k+1}-x^*|\le(c|x_{k}-x^*|)^2\le(c|x_{k-1}-x^*|)^4\le\dots\le\le(c|x_{k+1}-x^*|)^{2^{k+1}} \] 因此， \(c|x_0-x^*|=1\ \Rightarrow\ |x_0-x^*|\le\displaystyle\frac{2\min|f&amp;#39;(x)|}{\max|f&amp;#39;&amp;#39;(x)|}\) 时，Newton迭代法收敛。
Newton下山法 调整 \(x_0\) 的选取来使得Newton迭代法满足收敛条件。</description>
      <content:encoded><![CDATA[<h3 id="牛顿迭代法">4.11 - 15 牛顿迭代法</h3>
<h4 id="newton迭代法">Newton迭代法</h4>
<blockquote>
<p>泰勒级数： <span class="math inline">\(\displaystyle
f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span></p>
<p>泰勒展开公式： <span class="math inline">\(\displaystyle
f(x)=\sum_{n=0}^n\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\)</span></p>
<ul>
<li>皮亚诺型余项： <span
class="math inline">\(R_n(x)=o[(x-a)^n]\)</span> ，即当 <span
class="math inline">\(x\to a\)</span> 时，余项为 <span
class="math inline">\((x-a)^n\)</span> 的高阶无穷小</li>
<li>拉格朗日型余项： <span
class="math inline">\(R_n(x)=\displaystyle\frac{f^{(n+1)}(\theta)}{(n+1)!}(x-a)^{(n+1)},\
\theta\in(a,x)\)</span><br />
</li>
<li>积分型余项： <span
class="math inline">\(R_{n}(x)=\displaystyle\int_{a}^{x}{\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\,dt\)</span></li>
</ul>
</blockquote>
<p><strong>原理</strong>：将非线性方程线性化——Taylor展开</p>
<p>取 <span class="math inline">\(x_0\)</span> 作为初始近似值，将 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 处做一阶Taylor展开： <span
class="math display">\[
\begin{array}{c}f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\displaystyle{f&#39;&#39;(\xi)}{2!}(x-x_0)^2,\quad
\xi\in(x_0,x)\\
0=f(x^*)\approx f(x_0)+f&#39;(x_0)(x-x_0)\quad\Rightarrow\quad
x^*\approx x_0-\displaystyle\frac{f(x_0)}{f&#39;(x_0)}\\
\left\{\begin{array}{l}x_1=x_0-\displaystyle\frac{f(x_0)}{f&#39;(x_0)}\\
x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f&#39;(x_k)}\quad\leftarrow\
\textbf{Newton迭代公式}\end{array}\right.\end{array}
\]</span></p>
<h4 id="newton迭代法的收敛性">Newton迭代法的收敛性</h4>
<p><strong>定理</strong>：设 <span class="math inline">\(f\in
C^2[a,b]\)</span> （二阶连续可微），若 <span
class="math inline">\(x^*\)</span> 为 <span
class="math inline">\(f(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上的根，且 <span
class="math inline">\(f&#39;(x^*)\neq0\)</span>
，则Newton迭代法是二阶收敛的，且有 <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\frac{f&#39;&#39;(x^*)}{2f&#39;(x^*)}\)</span>
。</p>
<p><strong>初值的选取</strong>：令 <span
class="math inline">\(c=\displaystyle\frac{\max|f&#39;&#39;(x)|}{2\min|f&#39;(x)|}\)</span>
，则有： <span class="math display">\[
c|x_{k+1}-x^*|\le(c|x_{k}-x^*|)^2\le(c|x_{k-1}-x^*|)^4\le\dots\le\le(c|x_{k+1}-x^*|)^{2^{k+1}}
\]</span> 因此， <span class="math inline">\(c|x_0-x^*|=1\ \Rightarrow\
|x_0-x^*|\le\displaystyle\frac{2\min|f&#39;(x)|}{\max|f&#39;&#39;(x)|}\)</span>
时，Newton迭代法收敛。</p>
<h4 id="newton下山法">Newton下山法</h4>
<p>调整 <span class="math inline">\(x_0\)</span>
的选取来使得Newton迭代法满足收敛条件。</p>
<p><strong>定义</strong>：对Newton迭代过程附加单调性要求： <span
class="math inline">\(|f(x_{k+1})|&lt;|x_k|\)</span>
，满足该条件的Newton迭代法称为<strong>Newton下山法</strong>。</p>
<p><strong>实现</strong>：若由 <span class="math inline">\(x_k\)</span>
得到的 <span class="math inline">\(x_{k+1}\)</span> 不能使得 <span
class="math inline">\(|f|\)</span> 减小，则在 <span
class="math inline">\(x_k\)</span> 和 <span
class="math inline">\(x_{k+1}\)</span> 之间找点 <span
class="math inline">\(\overline{x_{k+1}}\)</span> ，使得 <span
class="math inline">\(|f(\overline{x_{k+1}})|&lt;|f(x_k)|\)</span> ，
<span class="math display">\[
\begin{aligned}\overline{x_{k+1}}&amp;=\lambda x_{k+1}+(1-\lambda)x_k\\
&amp;=\lambda[x_k-\frac{f(x_k)}{f&#39;(x_k)}]+(1-\lambda)x_k\\
&amp;=x_k-\lambda\frac{f(x_k)}{f&#39;(x_k)}\end{aligned}
\]</span> 其中， <span class="math inline">\(\lambda=1\)</span>
时即Newton迭代法，当 <span class="math inline">\(\lambda=1\)</span>
效果不好时，将 <span class="math inline">\(\lambda\)</span>
减半计算。</p>
<h4 id="newton迭代法的变形">Newton迭代法的变形</h4>
<p>Newton下山法中计算每次迭代都需要计算一阶导数，试图简化计算。</p>
<h5 id="简化newton迭代法">简化Newton迭代法</h5>
<p>采用迭代格式： <span
class="math inline">\(x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{M},\
k=0,1,2,\dots\)</span> ，即用常数来代替一阶导，通常取 <span
class="math inline">\(M=f&#39;(x_0)\)</span>
。一般，简化Newton迭代法只具有线性收敛。</p>
<h5 id="割线法">割线法</h5>
<p>采用迭代格式： <span
class="math inline">\(x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f(x_k)-f(x_{k-1})}\
k=0,1,2,3,\dots\)</span> ，需要取两个初值 <span
class="math inline">\(x_0,x_1\)</span> 。收敛阶 <span
class="math inline">\(p\approx1.618\)</span> 。</p>
<h4 id="求重根的newton迭代法">求重根的Newton迭代法</h4>
<blockquote>
<p><strong>重根</strong>：称 <span class="math inline">\(x^*\)</span>
为方程 <span class="math inline">\(f(x)=0\)</span> 的 <span
class="math inline">\(m\)</span> 重根时，是指 <span
class="math inline">\(f(x)=(x-x^*)^mh(x)\)</span> ，其中 <span
class="math inline">\(h(x)\)</span> 在 <span
class="math inline">\(x=x^*\)</span> 处连续且 <span
class="math inline">\(h(x^*)\neq0\)</span> ，若 <span
class="math inline">\(h(x)\)</span> 在 <span
class="math inline">\(x^*\)</span> 处充分可微，则 <span
class="math inline">\(f(x^*)=f&#39;(x^*)=\dots=f^{(m-1)}(x^*)=0,\
f^{(m)}(x^*)\neq0\)</span> 。</p>
</blockquote>
<p>由于 <span
class="math inline">\([f(x)]^{\frac{1}{m}}=(x-x^*)[h(x)]^{\frac{1}{m}}\)</span>
，知 <span class="math inline">\(x^*\)</span> 恰是方程 <span
class="math inline">\([f(x)]^{\frac{1}{m}}\)</span>
的单根。应用Newton迭代法对该方程求解，得到： <span
class="math display">\[
\begin{aligned}x_{k+1}&amp;=x_k-\frac{[f(x_k)]^{\frac{1}{m}}}{\frac{1}{m}[f(x_k)]^{\frac{1}{m}-1}f&#39;(x_k)}\\
&amp;=x_k-m\frac{f(x_k)}{f&#39;(x_k)},\quad k=0,1,2,\dots\end{aligned}
\]</span> 也称之为<strong>带参数的Newton迭代法</strong>，求方程 <span
class="math inline">\(f(x)=0\)</span> 的 <span
class="math inline">\(m\)</span> 重根时具有平方收敛。</p>
<p>当 <span class="math inline">\(m\)</span> 未知时：</p>
<p>根据函数 <span class="math inline">\(\displaystyle
u(x)=\frac{f(x)}{f&#39;(x)}=\frac{(x-x^*)h(x)}{mh(x)+(x-x^*)h&#39;(x)}\)</span>
，可见 <span class="math inline">\(x^*\)</span> 恰是方程 <span
class="math inline">\(u(x)\)</span> 的单根。对之应用Newton迭代法有：
<span class="math display">\[
x_{k+1}=x_k-\frac{u(x_k)}{u&#39;(x_k)}=x_k-\frac{f(x_k)f&#39;(x_k)}{[f&#39;(x_k)]^2-f(x_k)f&#39;&#39;(x_k)},\quad
k=0,1,2,\dots
\]</span> 在该迭代过程中，不需要知道根的重数，具有平方收敛。</p>
<h3 id="代码newton迭代法三种">代码：Newton迭代法（三种）</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-04.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">//已知一阶导函数求单根</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">//已知二阶导函数求重根（重数任意）</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_2<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">//未知导函数，有二初值，利用割线法求单根</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">,</span> <span class="dt">double</span> x_1<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pow<span class="op">(</span>x<span class="op">,</span><span class="dv">4</span><span class="op">)</span> <span class="op">-</span> <span class="fl">8.6</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">-</span> <span class="fl">35.51</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="fl">464.4</span><span class="op">*</span>x <span class="op">-</span> <span class="fl">998.46</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f_1 <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">4</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">-</span> <span class="dv">3</span><span class="op">*</span><span class="fl">8.6</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="fl">35.51</span><span class="op">*</span>x <span class="op">+</span> <span class="fl">464.4</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f_2 <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span><span class="op">*</span><span class="dv">4</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="fl">8.6</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="fl">35.51</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> f_1<span class="op">,</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> f_1<span class="op">,</span> f_2<span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> next_x<span class="op">;</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_2<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_2_x <span class="op">=</span> f_2<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> next_x<span class="op">;</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span> f_2_x<span class="op">=</span>f_2<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;OK&quot;</span><span class="op">;</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">,</span> <span class="dt">double</span> x_1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> pre_x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_pre_x <span class="op">=</span> f<span class="op">(</span>pre_x<span class="op">);</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_1<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">g_x</span> <span class="op">=</span> f_x <span class="op">-</span> f_pre_x<span class="op">;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        pre_x <span class="op">=</span> x<span class="op">;</span> x <span class="op">=</span> next_x<span class="op">;</span> f_pre_x <span class="op">=</span> f<span class="op">(</span>pre_x<span class="op">);</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="va">g_x</span> <span class="op">=</span> f_x <span class="op">-</span> f_pre_x<span class="op">;</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-03-数值分析-Day06-非线性方程的迭代解法及收敛性</title>
      <link>http://localhost:1313/posts/2021-03-03-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day06-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95%E5%8F%8A%E6%94%B6%E6%95%9B%E6%80%A7/</link>
      <pubDate>Wed, 03 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-03-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day06-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95%E5%8F%8A%E6%94%B6%E6%95%9B%E6%80%A7/</guid>
      <description>4.1-3 非线性方程简介及二分法：略 4.4 - 10 简单迭代法的构造与收敛性 构造简单迭代法 \[ \begin{array}{c}\begin{aligned} f(x)=0\quad&amp;amp;\Leftrightarrow\quad x=\varphi(x)\\ f(x)的根\quad&amp;amp;\Leftrightarrow\quad\varphi(x)的不动点 \end{aligned}\end{array} \]
其中 \(x_{k+1}=\varphi(x_k),\quad (k=0,1,2,\dots)\) 称为迭代格式， \(\varphi(x)\) 称为迭代函数。
简单迭代法的收敛条件 几何解释：求方程 \(x=\varphi(x)\) 的根，就是求直线 \(y=x\) 和曲线 \(y=\varphi(x)\) 的交点的横坐标。（图略。）
如果 \(x_{k+1}=\varphi(x_k)\) 收敛，则迭代函数 \(y=\varphi(x)\) 的曲线走势平坦，即 \(\left|\varphi&amp;#39;(x)\right|&amp;lt;1\) ；
如果 \(x_{k+1}=\varphi(x_k)\) 发散，则迭代函数 \(y=\varphi(x)\) 的曲线走势陡峭，即 \(\left|\varphi&amp;#39;(x)\right|\ge1\) ；
迭代法收敛的判定定理：设函数 \(\varphi(x)\) 满足条件： \[ \begin{array}{l}(1)\quad \forall x\in[a,b],\ a\le\varphi(x)\le b;\\ (2)\quad \exists0\le L&amp;lt;1,\ \begin{array}{l}\forall x,y\in[a,b],\ |\varphi(x)-\varphi(y)|\le L|x-y|\\或\ |\varphi&amp;#39;(x)\le L&amp;lt;1|\end{array}\end{array} \]
则 \(\forall x_0\in[a,b]\) ，由 \(x_{k+1}=\varphi(x_K)\) 得到的序列 \(\{x_k\}_{k=0}^\infty\) 收敛于 \(\varphi(x)\) 在 \([a,b]\) 上的唯一不动点。并且由误差估计式： \(\begin{array}{l}\displaystyle\left|x^*-x_k\right|\le\frac{1}{1-L}\left|x_k-x_{k-1}\right|\\\displaystyle\left|x^*-x_k\right|\le\frac{L^k}{1-L}\left|x_1-x_0\right|\end{array}\) 。由第一式分析误差；由第二式得到结论 \(L\) 越小，收敛越快 。</description>
      <content:encoded><![CDATA[<h3 id="非线性方程简介及二分法略">4.1-3 非线性方程简介及二分法：略</h3>
<h3 id="简单迭代法的构造与收敛性">4.4 - 10 简单迭代法的构造与收敛性</h3>
<h4 id="构造简单迭代法">构造简单迭代法</h4>
<p><span class="math display">\[
\begin{array}{c}\begin{aligned}
f(x)=0\quad&amp;\Leftrightarrow\quad x=\varphi(x)\\
f(x)的根\quad&amp;\Leftrightarrow\quad\varphi(x)的不动点
\end{aligned}\end{array}
\]</span></p>
<p>其中 <span class="math inline">\(x_{k+1}=\varphi(x_k),\quad
(k=0,1,2,\dots)\)</span> 称为<strong>迭代格式</strong>， <span
class="math inline">\(\varphi(x)\)</span>
称为<strong>迭代函数</strong>。</p>
<h4 id="简单迭代法的收敛条件">简单迭代法的收敛条件</h4>
<p><strong>几何解释</strong>：求方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的根，就是求直线 <span
class="math inline">\(y=x\)</span> 和曲线 <span
class="math inline">\(y=\varphi(x)\)</span>
的交点的横坐标。（图略。）</p>
<p>如果 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
收敛，则迭代函数 <span class="math inline">\(y=\varphi(x)\)</span>
的曲线走势平坦，即 <span
class="math inline">\(\left|\varphi&#39;(x)\right|&lt;1\)</span>
；<br />
如果 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
发散，则迭代函数 <span class="math inline">\(y=\varphi(x)\)</span>
的曲线走势陡峭，即 <span
class="math inline">\(\left|\varphi&#39;(x)\right|\ge1\)</span> ；</p>
<p><strong>迭代法收敛的判定定理</strong>：设函数 <span
class="math inline">\(\varphi(x)\)</span> 满足条件： <span
class="math display">\[
\begin{array}{l}(1)\quad \forall x\in[a,b],\ a\le\varphi(x)\le b;\\
(2)\quad \exists0\le L&lt;1,\ \begin{array}{l}\forall x,y\in[a,b],\
|\varphi(x)-\varphi(y)|\le L|x-y|\\或\ |\varphi&#39;(x)\le
L&lt;1|\end{array}\end{array}
\]</span></p>
<p>则 <span class="math inline">\(\forall x_0\in[a,b]\)</span> ，由
<span class="math inline">\(x_{k+1}=\varphi(x_K)\)</span> 得到的序列
<span class="math inline">\(\{x_k\}_{k=0}^\infty\)</span> 收敛于 <span
class="math inline">\(\varphi(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上的唯一不动点。并且由误差估计式：
<span
class="math inline">\(\begin{array}{l}\displaystyle\left|x^*-x_k\right|\le\frac{1}{1-L}\left|x_k-x_{k-1}\right|\\\displaystyle\left|x^*-x_k\right|\le\frac{L^k}{1-L}\left|x_1-x_0\right|\end{array}\)</span>
。由第一式分析误差；由第二式得到结论 <span
class="math inline">\(L\)</span> 越小，收敛越快 。</p>
<h4 id="局部收敛性">局部收敛性</h4>
<p><strong>定义</strong>：若存在 <span
class="math inline">\(x^*\)</span> 的某个邻域 <span
class="math inline">\(S=\{|x-x^*|\le\delta\}\subset[a,b]\)</span>
，使迭代过程 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
对于任一初值 <span class="math inline">\(x_0\in S\)</span>
均收敛则称迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在根 <span
class="math inline">\(x^*\)</span>
邻近具有<strong>局部收敛性</strong>。</p>
<p><strong>判定定理</strong>： <span
class="math inline">\(\varphi(x)\)</span> 在方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的精确根 <span
class="math inline">\(x^*\)</span> 的邻域连续，且 <span
class="math inline">\(|\varphi&#39;(x^*)|&lt;1\)</span> ，则迭代过程
<span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在根 <span
class="math inline">\(x^*\)</span> 的邻域具有局部收敛性。</p>
<p>不严格的准则：只要在一个不大的有根区间上， <span
class="math inline">\(|\varphi&#39;(x)|&lt;1\)</span>
明显成立，则从该区间内一点 <span class="math inline">\(x_0\)</span>
出发， <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
产生的迭代序列 <span class="math inline">\(\{x_k\}\)</span>
一般是收敛的。</p>
<h4 id="收敛阶描述收敛速度">收敛阶（描述收敛速度）</h4>
<p>观察得到， <span class="math inline">\(|\varphi&#39;(x)|\)</span>
越小，收敛速度越快，越大越慢。</p>
<p><strong>定义</strong>：记迭代误差 <span
class="math inline">\(e_k=x^*-x_k\)</span> ，对收敛于方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的根 <span
class="math inline">\(x^*\)</span> 的迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> ，若存在常数 <span
class="math inline">\(p\ge1\)</span> 和非零常数 <span
class="math inline">\(C\)</span> ，使得 <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{|e_{k+1}|}{|e_k|^p}=C\)</span>
，则称迭代过程是 <span class="math inline">\(\mathbf{p}\)</span>
<strong>阶收敛</strong>的， <span class="math inline">\(C\)</span>
是<strong>渐进误差常数</strong>。<br />
其中， <span class="math inline">\(p=1\)</span>
时称<strong>线性收敛</strong>， <span
class="math inline">\(p&gt;1\)</span> 时称<strong>超线性收敛</strong>，
<span class="math inline">\(p=2\)</span> 时称<strong>平方收敛</strong>。
<span class="math inline">\(p\)</span> 越大，收敛速度越快。</p>
<p><strong>定理</strong>：若 <span
class="math inline">\(\varphi&#39;(x)\)</span> 在 <span
class="math inline">\(\varphi(x)\)</span> 的不动点 <span
class="math inline">\(x^*\)</span> 邻域连续，且 <span
class="math inline">\(\varphi&#39;(x)\neq0\)</span> ，则迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在 <span
class="math inline">\(x^*\)</span> 的邻域是线性收敛的。</p>
<h4 id="mathbfp-阶收敛的迭代法"><span
class="math inline">\(\mathbf{p}\)</span> 阶收敛的迭代法</h4>
<p><strong>定理</strong>：若 <span class="math inline">\(x^*\)</span> 是
<span class="math inline">\(\varphi(x)\)</span> 的不动点，对于整数 <span
class="math inline">\(p&gt;1\)</span> ，迭代函数 <span
class="math inline">\(\varphi(x)\)</span> 及其 <span
class="math inline">\(p\)</span> 阶导数在 <span
class="math inline">\(x^*\)</span> 的邻域上连续，且满足： <span
class="math inline">\(\varphi&#39;(x^*)=\varphi&#39;&#39;(x^*)=\dots=\varphi^{(p-1)}(x^*)=0,\quad
\varphi^{(p)}(x^*)\neq0\)</span> ，则迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在 <span
class="math inline">\(x^*\)</span> 的邻域是 <span
class="math inline">\(p\)</span> 阶收敛的。且有： <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{e_{k+1}}{e_k^p}=\frac{\varphi^{(p)}(x^*)}{p!}\)</span>
。</p>
<p>因此， <span class="math inline">\(\varphi&#39;(x^*)\neq0\)</span>
时，迭代过程只可能是线性的，因此绝大部分迭代方法只能是线性收敛的。</p>
<h4 id="aitken加速算法">Aitken加速算法</h4>
<p>由于 <span
class="math inline">\(\begin{array}{l}x_{k+1}-x^*=\varphi&#39;(\xi_1)(x_k-x^*)\\x_{k+2}-x^*=\varphi&#39;(\xi_2)(x_{k+1}-x^*)\end{array}\)</span>
，当 <span class="math inline">\(k\)</span> 较大时，假设 <span
class="math inline">\(\varphi&#39;(\xi_1)\approx\varphi&#39;(\xi_2)\)</span>
，则有： <span
class="math inline">\(\displaystyle\frac{x_{k+1}-x^*}{x_{k+2}-x^*}\approx\frac{x_k-x^*}{x_{k+1}-x^*}\)</span>
。然后解得 <span class="math inline">\(x^*\approx \hat
x_k=x_k-\displaystyle\frac{(x_{k+1}-x_k)^2}{x_{k+2}-2x_{k+1}+x_k}\)</span>
。</p>
<p>则序列 <span class="math inline">\(\{\hat x_k\}\)</span> 比序列 <span
class="math inline">\(\{x_k\}\)</span> 更快地收敛于 <span
class="math inline">\(x^*\)</span>
，可构造如下<strong>Aitken加速算法</strong>： <span
class="math display">\[
\left\{\begin{array}{l}
y_k=\varphi(x_k)\\
z_k=\varphi(y_k)\\
x_{k+1}=x_k-\displaystyle\frac{(y_k-x_k)^2}{z_k-2y_k+x_k},
\quad k=0,1,2,\dots
\end{array}\right.
\]</span> 若第 <span class="math inline">\(k\)</span> 步发生 <span
class="math inline">\(z_k-2y_k+x_k=0\)</span> ，则中止计算，取 <span
class="math inline">\(x^*\approx x_k\)</span> 。</p>
<h3 id="代码二分法">代码：二分法</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-03.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> f<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> solve<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="dt">double</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">&amp;</span>b<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> solve<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;The solve in [1, 2] is : x = &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> f<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> x <span class="op">-</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> solve<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>f<span class="op">(</span>a<span class="op">)</span> <span class="op">*</span> f<span class="op">(</span>b<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;WRONG INTERVAL&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> epsilon <span class="op">=</span> <span class="fl">1e-5</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>a<span class="op">-</span>b<span class="op">)</span> <span class="op">&gt;=</span> epsilon<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        iterate<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="dt">double</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_a <span class="op">=</span> f<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_b <span class="op">=</span> f<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_c <span class="op">=</span> f<span class="op">((</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>f_c <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>f_a <span class="op">*</span> f_c <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> b <span class="op">=</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>f_b <span class="op">*</span> f_c <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> a <span class="op">=</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="代码简单迭代法与aitken加速算法比较">代码：简单迭代法与Aitken加速算法比较</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-03.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> phi<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_simple<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> next_x_simple<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_simple<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> simple<span class="op">();</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_aitken<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> next_x_aitken<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_aitken<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> aitken<span class="op">();</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    simple<span class="op">();</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    aitken<span class="op">();</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> phi<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.6</span> <span class="op">+</span> <span class="fl">0.99</span> <span class="op">*</span> cos<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> simple<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    x_simple <span class="op">=</span> <span class="fl">1.57</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x_simple <span class="op">=</span> next_x_simple<span class="op">,</span> <span class="op">++</span>count_simple<span class="op">,</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x_simple <span class="op">&lt;&lt;</span> <span class="st">&quot;; &quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        next_x_simple <span class="op">=</span> phi<span class="op">(</span>x_simple<span class="op">);</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x_simple <span class="op">-</span> x_simple<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1e-5</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op"> &lt;&lt;</span> <span class="st">&quot;The count is &quot;</span> <span class="op">&lt;&lt;</span> count_simple <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> aitken<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    x_aitken <span class="op">=</span> <span class="fl">1.57</span><span class="op">;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x_aitken <span class="op">=</span> next_x_aitken<span class="op">,</span> <span class="op">++</span>count_aitken<span class="op">,</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x_aitken <span class="op">&lt;&lt;</span> <span class="st">&quot;; &quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> y <span class="op">=</span> phi<span class="op">(</span>x_aitken<span class="op">);</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> z <span class="op">=</span> phi<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        next_x_aitken <span class="op">=</span> x_aitken</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> <span class="op">(</span>pow<span class="op">(</span>y <span class="op">-</span> x_aitken<span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                <span class="op">/</span> <span class="op">(</span>z <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> y <span class="op">+</span> x_aitken<span class="op">)</span> <span class="op">);</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x_aitken <span class="op">-</span> x_aitken<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1e-5</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op"> &lt;&lt;</span> <span class="st">&quot;The count is &quot;</span> <span class="op">&lt;&lt;</span> count_aitken <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-02-数值分析-Day05-SOR-迭代法收敛性</title>
      <link>http://localhost:1313/posts/2021-03-02-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day05-sor-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%94%B6%E6%95%9B%E6%80%A7/</link>
      <pubDate>Tue, 02 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-02-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day05-sor-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%94%B6%E6%95%9B%E6%80%A7/</guid>
      <description>续：3.1 - 6 迭代法 逐次超松弛迭代法（SOR迭代法） 选取分裂矩阵 \(M\) 为带参数的下三角阵： \(M=\displaystyle\frac{1}{\omega}(D-\omega L),\ B=I-M^{-1}A,\ f=M^{-1}b\) ，其中 \(w&amp;gt;0\) 为可选择的松弛因子。
构造迭代法，迭代矩阵为： \(L_\omega=I-\omega(D-\omega L)^{-1}A=(D-\omega L)^{-1}((1-\omega)D+\omega U)\) 。
则解 \(Ax=b\) 的SOR方法即为： \(\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=L_\omega x^{(k)}+f\quad(k=0,1,\dots)\end{array}\right.\\其中\begin{array}{l}L_\omega=(D-\omega L)^{-1}((1-\omega)D+\omega U),\\f=\omega(D-\omega L)^{-1}b\end{array}\end{array}\) 。
推导得： \(\begin{array}{l}(D-\omega L)x^{(k+1)}=((1-\omega)D+\omega U)x^{(k)}+\omega b\\或Dx^{(k+1)}=Dx^{(k+1)}+\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\end{array}\) 。
分量计算公式为： \(\displaystyle x_i^{(k+1)}=x_1^{(k)}+\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\) 。
可令 \(\Delta x_i=\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\) ，则 \(x_i^{(k+1)}=x_i^{(k)}+\Delta x_i\) 。
Gauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 \(\omega=1\) ）。
当 \(\omega&amp;lt;1\) 时，称为超松弛法；当 \(\omega&amp;gt;1\) 时，称为低松弛法。
计算机中，常用 \(\max\limits_{1\le i\le n}|\Delta x_i|=\max\limits_{1\le i\le n}\left|x_i^{(k+1)}-x_i^{(k)}\right|&amp;lt;\varepsilon\) 或者 \(\left\|r^{(k)}\right\|=\left\|b-Ax^{(k)}\right\|\) 作为迭代终止条件。
迭代法的收敛性 设 \(Ax=b\) ，其中 \(A\in R^{n\times n}\) 为非奇异矩阵，记 \(x^*\) 为原方程组精确解，且设有等价的方程组： \(Ax=b\Leftrightarrow x=Bx+f\) ，则 \(x^*=Bx^*+f\) 。设有一阶定常迭代法 \(x^{(k+1)}=Bx^{(k)}\) 。引进误差向量 \(\varepsilon^{(k)}=x^{(k)}\) ，得到误差向量递推公式 \(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\ \Rightarrow\ \varepsilon^{(k)}=B^k\varepsilon^{(0)}\) 。则研究问题从 \(\varepsilon^{(k)}\to0\) 转换为 \(B^k\to0\) 。</description>
      <content:encoded><![CDATA[<h3 id="续3.1---6-迭代法">续：3.1 - 6 迭代法</h3>
<h4 id="逐次超松弛迭代法sor迭代法">逐次超松弛迭代法（SOR迭代法）</h4>
<p>选取分裂矩阵 <span class="math inline">\(M\)</span>
为带参数的下三角阵： <span
class="math inline">\(M=\displaystyle\frac{1}{\omega}(D-\omega L),\
B=I-M^{-1}A,\ f=M^{-1}b\)</span> ，其中 <span
class="math inline">\(w&gt;0\)</span>
为可选择的<strong>松弛因子</strong>。</p>
<p>构造迭代法，迭代矩阵为： <span
class="math inline">\(L_\omega=I-\omega(D-\omega L)^{-1}A=(D-\omega
L)^{-1}((1-\omega)D+\omega U)\)</span> 。</p>
<p>则解 <span class="math inline">\(Ax=b\)</span> 的SOR方法即为： <span
class="math inline">\(\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=L_\omega
x^{(k)}+f\quad(k=0,1,\dots)\end{array}\right.\\其中\begin{array}{l}L_\omega=(D-\omega
L)^{-1}((1-\omega)D+\omega U),\\f=\omega(D-\omega
L)^{-1}b\end{array}\end{array}\)</span> 。</p>
<p>推导得： <span class="math inline">\(\begin{array}{l}(D-\omega
L)x^{(k+1)}=((1-\omega)D+\omega U)x^{(k)}+\omega
b\\或Dx^{(k+1)}=Dx^{(k+1)}+\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\end{array}\)</span>
。</p>
<p>分量计算公式为： <span class="math inline">\(\displaystyle
x_i^{(k+1)}=x_1^{(k)}+\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\)</span>
。</p>
<p>可令 <span class="math inline">\(\Delta
x_i=\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\)</span>
，则 <span class="math inline">\(x_i^{(k+1)}=x_i^{(k)}+\Delta
x_i\)</span> 。</p>
<p><strong>Gauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 <span
class="math inline">\(\omega=1\)</span> ）。</strong></p>
<p>当 <span class="math inline">\(\omega&lt;1\)</span>
时，称为<strong>超松弛法</strong>；当 <span
class="math inline">\(\omega&gt;1\)</span>
时，称为<strong>低松弛法</strong>。</p>
<p>计算机中，常用 <span class="math inline">\(\max\limits_{1\le i\le
n}|\Delta x_i|=\max\limits_{1\le i\le
n}\left|x_i^{(k+1)}-x_i^{(k)}\right|&lt;\varepsilon\)</span> 或者 <span
class="math inline">\(\left\|r^{(k)}\right\|=\left\|b-Ax^{(k)}\right\|\)</span>
作为迭代终止条件。</p>
<h4 id="迭代法的收敛性">迭代法的收敛性</h4>
<p>设 <span class="math inline">\(Ax=b\)</span> ，其中 <span
class="math inline">\(A\in R^{n\times n}\)</span> 为非奇异矩阵，记 <span
class="math inline">\(x^*\)</span>
为原方程组精确解，且设有等价的方程组： <span
class="math inline">\(Ax=b\Leftrightarrow x=Bx+f\)</span> ，则 <span
class="math inline">\(x^*=Bx^*+f\)</span> 。设有一阶定常迭代法 <span
class="math inline">\(x^{(k+1)}=Bx^{(k)}\)</span> 。引进误差向量 <span
class="math inline">\(\varepsilon^{(k)}=x^{(k)}\)</span>
，得到误差向量递推公式 <span
class="math inline">\(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\
\Rightarrow\ \varepsilon^{(k)}=B^k\varepsilon^{(0)}\)</span>
。则研究问题从 <span
class="math inline">\(\varepsilon^{(k)}\to0\)</span> 转换为 <span
class="math inline">\(B^k\to0\)</span> 。</p>
<p><strong>定理1</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=A\Leftrightarrow\lim\limits_{x\to\infty}\left\|A_k-A\right\|,\
\|\|为任一种算子范数\)</span></p>
<p><strong>定理2</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=A\Leftrightarrow\lim\limits_{x\to\infty}A_kx=Ax,\
x\in R^n\)</span></p>
<p><strong>定理3</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=0\Leftrightarrow\rho(A)&lt;1,\
\rho\ 谱半径\)</span></p>
<p><strong>迭代法收敛基本定理</strong>：对方程组 <span
class="math inline">\(x=Bx+f\)</span> ，及对应一阶定常迭代法 <span
class="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>
，迭代法收敛的充要条件为矩阵 <span class="math inline">\(B\)</span>
的谱半径 <span class="math inline">\(\rho(B)&lt;1\)</span> 。</p>
<p>由于 <span class="math inline">\(\rho(B)\le\|B\|\)</span> ，因此矩阵
<span class="math inline">\(B\)</span>
的范数也可用于判别迭代法的收敛性：<br />
<strong>迭代法收敛充分条件</strong>： <span
class="math inline">\(\exists \|B\|=q&lt;1\)</span> ，迭代法收敛，且有
<span
class="math inline">\(\begin{array}{l}\left\|x^*-x^{(k)}\right\|\le
q^k\left\|x^*-x^{(0)}\right\|\\\left\|x^*-x^{(k)}\right\|\le\displaystyle\frac{q}{1-q}\left\|x^k-x^{(k-1)}\right\|\\\left\|x^*-x^{(k)}\right\|\le\displaystyle\frac{q}{1-q^k}\left\|x^1-x^0\right\|\end{array}\)</span>
。根据第二式也可得到迭代法的一种终止条件参考量： <span
class="math inline">\(\left\|x^k-x^{(k-1)}\right\|\)</span> 。</p>
<h4 id="几种特殊迭代法的收敛性">几种特殊迭代法的收敛性</h4>
<blockquote>
<p>如果矩阵 <span class="math inline">\(A\)</span> 的元素满足： <span
class="math inline">\(|a_{ii}|&gt;\displaystyle\sum_{j=1,j\neq
i}^n|a_{ij}|,\ (i=1,2,\dots,n)\)</span> ，则称 <span
class="math inline">\(A\)</span> 为<strong>严格对角占优阵</strong>。</p>
<p>若 <span
class="math inline">\(|a_{ii}|\ge\displaystyle\sum_{j=1,j\neq
i}^n|a_{ij}|,\ (i=1,2,\dots,n)\)</span>
，且至少有一个不等式严格成立，则称 <span
class="math inline">\(A\)</span> 为<strong>弱对角占优阵</strong>。</p>
<p><strong>对角占优定理</strong>：若矩阵 <span
class="math inline">\(A\)</span> 为严格对角占优矩阵，则 <span
class="math inline">\(A\)</span> 为非奇异矩阵。</p>
</blockquote>
<p><strong>Jacobi和Gauss迭代法收敛的充分条件</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span>
为严格对角占优阵，则解该方程的Jacobi迭代法和Gauss-Seidel迭代法均收敛。</p>
<p><strong>SOR迭代法收敛的必要条件</strong>： <span
class="math inline">\(0&lt;\omega&lt;2\)</span> 。</p>
<p><strong>SOR迭代法收敛的充分条件1</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span> 为对称正定矩阵， <span
class="math inline">\(0&lt;\omega&lt;2\)</span>
，则解该方程的SOR迭代法收敛。</p>
<p><strong>SOR迭代法收敛的充分条件2</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span>
为严格对角占优矩阵（或弱对角占优不可约矩阵）， <span
class="math inline">\(0&lt;\omega\le1\)</span>
，则解该方程的SOR迭代法收敛。</p>
<h3 id="代码sor迭代与两种终止条件">代码：SOR迭代与两种终止条件</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">4</span><span class="op">},</span> <span class="op">{-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">17</span><span class="op">,</span> <span class="dv">10</span><span class="op">},</span> <span class="op">{-</span><span class="dv">4</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">}};</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="op">-</span><span class="dv">7</span><span class="op">};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">,</span> <span class="fl">1.46</span><span class="op">);</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span>iterate<span class="op">(</span>A_<span class="op">,</span><span class="va">b_</span><span class="op">,</span><span class="dv">1</span><span class="op">);}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>omega <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> omega <span class="op">&gt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;SOR does not converge !&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> omega <span class="op">*</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>            r <span class="op">+=</span> tmp <span class="op">*</span> tmp<span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r <span class="op">&lt;</span> <span class="fl">1e-10</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> omega <span class="op">*</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> maxDelta <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>next_x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>next_x<span class="op">)))</span> <span class="op">-</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                                   <span class="op">*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>x<span class="op">))));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> maxDelta <span class="op">&lt;&lt;</span> <span class="st">&quot; | &quot;</span><span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>maxDelta <span class="op">&lt;</span> <span class="fl">1e-3</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-01-数值分析-Day04-Jacobi-GaussSeidel</title>
      <link>http://localhost:1313/posts/2021-03-01-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day04-jacobi-gaussseidel/</link>
      <pubDate>Mon, 01 Mar 2021 20:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-03-01-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day04-jacobi-gaussseidel/</guid>
      <description>3.1 - 6 迭代法 基本思想 对线性方程组 \(Ax=b\) ，当 \(A\) 为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。
工程应用中 \(A\) 常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。
通法：
将 \(Ax=b\) 改写为 \(x=B_0x+f\) 任取初始值，如 \(x^{(0)}=(0,0,0)^T\) ，将其带入得到方程组解 \(x^{(1)}=B_0x^{(0)}+f\) 依次得： \(x^{(2)}=B_0x^{(1)}+f,\ x^{(2)}=B_0x^{(1)}+f,\ \dots,\ x^{(k)}=B_0x^{(k-1)}+f,\ \dots\) 即得向量序列 \(x^{(0)},x^{(1)},\dots,x^{(k)}\) ，迭代公式 \(x^{(k)}=B_0x^{(k-1)}+f\) 迭代次数较高时，向量序列 \(x^{(k)}\) 有可能收敛至逼近精确解的值（不一定）。 根据 \(x=Bx+f\) 变形方式的不同，存在多种迭代算法。
定义1：
对于给定方程组 \(x=Bx+f\) ，用公式 \(x^{k+1}=Bx^{(k)}+f,\ (k=0,1,2,3,\dots)\) 逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 \(B\) 与 \(k\) 无关）。
如果 \(\lim\limits_{k\to\infty}x^{(k)}=x^*\) ，即向量序列收敛至精确解序列，则称此迭代法收敛，否则称发散。
由于需要研究 \(\{x^{(k)}\}\) 的收敛性，引进误差向量 \(\varepsilon^{(k+1)}=x^{(k+1)}-x^*\) 。易得到： \(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\) ，递推得： \(\varepsilon^{(k)}=B\varepsilon^{(k-1)}=\dots=B^k\varepsilon^{(0)}\) 。
Jacobi迭代 通法细节：
将 \(A\) 分裂成 \(A=M-N\) ，其中 \(M\) 为可选择的非奇异矩阵，使 \(Mx=d\) 易解，一般选择为 \(A\) 的某种近似，称 \(M\) 为分裂矩阵。</description>
      <content:encoded><![CDATA[<h3 id="迭代法">3.1 - 6 迭代法</h3>
<h4 id="基本思想">基本思想</h4>
<p>对线性方程组 <span class="math inline">\(Ax=b\)</span> ，当 <span
class="math inline">\(A\)</span>
为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。<br />
工程应用中 <span class="math inline">\(A\)</span>
常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。</p>
<p><strong>通法</strong>：</p>
<ul>
<li>将 <span class="math inline">\(Ax=b\)</span> 改写为 <span
class="math inline">\(x=B_0x+f\)</span></li>
<li>任取初始值，如 <span
class="math inline">\(x^{(0)}=(0,0,0)^T\)</span> ，将其带入得到方程组解
<span class="math inline">\(x^{(1)}=B_0x^{(0)}+f\)</span></li>
<li>依次得： <span class="math inline">\(x^{(2)}=B_0x^{(1)}+f,\
x^{(2)}=B_0x^{(1)}+f,\ \dots,\ x^{(k)}=B_0x^{(k-1)}+f,\
\dots\)</span></li>
<li>即得向量序列 <span
class="math inline">\(x^{(0)},x^{(1)},\dots,x^{(k)}\)</span> ，迭代公式
<span class="math inline">\(x^{(k)}=B_0x^{(k-1)}+f\)</span></li>
<li>迭代次数较高时，向量序列 <span
class="math inline">\(x^{(k)}\)</span>
<strong>有可能</strong>收敛至逼近精确解的值（不一定）。</li>
</ul>
<p>根据 <span class="math inline">\(x=Bx+f\)</span>
变形方式的不同，存在多种迭代算法。</p>
<p><strong>定义1</strong>：<br />
对于给定方程组 <span class="math inline">\(x=Bx+f\)</span> ，用公式
<span class="math inline">\(x^{k+1}=Bx^{(k)}+f,\
(k=0,1,2,3,\dots)\)</span>
逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 <span
class="math inline">\(B\)</span> 与 <span
class="math inline">\(k\)</span> 无关）。<br />
如果 <span
class="math inline">\(\lim\limits_{k\to\infty}x^{(k)}=x^*\)</span>
，即向量序列<strong>收敛</strong>至精确解序列，则称此迭代法<strong>收敛</strong>，否则称<strong>发散</strong>。<br />
由于需要研究 <span class="math inline">\(\{x^{(k)}\}\)</span>
的收敛性，引进误差向量 <span
class="math inline">\(\varepsilon^{(k+1)}=x^{(k+1)}-x^*\)</span>
。易得到： <span
class="math inline">\(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\)</span>
，递推得： <span
class="math inline">\(\varepsilon^{(k)}=B\varepsilon^{(k-1)}=\dots=B^k\varepsilon^{(0)}\)</span>
。</p>
<h4 id="jacobi迭代">Jacobi迭代</h4>
<p><strong>通法细节</strong>：<br />
将 <span class="math inline">\(A\)</span> 分裂成 <span
class="math inline">\(A=M-N\)</span> ，其中 <span
class="math inline">\(M\)</span> 为可选择的非奇异矩阵，使 <span
class="math inline">\(Mx=d\)</span> 易解，一般选择为 <span
class="math inline">\(A\)</span> 的某种近似，称 <span
class="math inline">\(M\)</span> 为<strong>分裂矩阵</strong>。<br />
则原方程 <span class="math inline">\(Ax=b\)</span> 转化为 <span
class="math inline">\(Mx=Nx+b\)</span> ，即求解： <span
class="math inline">\(x=M^{-1}Nx+M^{-1}b\)</span> 。<br />
可构造一阶定常迭代法： <span class="math display">\[
\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=Bx^{(k)}+f\
(k=0,1,\dots)\end{array}\right.\\
B=M^{-1}N=M^{-1}(M-A)=I-M^{-1}A,\quad f=M^{-1}b
\]</span> 称 <span class="math inline">\(B=I-M^{-1}A\)</span>
为迭代法的迭代矩阵，选取 <span class="math inline">\(M\)</span> 阵就得到
<span class="math inline">\(Ax=b\)</span> 的各种迭代法。</p>
<p><strong>Jacobbi迭代</strong>：<br />
设 <span class="math inline">\(a_{ii}\neq0(i=1,2,\dots,n)\)</span>
，并将 <span class="math inline">\(A\)</span> 写成三部分： <span
class="math display">\[
\begin{aligned}A&amp;=\begin{pmatrix}
a_{11}\\
&amp;a_{22}\\
&amp;&amp;\ddots\\
&amp;&amp;&amp;a_{nn}
\end{pmatrix}\\
&amp;-\begin{pmatrix}
0\\
-a_{21}&amp;0\\
\vdots&amp;\vdots&amp;\ddots\\
-a_{n-1,1}&amp;-a_{n-1,2}&amp;\cdots&amp;0\\
-a_{n,1}&amp;-a_{n,2}&amp;\cdots&amp;-a_{n,n-1}&amp;0
\end{pmatrix}\\
&amp;-\begin{pmatrix}
0&amp;-a_{12}&amp;\cdots&amp;-a_{1,n-1}&amp;-a_{1,n}\\
&amp;0&amp;\cdots&amp;-a_{2,n-1}&amp;-a_{2,n}\\
&amp;&amp;\ddots&amp;\vdots&amp;\vdots\\
&amp;&amp;&amp;0&amp;-a_{n-1,n}\\
&amp;&amp;&amp;&amp;0
\end{pmatrix}\\
&amp;\equiv D-L-U
\end{aligned}
\]</span> 由此，当 <span
class="math inline">\(a_{ii}\neq0(i=1,2,\dots,n)\)</span> 时，选取 <span
class="math inline">\(M\)</span> 为 <span
class="math inline">\(A\)</span> 的对角元素部分，即选取 <span
class="math inline">\(M=D\)</span> ，<span
class="math inline">\(A=D-N\)</span> ，即得到 <span
class="math inline">\(Ax=b\)</span> 的<strong>Jacobi迭代法</strong>。
<span class="math display">\[
\begin{aligned}&amp;\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=Bx^{(k)}+f\
(k=0,1,\dots)\end{array}\right.\\
&amp;其中\ \begin{aligned}&amp;B=D^{-1}(L+U)\equiv J\\
&amp;f=D^{-1}b\end{aligned}\end{aligned}
\]</span> 称 <span class="math inline">\(J\)</span>
为Jacobi迭代法的<strong>迭代矩阵</strong>。</p>
<p><strong>Jacobi迭代法的分量计算公式</strong>： 记 <span
class="math inline">\(x^{(k)}=(x_1^{(k)},x_2^{(k)},\dots,x_n^{(k)})\)</span>
，则有： <span class="math display">\[
\begin{array}{l}
\begin{aligned}Dx^{k+1}&amp;=(L+U)x^{(k)}+b
a_{ii}x_i^{k+1}\\&amp;=-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}+b_i\quad(i=1,2,\dots,n)\end{aligned}\\
B=I-M^{-1}A,\ f=M^{-1}b
\end{array}
\]</span> 因此，解 <span class="math inline">\(Ax=b\)</span>
的Jacobi迭代法的计算公式为： <span class="math display">\[
\left\{\begin{array}{l}
x^{(0)}=(x_1^{(0)},\dots,x_i^{(0)},\dots,x_n^{(0)})^T\\
x_i^{(k+1)}=(b_i-\sum\limits_{j=1,j\neq i}^na_{ij}x_j^{(k)})/a_{ii}\\
i=1,2,\dots,n\\
k=0,1,\dots\ 表示迭代次数
\end{array}\right.
\]</span> 矩阵表示为： <span class="math display">\[
\begin{array}{l}
Ax=b\Leftrightarrow(D-L-U)x=b\Leftrightarrow Dx=(L+U)x+b\\
\begin{aligned}Dx&amp;=\begin{pmatrix}
a_{11}\\
&amp;a_{22}\\
&amp;&amp;\ddots\\
&amp;&amp;&amp;a_{nn}
\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}\\
&amp;=\begin{pmatrix}
0&amp;-a_{12}&amp;\cdots&amp;-a_{1,n-1}&amp;-a_{1,n}\\
-a_{21}&amp;0&amp;\cdots&amp;-a_{2,n-1}&amp;-a_{2,n}\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\
-a_{n-1,1}&amp;-a_{n-1,2}&amp;\cdots&amp;0&amp;-a_{n-1,n}\\
-a_{n,1}&amp;-a_{n,2}&amp;\cdots&amp;-a_{n,n-1}&amp;0
\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}+b\\
&amp;=(L+U)x+b
\end{aligned}\end{array}
\]</span></p>
<h4 id="gauss-seidel迭代法">Gauss-Seidel迭代法</h4>
<p><strong>改进Jacobi迭代法</strong>：选取分裂矩阵 <span
class="math inline">\(M\)</span> 为 <span
class="math inline">\(A\)</span> 的下三角部分，即 <span
class="math inline">\(M=D-L\)</span> ， <span
class="math inline">\(A=M-U\)</span> ，得到： <span
class="math display">\[
\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\quad初始向量\\x^{(k+1)}=Bx^{(k)}+f\quad
(k=0,1,\dots)\end{array}\right.\\
B=I-(D-L^{-1})A=(D-L)^{-1}U\equiv G,\quad f=(D-L)^{-1}b\end{array}
\]</span> 称 <span class="math inline">\(G\)</span>
为Gauss-Seidel迭代法的迭代矩阵。</p>
<p><strong>分量计算公式</strong>： <span class="math display">\[
\begin{array}{l}Dx^{(k+1)}=Dx^{(k)}-(Lx^{(k+1)}+Ux^{k}-Dx^{(k)}+b)\\\\
\left\{\begin{array}{l}
x_1^{(k+1)}=\displaystyle-\frac{a_{12}}{a_{11}}x_2^{(k)}-\frac{a_{13}}{a_{11}}x_3^{(k)}-\dots-\frac{a_{1n}}{a_{11}}x_n^{(k)}+\frac{b_2}{a_{22}}\\
x_2^{(k+1)}=\displaystyle-\frac{a_{21}}{a_{22}}x_2^{(k+1)}-\frac{a_{23}}{a_{22}}x_3^{(k)}-\dots-\frac{a_{2n}}{a_{22}}x_n^{(k)}+\frac{b_2}{a_{22}}\\
x_3^{(k+1)}=\displaystyle-\frac{a_{31}}{a_{33}}x_2^{(k+1)}-\frac{a_{32}}{a_{33}}x_3^{(k+1)}-\dots-\frac{a_{3n}}{a_{33}}x_n^{(k)}+\frac{b_3}{a_{33}}\\
\dots\\
x_n^{(k+1)}=\displaystyle-\frac{a_{n1}}{a_{nn}}x_2^{(k+1)}-\frac{a_{n2}}{a_{nn}}x_3^{(k+1)}-\dots-\frac{a_{n,n-1}}{a_{nn}}x_n^{(k+1)}+\frac{b_n}{a_{nn}}\\
\end{array}\right.\\
即\
\displaystyle{x_i^{k+1}=\frac{b_n-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}}{a_{ii}}}\end{array}
\]</span></p>
<h3 id="代码jacobi迭代">代码：Jacobi迭代</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">}};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">14</span><span class="op">,</span> <span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">14</span><span class="op">};</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="代码gauss-seidel迭代">代码：Gauss-Seidel迭代</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">/***区别***/</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Jacobi</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">//Gauss-Seidel</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">}};</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">14</span><span class="op">,</span> <span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">14</span><span class="op">};</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-28-数值分析-Day03-范数-迭代改善算法</title>
      <link>http://localhost:1313/posts/2021-02-28-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day03-%E8%8C%83%E6%95%B0-%E8%BF%AD%E4%BB%A3%E6%94%B9%E5%96%84%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 28 Feb 2021 20:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-02-28-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day03-%E8%8C%83%E6%95%B0-%E8%BF%AD%E4%BB%A3%E6%94%B9%E5%96%84%E7%AE%97%E6%B3%95/</guid>
      <description>2.9-11 范数 为研究线性方程组近似解的误差估计和迭代法的收敛性，对 \(R……n\) （ \(n\) 维向量空间）中的向量（ \(R^{n\times n}\) 中的矩阵）的“大小”引进度量——向量（或矩阵）的范数。
向量的范数 定义1：设 \(x=(x_1,x_2,\dots,x_n)^T,y=(y_1,y_2,\dots,y_n)^T\in R^n (or\ C^n)\)
将实数 \((x,y)=y^Tx=\sum_{i=1}^{n}x_i\overline{y_i}\)（或复数 \((x,y)=y^Hx=\sum_{i=1}^{n}x_iy_i\) ）称为向量x,y的数量积（内积）。
将非负实数 \(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}\) 或 \(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}|x_i|^2)^{1\over2}\) 称为向量 \(x\) 的欧式范数。
引理：向量的内积运算支持交换律、分配律、与实数乘时的结合律。
Cauchy-Schwarz不等式 \(|(x,y)|\le \|x\|_2\cdot\|y\|_2\) 当且仅当 \(x\) 与 \(y\) 线性相关时取等。
三角不等式 \(\|x+y\|_2\le\|x\|_2+\|y\|_2\)
定义2-向量的范数：若向量 \(x\in R^n\) （或 \(C^n\) ）的某个实值函数 \(N(x)=\|x\|\) ，满足条件： \[ \begin{aligned} &amp;amp; (1)\ \|x\|\ge 0\ (\|x\|=0当且仅当x=0)\quad\textbf{正定条件}\\ &amp;amp; (2)\ \|\alpha x\|=|\alpha|\|x\|,\ \forall\alpha\in R(或\alpha\in C)\quad\textbf{齐次性}\\ &amp;amp; (3)\ \|x+y\|_2\le\|x\|_2+\|y\|_2\quad\textbf{三角不等式}\\ &amp;amp; (3\to 4)\ \|x-y\|_2\ge\|x\|_2-\|y\|_2 \end{aligned} \] 则称 \(N(x)\) 是 \(R^n\) （或 \(C^n\) ）上的一个向量范数（或模）</description>
      <content:encoded><![CDATA[<h3 id="范数">2.9-11 范数</h3>
<p>为研究线性方程组近似解的误差估计和迭代法的收敛性，对 <span
class="math inline">\(R……n\)</span> （ <span
class="math inline">\(n\)</span> 维向量空间）中的向量（ <span
class="math inline">\(R^{n\times n}\)</span>
中的矩阵）的“大小”引进度量——向量（或矩阵）的<strong>范数</strong>。</p>
<h4 id="向量的范数">向量的范数</h4>
<p><strong>定义1</strong>：设 <span
class="math inline">\(x=(x_1,x_2,\dots,x_n)^T,y=(y_1,y_2,\dots,y_n)^T\in
R^n (or\ C^n)\)</span><br />
将实数 <span
class="math inline">\((x,y)=y^Tx=\sum_{i=1}^{n}x_i\overline{y_i}\)</span>（或复数
<span class="math inline">\((x,y)=y^Hx=\sum_{i=1}^{n}x_iy_i\)</span>
）称为向量x,y的数量积（内积）。<br />
将非负实数 <span
class="math inline">\(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}\)</span>
或 <span
class="math inline">\(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}|x_i|^2)^{1\over2}\)</span>
称为向量 <span class="math inline">\(x\)</span> 的欧式范数。</p>
<p><strong>引理</strong>：向量的内积运算支持交换律、分配律、与实数乘时的结合律。<br />
Cauchy-Schwarz不等式 <span class="math inline">\(|(x,y)|\le
\|x\|_2\cdot\|y\|_2\)</span> 当且仅当 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 线性相关时取等。<br />
三角不等式 <span
class="math inline">\(\|x+y\|_2\le\|x\|_2+\|y\|_2\)</span></p>
<p><strong>定义2-向量的范数</strong>：若向量 <span
class="math inline">\(x\in R^n\)</span> （或 <span
class="math inline">\(C^n\)</span> ）的某个实值函数 <span
class="math inline">\(N(x)=\|x\|\)</span> ，满足条件： <span
class="math display">\[
\begin{aligned}
&amp; (1)\ \|x\|\ge 0\ (\|x\|=0当且仅当x=0)\quad\textbf{正定条件}\\
&amp; (2)\ \|\alpha x\|=|\alpha|\|x\|,\ \forall\alpha\in R(或\alpha\in
C)\quad\textbf{齐次性}\\
&amp; (3)\ \|x+y\|_2\le\|x\|_2+\|y\|_2\quad\textbf{三角不等式}\\
&amp; (3\to 4)\ \|x-y\|_2\ge\|x\|_2-\|y\|_2
\end{aligned}
\]</span> 则称 <span class="math inline">\(N(x)\)</span> 是 <span
class="math inline">\(R^n\)</span> （或 <span
class="math inline">\(C^n\)</span>
）上的一个<strong>向量范数</strong>（或<strong>模</strong>）</p>
<p><strong>几种常用的向量范数</strong>：</p>
<ul>
<li>向量的 <span class="math inline">\(\infty\)</span>
-范数（最大范数）： <span
class="math inline">\(\displaystyle{\|x\|_\infty=\max\limits_{1\le i\le
n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(1\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_1=\sum_{i=1}^{n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(2\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}}\)</span></li>
<li>向量的 <span class="math inline">\(p\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_p=(\sum_{i=1}^{n}|x_i|^p)^{1\over
p}}\)</span></li>
<li>向量的 <span class="math inline">\(\infty\)</span>
-范数（最大范数）： <span
class="math inline">\(\displaystyle{\|x\|_{-\infty}=\min\limits_{1\le
i\le n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(0\)</span>
-范数：向量的非零元素个数</li>
</ul>
<p><strong>向量的收敛性</strong>：设 <span
class="math inline">\(\{x^{(k)}\}\)</span> 为 <span
class="math inline">\(R^n\)</span> 中的一个向量序列， <span
class="math inline">\(x^*\in R^n\)</span> ，记 <span
class="math inline">\(x^{(k)}=(x_1^{(k)}=(x_1^{(k)},x_2^{(k)},\dots,x_n^{(k)})^T\,
x^*=(x_1^*,x_2^*,\dots,x_n^*)^T\)</span> 。 若 <span
class="math inline">\(\lim\limits_{k\to\infty}x_i^{(k)}=x_i^*(i=1,2,\dots,n)\)</span>
，则称 <span class="math inline">\(x^{(k)}\)</span> 收敛于 <span
class="math inline">\(x^*\)</span> ，记为 <span
class="math inline">\(\lim\limits_{k\to\infty}x_i^{(k)}=x^*\)</span>
。</p>
<p><strong>范数的连续性</strong>：设非负函数 <span
class="math inline">\(N(x)=\|x\|\)</span> 为 <span
class="math inline">\(R^n\)</span> 上任一向量范数，则 <span
class="math inline">\(N(x)\)</span> 是 <span
class="math inline">\(x\)</span> 的分量 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span> 的连续函数。 <span
class="math inline">\(x\)</span> 有很小变化时，同时 <span
class="math inline">\(N(x)\)</span> 亦变化不大。</p>
<p><strong>向量范数的等价性</strong>：设 <span
class="math inline">\(\|x\|_s,\|x\|_t\)</span> 为 <span
class="math inline">\(R^n\)</span> 上向量的任意两种范数，则存在常数
<span class="math inline">\(c_1,c_2&gt;0\)</span> ，使得对一切 <span
class="math inline">\(x\in R^n\)</span> 有 <span
class="math inline">\(c_1\|x\|_s\le\|x\|_t\le c_2\|x\|_s\)</span> 。</p>
<h4 id="矩阵的范数">矩阵的范数</h4>
<h5 id="方阵">方阵</h5>
<p><strong>定义1</strong>：若矩阵 <span class="math inline">\(A\in
R^{n\times n}\)</span> 的某个非负实值函数 <span
class="math inline">\(N(A)=\|A\|\)</span> 满足条件：<br />
<span class="math display">\[
\begin{aligned}
&amp; (1)\ \|A\|\ge 0\ (\|A\|=0\Leftrightarrow
A=0)\quad\textbf{正定条件}\\
&amp; (2)\ \|c A\|=|c|\|A\|,\ c为实数\quad\textbf{齐次性}\\
&amp; (3)\ \|A+B\|\le\|A\|+\|B\|\quad\textbf{三角不等式}\\
&amp; (4)\ \|AB\|\le\|A\|\|B\|
\end{aligned}
\]</span> 则称 <span class="math inline">\(N(A)\)</span> 是 <span
class="math inline">\(R^{n\times n}\)</span>
上的一个<strong>矩阵范数</strong>（或<strong>模</strong>）。</p>
<p><strong>定义2-矩阵的算子范数</strong>：设 <span
class="math inline">\(x\in R^n, A\in R^{n\times n}\)</span>
，给出一种向量范数 <span class="math inline">\(\|x\|_\nu,\
(如\nu=1,2,\infty,\dots)\)</span> ，相应地定义一个矩阵的非负函数： <span
class="math inline">\(\displaystyle{\|A\|_\nu=\max\limits_{x\neq0}\frac{\|Ax\|_\nu}{\|x\|_\nu}}\)</span>
，可验证该非负函数为矩阵 <span class="math inline">\(A\)</span>
的范数，称之为矩阵 <span class="math inline">\(A\)</span>
的<strong>算子范数</strong>。</p>
<p><strong>定理</strong>： <span
class="math inline">\(\|Ax\|_\nu\le\|A\|_\nu\|x\|_\nu\)</span></p>
<p><strong>几种常用的矩阵范数</strong>：</p>
<ul>
<li>Frobenius范数（F范数）： <span
class="math inline">\(\displaystyle{F(A)=\|A\|_F=\left(\sum\limits_{i,j=1}^{n}a_{i,j}^2\right)^{1\over2}}\)</span>
，由向量的 <span class="math inline">\(2\)</span> -范数推广而来</li>
<li>行范数（<span class="math inline">\(\infty\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_\infty=\max\limits_{1\le i\le
n}\sum\limits_{j=1}^{n}|a_{i,j}|}\)</span></li>
<li>列范数（ <span class="math inline">\(1\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_1=\max\limits_{1\le j\le
n}\sum\limits_{i=1}^{n}|a_{i,j}|}\)</span></li>
<li>谱范数（ <span class="math inline">\(2\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_2=\sqrt{\lambda_{\max}(A^TA)},\
(\lambda为特征值)}\)</span></li>
</ul>
<h5 id="非方阵">非方阵</h5>
<p>矩阵 <span class="math inline">\(A_{mn}\)</span></p>
<ul>
<li>Frobenius范数（F范数）： <span
class="math inline">\(\displaystyle{F(A)=\|A\|_F=\left(\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{n}a_{i,j}^2\right)^{1\over2}}\)</span>
，由向量的 <span class="math inline">\(2\)</span> -范数推广而来</li>
<li>行范数（<span class="math inline">\(\infty\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_\infty=\max\limits_{1\le i\le
n}\sum\limits_{j=1}^{n}|a_{i,j}|}\)</span></li>
<li>列范数（ <span class="math inline">\(1\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_1=\max\limits_{1\le j\le
n}\sum\limits_{i=1}^{m}|a_{i,j}|}\)</span></li>
<li>谱范数（ <span class="math inline">\(2\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_2=\sqrt{\lambda_{\max}(A^TA)},\
(\lambda为特征值)}\)</span></li>
</ul>
<h3 id="谱半径">2.12 谱半径</h3>
<blockquote>
<p><strong>特征值和特征向量</strong> <span
class="math inline">\(Ax=\lambda x\)</span> 常数 <span
class="math inline">\(\lambda\)</span> 为<strong>特征值</strong>，矩阵
<span class="math inline">\(A\)</span>
为<strong>特征向量</strong>，且为方阵。 计算方法： <span
class="math inline">\(\det(A-\lambda I)=0\)</span></p>
</blockquote>
<p><strong>定义</strong>：设 <span class="math inline">\(A\in R^{n\times
n}\)</span> 的特征值为 <span
class="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span> ，称 <span
class="math inline">\(\rho(A)=\max\limits_{1\le i\le
n}|\lambda_i|\)</span> 为 <span class="math inline">\(A\)</span>
的谱半径。</p>
<p><strong>定理</strong>：</p>
<ul>
<li>设 <span class="math inline">\(A\in R^{n\times n}\)</span> ，则
<span class="math inline">\(\rho(A)\le\|A\|\)</span>
，即矩阵的谱半径不超过矩阵的任何一种算子范数（对F范数也成立）。</li>
<li>若 <span class="math inline">\(A\in R^{n\times n}\)</span>
为对称矩阵，则 <span class="math inline">\(\rho(A)=\|A\|_2\)</span>
。</li>
<li>若 <span class="math inline">\(\|B\|&lt;1\)</span> ，则 <span
class="math inline">\(I+B\)</span> 为非奇异矩阵，且 <span
class="math inline">\(\left\|(I\pm
B)^{-1}\right\|\le\displaystyle\frac{1}{1-\|B\|}\)</span> ，此处 <span
class="math inline">\(\|\ \|\)</span> 指算子范数。</li>
</ul>
<h3 id="方程组的条件数">2.13 - 14 方程组的条件数</h3>
<p><strong>定义</strong>：如果矩阵 <span
class="math inline">\(A\)</span> 或常数项 <span
class="math inline">\(b\)</span> 的微小变化，引起方程组 <span
class="math inline">\(Ax=b\)</span>
的解的巨大变化，则称该方程组为<strong>“病态”方程组</strong>，若矩阵
<span class="math inline">\(A\)</span>
为原因则称之为该方程组的<strong>“病态”矩阵</strong>。否则称<strong>“良态”</strong>。</p>
<ol type="1">
<li><p>设 <span class="math inline">\(A\)</span> 精确， <span
class="math inline">\(b\)</span> 有误差 <span
class="math inline">\(\delta b\)</span> ，解为 <span
class="math inline">\(x+\delta x\)</span> ，则： <span
class="math display">\[
A(x+\delta x)=b+\delta b\ \Rightarrow\ \delta x=A^{-1}\delta b\\
\|\delta x\|\le\|A^{-1}\|\|\delta b\|\\
\]</span> 由 <span class="math inline">\(Ax=b\)</span> 得： <span
class="math display">\[
\|b\|\le\|A\|\|x\|,\ \frac{1}{\|x\|}\le\frac{\|A\|}{\|b\|}\ (b\neq0)
\]</span> 两式相乘得到<strong>定理1</strong>：设 <span
class="math inline">\(A\)</span> 是非奇异矩阵， <span
class="math inline">\(Ax=b\neq0\)</span> ，且 <span
class="math inline">\(A(x+\delta x)=b+\delta b\)</span> ，则 <span
class="math inline">\(\displaystyle\frac{\|\delta
x\|}{\|x\|}\le\|A^{-1}\|\|A\|\frac{\|\delta b\|}{\|b\|}\)</span>
。该定理给出解的相对误差的上街，即常数项 <span
class="math inline">\(b\)</span> 的相对误差在解中至多放大 <span
class="math inline">\(\|A^{-1}\|\|A\|\)</span> 倍。</p></li>
<li><p>设 <span class="math inline">\(b\)</span> 精确， <span
class="math inline">\(A\)</span> 有微小误差（扰动） <span
class="math inline">\(\delta A\)</span> ，解为 <span
class="math inline">\(x+\delta x\)</span> ，则： <span
class="math display">\[
(A+\delta A)(x+\delta x)=b\ \Rightarrow\ (A+\delta A)\delta x=-(\delta
A)x\\
\]</span> 若 <span class="math inline">\(\delta A\)</span> 不受限制，
<span class="math inline">\(A+\delta A\)</span> 可能奇异，而： <span
class="math display">\[
(A+\delta A)=A(I+A^{-1}\delta A)
\]</span> 当 <span class="math inline">\(\|A^{-1}\delta
A\|&lt;1\)</span> 时， <span class="math inline">\((I+A^{-1}\delta
A)^{-1}\)</span> 存在。则可得： <span class="math display">\[
\delta x=-(I+A^{-1}\delta A)^{-1}A^{-1}(\delta A)x\\
\|\delta x\|\le\frac{\|A^{-1}\|\|\delta A\|\|x\|}{1-\|A^{-1}(\delta
A)\|}
\]</span> 设 <span class="math inline">\(1-\|A^{-1}(\delta
A)\|&lt;1\)</span> ，则有： <span class="math display">\[
\frac{\|\delta x\|}{\|x\|}\le\frac{\|A^{-1}\|\|A\|\frac{\|\delta
A\|}{\|A\|}}{1-\|A^{-1}\|\|A\|\frac{\|\delta A\|}{\|A\|}}
\]</span></p></li>
</ol>
<p>综上， <span class="math inline">\(\|A^{-1}\|\|A\|\)</span>
刻画了方程组的“病态”程度，称之为矩阵 <span
class="math inline">\(A\)</span> 的<strong>条件数</strong>： <span
class="math display">\[
cond(A)_\nu=\|A^{-1}\|_\nu\|A\|_\nu\ (\nu=1,2,\infty)
\]</span> <span class="math inline">\(cond(A)\)</span>
过大时，方程组“病态”。（相对于矩阵中的元比较大小。）</p>
<p><strong>通常使用的条件数</strong>： + 无穷条件数 <span
class="math inline">\(cond(A)_\infty=\|A^{-1}\|_\infty\|A\|_\infty\)</span>
+ 谱条件数 <span
class="math inline">\(cond(A)_2=\|A^{-1}\|_2\|A\|_2=\displaystyle\sqrt{\frac{\lambda_{\max}(A^TA)}{\lambda_{\min}(A^TA)}}\)</span>
当 <span class="math inline">\(A\)</span> 为对称矩阵时， <span
class="math inline">\(cond(A)_2=\displaystyle\frac{\lambda_1}{\lambda_2}\)</span>
，其中 <span class="math inline">\(\lambda_1,\lambda_2\)</span> 为 <span
class="math inline">\(A\)</span> 的绝对值最大和绝对值最小的特征值。</p>
<p><strong>条件数的性质</strong>： + <span
class="math inline">\(cond(A)_\nu=\|A^{-1}\|_\nu\|A\|_\nu\ge\|A^{-1}A\|=1\)</span>
+ <span class="math inline">\(cond(cA)_\nu=cond(A)_\nu, c为常数\)</span>
+ 若 <span class="math inline">\(A\)</span> 为正交矩阵（ <span
class="math inline">\(A^{-1}=A^T\)</span> ），则 <span
class="math inline">\(cond(A)_2=1\)</span> 若 <span
class="math inline">\(A\)</span> 为非奇异矩阵， <span
class="math inline">\(R\)</span> 为正交矩阵，则 <span
class="math inline">\(cond(RA)_2=cond(AR)_2=cond(A)_2\)</span></p>
<h3 id="事后误差估计与迭代改善算法">2.15 事后误差估计与迭代改善算法</h3>
<h4 id="事后误差估计">事后误差估计</h4>
<p>设 <span class="math inline">\(A\)</span> 为非奇异矩阵， <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(Ax=b\neq0\)</span> 的精确解。再设 <span
class="math inline">\(\overline x\)</span> 是此方程组的近似解， <span
class="math inline">\(r=b-A\overline x\)</span> ，则： <span
class="math display">\[
\frac{\|x-\overline x\|}{\|x\|}\le cond(A)\cdot\frac{\|r\|}{\|b\|}
\]</span></p>
<h4 id="迭代改善算法">迭代改善算法</h4>
<p><strong>理论</strong>： 设 <span class="math inline">\(Ax=b\)</span>
，其中 <span class="math inline">\(A\in R^{n\times n}\)</span>
为非奇异矩阵，且为病态方程组（但不过分病态）。 +
用选主元三角分析法实现分解计算 <span
class="math inline">\(PA=LU\)</span> ，其中 <span
class="math inline">\(P\)</span> 为置换阵， <span
class="math inline">\(L\)</span> 为单位下三角阵， <span
class="math inline">\(U\)</span> 为上三角阵，求得方程组近似解 <span
class="math inline">\(x_1\)</span> 。 + 计算剩余向量： <span
class="math inline">\(r_1=b-Ax_1\)</span> + 求解 <span
class="math inline">\(Ad=r_1\)</span> ，得到解 <span
class="math inline">\(d_1\)</span> ，然后改善原解： <span
class="math inline">\(x_2=x_1+d_1\)</span> 。 + 递归推：<span
class="math inline">\(d_2,d_3,\dots,\ x_3,x_4,\dots\)</span></p>
<p><strong>实现</strong>： + 用选主元三角分解实行分解计算 <span
class="math inline">\(PA=LU\)</span> ，且求计算解 <span
class="math inline">\(x_1\)</span> 。 + 对于 <span
class="math inline">\(k=1,2,\dots,N_0\)</span> : + 计算 <span
class="math inline">\(r_k=b-Ax_k\)</span> + 求解 <span
class="math inline">\(LUd_k=Pr_k=PAd_k\)</span> ，<span
class="math inline">\(\left\{\begin{array}{}Ly=Pr_k\\Ud_k=y\end{array}\right.\)</span>
+ 若 <span
class="math inline">\(\displaystyle\frac{\|d_k\|_\infty}{\|x_k\|_\infty}\le10^{-t}\)</span>
则输出 + 改善 <span class="math inline">\(x_{k+1}=x_k+d_k\)</span></p>
<h4 id="补充选主元三角分解法">补充：选主元三角分解法</h4>
<p>LU分解过程中的问题：有解问题无法LU分解（主元为0）；主元过小时引入较大误差</p>
<p>解决方法：选主元</p>
<ul>
<li>第 <span class="math inline">\(k\)</span>
列主元及主元所在列下方元素挑选绝对值最大的数</li>
<li>通过初等变换使该元位于主对角线上，最终将 <span
class="math inline">\(A\)</span> 转换为 <span
class="math inline">\(PA\)</span></li>
<li>则 Doolittle分解转换为 <span
class="math inline">\(PA=LU\)</span></li>
</ul>
<h3 id="代码迭代改善算法">代码：迭代改善算法</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-28.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> C<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> r<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">();</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">();</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshR<span class="op">();</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printX<span class="op">();</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="fl">1.0303</span><span class="op">,</span> <span class="fl">0.99030</span><span class="op">},</span> <span class="op">{</span><span class="fl">0.99030</span><span class="op">,</span> <span class="fl">0.95285</span><span class="op">}};</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="fl">2.4944</span><span class="op">,</span> <span class="fl">2.3988</span><span class="op">};</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    getPA<span class="op">();</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>assign<span class="op">(</span>A<span class="op">.</span>begin<span class="op">(),</span> A<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>assign<span class="op">(</span>b<span class="op">.</span>begin<span class="op">(),</span> b<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    solve<span class="op">();</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    x<span class="op">.</span>assign<span class="op">(</span>r<span class="op">.</span>begin<span class="op">(),</span> r<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        refreshR<span class="op">();</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>r<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>r<span class="op">)))</span> <span class="op">/</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>x<span class="op">)))</span> <span class="op">&lt;=</span> <span class="fl">1e-5</span><span class="op">)</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> r<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        printX<span class="op">();</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> d<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> r<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> r<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> C<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve d</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    d<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> C<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> r<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> C<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>assign<span class="op">(</span>d<span class="op">.</span>begin<span class="op">(),</span> d<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">&gt;</span> A<span class="op">[</span>max<span class="op">][</span>k<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>A<span class="op">[</span>k<span class="op">],</span> A<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>b<span class="op">[</span>k<span class="op">],</span>b<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>                    C<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> C<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> C<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> C<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>            C<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>C<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> C<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshR<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        r<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            r<span class="op">[</span>i<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printX<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="代码选主元doolittle算法">代码：选主元Doolittle算法</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-28.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">();</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">();</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_ <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}};</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x <span class="op">=</span> solve<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    getPA<span class="op">();</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve x</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    x<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> A<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">&gt;</span> A<span class="op">[</span>max<span class="op">][</span>k<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>A<span class="op">[</span>k<span class="op">],</span> A<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>b<span class="op">[</span>k<span class="op">],</span>b<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>                    A<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-27-数值分析-Day02-三角分解</title>
      <link>http://localhost:1313/posts/2021-02-27-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day02-%E4%B8%89%E8%A7%92%E5%88%86%E8%A7%A3/</link>
      <pubDate>Sat, 27 Feb 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-02-27-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day02-%E4%B8%89%E8%A7%92%E5%88%86%E8%A7%A3/</guid>
      <description>续 2.1 - 2.4 矩阵三角分解法 初等行变换 \(\Leftrightarrow\) 矩阵左乘初等矩阵 消元 \(\Leftrightarrow\) 矩阵左乘 \((n-1)\) 个初等矩阵
若 \(a_{11}^{(1)}\neq0\) ，令 \(l_{i1} = a_{i1}^{(1)}\div a_{11}^{11},\ i=2,3,\dots,n\) ，记： \(L_{1}=\begin{pmatrix} 1 \\ -l_{21} &amp;amp; 1 \\ -l_{31} &amp;amp;&amp;amp; 1 \\ \vdots &amp;amp;&amp;amp;&amp;amp; \ddots \\ -l_{31} &amp;amp;&amp;amp;&amp;amp;&amp;amp; 1 \end{pmatrix}\)
则有 \(A^{(2)}=L_{1}A^{(1)}=\begin{pmatrix} a_11^{(1)} &amp;amp; a_{12}^{(1)} &amp;amp; \cdots &amp;amp; a_{1n}^{(1)} \\ 0 &amp;amp; a_{22}^{(2)} &amp;amp; \cdots &amp;amp; a_{2n}^{(2)} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ 0 &amp;amp; a_{n2}^{(2)} &amp;amp; \cdots &amp;amp; a_{nn}^{(2)} \end{pmatrix}\)</description>
      <content:encoded><![CDATA[<h3 id="续-2.1---2.4">续 2.1 - 2.4</h3>
<h4 id="矩阵三角分解法">矩阵三角分解法</h4>
<p>初等行变换 <span class="math inline">\(\Leftrightarrow\)</span>
矩阵左乘初等矩阵 消元 <span
class="math inline">\(\Leftrightarrow\)</span> 矩阵左乘 <span
class="math inline">\((n-1)\)</span> 个初等矩阵</p>
<p>若 <span class="math inline">\(a_{11}^{(1)}\neq0\)</span> ，令 <span
class="math inline">\(l_{i1} = a_{i1}^{(1)}\div a_{11}^{11},\
i=2,3,\dots,n\)</span> ，记： <span
class="math inline">\(L_{1}=\begin{pmatrix} 1 \\ -l_{21} &amp; 1 \\
-l_{31} &amp;&amp; 1 \\ \vdots &amp;&amp;&amp; \ddots \\ -l_{31}
&amp;&amp;&amp;&amp; 1 \end{pmatrix}\)</span></p>
<p>则有 <span class="math inline">\(A^{(2)}=L_{1}A^{(1)}=\begin{pmatrix}
a_11^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ 0 &amp;
a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)} \\ \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 0 &amp; a_{n2}^{(2)} &amp; \cdots &amp;
a_{nn}^{(2)} \end{pmatrix}\)</span></p>
<p>同理进行第二步消元 <span class="math inline">\(A^{(3)}=L_{2}A^{(2)},\
\dots\)</span> 第 <span class="math inline">\((n-1)\)</span> 步得到：
<span class="math inline">\(A^{(n)}=L_{n-1}A^{(n-1)}=\begin{pmatrix}
a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ &amp;
a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)} \\ &amp;&amp; \ddots &amp;
\vdots \\ &amp;&amp;&amp; a_{nn}^{(n)} \end{pmatrix}\)</span></p>
<p>其中： <span
class="math inline">\(L_{n-1}=\begin{pmatrix}1\\&amp;1\\&amp;&amp;\ddots\\&amp;&amp;&amp;1\\&amp;&amp;&amp;-l_{n,n-1}&amp;1\end{pmatrix}\)</span></p>
<p>也就是： <span
class="math inline">\(A^{(n)}=L_{n-1}A^{(n-1)}=L_{n-1}L_{n-2}A^{(n-2)}=\dots=L_{n-1}L_{n-2}\dots
L_{2}L_{1}A^{(1)}\)</span></p>
<p>其中： <span
class="math inline">\(L_{k}=\begin{pmatrix}1\\&amp;\cdots\\&amp;&amp;1\\&amp;&amp;-l_{k+1k}&amp;1\\&amp;&amp;\vdots&amp;&amp;\ddots\\&amp;&amp;-l_{k+(n-1)k}&amp;&amp;&amp;1\end{pmatrix},\
k=1,2,\dots,n-1\)</span><br />
<span
class="math inline">\(L_{k}^{-1}=\begin{pmatrix}1\\&amp;\cdots\\&amp;&amp;1\\&amp;&amp;l_{k+1k}&amp;1\\&amp;&amp;\vdots&amp;&amp;\ddots\\&amp;&amp;l_{k+(n-1)k}&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>所以有： <span
class="math inline">\(A=A^{(1)}=L_{1}^{-1}L_{2}^{-1}\dots
L_{n-1}^{-1}A^{(n)}=LU\)</span> ，称为 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\(LU\)</span> 三角分解。</p>
<p>其中： <span class="math inline">\(L=L_{1}^{-1}L_{2}^{-1}\dots
L_{n-1}^{-1}, U=A^{(n)}\)</span> <span
class="math inline">\(L=\begin{pmatrix}1\\l_{21}&amp;1\\l_{31}&amp;l_{32}&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;l_{n3}&amp;\cdots&amp;1\end{pmatrix}\)</span>
即一个单位下三角矩阵</p>
<p><span class="math inline">\(U=\begin{pmatrix} a_{11}^{(1)} &amp;
a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ &amp; a_{22}^{(2)} &amp;
\cdots &amp; a_{2n}^{(2)} \\ &amp;&amp; \ddots &amp; \vdots \\
&amp;&amp;&amp; a_{nn}^{(n)} \end{pmatrix}\)</span> 为一个上三角矩阵</p>
<h3 id="直接三角分解法">2.5 - 2.6 直接三角分解法</h3>
<p><strong>定理1</strong>：设 <span class="math inline">\(n\)</span>
阶方阵 <span class="math inline">\(A\)</span>
的各阶顺序主子式不为零，则存在<strong>唯一</strong>单位下三角矩阵 <span
class="math inline">\(L\)</span> 和上三角矩阵 <span
class="math inline">\(U\)</span> 使得 <span
class="math inline">\(A=LU\)</span>
。（条件与顺序Gauss消去法的执行条件一致。）</p>
<p>由此可得： <span class="math inline">\(Ax=b \
\Rightarrow\  LUx=b\)</span> ，令 <span
class="math inline">\(Ux=y\)</span> ，得 <span
class="math inline">\(\left\{\begin{aligned}Ly=b\\Ux=y\end{aligned}\right.\)</span>
从而将问题转换为两个三角型方程组的求解。</p>
<p>直接得到 <span class="math inline">\(L\ U\)</span>
两个矩阵——<strong>Doolittle分解法</strong> 设： <span
class="math display">\[
\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{pmatrix}
=
\begin{pmatrix}1\\l_{21}&amp;1\\l_{31}&amp;l_{32}&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;l_{n3}&amp;\cdots&amp;1\end{pmatrix}
\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\]</span> 则得： <span class="math display">\[
\left\{\begin{array}{l}
u_{1j}=a_{1j}\quad j=1,2,\dots,n\\
l_{i1}=a_{i1}\div u_{11}\quad i=2,3,\dots,n\\\vdots\\
对k=2,3,\dots,n,计算\\
u_{kj}=a_{kj}-\sum_{m=1}^{k-1}{l_{km}u_{mj}}\quad j=k,k+1,\dots,n\\
l_{ik}=(a_{ik}-\sum_{m=1}^{k-1}{l_{im}u_{mk}})\div u_{kk}\quad
i=k+1,k+2,\dots,n
\end{array}\right.
\]</span> 应用中为节省存储空间，将矩阵 <span
class="math inline">\(U\)</span> 覆盖矩阵 <span
class="math inline">\(A\)</span> 的上三角进行存放，矩阵 <span
class="math inline">\(L\)</span> 覆盖矩阵 <span
class="math inline">\(A\)</span>
除对角线的下三角进行存放，即在原位形成矩阵： <span
class="math inline">\(\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\l_{21}&amp;u_{22}&amp;\cdots&amp;u_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\l_{n1}&amp;l_{n2}&amp;\cdots&amp;u_{nn}\end{pmatrix}\)</span></p>
<p>回代得到： <span class="math display">\[
\begin{array}{l}
\left\{\begin{array}{l}
\begin{pmatrix}1\\l_{21}&amp;1\\\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;\cdots&amp;1\end{pmatrix}
\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix} =
\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix},\\
\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix} =
\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix}
\end{array}\right.\\
解得\left\{\begin{array}{l}
y_1=b_1\\
y_k=b_k-\sum_{i=1}^{k-1}{l_{ki}y_i},\quad k=2,3,\dots,n\\
x_n=y_n\div u_{nn}\\
x_i=(y_i-\sum_{j=i+1}^{n}{u_{ij}x_j})\div u_{ii},\quad i=n-1,n-2m\dots,1
\end{array}\right.
\end{array}
\]</span></p>
<h3 id="平方根法">2.7 平方根法</h3>
<p>针对系数矩阵 <span class="math inline">\(A\)</span>
为对称正定矩阵情况，有 <span
class="math inline">\(A=LU,u_{kk}&gt;0\)</span> ，而：</p>
<p><span
class="math inline">\(\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
=
\begin{pmatrix}u_{11}\\&amp;u_{22}\\&amp;&amp;\ddots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\begin{pmatrix}1&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;1&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>令 <span
class="math inline">\(D=\begin{pmatrix}u_{11}\\&amp;u_{22}\\&amp;&amp;\ddots\\&amp;&amp;&amp;u_{nn}\end{pmatrix},\
M=\begin{pmatrix}1&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;1&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>则有： <span class="math inline">\(A=LDM\)</span> ，又因为 <span
class="math inline">\((LDM)^T=M^TDL^T=LDM\)</span> ，所以： <span
class="math inline">\(M=L^T\)</span> ，则有： <span
class="math inline">\(A=LDM=LDL^T\)</span> 。</p>
<p>令 <span
class="math inline">\(D=\begin{pmatrix}\sqrt{u_{11}}\\&amp;\sqrt{u_{22}}\\&amp;&amp;\ddots\\&amp;&amp;&amp;\sqrt{u_{nn}}\end{pmatrix}^2=(D^{\frac{1}{2}})^2\)</span></p>
<p>则有： <span
class="math inline">\(A=LD^{\frac{1}{2}}D^{\frac{1}{2}}L^T=(LD^{\frac{1}{2}})(LD^{\frac{1}{2}})^T=GG^T,\quad
G=LD^{\frac{1}{2}}\)</span></p>
<p>分解 <span class="math inline">\(A=GG^T\)</span>
称为对称正定矩阵的<strong>Cholesky分解</strong>， <span
class="math inline">\(Ax=b\)</span> 则转换为 <span
class="math inline">\(\left\{\begin{aligned}Gy=b\\G^Tx=y\end{aligned}\right.\)</span>
，称为<strong>平方根法</strong>。</p>
<p>求解方法：</p>
<p>若记 <span class="math inline">\(G=(g_{ij})\)</span> ，则对 <span
class="math inline">\(k=1,2,\dots,n\)</span> 有： <span
class="math inline">\(\left\{\begin{array}{l}g_{kk}=(a_{kk}-\sum_{m=1}^{k-1}{g_{km}^2})^\frac{1}{2}\\g_{ik}=(a_{ik}-\sum_{m=1}^{k-1}{g_{im}g_{km}})\div
g_{kk},\ i=k+1,\dots,n\end{array}\right.\)</span></p>
<p>同样将 <span class="math inline">\(G\)</span> 存放在 <span
class="math inline">\(A\)</span> 的位置来节省存储。</p>
<p>解三角方程 <span
class="math inline">\(\left\{\begin{aligned}Gy=b\\G^Tx=y\end{aligned}\right.\)</span>
得： <span
class="math inline">\(\left\{\begin{array}{l}y_k=(b_k-\sum_{m=1}^{k-1}{g_{km}y_m})\div
g_{kk},\quad k=1,2,\dots,n\\x_k=(y_k-\sum_{m=k+1}^{n}g_{mk})\div
g_{kk},\quad k=n,n-1,\dots,1\end{array}\right.\)</span></p>
<h3 id="追赶法">2.8 追赶法</h3>
<p>追赶法是求三对角线性方程组的三角分解法： <span
class="math inline">\(\begin{pmatrix}a_1&amp;c_1\\d_2&amp;a_2&amp;c_2\\&amp;\ddots&amp;\ddots&amp;\ddots\\&amp;&amp;d_{n-1}&amp;a_{n-1}&amp;c_{n-1}\\&amp;&amp;&amp;d_n&amp;a_n\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_{n-1}\\x_n\end{pmatrix} =
\begin{pmatrix}b_1\\b_2\\\vdots\\b_{n-1}\\b_n\end{pmatrix}\)</span></p>
<p>三对角矩阵 <span class="math inline">\(A\)</span>
的各阶顺序主子式都不为零的一个充分条件是： <span
class="math inline">\(|a_1|&gt;|c_1|&gt;0;\ |a_n|&gt;|d_n|&gt;0;\
|a_i|\ge|c_i|+|d_i|, c_id_i\neq0, i=2,3,\dots,n-1\)</span> 在此条件下，
<span class="math inline">\(A=LDM=TM\)</span> ，称为矩阵 <span
class="math inline">\(A\)</span> 的<strong>Crout分解</strong>。</p>
<p>对三对角矩阵 <span class="math inline">\(A\)</span>
进行Crout分解，有：<span
class="math inline">\(A=\begin{pmatrix}\alpha_1\\\gamma_2&amp;\alpha_2\\&amp;\ddots&amp;\ddots\\&amp;&amp;\gamma_{n-1}&amp;\alpha_{n-1}\\&amp;&amp;&amp;\gamma_n&amp;\alpha_n\end{pmatrix}
\begin{pmatrix}1&amp;\beta_1\\&amp;1&amp;\beta_2\\&amp;&amp;\ddots&amp;\ddots\\&amp;&amp;&amp;1&amp;\beta_{n-1}\\&amp;&amp;&amp;&amp;1\end{pmatrix}\)</span><br />
<span class="math inline">\(\left\{\begin{array}{l}\alpha_1=a_1,\
\beta_1=c_1\div\alpha_1,\ \gamma_i=d_i,\ i=1,2,3,\dots,n\\
\alpha_i=a_i-d_i\beta_{i-1},\ i=2,3,\dots,n\\ \beta_i=c_i\div\alpha_i,\
i=2,3,\dots,n-1 \end{array}\right.\)</span></p>
<h3 id="代码lu分解法doolittle">代码：LU分解法（Doolittle）</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-27.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">();</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_ <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x <span class="op">=</span> solve<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve x</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    x<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> A<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>                    A<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-26-数值分析-Day01-顺序Gauss消元</title>
      <link>http://localhost:1313/posts/2021-02-26-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day01-%E9%A1%BA%E5%BA%8Fgauss%E6%B6%88%E5%85%83/</link>
      <pubDate>Fri, 26 Feb 2021 18:00:00 +0800</pubDate>
      
      <guid>http://localhost:1313/posts/2021-02-26-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day01-%E9%A1%BA%E5%BA%8Fgauss%E6%B6%88%E5%85%83/</guid>
      <description>1.1 - 1.2 数值分析的算法要求 结构简单，易于计算机实现 理论上保证方法的收敛性和数值稳定性 计算效率高：速度快，内存开销小 经过数值实验验证 误差的来源和分类 模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免 观测误差：观测实验得到的参数带来的误差 截断误差：近似方法产生的误差 舍入误差：计算机有限位计算产生的误差 （后两者为本课程主要研究对象）
绝对误差和相对误差
设 \(x\) 是精确值 \(x^{*}\) 的一个近似值，则 \(e=x^{*}-x\) 为近似值 \(x\) 的绝对误差，简称误差。
若 \(\varepsilon\) 满足 \(|e|\le\varepsilon\) ，则称 \(\varepsilon\) 为 \(x\) 的绝对误差限，简称误差限，有量纲。则满足 \(x-\varepsilon \le x^{*} \le x+\varepsilon\) ，简写为 \(x^{*} = x\pm\varepsilon\) 。
\(e_{r} = \displaystyle\frac{e}{x^{*}} = \frac{x^{*}-x}{x^{*}}\) 称相对误差。
\(\varepsilon_{r} = \displaystyle\frac{\varepsilon}{|x|}\) 称相对误差限， \(|e_{r}| \le \varepsilon_{r}\) ，无量纲。
（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）
1.3 有效数字 定义1：设数 \(x\) 是数 \(x^{*}\) 的近似值，如果 \(x\) 的绝对误差限是它的某一数位的半个单位，并且从 \(x\) 左起第一个非零数到该数位共有 \(n\) 位，则称这 \(n\) 个数字为 \(x\) 的有效数字，也称用 \(x\) 近似 \(x*\) 时具有 \(n\) 位有效数字。</description>
      <content:encoded><![CDATA[<h3 id="section">1.1 - 1.2</h3>
<h4 id="数值分析的算法要求">数值分析的算法要求</h4>
<ul>
<li>结构简单，易于计算机实现</li>
<li>理论上保证方法的收敛性和数值稳定性</li>
<li>计算效率高：速度快，内存开销小</li>
<li>经过数值实验验证</li>
</ul>
<h4 id="误差的来源和分类">误差的来源和分类</h4>
<ul>
<li><ul>
<li>模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免</li>
<li>观测误差：观测实验得到的参数带来的误差</li>
<li><strong>截断误差</strong>：近似方法产生的误差</li>
<li><strong>舍入误差</strong>：计算机有限位计算产生的误差</li>
</ul>
<p>（后两者为本课程主要研究对象）</p></li>
<li><p>绝对误差和相对误差</p>
<p>设 <span class="math inline">\(x\)</span> 是精确值 <span
class="math inline">\(x^{*}\)</span> 的一个近似值，则 <span
class="math inline">\(e=x^{*}-x\)</span> 为近似值 <span
class="math inline">\(x\)</span>
的<strong>绝对误差</strong>，简称<strong>误差</strong>。</p>
<p>若 <span class="math inline">\(\varepsilon\)</span> 满足 <span
class="math inline">\(|e|\le\varepsilon\)</span> ，则称 <span
class="math inline">\(\varepsilon\)</span> 为 <span
class="math inline">\(x\)</span>
的<strong>绝对误差限</strong>，简称<strong>误差限</strong>，有量纲。则满足
<span class="math inline">\(x-\varepsilon \le x^{*} \le
x+\varepsilon\)</span> ，简写为 <span class="math inline">\(x^{*} =
x\pm\varepsilon\)</span> 。</p>
<p><span class="math inline">\(e_{r} = \displaystyle\frac{e}{x^{*}} =
\frac{x^{*}-x}{x^{*}}\)</span> 称<strong>相对误差</strong>。</p>
<p><span class="math inline">\(\varepsilon_{r} =
\displaystyle\frac{\varepsilon}{|x|}\)</span>
称<strong>相对误差限</strong>， <span class="math inline">\(|e_{r}| \le
\varepsilon_{r}\)</span> ，无量纲。</p>
<p>（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）</p></li>
</ul>
<h3 id="有效数字">1.3 有效数字</h3>
<p><strong>定义1</strong>：设数 <span class="math inline">\(x\)</span>
是数 <span class="math inline">\(x^{*}\)</span> 的近似值，如果 <span
class="math inline">\(x\)</span>
的绝对误差限是它的某一数位的半个单位，并且从 <span
class="math inline">\(x\)</span> 左起第一个非零数到该数位共有 <span
class="math inline">\(n\)</span> 位，则称这 <span
class="math inline">\(n\)</span> 个数字为 <span
class="math inline">\(x\)</span> 的有效数字，也称用 <span
class="math inline">\(x\)</span> 近似 <span
class="math inline">\(x*\)</span> 时具有 <span
class="math inline">\(n\)</span> 位有效数字。</p>
<p><strong>有效数字与绝对误差限的关系</strong>： <span
class="math inline">\(x\)</span> 作为 <span
class="math inline">\(x^{*}\)</span> 的近似值，具有 <span
class="math inline">\(n\)</span> 位（ <span class="math inline">\(n \le
k\)</span> ）有效数字当且仅当：</p>
<p><span class="math display">\[
\left|x^{*}-x\right| \le \frac{1}{2}\times10 ^{m-n}
\]</span></p>
<p>近似值的有效数字越多，其绝对误差越小。</p>
<p>（PS：精确值的有效数字可认为有无限多位。）</p>
<p><strong>有效数字与相对误差限的关系</strong>：若 <span
class="math inline">\(x\)</span> 有 <span
class="math inline">\(n\)</span> 位有效数字，则其相对误差限为： <span
class="math display">\[
\varepsilon_{r} \le \frac{1}{2 a_{1}}\times10^{-n+1}
\]</span> 反之，若 <span class="math inline">\(x\)</span> 的相对误差限：
<span class="math display">\[
\varepsilon_{r} \le \frac{1}{2(a_{1}+1)}\times10^{-n+1}
\]</span> 则 <span class="math inline">\(x\)</span> 至少有 <span
class="math inline">\(n\)</span> 位有效数字。</p>
<h3 id="数值计算中的若干原则">1.4 - 1.6 数值计算中的若干原则</h3>
<p>为减少舍入误差</p>
<ul>
<li><p>避免两个相近的数相减</p>
<p>利用对数计算法则将减法转换为除法、利用三角函数和差化积公式转换为乘除、倒用分母有理化将减法转换为分母上的乘法等方法。</p></li>
<li><p>防止大数“吃掉”小数</p>
<p>指参与计算的数数量级差很大时，则加减运算中，绝对值小的数往往被绝对值大的数“吃掉”（如被计算机存储位数限制舍去）。</p>
<p>改变计算顺序，在求和差过程中由小到大进行计算。</p></li>
<li><p>绝对值太小的数不宜作除数</p></li>
<li><p>注意简化计算程序，减少计算次数</p></li>
<li><p>选用数值稳定性好的算法</p>
<p>计算舍入误差积累是可控制的。</p></li>
</ul>
<h3 id="gauss消去法">2.1 - 2.4 Gauss消去法</h3>
<p>求解线性方程组 <span class="math display">\[
\left\{
\begin{aligned}
a_{11}x_{1} + a_{12}x_{2} + ... + a_{1n}x_{n} = b_{1}\\
a_{21}x_{1} + a_{22}x_{2} + ... + a_{2n}x_{n} = b_{2}\\
\dots\\
a_{n1}x_{1} + a_{n2}x_{2} + ... + a_{nn}x_{n} = b_{n}\\
\end{aligned}
\right.
(1)
\]</span> 矩阵形式 <span class="math inline">\(Ax = b\)</span> <span
class="math display">\[
A=  
\begin{pmatrix}  
  a_{11}&amp; a_{12}&amp; \cdots  &amp; a_{1n} \\  
  a_{21}&amp; a_{22}&amp; \cdots  &amp; a_{2n} \\  
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  
  a_{n1}&amp; a_{n2}&amp; \cdots  &amp; a_{nn}
\end{pmatrix},
x=
\begin{pmatrix}  
  x_{1} \\
  x_{2} \\
  \cdots \\
  x_{n} \\
\end{pmatrix},
b=
\begin{pmatrix}  
  b_{1} \\
  b_{2} \\
  \cdots \\
  b_{n} \\
\end{pmatrix} \\
矩阵A奇异，det(A)\neq0
\]</span></p>
<p>Cramer法则：直接方法，计算量过大，不适合实际应用</p>
<p><strong>Gauss消去法</strong>：直接方法，逐次消元，转换为上三角方程组。</p>
<h4 id="顺序gauss消去法">顺序Gauss消去法</h4>
<p>顺序Gauss消去法求解线性方程组 <span
class="math inline">\((1)\)</span>：</p>
<p>记 <span class="math inline">\(A^{(1)}=A, b^{(1)}=b,
a_{ij}^{(1)}=a_{ij}, b_{i}*{(1)}=b_{i}\)</span></p>
<p>则，线性方程组 <span class="math inline">\((1)\)</span>
的增广矩阵为： <span class="math display">\[
(A^{(1)},b^{(1)})=  
\begin{pmatrix}  
  a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
  a_{21}^{(1)}&amp; a_{22}^{(1)}&amp; a_{23}^{(1)}&amp; \dots  &amp;
a_{2n}^{(1)}&amp; b_{2}^{(1)} \\
  a_{31}^{(1)}&amp; a_{32}^{(1)}&amp; a_{33}^{(1)}&amp; \dots  &amp;
a_{3n}^{(1)}&amp; b_{3}^{(1)} \\
  \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
  a_{n1}^{(1)}&amp; a_{n2}^{(1)}&amp; a_{n3}^{(1)}&amp; \dots  &amp;
a_{nn}^{(1)}&amp; b_{n}^{(1)} \\
\end{pmatrix},
\]</span></p>
<ul>
<li><p>第 <span class="math inline">\(1\)</span> 步：设 <span
class="math inline">\(a_{11}^{(1)}\neq0\)</span> ，依次用 <span
class="math inline">\(-l_{i1}=-\displaystyle\frac{a_{i1}^{(1)}}{a_{11}^{(1)}},
(i=2,3,\dots,n)\)</span> 乘以矩阵的第 <span
class="math inline">\(1\)</span> 行加到第 <span
class="math inline">\(i\)</span> 行，得到矩阵： <span
class="math display">\[
\begin{array}{l}
(A^{(2)},b^{(2)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; a_{32}^{(2)}&amp; a_{33}^{(2)}&amp; \dots  &amp;
a_{3n}^{(2)}&amp; b_{3}^{(2)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; a_{n2}^{(2)}&amp; a_{n3}^{(2)}&amp; \dots  &amp;
a_{nn}^{(2)}&amp; b_{n}^{(2)} \\
\end{pmatrix},\\
其中：\begin{aligned}
a_{ij}^{(2)} = a_{ij}^{(1)} - l_{i1}a_{1j}^{(1)},\quad i,j=2,3,\dots,n
\\
b_{i}^{(2)} = b_{i}^{(1)} - l_{i1}b_{1}^{(1)},\qquad i=2,3,\dots,n
\end{aligned}
\end{array}
\]</span></p></li>
<li><p>第 <span class="math inline">\(2\)</span> 步：设 <span
class="math inline">\(a_{22}^{(2)}\neq0\)</span> ，依次用 <span
class="math inline">\(-l_{i2}=-\displaystyle\frac{a_{i2}^{(2)}}{a_{22}^{(2)}},
(i=3,4,\dots,n)\)</span> 乘以矩阵的第 <span
class="math inline">\(2\)</span> 行加到第 <span
class="math inline">\(i\)</span> 行，得到矩阵： <span
class="math display">\[
\begin{array}{l}
(A^{(2)},b^{(2)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; 0&amp; a_{33}^{(3)}&amp; \dots  &amp; a_{3n}^{(3)}&amp;
b_{3}^{(3)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; 0&amp; a_{n3}^{(3)}&amp; \dots  &amp; a_{nn}^{(3)}&amp;
b_{n}^{(3)} \\
\end{pmatrix},\\
其中：\begin{aligned}
a_{ij}^{(3)} = a_{ij}^{(2)} - l_{i2}a_{2j}^{(2)},\quad i,j=3,4,\dots,n
\\
b_{i}^{(3)} = b_{i}^{(2)} - l_{i2}b_{2}^{(2)},\qquad i=3,4,\dots,n
\end{aligned}
\end{array}
\]</span></p></li>
<li><p>第 <span class="math inline">\(3\)</span> 步，第 <span
class="math inline">\(4\)</span> 步， <span
class="math inline">\(\dots\)</span> ，第 <span
class="math inline">\((n-1)\)</span> 步后得到矩阵： <span
class="math display">\[
(A^{(n)},b^{(n)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; 0&amp; a_{33}^{(3)}&amp; \dots  &amp; a_{3n}^{(3)}&amp;
b_{3}^{(3)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; 0&amp; 0&amp; \dots  &amp; a_{nn}^{(n)}&amp; b_{n}^{(n)} \\
\end{pmatrix}
\]</span></p></li>
<li><p>对应的方程组则变成： <span class="math display">\[
\left\{
\begin{aligned}
a_{11}^{(1)}x_{1} + a_{12}^{(1)}x_{2} + ... + a_{1n}^{(1)}x_{n} =
b_{1}^{(1)}\\
a_{22}^{(2)}x_{2} + ... + a_{2n}^{(2)}x_{n} = b_{2}^{(2)}\\
\dots\\
a_{nn}^{(n)}x_{n} = b_{n}^{(n)}\\
\end{aligned}
\right.
\]</span></p></li>
<li><p>对此方程组进行回代，就可求出方程组的解</p></li>
</ul>
<p>顺序Gauss消去法的乘除计算量：<span
class="math inline">\(\displaystyle\sum_{k=1}^{n}(k^{2}-1)\ +\
\displaystyle\sum_{k=1}^{n}k\ =\
\displaystyle\frac{1}{3}(n^{3}+3n^{2}-n)\)</span></p>
<p><strong>顺序Gauss消去法</strong>也简称为<strong>Gauss消去法</strong>，其中
<span class="math inline">\(a_{kk}^{(k)}(k=1,2,\dots,n)\)</span>
也称为<strong>主元素</strong>，且主元素不为零（使用顺序Gauss消去法的充要条件）。</p>
<h4 id="列主元gauss消去法">列主元Gauss消去法</h4>
<p>顺序Gauss消去法的局限性：主元素过小时出现“大数吃小数”情况，舍入误差较大。常采用<strong>列主元Gauss消去法</strong>和<strong>全主元Gauss消去法</strong>解决。</p>
<p>线性方程组 <span class="math inline">\(Ax=b\)</span>，记 <span
class="math inline">\(A^{(1)}=A, b^{(1)}=b,\)</span>
列主元Gauss消去法过程如下： + 在增广矩阵 <span
class="math inline">\(B^{(1)}=(A^{(1)},b^{(1)})\)</span>
的第一列元素中，取： <span
class="math inline">\(\left|a_{k1}^{(1)}\right| = \max\limits_{1\le i\le
n}{\left|a_{i1}^{(1)}\right|}\)</span> 为主元素， <span
class="math inline">\(r_{k}\leftrightarrow r_{1}\)</span> 。 然后进行第
<span class="math inline">\(1\)</span> 步消元得到增广矩阵 <span
class="math inline">\(B^{2}=(A^{(2), b^{(2)}})\)</span> 。 + 再在矩阵
<span class="math inline">\(B^{(2)}=(A^{(2)},b^{(2)})\)</span>
的第二列元素中，取： <span
class="math inline">\(\left|a_{k2}^{(2)}\right| = \max\limits_{2\le i\le
n}{\left|a_{i2}^{(2)}\right|}\)</span> 为主元素， <span
class="math inline">\(r_{k}\leftrightarrow r_{2}\)</span> 。
然后进行第二步消元得到增广矩阵 <span
class="math inline">\(B^{3}=(A^{(3), b^{(3)}})\)</span> 。 +
依此类推，经过 <span class="math inline">\((n-1)\)</span>
步选主元和消元运算，得到增广矩阵 <span
class="math inline">\(B^{n}=(A^{(n), b^{(n)}})\)</span> 。则方程组 <span
class="math inline">\(A^{(n)}x=b^{(n)}\)</span>
是与原方程组等价的上三角方程组，回代求解。 + <strong>易证：只要 <span
class="math inline">\(|A|\neq 0\)</span>
列主元Gauss消去法就可顺利进行。</strong></p>
<h4 id="全主元gauss消去法">全主元Gauss消去法</h4>
<p>在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。</p>
<h3 id="代码顺序gauss消去法">代码：顺序Gauss消去法</h3>
<p>在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-26.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> matrix<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> input<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upperTriangular<span class="op">();</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swapRow<span class="op">(</span><span class="dt">int</span> index<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss<span class="op">(</span><span class="dt">int</span> index<span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">*</span> a<span class="op">,</span> T<span class="op">*</span> b<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printMatrix<span class="op">();</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> test <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}};</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> ans <span class="op">=</span> solve<span class="op">(</span>test<span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ans<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> ans<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> input<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span>assign<span class="op">(</span>input<span class="op">.</span>begin<span class="op">(),</span> input<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solution<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    upperTriangular<span class="op">();</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;No Solution.&quot;</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    solution<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">]/</span>matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> tmp <span class="op">=</span> matrix<span class="op">[</span>i<span class="op">][</span>size<span class="op">];</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            tmp <span class="op">-=</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> solution<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        solution<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">/</span>matrix<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solution<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upperTriangular<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        swapRow<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        gauss<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swapRow<span class="op">(</span><span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max <span class="op">=</span> index<span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> index<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>index<span class="op">]</span> <span class="op">&gt;</span> matrix<span class="op">[</span>max<span class="op">][</span>index<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>matrix<span class="op">[</span>index<span class="op">],</span> matrix<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;swap&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss<span class="op">(</span><span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> l <span class="op">=</span> matrix<span class="op">[</span>i<span class="op">][</span>index<span class="op">]</span> <span class="op">/</span> matrix<span class="op">[</span>index<span class="op">][</span>index<span class="op">];</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>            matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> l <span class="op">*</span> matrix<span class="op">[</span>index<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;</span> <span class="fl">1e-16</span> <span class="op">&amp;&amp;</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;</span> <span class="op">-</span><span class="fl">1e-10</span><span class="op">)</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;gauss&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">*</span> a<span class="op">,</span> T<span class="op">*</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printMatrix<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
