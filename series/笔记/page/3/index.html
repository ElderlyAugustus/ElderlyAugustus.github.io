<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>笔记 | xα&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="xα&#39;s blog">
<meta name="author" content="xα">
<link rel="canonical" href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://elderlyaugustus.github.io/icons/favicon.ico">
<link rel="apple-touch-icon" href="https://elderlyaugustus.github.io/icons/apple-touch-icon.png">
<link rel="alternate" type="application/rss+xml" href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/index.xml">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="笔记 | xα&#39;s blog" />
<meta name="twitter:description" content="xα&#39;s blog" />
<meta property="og:title" content="笔记 | xα&#39;s blog" />
<meta property="og:description" content="xα&#39;s blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/" />
    <meta property="og:image" content="https://elderlyaugustus.github.io/papermod-cover.png"/>


<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
  </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class="list-page type-series kind-term layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://elderlyaugustus.github.io/" accesskey="h" title="xα&#39;s blog (Alt + H)">xα&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://elderlyaugustus.github.io/archives/" title="Archives"
                >Archives
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/tags/" title="Tags"
                >Tags
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/about/" title="Me &amp; Friends"
                >Me &amp; Friends
                </a>
            </li>
            <li>
                <a href="https://elderlyaugustus.github.io/search/" title="Search (Alt &#43; /)"data-no-instant accesskey=/
                >Search
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://elderlyaugustus.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://elderlyaugustus.github.io/series/">Series</a></div>
  <h1>
    series: 笔记</h1><div class="inline-links">
  
  
  <span><a href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/index.xml" target="_blank">RSS</a></span></div>
</header>






<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-17-GAMES104现代游戏引擎-Lecture5-Lighting, Materials and Shaders
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture05 Lighting, Materials and Shaders The Rendering Equation \[ {\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ &#43;\int _{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n} )\operatorname {d} \omega _{\text{i}}} \]
多重挑战：
如何得到入射光 Visibility to Lights, Shadow Light Source Complexity, 尤其面光源 如何快速地积分 如何计算次级光源，全局光照，无限递归 从简单开始 Ambient &#43; Simple Light == Result
环境光贴图反射
相当于Rendering Equation特例化
Blinn-Phong \[ \begin{aligned}L&amp;=L_{\text{ambient}}&#43;L_{\text{diffuse}}&#43;L_{\text{specular}}\\ &amp;=k_{\text{ambient}}I_{\text{ambient}}&#43;k_{\text{diffuse}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)&#43;k_{\text{specular}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)^p \end{aligned} \] 问题：...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 17, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">现代游戏引擎</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-17-GAMES104现代游戏引擎-Lecture5-Lighting, Materials and Shaders" href="https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-17-GAMES104现代游戏引擎-Lecture4-Rendering in Game Engine
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture04 Rendering in Game Engine 挑战
场景极其复杂 实时，帧率稳定 大纲
基础 硬件架构 渲染数据结构 可见性 材质、Shader、光照 PBR Shader Permutation 光照 点/方向光照 IBL / Simple GI 特殊的渲染 地形 天空 / 雾 后处理 Pipeline 前向渲染 Forward、延迟渲染 Deferred、Forward Plus Ring buffer and V-Sync Tiled-based Rendering @GAMES101
Vertex Data -&gt; Triangle Data -&gt; Material Parameters -&gt; Textures
投影 -&gt; 光栅化
eg. Computation - Texture Sampling
Step 1 : 使用相邻两层MIPMAP Step 2 : 在两层MIPMAP之间双线性插值 Step 3 : 结果像素之间的线性插值 GPU SIMD and SIMT SIMD : Single Instruction Multiple Data eg....</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 17, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">现代游戏引擎</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-17-GAMES104现代游戏引擎-Lecture4-Rendering in Game Engine" href="https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-17-GAMES104现代游戏引擎-Lecture2-3-游戏引擎架构
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture02 游戏引擎分层结构 工具层 Tool Layer 编辑器
功能层 Function Layer 渲染/模拟/玩法/交互/…
资源层 Resource Layer 数据和文件
核心层 Core Layer 内存管理/资源分配/数学模块
平台层 Platform Layer 硬件设备的调用
PS：中间件/第三方库
情景：制作一个动画角色
Resource 怎么获取数据
Offline Importing resource -&gt; assets 将resource转换为asset的文件格式 asset读取更快 建构所有资产的关联关系（reference） GUID 实时/运行时（Runtime）资产管理器 基于路径加载/卸载asset 通过Handle系统管理asset的生命周期和参考 Function 怎么使世界动起来
tick() tickLogic() tickRender() 有大量系统组成 必定属于引擎功能层的：渲染/模拟等 引擎功能层/游戏Gameplay有时有一定冲突 多线程 固定线程：不同线程作不同功能 主流用法，Job join：将模拟/动画等适合多线程的任务平均分配 原子化/任务系统：转换为一个个Job分配给所有线程 Core
数学库
线性代数
为什么要单独写数学库 - 效率
eg. 卡马克快速平方根（牛顿迭代）
SIMD 一条指令完成四个数操作（非常适合齐次坐标运算）
数据结构
vector / map / tree / … 为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作 内存管理 - 追求最高效率...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 17, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">现代游戏引擎</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-17-GAMES104现代游戏引擎-Lecture2-3-游戏引擎架构" href="https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-16-GAMES202高质量实时渲染-Lecture5-6-Environment Light
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture 5-6 Environment Lighting Recap
环境光贴图 球面贴图 Spherical Map / 立方体贴图 Cube Map Shading from Environment Lighting / Image-Based Lighting (IBL) 解渲染方程（不考虑阴影） \[ L_o(\mathrm p,\omega_o)=\int_{\Omega^&#43;}L_i(\mathrm p,\omega_i)f_r(\mathrm p,\omega_i,\omega_o)\cos\theta_i\xcancel{V(\mathrm p,\omega_i)}\,\mathrm d\omega_i \]
蒙特卡洛积分——数值解、大量采样，非常慢 PS: 一旦涉及采样，就很难实时，近年开始有一些进展 观察：
glossy BRDF : BRDF覆盖很小 diffuse BRDF : BRDF覆盖大，但是平滑 因此考虑近似方法 \[ \int_\Omega f(x)g(x)\,\mathrm dx\approx\dfrac{\int_{\Omega_G}f(x)\,\mathrm dx}{\int_{\Omega_G}\,\mathrm d x}\cdot\int_\Omega g(x)\,\mathrm dx \] （该式在 \(g(x)\) 范围小/结果平滑时较为准确）
则有 \[ L_o(\mathrm p,\omega_o)\approx\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm d\omega_i}\int_{\Omega^&#43;}f_r(\mathrm p,\omega_i,\omega_o)\cos\theta_i\,\mathrm d\omega_i \]
\(\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm d\omega_i}\) 表示对环境光贴图做模糊化处理，即滤波...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 16, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">高质量实时渲染</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-16-GAMES202高质量实时渲染-Lecture5-6-Environment Light" href="https://elderlyaugustus.github.io/posts/2022-04-16-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture5-6-environmentlight/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-14-GAMES202高质量实时渲染-Lecture14-Practical Industrial Solutions
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture 14 Practical Industrial Solutions Temporal Anti-Aliasing, TAA Recall: why aliasing
光栅化的采样数不够 终极解决方案：加样本（MSAA） TAA：应用Temporal信息，与RTRT的降噪思路一致
每四帧复用：
（如果不是4个固定位置而是是随机生成，引入了其他高频信息，效果并不好）
Notes on AA
MSAA vs SSAA SSAA：按几倍分辨率渲染场景，再下变换，效果好开销大 MSAA：对SSAA的效率改进 对一个像素内的一个Primitive，只采样一次（取中心或其他代表点） 空间上的Sample Reuse：样本分布上的Trick 基于图像的反走样方法 SMAA, Enhanced Subpixel Morphological AA FXAA -&gt; MLAA(Morphological AA) -&gt; SMAA G-Buffer一定不能反走样！（信息会出错） Temporal Super Resolution Super resolution == Super sampling
提升分辨率 eg. DLSS DLSS 1.0 全靠猜，每个游戏/场景单独训练一个网络 DLSS 2.0 利用Temporal信息 应用类似TAA的思路 重用Samples 问题：Temporal failure时不能clamp——因为每一个像素需要一个明确的值 DL不输出图像，而是输出关于上一帧的Temporal信息如何利用 Deferred Shading 延迟渲染 提高Shading效率 传统管线 Triangles -&gt; Fragments -&gt; Depth Test -&gt; Shading -&gt; Pixel 每一个Fragment都需要做Shading 复杂度：\(O(\text{\#Fragment}*\text{\#Light})\) 关键想法：有很多Fragment不会被看到 -&gt; 只对被看到的Fragment做Shading 修改管线 光栅化两次场景 Pass 1 : 不做Shading，更新Depth Buffer Pass 2 : 对可见的Fragment做Shading 复杂度：\(O(\text{\#Vis....</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 14, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">高质量实时渲染</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-14-GAMES202高质量实时渲染-Lecture14-Practical Industrial Solutions" href="https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture14-industry/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-12-GAMES202高质量实时渲染-Lecture12-13-Real Time Ray Tracing
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture 12-13 Real-Time Ray-Tracing RTX : 10G rays per second == 1 sample per pixel
1 SPP path tracing == 1 rasterization (primary) &#43; 1 ray (primary visibility) &#43; 1 ray (primary bounce) &#43; 1 ray (primary vis.) &#43;
1 SPP is Extremely Noisy
Key Tech : Denosing
Goals : &#43; Quality (no overblur, no artifacts, keep all details) &#43; Speed (&lt; 2ms to denoise per frame)
==&gt; Temporal !...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 12, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">高质量实时渲染</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-12-GAMES202高质量实时渲染-Lecture12-13-Real Time Ray Tracing" href="https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture12-13-rtrt/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字
    </h2>
  </header>
  <section class="entry-content">
    
      <p>开头说明一下，这是UE5.0正式版发布时给系里和某些合作单位供稿的一些介绍性文字，比较简单的整理，非最终发布版（考虑到影视业读者还在这基础上进一步删减了），补充发布到自己个站算是留痕吧
虚幻引擎5.0新功能为电影虚拟化制作助力 2021年5月26日，Epic Games推出虚幻引擎5.0 Early Access抢先体验版本，吸引了各行业的大量关注，其推出的Lumen、Nanite等新功能带来了更佳的实时渲染质量和更高的创作效率。直至2022年4月5日，Epic Games正式发布虚幻引擎5.0版本，长达近一年的预览期内，包括影视创作行业在内的各领域创作者、研究者进行了大量的探索和尝试。随着正式版本发布、新功能不断完善、更多的官方解析释出和源代码的发布，我们也对虚幻引擎5.0的许多新功能有了更加深入清晰的认识。
电影虚拟化制作作为基于实时渲染引擎的新型电影制作方案，随着虚幻引擎的完善与发展，及其对电影虚拟化制作相关功能的补充，近年来许多具体的解决方案通过虚幻引擎来实现。因此，虚幻引擎更新至5.0也引发了影视制作行业的重点关注。本文即关于虚幻引擎5.0中为电影虚拟化制作带来新动力的新功能，做一定的简单分析。
新功能概览 虚幻引擎中的电影虚拟化制作模块In-Camera VFX自虚幻引擎4.25开始发展，直至4.27有一个比较全面的更新，达到了基本完善的程度。而虚幻引擎5.0的早期开发是与4.27版本同步进行的，因此在5.0的早期预览版本中仍然使用的是4.26的In-Camera VFX系统。更新5.0正式版后，In-Camera VFX系统也承接了4.27版本中的形态，以更成熟的结构呈现。
在虚幻引擎5.0中，电影虚拟化制作相关功能获得了nDisplay虚拟纹理、nDisplay内视锥过扫描、相机镜头校准、DMX等插件、关卡快照、Switchboard、Sequencer、USD流程等诸多功能的支持和改进。
但由于In-Camera VFX系统在5.0中的开发刚刚开始，有不少5.0版本的新功能尚未能在In-Camera VFX和其依赖的nDisplay系统中获得支持，比如Lumen的渲染管线。不过进一步的支持应该也只是一个时间问题。相信在这些新功能的加持下，In-Camera VFX系统的电影虚拟化制作能力将达到一个新高度。
可以预见Lumen、Nanite为主导的渲染新功能将为电影虚拟化制作带来更高的背景影像质量和更高的场景资产制作效率，
Lumen Lumen是虚幻引擎5.0给出的“新一代”动态全局光照解决方案，其代码存放在Engine/Source/Runtime/Renderer/Private/Lumen中。
Lumen的整体思路是以SDF(Signed Distance Field) Trace为主的混合Tracing框架，同时用重新设计的Surface Cache场景表达，Radiance Cache作为最终的渲染结果收集。
混合的Tracing方案 在Lumen中，也可以先尝试调用基于硬件的RTX Trace，但主要还是软件的混合Tracing方案。其中包括Screen Space Trace、Mesh SDF Trace、Voxel Trace(Global SDF Trace)，按这一顺序依次Trace，前者失败则交给后者计算，成功则返回。
Screen Space Trace 首先是屏幕空间的Trace方法，它来自于虚幻引擎4.25就加入的SSGI(Screen Space Global Illumination)方案。这一方法能够很好地处理近似场景表达中丢失的细节。它利用HZB(Hierarchical Z-Buffer)优化遍历，可以改善线性遍历时的漏光问题，针对HZB带来的高开销问题，则限制其Trace步长在50步以内，否则交给下一种Trace方法。
世界空间的SDF Trace 屏幕空间方法失败之后，来到世界空间的Trace方法，也是Lumen的Trace管线中最为主要的Trace方法：SDF Trace。
对于近处的场景（例如1.8m内），Lumen采用Mesh SDF存储。对每一个Mesh存储一份SDF，实现相对低效但具有较好效果的SDF Trace。
在Mesh SDF中，为了解决物体厚度小于SDF存储的体素大小时判断失败的问题，Lumen对每一个物体扩展0.5倍的体素大小，这样保证了每一种厚度的物体都能够被Trace到，Trace到物体计算Radiance时再做相应的偏移梯度计算就能够得到相对准确的结果。
而远景则将每一个物体的Mesh SDF合并为全局的Global SDF，并生成层级结构Clipmaps。这样降低了远景场景的Trace精度，但大大提高了效率。
Global SDF的显存占用较大，更新开销正比于场景中的运动物体数量。这里采用了稀疏的存储方式，跳过大量的负值、零值SDF区域，减少了16倍的存储量，同时带来的多一次查询的问题则生成一层MIP2的贴图来改善：先查询MIP2，在接近物体表面时再查询全精度的Clipmap，这样对场景的更新也带来了遍历。
最后，对于每一步的Trace结构，还需要做一次压缩，以减小占用、提升缓存一致性。
这样，SDF Trace将Tracing、远景场景、远景场景复杂解耦，带来了较高的效率。但同时也具有体积存储大、缺乏微小细节、无法参数化表面数据等问题。
Surface Cache 在Surface Cache中，预先进行了一次分离的材质计算和光照计算的pass，在Tracing计算时，直接在Hit位置对Surface Cache作一次查询即可获得相对好的结果，提高Tracing效率。
Mesh Card SDF Trace无法用传统的三角形表达插值着色，因此Lumen使用Mesh Card的方式参数化存储场景表达。Mesh Card是渲染之前离线提前生成的有向矩形块，覆盖在模型表面——因此当模型较为模块化时效果较好。...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 10, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/misc/">Misc</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-10-UE5.0时给系里写的Lumen和Nanite的一些介绍性文字" href="https://elderlyaugustus.github.io/posts/2022-04-10-ue5.0%E6%97%B6%E7%BB%99%E7%B3%BB%E9%87%8C%E5%86%99%E7%9A%84lumen%E5%92%8Cnanite%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D%E6%80%A7%E6%96%87%E5%AD%97/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2021-04-05-GAMES202高质量实时渲染-Lecture3-4-Soft Shadow
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture 3-4 Soft Shadow Recap of Shadow Mapping - 点光源 从“Light”处看向场景，生成场景关于光源的深度图，即Shadow Map； 从相机处看向场景渲染画面，利用Shadow Map判断像素是否在阴影中。 Feature：
基于二维图像的算法，而不需要三维几何场景 使用透视投影后Z值或透视投影前实际距离生成深度图皆可，Shadow Map与阴影生成时的深度判定方式一致即可 Problem
Self occlusion 自遮挡
Shadow Map的每一个像素记录同一深度，形成下图现象。在单个/行像素采样处，形成尺寸为像素宽高的遮挡面。 解决方案：在反射表面邻近区域不计算遮挡。不计算区域Light长度（Bias）由Light与反射表面法线夹角决定。（Light垂直于表面时不产生自遮挡问题）。——带来新问题：丢失遮挡关系。
Detached shadow 由解决自遮挡的Bias不计算带来的阴影残缺问题。
工业界无法彻底解决该问题，通过找到合适的Bias值减少视觉问题。
学术解决方案：Second-depth shadow mapping
存储第一深度和次级深度（离得第二近的表面距离），取中间值作为深度判断的值。 存在问题：要求所有物体watertight（有正反面）；计算量过大。 实时渲染不相信复杂度，只相信绝对速度！因此工业界不适用。 Aliasing 采样
The math behind shadow mapping 微积分中常见的不等式： \[ \begin{array}{c} Schwarz不等式： \displaystyle\left[\int_a^bf(x)g(x)\,\mathrm d x\right]^2\le\int_a^bf^2(x)\,\mathrm d x\cdot\int_a^bg^2(x)\,\mathrm d x\\ Minkowski不等式：\displaystyle\left\{\int_a^b\left[f(x)&#43;g(x)\right]^2\,\mathrm d x\right\}^\frac{1}{2}\le\left\{\int_a^bf^2(x)\,\mathrm d x\right\}^\frac{1}{2}&#43;\left\{\int_a^bg^2(x)\,\mathrm d x\right\}^\frac{1}{2} \end{array} \] Approximation in RTR: But we care more about “approximately equal”....</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 5, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">高质量实时渲染</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2021-04-05-GAMES202高质量实时渲染-Lecture3-4-Soft Shadow" href="https://elderlyaugustus.github.io/posts/2021-04-05-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture3-4-softshadow/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2022-04-02-GAMES202高质量实时渲染-Lecture10-11-Physically-Based Material
    </h2>
  </header>
  <section class="entry-content">
    
      <p>Lecture 10-11 Physically-Based Material Content
Real-Time Physically-Based Materials Microfacet BRDF Disney principled BRDF Shading with microfacet BRDFs under polygonal lighting Linearly Transformed Cosines (LTC) Concept
Physically-Based Rendering (PBR) Everything in rendering should be physically based Materials, lighting, camera, light transport, etc. Not just materials, but usually referred to as materials PBR materials in RTR The RTR community is much behind the offline community “PB” in RTR is usually not actually physically based PBR materials in RTR...</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>April 2, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">高质量实时渲染</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2022-04-02-GAMES202高质量实时渲染-Lecture10-11-Physically-Based Material" href="https://elderlyaugustus.github.io/posts/2022-04-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture10-11-pbm/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>2021-03-11-数值分析-Day14-RungeKutta方法-线性多步方法
    </h2>
  </header>
  <section class="entry-content">
    
      <p>7.5 - 7.7 Runge-Kutta方法 单步高阶方法构造思路 设 \(y(x)\) 是一阶常微分方程初值问题的精确解，Taylor展开得： \[ \begin{aligned} \displaystyle y(x_{n&#43;1})&amp;=y(x_n)&#43;y&#39;(x_n)h&#43;\frac{y&#39;&#39;(x_n)}{2!}h^2&#43;\dots&#43;\frac{y^{(p)}(x_n)}{p!}h^p&#43;\frac{y^{({p&#43;1})}(x_n)}{(p&#43;1)!}h^{p&#43;1}\\ &amp;=y(x_n)&#43;hf(x_n,y(x_n))&#43;\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))&#43;\dots&#43;\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))&#43;O(h^{p&#43;1})\end{aligned} \] 因此可建立节点处近似值 \(y_n\) 满足的差分公式： \[ \left\{\begin{array}{l}\displaystyle y_{n&#43;1}=y_n&#43;hf(x_n,y_n)&#43;\frac{h^2}{2!}f^{(1)}(x_n,y_n)&#43;\dots&#43;\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\y_0=\alpha,\quad n=0,1,\dots,N-1\end{array}\right. \] 称之为 \(\mathbf p\) 阶Taylor展开方法。 其中： \(\begin{array}{l}\displaystyle f^{(1)}(x,y)=\frac{\partial f(x,y)}{\partial x}&#43;\frac{\partial f(x,y)}{\partial y}f(x,y)\\\displaystyle f^{(2)}(x,y)=\frac{\partial^2f}{\partial x^2}&#43;2\frac{\partial^2f}{\partial x\partial y}f&#43;\frac{\partial^2 f}{\partial y^2}f^2&#43;\frac{\partial f}{\partial x}\frac{\partial f}{\partial y}&#43;\left(\frac{\partial f}{\partial y}\right)^2f\\\dots\end{array}\)
计算过于复杂，很少直接使用
减少Taylor展开次数得： \[ y(x_{n&#43;1})=y(x_n)&#43;hy&#39;(\xi)=y(x_n)&#43;hf(\xi,y(\xi)),\quad x_n\le\xi\le x_{n&#43;1} \] 构造差分方法即利用适当的函数值来近似计算 \(f(\xi,y(\xi))\) 。
Euler方法用 \(K_1\) 作为其近似，其 \(y_{n&#43;1}\) 表达式与精确解的Taylor展式前 \(2\) 项一致。为 \(1\) 阶方法。 改进Euler方法用 \(K_1,K_2\) 的线性组合作为其近似，其 \(y_{n&#43;1}\) 表达式与精确解的Taylor展式前 \(3\) 项一致。为 \(2\) 阶方法。 能否增加计算 \(f(x,y)\) 的次数来提高方法阶数？ Runge-Kutta方法 \[ \left\{\begin{array}{l} y_{n&#43;1}=y_n&#43;h(\lambda_1K_1&#43;\lambda_2K_2&#43;\dots&#43;\lambda_pK_p)\\ K_1=f(x_n,y_n)\\ K_2=f(x_n&#43;\alpha_2h,y_n&#43;h\beta_{21}K_1)\\ \dots\\ K_p=f(x_n&#43;\alpha_ph,y_n&#43;h\sum\limits_{i=1}^{p-1}\beta_{pi}K_i) \end{array}\right....</p>
    
  </section>
  <footer class="entry-footer"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>March 11, 2021</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://elderlyaugustus.github.io/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/">数值分析</a></span></span>
</footer>
  <a class="entry-link" aria-label="post link to 2021-03-11-数值分析-Day14-RungeKutta方法-线性多步方法" href="https://elderlyaugustus.github.io/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/page/2/">« Prev Page</a>
    <a class="next" href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/page/4/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
  <span>&copy; 2024 <a href="https://elderlyaugustus.github.io/">xα&#39;s blog</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instantintegrity=""
></script>
</body>

</html>
