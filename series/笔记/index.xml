<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>笔记 on xα&#39;s blog</title>
    <link>https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on xα&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Oct 2022 21:00:00 +0800</lastBuildDate><atom:link href="https://elderlyaugustus.github.io/series/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022-10-23-GAMES104现代游戏引擎-Lecture22-GPU Driven Geometry Pipeline - Nanite</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture22-nanite/</link>
      <pubDate>Sun, 23 Oct 2022 21:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture22-nanite/</guid>
      <description>Lecture22 GPU Driven Geometry Pipeline - Nanite Research Background 传统渲染管线 CPU发起Draw Call，GPU准备State、进入漫长的Pipeline CPU、GPU不同步 存在大量的算力浪费 现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈 “曙光”: Compute Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算 Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh GPU Driven Render Pipeline 将场景完整load到显存中，完全由GPU处理：DrawPrimitive -&amp;gt; DrawScene @《刺客信条：大革命》
Mesh Cluster Rendering 将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算 不可见的Cluster不渲染；Culling流程： 尽可能裁剪掉不可见的三角形 将可见的三角形组成同一个Buffer GPU Driven Pipeline CPU端： 根据材质不同组合Instance 根据相机距离LoD 打包交给GPU做后续处理 GPU Instance Culling Instance Culling 将（64个）Cluster组成一个Chunk，再次Culling，以加速 GPU Cluster Culling Chunk -&amp;gt; Cluster -&amp;gt; Triangle 一步步裁剪，将视锥外、背面的全部裁剪 Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer 三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题 =&amp;gt; 硬件Multi-Indirect Draw Call或可解决此问题 对高精度的Mesh效率非常高 Codec Triangle Visibility in Cube : Backface Culling 每个Cluster存储每个三角形对两个方向的可见性 利用这一数据快速做Backface Culling Occlusion Culling for Camera and Shadow 利用前一帧Z-Buffer的方法： 取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer 将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处 保守估计Culling Instance -&amp;gt; Chunk -&amp;gt; Cluster -&amp;gt; Triangle 问题：高速移动物体存在一定Artifact Two-Phase Occlusion Culling 快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer 再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者 更加准确 Fast Occlusion for Shadow Shadow中生成深度时对几何细节量敏感 对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度 只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer Visibility Buffer Forward Rendering：所有互相遮挡、透明的物体需要做重复计算 Deferred Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算 G-Buffer的存储、IO开销大 复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over draw，多次绘制同一像素时开销大 Visibility Buffer： 第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID, PrimitiveID, MaterialID, …) 根据各种ID读取对应贴图，再做重心坐标插值着色 几乎没有Over Draw Cache Miss率低 Pipeline Visibility Buffer + Deferred Shading 一般来说，草丛等复杂细节情况可直接用Visibility Buffer渲染，主角等主要内容Gather到G-Buffer再渲染 注意点：MIPMAP采样时的插值平滑问题 Virtual Geometry - Nanite Overview Virtual Texture Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图 所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP 预烘焙这张“大贴图”，并做MIPMAP 根据View区域动态加载所需的部分 Idea of Nanite Virtual Geometry like Virtual Texture 挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point Cloud可以Filter） Voxel ?</description>
      <content:encoded><![CDATA[<h2 id="lecture22-gpu-driven-geometry-pipeline---nanite">Lecture22 GPU
Driven Geometry Pipeline - Nanite</h2>
<h3 id="research-background">Research Background</h3>
<h4 id="传统渲染管线">传统渲染管线</h4>
<h4
id="section"><img src="/images/games104/L22_TraditionalRenderPipeline.png" alt="L22_TraditionalRenderPipeline" style="zoom: 25%;" /></h4>
<ul>
<li>CPU发起Draw Call，GPU准备State、进入漫长的Pipeline
<img src="/images/games104/L22_CPUDrivenRenderPipeline.jpg" alt="L22_CPUDrivenRenderPipeline" style="zoom: 50%;" />
<ul>
<li>CPU、GPU不同步</li>
<li>存在大量的算力浪费</li>
</ul></li>
<li>现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈</li>
<li>“曙光”:
<ul>
<li>Compute
Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算
<img src="/images/games104/L22_ComputeShader.jpg" alt="L22_ComputeShader" style="zoom: 33%;" /></li>
<li>Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh
<img src="/images/games104/L22_DrawIndirect.jpg" alt="L22_DrawIndirect" style="zoom: 50%;" /></li>
</ul></li>
</ul>
<h4 id="gpu-driven-render-pipeline">GPU Driven Render Pipeline</h4>
<p>将场景完整load到显存中，完全由GPU处理：DrawPrimitive -&gt; DrawScene
<img src="/images/games104/L22_GPUDrivenRenderPipeline.jpg" alt="L22_GPUDrivenRenderPipeline" style="zoom: 50%;" /></p>
<p>@《刺客信条：大革命》</p>
<h5 id="mesh-cluster-rendering">Mesh Cluster Rendering</h5>
<ul>
<li>将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算</li>
<li>不可见的Cluster不渲染；Culling流程：
<img src="/images/games104/L22_ClusterCulling.jpg" alt="L22_ClusterCulling" style="zoom: 33%;" />
<ul>
<li>尽可能裁剪掉不可见的三角形</li>
<li>将可见的三角形组成同一个Buffer</li>
</ul></li>
</ul>
<h5 id="gpu-driven-pipeline">GPU Driven Pipeline</h5>
<ul>
<li>CPU端：
<ul>
<li>根据材质不同组合Instance</li>
<li>根据相机距离LoD</li>
<li>打包交给GPU做后续处理</li>
</ul></li>
<li>GPU Instance Culling
<ul>
<li>Instance Culling</li>
<li>将（64个）Cluster组成一个Chunk，再次Culling，以加速</li>
</ul></li>
<li>GPU Cluster Culling
<ul>
<li>Chunk -&gt; Cluster -&gt; Triangle
一步步裁剪，将视锥外、背面的全部裁剪</li>
</ul></li>
<li>Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer
<ul>
<li>三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题
=&gt; 硬件Multi-Indirect Draw Call或可解决此问题</li>
<li>对高精度的Mesh效率非常高</li>
</ul></li>
<li>Codec Triangle Visibility in Cube : Backface Culling
<ul>
<li>每个Cluster存储每个三角形对两个方向的可见性</li>
<li>利用这一数据快速做Backface Culling</li>
</ul></li>
</ul>
<h5 id="occlusion-culling-for-camera-and-shadow">Occlusion Culling for
Camera and Shadow</h5>
<ul>
<li>利用前一帧Z-Buffer的方法：
<ul>
<li>取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer</li>
<li>将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处</li>
<li>保守估计Culling Instance -&gt; Chunk -&gt; Cluster -&gt;
Triangle</li>
<li>问题：高速移动物体存在一定Artifact</li>
</ul></li>
<li><strong>Two-Phase Occlusion Culling</strong>
<ul>
<li>快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer</li>
<li>再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者
<img src="/images/games104/L22_TwoPhaseOcclusionCulling.jpg" alt="L22_TwoPhaseOcclusionCulling" style="zoom: 50%;" /></li>
<li>更加准确</li>
</ul></li>
<li><strong>Fast Occlusion for Shadow</strong>
<ul>
<li>Shadow中生成深度时对几何细节量敏感</li>
<li>对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度</li>
<li>只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer
<img src="/images/games104/L22_ShadowOcclusion.jpg" alt="L22_ShadowOcclusion" style="zoom: 33%;" /></li>
</ul></li>
</ul>
<h4 id="visibility-buffer">Visibility Buffer</h4>
<ul>
<li>Forward Rendering：所有互相遮挡、透明的物体需要做重复计算</li>
<li>Deferred
Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算
<img src="/images/games104/L22_DeferredShading.jpg" alt="L22_DeferredShading" style="zoom: 25%;" />
<ul>
<li>G-Buffer的存储、IO开销大</li>
<li>复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over
draw，多次绘制同一像素时开销大</li>
</ul></li>
<li><strong>Visibility Buffer</strong>：
<ul>
<li>第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID,
PrimitiveID, MaterialID, …)</li>
<li>根据各种ID读取对应贴图，再做重心坐标插值着色
<ul>
<li>几乎没有Over Draw</li>
<li>Cache Miss率低</li>
</ul></li>
<li>Pipeline
<img src="/images/games104/L22_VisibilityBuffer.jpg" alt="L22_VisibilityBuffer" style="zoom: 25%;" /></li>
</ul></li>
<li>Visibility Buffer + Deferred Shading
<img src="/images/games104/L22_VisibilityBufferDeferredShading.jpg" alt="L22_VisibilityBufferDeferredShading" style="zoom: 50%;" />
<ul>
<li>一般来说，草丛等复杂细节情况可直接用Visibility
Buffer渲染，主角等主要内容Gather到G-Buffer再渲染</li>
<li>注意点：MIPMAP采样时的插值平滑问题</li>
</ul></li>
</ul>
<h3 id="virtual-geometry---nanite">Virtual Geometry - Nanite</h3>
<h4 id="overview">Overview</h4>
<h5 id="virtual-texture">Virtual Texture</h5>
<ul>
<li>Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图</li>
<li>所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP</li>
<li>预烘焙这张“大贴图”，并做MIPMAP</li>
<li>根据View区域动态加载所需的部分</li>
</ul>
<h5 id="idea-of-nanite">Idea of Nanite</h5>
<ul>
<li><strong>Virtual Geometry</strong> like <strong>Virtual
Texture</strong></li>
<li>挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point
Cloud可以Filter）</li>
<li>Voxel ?
<ul>
<li>数据量非常大</li>
<li>属性Leaking</li>
<li>非常不适合目前的美术工作流</li>
</ul></li>
<li>Subdivision Surface ?
<ul>
<li>需要使用四边形面</li>
<li>Subdivision很难做Downsampling</li>
</ul></li>
<li>Maps-based Method ? 高度图、置换等
<ul>
<li>很难做非常细的几何细节</li>
<li>NVIDIA正在从硬件上做这方面的更多工作，或许还有发展的可能</li>
</ul></li>
<li>Point Cloud ?
<ul>
<li>效果不好</li>
<li>Over Draw</li>
<li>材质如何绑定</li>
</ul></li>
<li>Triangle !
<ul>
<li>绘制三角形数量恰多于屏幕像素数量 1 more triangle per pixel</li>
</ul></li>
</ul>
<h4 id="geometry-representation">Geometry Representation</h4>
<h5 id="cluster-based-lod">Cluster-based LoD</h5>
<ul>
<li>Clusters, 128 Triangles per cluster
<img src="/images/games104/L22_NaniteClusters.png" alt="L22_NaniteClusters" style="zoom: 25%;" /></li>
<li>View Dependent LoD
<img src="/images/games104/L22_NaniteLoD.png" alt="L22_NaniteLoD" style="zoom:25%;" />
用远少于LoD0的Triangle数实现1 more triangle per pixel的精度</li>
<li>Naive Solution
<ul>
<li>Cluster两两合并，减少一半三角形，得到简单的Cluster Hierarchy</li>
<li>根据View得到对Cluster的Cut Line，选择对应精度的Cluster</li>
<li>Like <strong>Virtual Texturing</strong>，流式加载数据</li>
<li>问题：不同Cluster之间的Juction问题
<ul>
<li>锁住Cluster的边：边缘处的Triangle密度过高
<ul>
<li>面片简化利用率不高</li>
<li>密度不均匀，产生画面Artifact（缝合线感）</li>
</ul></li>
</ul></li>
</ul></li>
<li>Nanite Solution
<ul>
<li>Cluster Group
<ul>
<li>将一定数量的Cluster组成一个Group</li>
<li>每个Group选择同样的LoD级别</li>
</ul></li>
<li>在Group内做简化，锁住Group的边</li>
<li>简化后重新生成Cluster
<img src="/images/games104/L22_NaniteClusterGroup.png" alt="L22_NaniteClusterGroup" style="zoom: 33%;" /></li>
<li>每一级LoD，选择不同的Group边锁住
<img src="/images/games104/L22_NaniteAlternateGroupBoundaries.jpg" alt="L22_NaniteAlternateGroupBoundaries" style="zoom: 50%;" />
类似图片降采样时的Jiltering</li>
<li>构建DAG（有向无环图）
<img src="/images/games104/L22_NaniteDAG.png" alt="L22_NaniteDAG" style="zoom:33%;" /></li>
<li>细节：QEM，保证Error计算的精确性，且Error单向向上传递</li>
<li><img src="/images/games104/L22_NaniteLoDPipeline.png" alt="L22_NaniteLoDPipeline" style="zoom: 25%;" />
##### Runtime LoD</li>
</ul></li>
<li>直接在DAG中选择？但直接在DAG中遍历非常复杂</li>
<li>同属于一个Group的Cluster用同样的LoD等级</li>
<li>并行地做View Dependent Cut
<img src="/images/games104/L22_ViewDependentCut.png" alt="L22_ViewDependentCut" style="zoom:25%;" />
<ul>
<li>规则：
<ul>
<li>Parent View Error &gt;= Child View Error</li>
</ul></li>
<li>LoD Cull 判定条件
<ul>
<li>Render : ParentErr &gt; threshold &amp;&amp; ClusterErr &lt;=
threshold</li>
<li>Cull : ParentErr &lt;= threshold || Cluster &gt; threshold</li>
<li>若Parent已经足够精确，则无需再Check Child
<ul>
<li>ParentErr &lt;= threshold</li>
</ul></li>
</ul></li>
</ul></li>
<li>每一个Cluster Group的每一次LoD
Selection是独立的，不会上一级没通过再看下一级</li>
</ul>
<h5 id="bvh-acceleration-for-lod-selection">BVH Acceleration for LoD
Selection</h5>
<ul>
<li>想法核心：把LoD0、LoD1、…每一层LoD独立组成一个BVH，最后再将所有BVH组成一个大的树
<img src="/images/games104/L22_LoDBVH.png" alt="L22_LoDBVH" style="zoom: 33%;" /></li>
<li>方便地取BVH的Bounding，做相机剔除后再Check，节省了非常多计算量</li>
</ul>
<h5 id="hierarchical-culling">Hierarchical Culling</h5>
<p>加速的Trick
<img src="/images/games104/L22_HierarchicalCulling.jpg" alt="L22_HierarchicalCulling" style="zoom: 50%;" /></p>
<h4 id="rendering">Rendering</h4>
<h5 id="software-and-hardware-rasterization">Software and Hardware
Rasterization</h5>
<ul>
<li>硬件光栅化：光栅化单元是2*2的Quad（为了算ddx和ddy），用4*4的Tile遍历加速，剔除不参与渲染的Tile</li>
<li>Triangle小到1个pixel的大小时 —— 上述优化均失效</li>
<li><strong>软件光栅化</strong>：
<ul>
<li>Compute Shader直接接管小三角形的光栅化</li>
<li>若三角形小于1pixel，则直接给pixel着色</li>
<li>直接通过三角形的UV算ddx、ddy，不用Tile计算</li>
<li>若三角形边长小于18pixel，则使用软件光栅化（Scanline），反之回到硬件光栅化</li>
<li><strong>深度测试</strong>：存储64bit的atomic数据 —— 32bit Depth +
25bit Visible Cluster Index + 7bit Triangle Index （<strong>Visibility
Buffer</strong>）</li>
</ul></li>
<li>硬件光栅化</li>
<li><strong>Imposter</strong>：对足够远、足够小的Instance，生成12*12个方向的的12*12大小的各种贴图（Aldobe、Normal、…）</li>
<li>Overdraw：
<ul>
<li>没有逐像素剔除</li>
<li>没有硬件HiZ像素剔除</li>
<li>软件HZB来自上一帧</li>
<li>大Cluster、重叠Cluser、聚合、快速移动等带来的Overdraw</li>
<li>…</li>
</ul></li>
<li>期待硬件支持更完善，不要用软件Trick完成这些ideas</li>
</ul>
<h5 id="deferred-materials">Deferred Materials</h5>
<ul>
<li>早期：
<ul>
<li>将每个Material ID转换为一个Depth值，记录为一张Depth Buffer</li>
<li>扫描整张Buffer，判断Depth与Material
ID相等时，用对应Material绘制</li>
<li>消耗较大</li>
</ul></li>
<li>Tiled Based的思想
<ul>
<li>将全屏幕分为多个Tile，标记每个材质是否在Tile中出现</li>
<li>在逐材质扫描整张Buffer时，可以直接跳过没有该材质的Tile</li>
</ul></li>
</ul>
<h4 id="shadow">Shadow</h4>
<ul>
<li>Shadow Casting的精度要求很高</li>
<li>Ray Trace？ Nanite几何表达无法兼容</li>
<li><strong>Cascaded Shadow Map</strong> 具体略 本质：View-dependent
Sampling</li>
<li><strong>Sample Distribution Shadow Maps</strong> 相当于将Cascaded
Shadow Maps中重复的、视锥外的像素去除的Shadow Maps</li>
<li>Shadow Map的本质：根据相机视空间的精度，采样光空间</li>
</ul>
<h5 id="virtual-shadow-map---a-cached-shadow-system">Virtual Shadow Map
- A Cached Shadow System</h5>
<ul>
<li>核心思想：将Shadow
Map切成足够小的块，确保每一小块与视空间的采样率高度一直，且只更新产生光照变化的块</li>
<li>实际：给每个光源一张16k的VSM（点光源为6个方向的6张），仅可见像素会被Cache</li>
<li>相机运动、光照几何变化时，更新部分Tile即可</li>
</ul>
<h4 id="streaming-and-compression">Streaming and Compression</h4>
<h5 id="streaming">Streaming</h5>
<ul>
<li>流送的核心：只Load需要的数据到内存中</li>
<li>构建成逐个Page，动态加载</li>
</ul>
<h5 id="compression">Compression</h5>
<ul>
<li>内存数据：Quantization
<ul>
<li>浮点变定点等</li>
</ul></li>
<li>硬盘数据
<ul>
<li>LZ Compression</li>
<li>显存加载自动解压缩</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-23-GAMES104现代游戏引擎-Lecture21-Dynamic Global Illumination and Lumen</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture21-lumen/</link>
      <pubDate>Sun, 23 Oct 2022 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture21-lumen/</guid>
      <description>Lecture21 Dynamic Global Illumination and Lumen Part I Dynamic Global Illumination Global Illumination - 略 Reflective Shadow Maps, RSM - 略 低分辨率间接光照加速：
计算低分辨率间接光照 对全分辨率图像的每个像素 获得周围四个低分辨率采样 通过法线和世界坐标位置判断，采样间差异过大时剔除 双线性插值 以全分辨率重新计算剔除的像素 Light Propagation Volumes, LPV - 略 Sparse Voxel Octree for Real-time Global Illumination, SVOGI 如何组织voxel的分布？
硬件保守光栅化：对很小的三角形，保证其至少有一个voxel 八叉树存储 Shading with Cone Tracing in Voxel Tree 着色点根据BRDF发射Diffuse和Specular的Cone 根据Cone尺寸查询树结构获取光照 - 非常适合Hierarchy结构存储的光照数据 NVIDIA的工作，GPU表达非常复杂 Voxelization Based Global Illumination, VXGI 更关注相机视锥内的区域、更关注近处的区域 Clipmap，voxel版的Mipmap 利用Clipmaps存储voxel数据 重心区域使用更高分辨率voxel 更适合Cone Tracing 建构简单、读取简单、GPU Friendly… Voxel Update：空间网格位置固定，只需要更新相机周围的Voxel Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向 对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine Specular） 问题： 错误的遮挡关系，简单使用Opacity来表示 Light Leaking：遮挡物薄于Voxel时 Screen Space Global Illumination, SSGI Reuse screen space data &amp;lt;- Screen Space Reflection, SSR SSR：单根光线，构建反射 -&amp;gt; 多方向多根光线，构建GI 对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记 Reuse近邻像素 做Cone Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering 优势：快，质量高，没有遮挡问题 问题：缺少屏外信息，重用近邻像素带来的错误Visibility 独特优势： 易于处理非常近的接近阴影 准确的Hit点计算 对场景复杂度不敏感 可以处理动态物体 Part II Lumen Real-time Ray Tracing的问题：</description>
      <content:encoded><![CDATA[<h2 id="lecture21-dynamic-global-illumination-and-lumen">Lecture21
Dynamic Global Illumination and Lumen</h2>
<h3 id="part-i-dynamic-global-illumination">Part I Dynamic Global
Illumination</h3>
<h4 id="global-illumination---略">Global Illumination - 略</h4>
<h4 id="reflective-shadow-maps-rsm---略">Reflective Shadow Maps, RSM -
略</h4>
<p><strong>低分辨率间接光照加速</strong>：</p>
<ul>
<li>计算低分辨率间接光照</li>
<li>对全分辨率图像的每个像素
<ul>
<li>获得周围四个低分辨率采样</li>
<li>通过法线和世界坐标位置判断，采样间差异过大时剔除</li>
<li>双线性插值</li>
</ul></li>
<li>以全分辨率重新计算剔除的像素</li>
</ul>
<h4 id="light-propagation-volumes-lpv---略">Light Propagation Volumes,
LPV - 略</h4>
<h4
id="sparse-voxel-octree-for-real-time-global-illumination-svogi">Sparse
Voxel Octree for Real-time Global Illumination, SVOGI</h4>
<p>如何组织voxel的分布？</p>
<ul>
<li>硬件保守光栅化：对很小的三角形，保证其至少有一个voxel</li>
<li>八叉树存储</li>
<li><strong>Shading with Cone Tracing in Voxel Tree</strong>
<ul>
<li>着色点根据BRDF发射Diffuse和Specular的Cone</li>
<li>根据Cone尺寸查询树结构获取光照 -
非常适合Hierarchy结构存储的光照数据</li>
</ul></li>
<li>NVIDIA的工作，GPU表达非常复杂</li>
</ul>
<h4 id="voxelization-based-global-illumination-vxgi">Voxelization Based
Global Illumination, VXGI</h4>
<ul>
<li>更关注相机视锥内的区域、更关注近处的区域</li>
<li>Clipmap，voxel版的Mipmap
<img src="/images/games104/L21_Clipmap.jpg" alt="L21_Clipmap" style="zoom: 50%;" />
利用Clipmaps存储voxel数据
<ul>
<li>重心区域使用更高分辨率voxel
<img src="/images/games104/L21_VXGI.jpg" alt="L21_VXGI" style="zoom: 67%;" /></li>
<li>更适合Cone Tracing</li>
</ul></li>
<li>建构简单、读取简单、GPU Friendly…</li>
<li><strong>Voxel
Update</strong>：空间网格位置固定，只需要更新相机周围的Voxel</li>
<li>Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向</li>
<li>对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine
Specular）
<img src="/images/games104/L21_VXGIConeTracing.png" alt="L21_VXGIConeTracing" style="zoom: 25%;" /></li>
<li>问题：
<ul>
<li>错误的遮挡关系，简单使用Opacity来表示</li>
<li><strong>Light Leaking</strong>：遮挡物薄于Voxel时</li>
</ul></li>
</ul>
<h4 id="screen-space-global-illumination-ssgi">Screen Space Global
Illumination, SSGI</h4>
<ul>
<li>Reuse screen space data &lt;- Screen Space Reflection, SSR</li>
<li>SSR：单根光线，构建反射 -&gt; 多方向多根光线，构建GI</li>
<li>对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记</li>
<li>Reuse近邻像素
<img src="/images/games104/L21_SSGIReuseNeighbor.jpg" alt="L21_SSGIReuseNeighbor" style="zoom: 25%;" /></li>
<li>做Cone
Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering</li>
<li>优势：快，质量高，没有遮挡问题</li>
<li>问题：缺少屏外信息，重用近邻像素带来的错误Visibility</li>
<li>独特优势：
<ul>
<li>易于处理非常近的接近阴影</li>
<li>准确的Hit点计算</li>
<li>对场景复杂度不敏感</li>
<li>可以处理动态物体</li>
</ul></li>
</ul>
<h3 id="part-ii-lumen">Part II Lumen</h3>
<p>Real-time Ray Tracing的问题：</p>
<ul>
<li>1/2 ray per pixel</li>
<li>Sampling</li>
</ul>
<p><strong>Idea：低分辨率的屏幕空间的Probe，采样简介光照</strong></p>
<h4 id="phase-1-fast-ray-trace-in-any-hardware">Phase 1 : Fast Ray Trace
in Any Hardware</h4>
<h5 id="signed-distance-function-sdf">Signed Distance Function, SDF</h5>
<ul>
<li>Per-Mesh SDF 对每个Mesh构建SDF，所有SDF组合成场景
<ul>
<li>对于薄于SDF分辨率的Mesh，将其加厚</li>
</ul></li>
<li>Ray Tracing with SDF
<img src="/images/games104/L21_SDFSphereTracing.jpg" alt="L21_SDFSphereTracing" style="zoom: 50%;" /></li>
<li>Cone Tracing with SDF (eg. SDF Soft Shadow)
<img src="/images/games104/L21_SDFConeTracing1.jpg" alt="L21_SDFConeTracing1" style="zoom: 80%;" /><img src="/images/games104/L21_SDFConeTracing2.png" alt="L21_SDFConeTracing2" style="zoom: 25%;" /></li>
<li>对SDF稀疏化存储，但可能导致Raymarch迭代步长变长
<img src="/images/games104/L21_SDFSparse.jpg" alt="L21_SDFSparse" style="zoom: 67%;" /></li>
<li>对SDF做LoD</li>
<li>SDF可导，导数为法线方向</li>
<li>可以根据相机远近方便地切换SDF分辨率</li>
</ul>
<h5 id="从mesh-sdf合成低分辨率的场景的global-sdf">从Mesh
SDF合成低分辨率的场景的Global SDF</h5>
<ul>
<li>场景Tracing非常快</li>
<li>精度相对低</li>
<li>在Lumen中结合对Global SDF的Tracing和对Mesh SDF的Tracing</li>
<li>4 Clipmaps Global SDF, 根据相机距离</li>
</ul>
<h4 id="phase-2-radiance-injection-and-caching">Phase 2 : Radiance
Injection and Caching</h4>
<h5 id="mesh-card">Mesh Card</h5>
<ul>
<li>为场景中的Mesh“拍快照”，对六个面采样
<img src="/images/games104/L21_MeshCard.png" alt="L21_MeshCard" style="zoom: 25%;" /></li>
<li>对场景以AABB方式生成
<img src="/images/games104/L21_MeshCardScene.jpg" alt="L21_MeshCardScene" style="zoom: 67%;" /></li>
<li>对每个Card，存储其六个面的：
<ul>
<li>Albedo</li>
<li>Normal</li>
<li>Depth</li>
<li>Emissive</li>
<li>…</li>
</ul></li>
<li>根据物体大小、相机远近，对Card应用不同的分辨率</li>
</ul>
<h5 id="surface-cache">Surface Cache</h5>
<ul>
<li>从Mesh Card生成Surface Cache
<img src="/images/games104/L21_SurfaceCache.jpg" alt="L21_SurfaceCache" style="zoom: 67%;" />
<ul>
<li>Pass 1 : Card capture</li>
<li>Pass 2 : Copy cards to Surface Cache and compress</li>
</ul></li>
<li>“Freeze” lighting on Surface Cache
<ul>
<li>Surface Cache上的像素是否在阴影中？ 如何处理多次Bounce？</li>
<li>Lighting Cache Pipeline 最终生成<strong>Surface Cache Final
Lighting</strong>
<img src="/images/games104/L21_LightingCachePipeline.png" alt="L21_LightingCachePipeline" style="zoom: 25%;" />
计算当前帧的一次Bounce，利用前一帧的一次Bounce作为次级光源照亮场景，则相当于二次Bounce，依次累计，相当于同一场景下Bounce越积越多（Temporal思路）</li>
<li><strong>1. Direct Lighting</strong>
<img src="/images/games104/L21_DirectLighting.png" alt="L21_DirectLighting" style="zoom: 25%;" />
<ul>
<li>直接累加多光源</li>
<li>对近处物体，直接取得精确的Instance，从Surface Cache上计算光照</li>
<li>对远处物体，因为Global
SDF无法标记具体Instance，则对全场景光照做Voxelize表达，建构Clipmaps，对每个Voxel存储六个面的光照</li>
</ul></li>
<li><strong>2. World Space Voxel Lighting</strong>
<ul>
<li>由Final
Lighting照亮计算得到的Voxel光照存储，用于下一帧的间接光照计算</li>
<li>与后面会提到的Light
Probe区分：只存储Voxel六个面的亮度（被照亮的亮度）</li>
</ul></li>
<li><strong>3. Surface Cache Indirect Lighting</strong>
<ul>
<li>Light Probe</li>
<li>用SH存储间接光照，方便做插值</li>
</ul></li>
<li><strong>Combine Lighting</strong> FinalLighting = (DirectLighting +
InDirectLighting) * Diffuse_Lambert(Albedo) + Emissive</li>
<li>光照更新策略，保障性能开销稳定
<ul>
<li>固定的更新预算</li>
<li>桶排序更新优先级</li>
</ul></li>
</ul></li>
</ul>
<h4 id="phase-3-build-a-lot-of-probes-with-different-kinds">Phase 3 :
Build a lot of Probes with Different Kinds</h4>
<h5 id="screen-space-probe">Screen Space Probe</h5>
<ul>
<li>只在Screen Space分布Probe，每16*16像素一个</li>
<li>Octahedron Mapping，使用8*8的Texture存储Probe
<img src="/images/games104/L21_OctahedronMapping.png" alt="L21_OctahedronMapping" style="zoom: 33%;" />
<img src="/images/games104/L21_OctahedronMappingCode.jpg" alt="L21_OctahedronMappingCode" style="zoom: 33%;" /></li>
<li>对于高频细节部分，进一步细化增加Probe，至8*8或4*4每个
<ul>
<li>判定是否需要增加Probe
<ul>
<li>Probe之间很近、着色点之间实际距离较远时（深度差异过大）</li>
<li>取一些着色点，邻近四个Probe作着色点法平面投影，投影距离的权重超出阈值时，判定为无效采样，增加Probe</li>
</ul></li>
<li>Screen Probe Atlas
<img src="/images/games104/L21_ScreenProbeAtlas.png" alt="L21_ScreenProbeAtlas" style="zoom: 25%;" />
依次往下存储，因此不会造成过多额外开销</li>
</ul></li>
</ul>
<h5 id="importance-sampling">Importance Sampling</h5>
<ul>
<li><p>蒙特卡罗采样： <span class="math display">\[
\lim_{N\to\infty}\dfrac{1}{N}\sum_{k=1}^{N}\dfrac{L_i(l)f_s(l\to
v)\cos(\theta l)}{P_k}
\]</span> 重要性采样即取 <span class="math inline">\(P_k\)</span>
使其尽可能符合分子分布</p>
<ul>
<li>对光源：尽可能符合 <span class="math inline">\(L_i\)</span>
分布</li>
<li>对BRDF：尽可能符合 <span class="math inline">\(f_s\)</span>
分布</li>
</ul></li>
<li><p>对光源做重要性采样，如何估计光源</p>
<ul>
<li>利用前一帧的光照数据</li>
<li>对前一帧邻近四个Probe的Radiance做插值</li>
<li>若邻近Probe被遮挡则fallback到世界空间Probe</li>
<li>得到插值后8*8的光照分布，作为Light PDF</li>
</ul></li>
<li><p>对BRDF的法线分布做重要性采样</p>
<ul>
<li>法线分布不能用高频的着色点Normal指代</li>
<li>在32*32范围内取64点采样，保证深度权重的情况下，将每个Normal的SH累加得到法线分布，作为BRDF
PDF</li>
</ul></li>
<li><p><strong>Structured Importance Sampling</strong></p>
<ul>
<li>每个Probe采样64根ray</li>
<li>将BRDF PDF与Lighting PDF卷积，得到重要的采样方向</li>
<li>对重要的方向做Supersampling，对不重要的方向忽略
<img src="/images/games104/L21_ImportanceSampling.png" alt="L21_ImportanceSampling" style="zoom: 25%;" /></li>
</ul></li>
</ul>
<h5 id="denoising-and-spatial-probe-filtering">Denoising and Spatial
Probe Filtering</h5>
<ul>
<li>取Probe周围3*3，做filtering</li>
<li>但不同Probe的ray方向不同时，差异过大 -&gt;
判断，若邻近Probe的ray着色点与当前Probe连线，与当前ray角度差大于阈值（10°）时则丢弃不用
<img src="/images/games104/L21_ProbeFiltering1.png" alt="L21_ProbeFiltering1" style="zoom: 25%;" /></li>
<li>邻近Probe的ray方向接近时，但Hit点差异过大 -&gt; Clamp ray深度
<img src="/images/games104/L21_ProbeFiltering2.png" alt="L21_ProbeFiltering2" style="zoom: 25%;" /></li>
</ul>
<h5 id="world-space-radiance-cache">World Space Radiance Cache</h5>
<ul>
<li>Screen Space Probe采样较近的物体</li>
<li>World Space预先放置Probe，记录远处光照，Screen
Space在采样远处时直接读取World Space Probe
<img src="/images/games104/L21_WorldSpaceRadianceCache.png" alt="L21_WorldSpaceRadianceCache" style="zoom: 25%;" /></li>
<li>Clipmaps存储，分布分辨率48*48*48，每个Probe Atlas分辨率32*32</li>
<li>连接Screen Space Probe和World Space Probe的ray
<ul>
<li>取Screen Space Probe邻近8个World Space Probe，距离权重插值。
<img src="/images/games104/L21_ConnectRays.png" alt="L21_ConnectRays" style="zoom: 25%;" />
（Cube半径两倍范围内已采样，向更远处raycast时可以skip这段距离）</li>
<li>插值后产生与原方向的偏差，跳过遮挡物，产生漏光
<img src="/images/games104/L21_ConnectRaysLeaking1.png" alt="L21_ConnectRaysLeaking1" style="zoom: 25%;" />
球面parallax，如图修改光线，导致光线转弯，但Hack可接受
<img src="/images/games104/L21_ConnectRaysLeaking2.png" alt="L21_ConnectRaysLeaking2" style="zoom: 25%;" /></li>
<li>World Space Probe当且仅当有Screen Space
Probe有采样需求时，才做Trace并更新光照</li>
</ul></li>
</ul>
<h4 id="phase-4-shading-full-pixels-with-screen-space-probes">Phase 4 :
Shading Full Pixels with Screen Space Probes</h4>
<h5 id="将probe-radiance转换为三阶sh">将Probe Radiance转换为三阶SH</h5>
<ul>
<li>相当于对Radiance做低通滤波，效果更柔和</li>
<li>SH积分更快速友好，质量也更高</li>
<li>最后利用SH着色</li>
</ul>
<h4 id="overall-performance-and-result">Overall, Performance and
Result</h4>
<ul>
<li>核心思想：利用对不同数据结构、不同采样对象做Ray
Tracing的硬件开销不一样
<img src="/images/games104/L21_SpeedOfDifferentTracingMethods.jpg" alt="L21_SpeedOfDifferentTracingMethods" style="zoom: 67%;" /></li>
<li>根据具体情况应用不同的方式
<img src="/images/games104/L21_LumenOverall1.png" alt="L21_LumenOverall1" style="zoom: 25%;" /></li>
<li>Fallback过程
<img src="/images/games104/L21_LumenOverall2.png" alt="L21_LumenOverall2" style="zoom: 50%;" /></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-22-GAMES104现代游戏引擎-Lecture16-Gameplay Systems - Basic Artificial Intelligence</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture16-gameplaybasicartificialintelligence/</link>
      <pubDate>Sat, 22 Oct 2022 21:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture16-gameplaybasicartificialintelligence/</guid>
      <description>PS: Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记
Lecture16 Gameplay Systems - Basic Artificial Intelligence Navigation 三个步骤： Map Representation 地图表达 Walkable Area
需要考虑：
Physical Collision Climbing Slope/Height Jumping Distance … 难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI Agents和Player的可行区域相同
Waypoint Network
路网，类似地铁线路图 寻找最近的路点 易于实现，快速寻路不够灵活，路网需要手工标注 Grid
Square / Triangle / Hexagon 其中Square相对易于存储 易于实现、均匀数据结构、动态可更新 精确性依赖分辨率 密集网格降低寻路性能 内存消耗大 难以处理3D地图（桥梁、隧道等） Navigation Mesh
用简化的凸多边形表示场景 若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域 优势：
支持3D可行区域 精确 快速寻路 灵活选择起始地、目的地 动态 缺陷：
复杂的生成算法 不支持3D空间，例如空中飞行 Sparse Voxel Octree
空间八叉树 存储量大 寻路复杂 Path Finding 寻找路径 所有表达，都可归为图结构
即在图上找到一个路径，尽可能找到最优（短）路径
深度优先搜索 / 广度优先搜索 消耗比较高，广度优先适合找到最短路径</description>
      <content:encoded><![CDATA[<blockquote>
<p>PS:
Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记</p>
</blockquote>
<h3
id="lecture16-gameplay-systems---basic-artificial-intelligence">Lecture16
Gameplay Systems - Basic Artificial Intelligence</h3>
<h4 id="navigation">Navigation</h4>
<p>三个步骤：
<img src="/images/games104/L16_NavigationSteps.png" alt="L16_NavigationSteps" style="zoom: 25%;" /></p>
<h5 id="map-representation-地图表达">Map Representation 地图表达</h5>
<ul>
<li><p>Walkable Area</p>
<ul>
<li><p>需要考虑：</p>
<ul>
<li>Physical Collision</li>
<li>Climbing Slope/Height</li>
<li>Jumping Distance</li>
<li>…</li>
</ul>
<p>难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI
Agents和Player的可行区域相同</p></li>
<li><p>Waypoint Network</p>
<ul>
<li>路网，类似地铁线路图
<img src="/images/games104/L16_WaypointNetwork.png" alt="L16_WaypointNetwork" style="zoom: 25%;" /></li>
<li>寻找最近的路点</li>
<li>易于实现，快速寻路不够灵活，路网需要手工标注</li>
</ul></li>
<li><p>Grid</p>
<ul>
<li>Square / Triangle / Hexagon 其中Square相对易于存储</li>
<li><img src="/images/games104/L16_GridPathFinding.gif" alt="L16_GridPathFinding" style="zoom: 33%;" /></li>
<li>易于实现、均匀数据结构、动态可更新</li>
<li>精确性依赖分辨率</li>
<li>密集网格降低寻路性能</li>
<li>内存消耗大</li>
<li>难以处理3D地图（桥梁、隧道等）</li>
</ul></li>
<li><p>Navigation Mesh</p>
<ul>
<li><p>用简化的凸多边形表示场景
<img src="/images/games104/L16_NavMesh.jpg" alt="L16_NavMesh" style="zoom:33%;" /></p>
<blockquote>
<p>若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域
<img src="/images/games104/L16_NavMeshConvex.png" alt="L16_NavMeshConvex" style="zoom:25%;" /></p>
</blockquote></li>
<li><p>优势：</p>
<ul>
<li>支持3D可行区域</li>
<li>精确</li>
<li>快速寻路</li>
<li>灵活选择起始地、目的地</li>
<li>动态</li>
</ul></li>
<li><p>缺陷：</p>
<ul>
<li>复杂的生成算法</li>
<li>不支持3D空间，例如空中飞行</li>
</ul></li>
</ul></li>
<li><p>Sparse Voxel Octree</p>
<ul>
<li>空间八叉树</li>
<li>存储量大</li>
<li>寻路复杂</li>
</ul></li>
</ul></li>
</ul>
<h5 id="path-finding-寻找路径">Path Finding 寻找路径</h5>
<ul>
<li><p>所有表达，都可归为图结构</p></li>
<li><p>即在图上找到一个路径，尽可能找到最优（短）路径</p></li>
<li><p>深度优先搜索 / 广度优先搜索
消耗比较高，广度优先适合找到最短路径</p></li>
<li><p>Dijkstra Algorithm</p>
<pre class="pseudocode"><code>for each vertex v:
  dist[v] = ∞
  prev[v] = none
dist[source] = 0
set all vertices to unexplored
while destination not explored:
  v = least - valued unexplored vertex
  set v to explored
  for each edge(v, w):
      if dist[v] +len(v, w) &lt; dist[w]:
          dist[w] = dist[v] + len(v, w)
          prev[w] = v</code></pre></li>
<li><p>A Star （A*） 一种启发式算法，不用精确的最短路径</p>
<ul>
<li>启发函数：预估当前点到终点的距离 <span
class="math inline">\(h(n)\)</span>
<ul>
<li>例如：欧拉距离 / 曼哈顿距离</li>
<li><span class="math inline">\(h(n)\)</span> 的精确性影响性能表现</li>
</ul></li>
<li>则每一个当前点消耗为 <span class="math inline">\(f(n)= g(n) +
h(n)\)</span></li>
<li>优先搜索 <span class="math inline">\(f(n)\)</span> 最小的情况</li>
<li>走到终点就停止，不追求完全最短</li>
</ul></li>
</ul>
<h5 id="path-smoothing-路径平滑">Path Smoothing 路径平滑</h5>
<ul>
<li>Funnel Algorithm
<ul>
<li>“走路时看前面”</li>
<li>当前点和所在三角形两端点组成一个扇形（漏斗，Funnel），下一个目标点是否在扇形中，来决定行走路线</li>
<li>寻找扇形两端点比较复杂</li>
</ul></li>
</ul>
<h5 id="navmesh-generation">NavMesh Generation</h5>
<ul>
<li>先将整个场景体素化</li>
<li>Region Segmentation
<ul>
<li>寻找Edge Voxel，生成Distance
Field，找到区块的中心区域（离Edge最远的）</li>
<li>”洪水“算法，类似Voroni算法，找到空间划分</li>
<li>处理Overlap问题</li>
</ul></li>
<li>生成分割区域，凸多边形</li>
<li>可以为不同的凸多边形打上不同的标记 Polygon Flag
<ul>
<li>AI寻路逻辑</li>
<li>AI移动速度</li>
<li>…</li>
</ul></li>
</ul>
<h5 id="advanced-features">Advanced Features</h5>
<ul>
<li>基于Tile的分区域NavMesh，易于更新</li>
<li>Off-Mesh Link建立不同Mesh之间的连接，手动，实现攀爬等动作</li>
</ul>
<h4 id="steering-转向系统">Steering 转向系统</h4>
<p>寻路中，车辆无法严格执行路径（受到物理限制），需要转向系统</p>
<ul>
<li>Seek / Flee 追着目标点
<ul>
<li>Pursue 追踪</li>
<li>Path Following</li>
<li>Wander</li>
<li>Flow Field Following 方向场</li>
</ul></li>
<li>Velocity Match
<ul>
<li>目标点速度，反向算每步加速度</li>
</ul></li>
<li>Align 保证朝向一致
<ul>
<li>目标点角速度，反向算每步角加速度</li>
</ul></li>
</ul>
<h4 id="crowd-simulation-群集模拟">Crowd Simulation 群集模拟</h4>
<p>参考《基于物理的动画-粒子系统》</p>
<ul>
<li>“Boids”</li>
<li>三种力
<ul>
<li>Separation</li>
<li>Cohesion</li>
<li>Alignment</li>
</ul></li>
<li>行人，沿着一定的Line运动</li>
<li>避障、避免碰撞</li>
<li>对每个个体做寻路消耗非常大 —— Distance Field</li>
</ul>
<h5 id="velocity-based-models">Velocity-based Models</h5>
<ul>
<li>核心想法：个体相遇时，产生速度的障碍，调整速度</li>
<li><strong>Reciprocal Velocity Obstacle</strong></li>
<li>两个以上个体相遇时产生冲突，如何优化？ <strong>Optimal Reciprocal
Collision Avoidance</strong></li>
<li>结果最优，但开销大，根据需求自主选择（基于力的方式效果较差但开销小）</li>
</ul>
<h4 id="sensing-or-perception">Sensing or Perception</h4>
<ul>
<li>AI所获得的信息
<ul>
<li>内部：位置、HP、子弹、Buff等</li>
<li>外部：
<ul>
<li>静态空间信息
<ul>
<li>Navigation Data</li>
<li>Tactical Map 战术地图（更具有战术价值的位置）</li>
<li>Smart Object eg.可打破的墙等</li>
<li>Cover Point 掩体点</li>
<li>…</li>
</ul></li>
<li>动态空间信息
<ul>
<li>Influence Map 战场态势感知的热力图，避开危险系数高的区域</li>
<li>Navigation Data上更新的标记</li>
<li>Sight Area 视野区域</li>
<li>…</li>
</ul></li>
<li>Game Object</li>
</ul></li>
</ul></li>
<li>Sensing Simulation 模仿人类的感知
<ul>
<li>考虑开销</li>
<li>共享Influence Map等方式</li>
</ul></li>
<li>引擎侧提供充足的接口和自定义性</li>
</ul>
<h4 id="classic-decision-making-algorithms">Classic Decision Making
Algorithms</h4>
<ul>
<li><strong>Finite State Machine</strong></li>
<li><strong>Behavior Tree</strong></li>
<li>Hierarchical Tasks Network</li>
<li>Goal Oriented Action Planning</li>
<li>Monte Carlo Tree Search</li>
<li>Deep Learning</li>
</ul>
<h5 id="finite-state-machine">Finite State Machine</h5>
<p><img src="/images/games104/L16_FiniteStateMachine.png" alt="L16_FiniteStateMachine" style="zoom:20%;" /></p>
<ul>
<li>State</li>
<li>Transition</li>
<li>Condition</li>
<li>问题：
<ul>
<li>复杂情形下State过于多，网络过于复杂</li>
<li>解决方法：Hierarchical Finite State Machine
<img src="/images/games104/L16_HierarchicalFiniteStateMachine.png" alt="L16_HierarchicalFiniteStateMachine" style="zoom:15%;" />
子状态之间切换变得复杂</li>
</ul></li>
</ul>
<h5 id="behavior-tree">Behavior Tree</h5>
<ul>
<li>状态机是对AI逻辑的抽象，并不符合人的知觉系统</li>
<li>将AI的行为Pattern从状态机的“飞线”转换为更符合人的<strong>决策树</strong>结构</li>
<li>Execution Node 执行节点（叶子节点）：
<ul>
<li>Condition Node 条件节点</li>
<li>Action Node 动作节点 三种状态：
<ul>
<li>Success</li>
<li>Failure</li>
<li>Running</li>
</ul></li>
</ul></li>
<li>Control Node
<ul>
<li>Sequence 依次执行</li>
<li>Selector
按优先级选择执行：A不行执行B，B不行执行C，有一个可执行就继续执行下去
<img src="/images/games104/L16_BTSelector.png" alt="L16_BTSelector" style="zoom:20%;" /></li>
<li>Parallel 并行执行</li>
<li>Decorator 修饰器，例如增加延时等</li>
</ul></li>
<li>如何Tick行为树？
<ul>
<li>每一次从根节点开始Tick，防止动作保持在某一叶子节点</li>
<li>行为树同时在Running的节点不一定只有一个</li>
</ul></li>
<li>Blackboard 记录环境变量，环境信息，与Gameplay交换信息的介质</li>
<li>缺点：Tick的消耗较大</li>
</ul>
<h4 id="upcoming-ai-planning-and-goals">Upcoming: AI Planning and
Goals</h4>
<p>上述提到的AI方法，均为条件-执行逻辑，AI是没有计划和目的的，期待下一课…</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-22-GAMES104现代游戏引擎-Lecture15-Gameplay Complexity and Building Blocks</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture15-gameplaycomplexityandbuildingblocks/</link>
      <pubDate>Sat, 22 Oct 2022 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture15-gameplaycomplexityandbuildingblocks/</guid>
      <description>Lecture15 Gameplay Complexity and Building Blocks Overview Gameplay的挑战 多个系统之间的合作 同一个游戏中Gameplay的多样性 快速迭代 Event Mechanism Hard Code写在函数中：无数的if/else、非常难以修改 Event/Message Mechanism：GO之间的“通讯协议” Publish-subscribe Pattern 发行-订阅设计模式 Event Definition 信息的定义 方法1：Event作为类设计 -&amp;gt; 不适合交给设计师修改 方法2：允许定义任意的Event 再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦 在引擎核心代码之外定义 dll注入 用脚本层语言实现 Callback Registration 响应注册 注册和调用不在同一处 –&amp;gt; 对象的生命周期和回调函数安全性问题 Strong Reference 强引用：引用关系绑定 Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多 Event Dispatching 信息分发 遍历每个GO，逐个分发调用函数 —— 效率过低 Immediate：发送消息立即调用函数 会打断前一任务，等待Callback执行后再继续 单次打断引发连锁Callback，易导致Callstack非常深，难以Debug 难以并行 Event Queue 把Event存储至队列，依次执行 Event Queue的序列化和反序列化 实现：利用反射，获取每个对象的描述结构 存储结构：Ring Buffer 不用重复申请新内存 Batching，将多个独立系统分开处理 问题： 无法保证多个系统间的执行顺序 =&amp;gt; 保留一定的Immediate处理能力 同时具备Pre、Post、Immediate处理方式 有系统延迟，削弱动作游戏打击感 =&amp;gt; 经常Hardcode绕过Delay Script System Game Logic 直接在游戏引擎代码内，使用编译语言编写 （C/C++） 每次修改Gameplay，需要重新编译游戏引擎 极难支持热更新 对设计师极不友好 脚本语言 Script System 支持快速迭代 易于学习、编写 支持热更新 沙盒运行，稳定、更少Crash 如何运行 基于虚拟机 Script Text -&amp;gt; [Compiler] -&amp;gt; Bytecode [Virtual Machine] 速度略慢 如何管理GO 强调效率：引擎内核管理，脚本触发引擎执行 编写难度大 执行过程非常复杂 直接交给脚本系统管理 脚本如何处理GO的生命周期：GC, Garbage Collection 优势：不需要手动管理对象生命周期，自动处理 问题：每次需要扫描内存，处理效率低 对于玩法相对简单的单机游戏，大多交给引擎管理； MMORPG等玩法非常复杂的游戏，大多脚本系统管理 架构 引擎调用脚本 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture15-gameplay-complexity-and-building-blocks">Lecture15
Gameplay Complexity and Building Blocks</h3>
<h4 id="overview">Overview</h4>
<ul>
<li>Gameplay的挑战
<ul>
<li>多个系统之间的合作</li>
<li>同一个游戏中Gameplay的多样性</li>
<li>快速迭代</li>
</ul></li>
</ul>
<h4 id="event-mechanism">Event Mechanism</h4>
<ul>
<li>Hard Code写在函数中：无数的if/else、非常难以修改</li>
<li><strong>Event/Message Mechanism：GO之间的“通讯协议”</strong>
Publish-subscribe Pattern 发行-订阅设计模式
<ul>
<li>Event Definition 信息的定义
<ul>
<li>方法1：Event作为类设计 -&gt; 不适合交给设计师修改</li>
<li>方法2：允许定义任意的Event
<ul>
<li>再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦</li>
<li>在引擎核心代码之外定义
<ul>
<li>dll注入</li>
<li>用脚本层语言实现</li>
</ul></li>
</ul></li>
</ul></li>
<li>Callback Registration 响应注册
<ul>
<li>注册和调用不在同一处 –&gt; 对象的生命周期和回调函数安全性问题
<ul>
<li>Strong Reference 强引用：引用关系绑定</li>
<li>Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多</li>
</ul></li>
</ul></li>
<li>Event Dispatching 信息分发
<ul>
<li>遍历每个GO，逐个分发调用函数 —— 效率过低</li>
<li>Immediate：发送消息立即调用函数
<ul>
<li>会打断前一任务，等待Callback执行后再继续
<img src="/images/games104/L15_EventDispatchImmediate.jpg" alt="L15_EventDispatchImmediate" style="zoom: 50%;" /></li>
<li>单次打断引发连锁Callback，易导致Callstack非常深，难以Debug</li>
<li>难以并行</li>
</ul></li>
<li><strong>Event Queue</strong>
<ul>
<li>把Event存储至队列，依次执行</li>
<li>Event Queue的序列化和反序列化
<img src="/images/games104/L15_EventSerializingAndDeserializing.png" alt="L15_EventSerializingAndDeserializing" style="zoom: 25%;" />
实现：利用反射，获取每个对象的描述结构</li>
<li>存储结构：Ring Buffer 不用重复申请新内存
<img src="/images/games104/L15_RingBuffer.jpg" alt="L15_RingBuffer" style="zoom: 67%;" /></li>
<li>Batching，将多个独立系统分开处理
<img src="/images/games104/L15_EventQueueBatching.png" alt="L15_EventQueueBatching" style="zoom: 25%;" /></li>
<li>问题：
<ul>
<li>无法保证多个系统间的执行顺序 =&gt; 保留一定的Immediate处理能力
同时具备Pre、Post、Immediate处理方式</li>
<li>有系统延迟，削弱动作游戏打击感 =&gt; 经常Hardcode绕过Delay</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="script-system">Script System</h4>
<ul>
<li>Game Logic
<ul>
<li>直接在游戏引擎代码内，使用编译语言编写 （C/C++）
<ul>
<li>每次修改Gameplay，需要重新编译游戏引擎</li>
<li>极难支持热更新</li>
<li>对设计师极不友好</li>
</ul></li>
<li>脚本语言 Script System
<ul>
<li>支持快速迭代</li>
<li>易于学习、编写</li>
<li>支持热更新</li>
<li>沙盒运行，稳定、更少Crash</li>
</ul></li>
</ul></li>
<li>如何运行
<ul>
<li>基于虚拟机</li>
<li>Script Text -&gt; [Compiler] -&gt; Bytecode [Virtual Machine]</li>
<li>速度略慢</li>
</ul></li>
<li>如何管理GO
<img src="/images/games104/L15_GOManagement.png" alt="L15_GOManagement" style="zoom: 25%;" />
<ul>
<li>强调效率：引擎内核管理，脚本触发引擎执行
<ul>
<li>编写难度大</li>
<li>执行过程非常复杂</li>
</ul></li>
<li>直接交给脚本系统管理
<ul>
<li>脚本如何处理GO的生命周期：GC, Garbage Collection
<ul>
<li>优势：不需要手动管理对象生命周期，自动处理</li>
<li>问题：每次需要扫描内存，处理效率低</li>
</ul></li>
</ul></li>
<li>对于玩法相对简单的单机游戏，大多交给引擎管理；
MMORPG等玩法非常复杂的游戏，大多脚本系统管理</li>
</ul></li>
<li>架构
<ul>
<li>引擎调用脚本 eg. UE / Unity</li>
<li>脚本包引擎，引擎相当于一系列SDK库，目前应用相对少</li>
</ul></li>
<li>热更新
<ul>
<li>直接修改对应位置的脚本
<img src="/images/games104/L15_ScriptHotUpdate.png" alt="L15_ScriptHotUpdate" style="zoom: 25%;" /></li>
<li>可能会导致Crash</li>
<li>需要保障鲁棒性</li>
</ul></li>
<li>脚本语言的问题
<ul>
<li>弱类型语言难以编译优化</li>
<li>需要虚拟机运行</li>
<li>JIT，一边解释执行一边编译，可以优化</li>
</ul></li>
<li>根据情况选择脚本语言
<ul>
<li>Lua 轻量，效率高，缺少拓展</li>
<li>Python 支持反射，面向对象，丰富的拓展库，虚拟机较重</li>
<li>C# Mono等库/.NET官方支持，将原生编译语言变成脚本语言</li>
</ul></li>
</ul>
<h4 id="visual-script">Visual Script</h4>
<ul>
<li>eg. UE Blueprint, Unity Visual Script</li>
<li>对设计师和艺术家更友好</li>
<li>作为编程语言的要素：
<ul>
<li>Variable 变量</li>
<li>Statement and Expression 声明和表达式</li>
<li>Control Flow 控制语句</li>
<li>Function 函数</li>
<li>Class 类（对于面向对象的语言）</li>
</ul></li>
<li>可视化Debug</li>
<li>问题：
<ul>
<li>多人编辑的Merge问题</li>
<li>复杂度高后难以阅读</li>
</ul></li>
<li>Visual Script和脚本本质同类 Script Graph -&gt; Graph Compiler -&gt;
Bytecode -&gt; Virtual Machine</li>
</ul>
<h4 id="character-control-and-camera">Character, Control and Camera</h4>
<h5 id="character">Character</h5>
<ul>
<li>Movement
<ul>
<li>Idle, Start, Walk, Accelerate, Run, Brake, …</li>
<li>与环境交互 Hanging, Skating, Diving, …</li>
<li>与其它系统互动</li>
<li>基于物理的运动</li>
<li><strong>Movement State Machine</strong> 状态机</li>
</ul></li>
<li>Skills</li>
<li>…</li>
</ul>
<h5 id="control">Control</h5>
<ul>
<li>不同的输入设备，输入设备 -&gt; 游戏逻辑
<img src="/images/games104/L15_Control.png" alt="L15_Control" style="zoom: 15%;" /></li>
<li>Zoom in and out</li>
<li>Aim Assist 吸附操作等（尤其主机游戏）</li>
<li>Feedback 力反馈、声音反馈、光效反馈、…</li>
<li>Context Awareness 不同的游戏片段，输入响应不同</li>
<li>Chord &amp; Key Sequences 按键触发、多个按键序列触发</li>
</ul>
<h5 id="camera">Camera</h5>
<ul>
<li>基础：POV和FOV Point of View, Field of View</li>
<li>相机绑定
<ul>
<li>Spring Arm</li>
</ul></li>
<li>Camera Track</li>
<li>Camera Effect</li>
<li>Camera Manager 多相机管理，视角切换等 eg.枪械瞄准、赛车</li>
<li>Subjective Feelings 强调主观感受</li>
</ul>
<p>引擎针对3C系统要公开足够多的接口到 Script / Visual Script
提供给设计师、艺术家</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-07-03-GAMES104现代游戏引擎-Lecture14-Tool Chains Applications &amp; Advanced Topic</title>
      <link>https://elderlyaugustus.github.io/posts/2022-07-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture14-applicationsadvancedtopic/</link>
      <pubDate>Sun, 03 Jul 2022 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-07-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture14-applicationsadvancedtopic/</guid>
      <description>Lecture14 Tool Chains Applications &amp;amp; Advanced Topic Architecture of A World Editor A hub for everything to build the world
Editor Viewport 运行一个完整游戏，“Editor Mode” 代码存在Editor Only -&amp;gt; 避免编译到最终游戏中 Everything is an Editable Object Objects Views Tree View Layer View Categories and groups 通过Schema系统编辑Object参数，参数编辑面板 Content Browser Editing Utilities in World Editor 鼠标选取
Ray casting 不需要缓存，支持同时选取多个物体 遍历性能差 RTT 在G-Buffer中存储Object ID 根据点击像素直接对应Object ID 其他Trick来选取无Mesh的Object Object Transform Editing
Terrain
Heightmap Texture 植被、水体等 Brush Height Brush 笔刷边缘的过渡、笔刷的可拓展性 Instance Brush eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture14-tool-chains-applications-advanced-topic">Lecture14
Tool Chains Applications &amp; Advanced Topic</h3>
<h4 id="architecture-of-a-world-editor">Architecture of A World
Editor</h4>
<p><strong>A hub for everything to build the world</strong></p>
<ul>
<li>Editor Viewport
<ul>
<li>运行一个完整游戏，“Editor Mode”</li>
<li>代码存在Editor Only -&gt; 避免编译到最终游戏中</li>
</ul></li>
<li>Everything is an Editable Object
<ul>
<li>Objects Views
<ul>
<li>Tree View</li>
<li>Layer View</li>
<li>Categories and groups</li>
</ul></li>
<li>通过Schema系统编辑Object参数，参数编辑面板</li>
</ul></li>
<li>Content Browser</li>
<li>Editing Utilities in World Editor
<ul>
<li><p>鼠标选取</p>
<ul>
<li>Ray casting
<ul>
<li>不需要缓存，支持同时选取多个物体</li>
<li>遍历性能差</li>
</ul></li>
<li>RTT
<ul>
<li>在G-Buffer中存储Object ID</li>
<li>根据点击像素直接对应Object ID</li>
<li>其他Trick来选取无Mesh的Object</li>
</ul></li>
</ul></li>
<li><p>Object Transform Editing</p></li>
<li><p>Terrain</p>
<ul>
<li>Heightmap</li>
<li>Texture</li>
<li>植被、水体等</li>
<li>Brush
<ul>
<li>Height Brush 笔刷边缘的过渡、笔刷的可拓展性</li>
<li>Instance Brush eg.刷植被</li>
</ul></li>
</ul></li>
<li><p>Environment</p>
<ul>
<li>Sky</li>
<li>Light</li>
<li>Roads</li>
<li>Rivers</li>
<li>…</li>
</ul></li>
<li><p>Rule System in Environment</p>
<ul>
<li>eg. 路上不能有植被</li>
<li>保证局部修改而不是全部重新生成</li>
</ul></li>
</ul></li>
</ul>
<h4 id="plugin-architecture">Plugin Architecture</h4>
<ul>
<li>系统和对象的功能“矩阵”
<img src="/images/games104/L14_MatrixOfSystemsAndObjects.jpg" alt="L14_MatrixOfSystemsAndObjects" style="zoom: 33%;" />
插件既需要在横向上拓展对象，也需要在纵向上拓展系统</li>
<li>插件的Combination
<ul>
<li>Covered：覆盖原有逻辑 eg.地形编辑系统
<img src="/images/games104/L14_PluginsCombinationCoverd.jpg" alt="L14_PluginsCombinationCoverd" style="zoom: 67%;" /></li>
<li>Distributed：分布式，最终混合输出 eg.大部分编辑系统
<img src="/images/games104/L14_PluginsCombinationDistributed.jpg" alt="L14_PluginsCombinationDistributed" style="zoom: 67%;" /></li>
<li>Pipeline：串联，前者输出作为后者输入 eg.资产预处理、物理几何体
<img src="/images/games104/L14_PluginsCombinationPipeline.jpg" alt="L14_PluginsCombinationPipeline" style="zoom: 67%;" /></li>
<li>Onion rings：洋葱圈，如图 eg.地形插件的道路编辑插件
<img src="/images/games104/L14_PluginsCombinationOnionRings.jpg" alt="L14_PluginsCombinationOnionRings" style="zoom: 67%;" /></li>
</ul></li>
<li>版本控制
<ul>
<li>理想情况：版本更新 with 插件版本更新</li>
<li>插件使用SDK的方式不确定，保持SDK相同的输入输出并不一定代表稳定迭代更新</li>
</ul></li>
</ul>
<h4 id="design-narrative-tools-设计叙事工具">Design Narrative Tools
设计叙事工具</h4>
<h5 id="eg.-sequencer-in-ue">eg. Sequencer in UE</h5>
<ul>
<li>Track</li>
<li>Property Track</li>
<li>Timeline</li>
<li>Key Frame</li>
<li>Sequence</li>
</ul>
<h4 id="reflection-and-gameplay">Reflection and Gameplay</h4>
<h5 id="反射">反射</h5>
<ul>
<li>反射是Sequencer的基础，修改参数怎样应用到Runtime的对象上。Schema架构，反射系统执行</li>
<li>Visual Scripting System eg.UE蓝图 ——
核心解决问题：底层代码的可扩展性
<ul>
<li>eg.
底层增加一个新的Function，表层也需要跟着增加相应的调用，非常麻烦（可以通过继承减少一部分工作）</li>
<li>利用反射解决</li>
</ul></li>
<li>反射：构建代码和工具之间的桥梁
<ul>
<li>使用反射生成代码元数据map，包括class_name、func_name</li>
<li>生成accessor（gettor、setter、invoker、…）</li>
</ul></li>
</ul>
<h5 id="c如何实现反射">C++如何实现反射</h5>
<ul>
<li>生成Schema
<ul>
<li>GPL编译规范
<img src="/images/games104/L14_GPL.jpg" alt="L14_GPL" style="zoom: 67%;" /></li>
<li>从AST（Abstract Syntax
Tree）可以很方便得到类型信息，生成Schema大量开源的编译器可以生成AST eg.
gcc clang</li>
<li>Piccolo
<ul>
<li>clang生成AST，得到Schema数据结构</li>
<li>利用宏定义精确控制反射范围（不是所有变量、函数都需要被反射）
<ul>
<li>clang可以定义<code>__attribute__</code>，控制编译器行为</li>
</ul></li>
</ul></li>
</ul></li>
<li>生成Accessor
<ul>
<li>get / set / invoke</li>
<li>代码渲染
<ul>
<li>自动化生成代码</li>
<li>节约人力</li>
<li>很难出错</li>
<li>数据和逻辑分离</li>
</ul></li>
<li>Piccolo
<ul>
<li>利用Mustache生成代码</li>
</ul></li>
</ul></li>
</ul>
<h4 id="collaborative-editing-协同编辑">Collaborative Editing
协同编辑</h4>
<ul>
<li>核心问题：多人协作发生冲突</li>
<li>文件区分方式
<ul>
<li>分层方
<ul>
<li>按照资产分成多层，各自编辑单独层，最后Merge</li>
<li>分层难以完全分离，层之间经常存在相互关联</li>
</ul></li>
<li>分块
<ul>
<li>将世界分成多块，各自单独编辑，最后Merge</li>
<li>难以解决块之间的连接</li>
<li>单独有Artist处理边界</li>
</ul></li>
<li><strong>OFPA, One File Per Actor</strong> <span class="citation"
data-cites="UE5">@UE5</span>
<ul>
<li>每个对象都有独立的文件</li>
<li>很好地解决冲突</li>
<li>但最终文件提交量非常大</li>
<li>cooking时打包小文件开销大</li>
</ul></li>
</ul></li>
<li>基于网络同时编辑，互相可见
<ul>
<li>问题
<ul>
<li>需要处理网络架构</li>
<li>操作之间相互同步，要将操作原子化</li>
<li>怎么解决Undo&amp;Redo</li>
</ul></li>
<li>方案
<ul>
<li>使用“锁定”机制固定部分资产不可修改</li>
<li>OT, Operation Transform</li>
<li>CRDT, Conflict-free Replicated Data Type</li>
</ul></li>
<li>现在大部分网络方案：客户端提交，由服务器决策分发
<ul>
<li>Client Crash： Nothing</li>
<li>Server Crash： Boom</li>
</ul></li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-26-GAMES104现代游戏引擎-Lecture13-Tool Chains</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-26-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture13-toolchain/</link>
      <pubDate>Sun, 26 Jun 2022 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-26-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture13-toolchain/</guid>
      <description>Lecture13 Tool Chains 游戏引擎工具链的地位：
用户和引擎Runtime层的桥梁 引擎和DCC软件的桥梁：Asset Conditioning Pipeline 调和不同思维方式的平台：策划 / 美术 / 程序 GUI Immediate Mode 逐帧直接绘制，由引擎逻辑绘制，简单轻量直接 扩展性有限，性能有限，将业务压力交给了引擎逻辑 eg. Unity UGUI / Omniverse GUI / Piccolo GUI Retained Mode 将需要绘制的图形内容存储成Buffer，再交由GUI绘制 将引擎逻辑和GUI工具隔离，扩展性强，性能表现好 对开发者来说相对复杂 eg. Unreal UMG / WPF GUI / QT GUI Design Pattern MVC MVP：在MVC基础上的变化，View进一步与Model分离 MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View 平台兼容性问题，eg. 在Windows下WPF表现较好 数据处理 Serialization and Deserialization 序列化与反序列化：文件、数据库、内存、网络之间的数据转换
存储数据 - Serialization 文件格式 最简单的数据格式：文本文件 易读易处理，但缺乏安全性 纯文本信息 eg. txt/obj/… -&amp;gt; 结构化 eg. XML/… -&amp;gt; 更简单的结构 eg. json/… eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture13-tool-chains">Lecture13 Tool Chains</h3>
<p><strong>游戏引擎工具链的地位</strong>：</p>
<ul>
<li>用户和引擎Runtime层的桥梁</li>
<li>引擎和DCC软件的桥梁：Asset Conditioning Pipeline</li>
<li>调和不同思维方式的平台：策划 / 美术 / 程序</li>
</ul>
<h4 id="gui">GUI</h4>
<h5 id="immediate-mode">Immediate Mode</h5>
<ul>
<li>逐帧直接绘制，由引擎逻辑绘制，简单轻量直接</li>
<li>扩展性有限，性能有限，将业务压力交给了引擎逻辑</li>
<li>eg. Unity UGUI / Omniverse GUI / Piccolo GUI</li>
</ul>
<h5 id="retained-mode">Retained Mode</h5>
<ul>
<li>将需要绘制的图形内容存储成Buffer，再交由GUI绘制</li>
<li>将引擎逻辑和GUI工具隔离，扩展性强，性能表现好</li>
<li>对开发者来说相对复杂</li>
<li>eg. Unreal UMG / WPF GUI / QT GUI</li>
<li><strong>Design Pattern</strong>
<ul>
<li>MVC
<img src="/images/games104/L13_MVC.png" alt="L13_MVC" style="zoom: 25%;" /></li>
<li>MVP：在MVC基础上的变化，View进一步与Model分离
<img src="/images/games104/L13_MVP.jpg" alt="L13_MVP" style="zoom: 50%;" /></li>
<li>MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View
<img src="/images/games104/L13_MVVM1.jpg" alt="L13_MVVM1" style="zoom: 67%;" />
<img src="/images/games104/L13_MVVM2.png" alt="L13_MVVM2" style="zoom: 33%;" />
<ul>
<li>平台兼容性问题，eg. 在Windows下WPF表现较好</li>
</ul></li>
</ul></li>
</ul>
<h4 id="数据处理">数据处理</h4>
<h5 id="serialization-and-deserialization">Serialization and
Deserialization</h5>
<p>序列化与反序列化：文件、数据库、内存、网络之间的数据转换</p>
<h5 id="存储数据---serialization">存储数据 - Serialization</h5>
<ul>
<li><strong>文件格式</strong>
<ul>
<li>最简单的数据格式：文本文件
<ul>
<li>易读易处理，但缺乏安全性</li>
<li>纯文本信息 eg. txt/obj/… -&gt; 结构化 eg. XML/… -&gt; 更简单的结构
eg. json/…</li>
<li>eg. Unity YAML / Piccolo json / Cryengine XML json</li>
</ul></li>
<li>二进制文件
<ul>
<li>体积小，读取时无需语义处理，加载速度快</li>
</ul></li>
</ul></li>
<li><strong>Asset Reference</strong>
<ul>
<li>大量重用的资产 -&gt; 多个Instance引用同一个Asset</li>
<li>Object Instance Variance：为Asset提供各种可变性，例如更换贴图
<ul>
<li>低效方法：copy一份直接修改</li>
<li>Data Inheritance，数据继承，override修改部分</li>
</ul></li>
</ul></li>
</ul>
<h5 id="加载数据---deserialization">加载数据 - Deserialization</h5>
<ul>
<li>Parse Asset File
<img src="/images/games104/L13_ParseAssetFile.png" alt="L13_ParseAssetFile" style="zoom: 20%;" />
<ul>
<li>语义解析，生成 &lt;field-value&gt; tree
<ul>
<li>文本格式需要较为复杂的parse得到树</li>
<li>二进制文件则一般直接按树的顺序，field name + field data
存成表格</li>
<li>二进制文件需要考虑 Endianness，大端小端序
<ul>
<li>引擎本身保持同一字节序</li>
<li>根据不同平台判断提前处理</li>
</ul></li>
</ul></li>
</ul></li>
<li>Asset Version Compatibility
<ul>
<li>eg. 增删field
<ul>
<li>强制判断version number，将缺失field设为默认值</li>
<li>Protocol buffer：要求在增删field时标记UID，UID按新增顺序增加</li>
</ul></li>
</ul></li>
</ul>
<h4 id="如何增强工具链鲁棒性">如何增强工具链鲁棒性</h4>
<ul>
<li>Undo &amp; Redo
<ul>
<li>Command Pattern
<ul>
<li>原子化操作，存储用户command，Undo/Redo时重新加载command</li>
<li>Command类设计
<ul>
<li>UID（及get/set）</li>
<li>Data（及get/set）</li>
<li>Invoke()</li>
<li>Revoke()</li>
<li>Serialize()</li>
<li>Deserialize()</li>
</ul></li>
<li>三类Command
<ul>
<li>增加对象
<ul>
<li>数据：通常使用runtime instance的拷贝</li>
<li>Invoke：根据数据创建runtime instance</li>
<li>Revoke：删除runtime instance</li>
</ul></li>
<li>删除对象
<ul>
<li>数据：通常使用runtime instance的拷贝</li>
<li>Invoke：删除runtime instance</li>
<li>Revoke：根据数据创建runtime instance</li>
</ul></li>
<li>更新对象
<ul>
<li>数据：通常使用对runtime instance的修改属性的属性名和新值旧值</li>
<li>Invoke：设置runtime instance的属性为新值</li>
<li>Revoke：设置runtime instance的属性为旧值</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="如何形成工具链">如何形成工具链</h4>
<ul>
<li>Building Blocks —— 从不同数据中找出共性，原子化</li>
<li>Schema —— 一种描述结构，描述Building Blocks的组合
<ul>
<li>用Schema构建各种高级数据</li>
<li>Schema需要支持继承
<img src="/images/games104/L13_SchemaInheritance.jpg" alt="L13_SchemaInheritance" style="zoom: 50%;" /></li>
<li>两种Schema的定义方式
<ul>
<li>用独立的Schema定义文件
<ul>
<li>解耦性好，易于理解</li>
<li>需要用parser创建代码，难以debug</li>
</ul></li>
<li>在代码中直接定义</li>
</ul></li>
</ul></li>
<li>引擎数据的三种视角
<ul>
<li>Runtime内存：强调性能</li>
<li>硬盘：强调节约空间</li>
<li>用户视角/工具视角：强调易于理解</li>
</ul></li>
</ul>
<h4 id="what-you-sees-is-what-you-get-所见即所得">What you sees is what
you get “所见即所得”</h4>
<ul>
<li>创作视图和运行时一致</li>
<li>Stand-alone Tools 工具层和runtime层分开，难以实现所见即所得</li>
<li>In Game Tools
工具层直接架在runtime层之上，直接使用runtime层运行创作窗口</li>
<li>Play in Editor, PIE
<ul>
<li>直接在Editor World内运行
<ul>
<li>简单</li>
<li>会污染runtime层模式</li>
<li>编译成游戏Release版本时可能会出bug</li>
</ul></li>
<li>拷贝所有数据运行单独的PIE World
<ul>
<li>复杂度高，内存开销大</li>
<li>可以较好地保证编译结果一致</li>
<li>eg. Unreal Engine</li>
</ul></li>
</ul></li>
</ul>
<h4 id="plugin">Plugin</h4>
<ul>
<li>提供大量的API</li>
<li>尽可能把各种功能API化，自己实现引擎工具链时也使用API实现</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-18-GAMES104现代游戏引擎-Lecture12-Effects</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-18-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture12-effects/</link>
      <pubDate>Sat, 18 Jun 2022 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-18-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture12-effects/</guid>
      <description>Lecture12 Effects Particle 一个粒子 @PBA 粒子形态 Billboard Particle 永远朝向相机的面片 Mesh Particle eg. 碎石 Ribbon Particle 光带 eg. 刀的尾迹 样条插值，一般用Catmull 粒子渲染 透明混合顺序 全局排序 精确但开销大 层级结构 系统 -&amp;gt; Emitter -&amp;gt; Within emitter 分辨率，性能开销爆炸 Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合 GPU粒子 定义Particle Pool
管理Dead list和Alive list
在Compute Shader上计算
Visualization Culling，管理Alive list
Depth Buffer
Sorting
GPU并行Merge sort
双指针合并排序，读写会跳来跳去 优化：单指针遍历待写位置，找该写入的数值写入 Depth Buffer Collision 利用Depth Buffer做碰撞
Advanced Particle Animated Particle Mesh 动画可以编码成Texture：Particle Animation Texture 状态机可以通过切换贴图实现 Navigation Texture 从SDF计算Direction Texture（RG通道贴图） 实现群集运动的运动方向 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture12-effects">Lecture12 Effects</h3>
<h4 id="particle">Particle</h4>
<h5 id="一个粒子-pba">一个粒子 <span class="citation"
data-cites="PBA">@PBA</span></h5>
<h5 id="粒子形态">粒子形态</h5>
<ul>
<li>Billboard Particle 永远朝向相机的面片</li>
<li>Mesh Particle eg. 碎石</li>
<li>Ribbon Particle 光带 eg. 刀的尾迹
<ul>
<li>样条插值，一般用Catmull</li>
</ul></li>
</ul>
<h5 id="粒子渲染">粒子渲染</h5>
<ul>
<li>透明混合顺序
<ul>
<li>全局排序 精确但开销大</li>
<li>层级结构 系统 -&gt; Emitter -&gt; Within emitter</li>
</ul></li>
<li>分辨率，性能开销爆炸
<ul>
<li>Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合</li>
</ul></li>
</ul>
<h5 id="gpu粒子">GPU粒子</h5>
<ul>
<li><p>定义Particle Pool</p></li>
<li><p>管理Dead list和Alive list</p></li>
<li><p>在Compute Shader上计算</p></li>
<li><p>Visualization Culling，管理Alive list</p></li>
<li><p>Depth Buffer</p></li>
<li><p>Sorting</p>
<blockquote>
<p>GPU并行Merge sort</p>
<ul>
<li>双指针合并排序，读写会跳来跳去</li>
<li>优化：单指针遍历待写位置，找该写入的数值写入</li>
</ul>
</blockquote></li>
<li><p>Depth Buffer Collision 利用Depth Buffer做碰撞</p></li>
</ul>
<h5 id="advanced-particle">Advanced Particle</h5>
<ul>
<li>Animated Particle Mesh
<ul>
<li>动画可以编码成Texture：Particle Animation Texture
状态机可以通过切换贴图实现</li>
<li>Navigation Texture
<ul>
<li>从SDF计算Direction Texture（RG通道贴图）</li>
<li>实现群集运动的运动方向</li>
</ul></li>
</ul></li>
<li>eg. Mesh变成粒子再编程Mesh
<ul>
<li>Skeleton mesh emitter</li>
<li>Dynamic procedural splines</li>
<li>Reactions to other players</li>
<li>…</li>
</ul></li>
<li>群集模拟</li>
</ul>
<h5 id="游戏中的粒子系统工具">游戏中的粒子系统工具</h5>
<ul>
<li>早期：设定emitter参数，增加各种效果</li>
<li>现代：节点式，更复杂的处理</li>
<li>eg. Niagara</li>
</ul>
<h4 id="sound-system">Sound System</h4>
<ul>
<li>声音基础知识（略）</li>
<li>Panning</li>
<li>Attenuation 衰减
<ul>
<li>Attenuation Shape 在区域内不衰减
<ul>
<li>溪流沿岸 圆柱体</li>
<li>空间内 长方体</li>
<li>喇叭 锥体</li>
</ul></li>
<li>Obstruction and Occlusion
<ul>
<li>Raycast</li>
</ul></li>
</ul></li>
<li>Reverb 混响
<ul>
<li>分类
<ul>
<li>Direct (Dry) 干音</li>
<li>Early reflection (Echo) 回音</li>
<li>Late reverberations (Tail) 尾音</li>
<li>回音 + 尾音 == Wet 湿音</li>
</ul></li>
<li>Absorption
<ul>
<li>Pre-delay (seconds)</li>
<li>HF ratio</li>
<li>Dry level</li>
<li>Wet level</li>
</ul></li>
</ul></li>
<li>The Dopppler Effect 多普勒效应</li>
<li>Spatialization - Soundfield</li>
<li>引擎中间件 eg. Wwise</li>
<li>建模整个声音世界</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-04-GAMES104现代游戏引擎-Lecture11-Physics System - Applications</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-04-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture11-physicssystemapplications/</link>
      <pubDate>Sat, 04 Jun 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-04-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture11-physicssystemapplications/</guid>
      <description>Lecture11 Physics System - Applications Character Controller 一个反物理的系统：符合玩家感知 + 实现反物理运动 没有Character Controller时，大量Hack Kinematic Actor 不受物理规律控制 Push其他Actor Shape （人类角色时） Capsule 主要使用，一般设计两层 内层：碰撞 外层：防止角色与物体（墙面）太近 高速移动时容易卡进墙体 相机穿透导致看到墙后物体 Box Convex Collide with environment Sweep Test 判断 Sliding：撞到墙上时左右滑动 Auto Stepping：台阶 每帧尝试抬升高度前进 Slope 斜坡 坡度大于多少时，冲上去会滑下来 改变Controller形状/体积 eg.蹲下站起的变化 限制在环境大小不够时不可站起（eg.在隧道中） 更新前重叠测试，阻止形状更新 Push Objects (Dynamic Actors) Controller站在运动平台上时 不作处理就会平台动、Controller在原地 Ray Cast检测所站物体上，绑定，运动时也相对于平台 进一步精细：平台运动过快时的趔趄等 Ragdoll 不适用Ragdoll：播放死亡动画 =&amp;gt; 死亡环境并不一定与动画一致 eg. 在悬崖边，悬空挂在坡面上甚至插入地形 用Rigid Body将关键的Joint连结起来 考虑Constraints 将Ragdoll中较少Joints的运动映射到Skeleton Animation Retargeting 三种Joints Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据 Leaf Joints：一般不动，例如手掌脚掌 Intermediate Joints：Active Joints之间的Joints，利用邻近Active Joints插值 死亡动画到Ragdoll的过渡 一个问题：游戏中动画与物理的边界在哪里？ Powered Ragdoll - Physics-Animation Blending 纯Ragdoll：效果不像人类 纯动画：循环播放，有模式感 两种混合 Cloth 传统：Bake动画，随着运动方向更换动画，移动端常用</description>
      <content:encoded><![CDATA[<h3 id="lecture11-physics-system---applications">Lecture11 Physics
System - Applications</h3>
<h4 id="character-controller">Character Controller</h4>
<ul>
<li>一个反物理的系统：符合玩家感知 + 实现反物理运动</li>
<li>没有Character Controller时，大量Hack</li>
<li>Kinematic Actor
<ul>
<li>不受物理规律控制</li>
<li>Push其他Actor</li>
</ul></li>
<li>Shape （人类角色时）
<ul>
<li><strong>Capsule</strong> 主要使用，一般设计两层
<ul>
<li>内层：碰撞</li>
<li>外层：防止角色与物体（墙面）太近
<ul>
<li>高速移动时容易卡进墙体</li>
<li>相机穿透导致看到墙后物体</li>
</ul></li>
</ul></li>
<li>Box</li>
<li>Convex</li>
</ul></li>
<li>Collide with environment
<ul>
<li>Sweep Test 判断</li>
<li>Sliding：撞到墙上时左右滑动
<img src="/images/games104/L11_Sliding.png" alt="L11_Sliding" style="zoom: 25%;" /></li>
<li>Auto Stepping：台阶 每帧尝试抬升高度前进
<img src="/images/games104/L11_AutoStepping.gif" alt="L11_AutoStepping" style="zoom:25%;" /></li>
<li>Slope 斜坡
<ul>
<li>坡度大于多少时，冲上去会滑下来</li>
</ul></li>
<li>改变Controller形状/体积 eg.蹲下站起的变化
<ul>
<li>限制在环境大小不够时不可站起（eg.在隧道中）
更新前重叠测试，阻止形状更新</li>
</ul></li>
<li>Push Objects (Dynamic Actors)</li>
<li>Controller站在运动平台上时
<ul>
<li>不作处理就会平台动、Controller在原地</li>
<li>Ray Cast检测所站物体上，绑定，运动时也相对于平台</li>
<li>进一步精细：平台运动过快时的趔趄等</li>
</ul></li>
</ul></li>
</ul>
<h4 id="ragdoll">Ragdoll</h4>
<ul>
<li>不适用Ragdoll：播放死亡动画 =&gt; 死亡环境并不一定与动画一致 eg.
在悬崖边，悬空挂在坡面上甚至插入地形</li>
<li>用Rigid Body将关键的Joint连结起来
<img src="/images/games104/L11_RigdollJoints.jpg" alt="L11_RigdollJoints" style="zoom:30%;" />
<ul>
<li>考虑Constraints</li>
<li>将Ragdoll中较少Joints的运动映射到Skeleton
<ul>
<li><strong>Animation Retargeting</strong></li>
<li>三种Joints
<img src="/images/games104/L11_RagdollAnimation.png" alt="L11_RagdollAnimation" style="zoom:25%;" />
<ul>
<li>Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据</li>
<li>Leaf Joints：一般不动，例如手掌脚掌</li>
<li>Intermediate Joints：Active Joints之间的Joints，利用邻近Active
Joints插值</li>
</ul></li>
</ul></li>
<li>死亡动画到Ragdoll的过渡
<ul>
<li>一个问题：游戏中动画与物理的边界在哪里？</li>
<li>Powered Ragdoll - Physics-Animation Blending
<ul>
<li>纯Ragdoll：效果不像人类</li>
<li>纯动画：循环播放，有模式感</li>
<li>两种混合
<img src="/images/games104/L11_PoweredRagdoll.jpg" alt="L11_PoweredRagdoll" style="zoom:25%;" /></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="cloth">Cloth</h4>
<ul>
<li><p>传统：Bake动画，随着运动方向更换动画，移动端常用</p></li>
<li><p>动力学骨骼模拟：精度较低</p></li>
<li><p>Mesh-based Cloth Simulation ##### Mesh-based Cloth
Simulation</p></li>
<li><p>Physical Mesh远低于Render Mesh，模拟完再用重心坐标插值到Render
Mesh</p></li>
<li><p>Constraints：</p>
<ul>
<li>划定布料每个顶点的运动范围</li>
<li>一般离人体越近，运动范围越小 eg.披风脖子处运动幅度小</li>
<li>解决衣料穿模问题</li>
</ul></li>
<li><p>布料物理材质（丝绸/棉布等）</p></li>
</ul>
<h5 id="cloth-solver---mass-spring-system">Cloth Solver - Mass Spring
System</h5>
<ul>
<li><p>质点弹簧系统</p>
<ul>
<li><p>Spring force 胡克力 <span class="math display">\[
\vec F^S=k_{\rm spring}\Delta\vec x
\]</span></p></li>
<li><p>Spring damping force （damping
衰减，空气阻力所致/提高迭代稳定性） <span class="math display">\[
\vec F^d=-k_{\rm damping}\vec v
\]</span></p></li>
</ul></li>
<li><p>横向、纵向、斜向、跨越质点加弹簧，提高精度
<img src="/images/games104/L11_MassSpringCloth.png" alt="L11_MassSpringCloth" style="zoom:20%;" /></p></li>
<li><p>受力</p>
<ul>
<li>重力</li>
<li>风力</li>
<li>空气阻力</li>
<li>周围弹簧弹力（胡克力 + damping） <span class="math display">\[
\vec F_{\rm net}^{\rm vertex}=M\vec g+\vec F_{\rm wind}(t)+\vec F_{\rm
air\ resistance}(t)+\sum_{\rm springs\in v}(k_{\rm spring}\Delta \vec
x(t)-k_{\rm damping}\vec v(t))=M\vec a(t)
\]</span></li>
</ul></li>
<li><p>Verlet数值积分 <span class="math display">\[
\vec x(t+\Delta t)=2\vec x(t)-\vec x(t-\Delta t)+\vec a(t)(\Delta t)^2
\]</span></p>
<ul>
<li>半隐式欧拉积分 <span class="math display">\[
\vec v(t+\Delta t)=\vec v(t)+\vec a(t)\Delta t \\ \vec x(t+\Delta
t)=\vec x(t)+\vec v(t+\Delta t)\Delta t
\]</span></li>
<li>Observation <span class="math display">\[
\left\{\begin{array}{l}\vec v(t+\Delta t)=\vec v(t)+\vec a(t)\Delta t \\
\vec x(t+\Delta t)=\vec x(t)+\vec v(t+\Delta t)\Delta t\\
\vec x(t)=\vec x(t-\Delta t)+\vec v(t)\Delta t
\end{array}\right.\ \Rightarrow\
\left\{\begin{array}{l}
\vec x(t+\Delta t)=\vec x(t)+(\vec v(t)+\vec a(t)\Delta t)\Delta t\\
\vec x(t)=\vec x(t-\Delta t)+\vec v(t)\Delta t
\end{array}\right.
\]</span></li>
<li>得到 <span class="math display">\[
\vec x(t+\Delta t)=2\vec x(t)-\vec x(t-\Delta t)+\vec a(t)(\Delta t)^2
\]</span></li>
<li>与半隐式欧拉积分数学等价，但实现上因为排除了不稳定的速度因素，更加稳定</li>
</ul></li>
</ul>
<h5 id="cloth-solver---position-based-dynamics">Cloth Solver - Position
Based Dynamics</h5>
<ul>
<li>区别
<ul>
<li>传统Simulation：Constrains =&gt; Force =&gt; Velocity =&gt;
Position</li>
<li>PBD：Constrains ==&gt; Position</li>
</ul></li>
<li>用约束描述物理属性</li>
<li>Solver更稳定</li>
<li>后面会再进一步解释</li>
</ul>
<h5 id="self-collision">Self Collision</h5>
<p>包括布料与布料、布料与刚体的碰撞，精度较低时极易发生</p>
<ul>
<li>暴力方法：加厚布料（渲染时），发生自穿插时不会渲染出来</li>
<li>提高迭代精度，减小迭代Step</li>
<li>Maximal velocity 这样每次穿插不会过深，可以在下次迭代时弹回</li>
<li>增加一个负向力场，负向SDF实现</li>
</ul>
<h4 id="destruction">Destruction</h4>
<ul>
<li><p>Chunk Hierarchy，组织未破碎物体的碎片</p></li>
<li><p>Connectivity Graph，生成连接关系，每个Edge有Connectivity
Value</p></li>
<li><p>Damage Calculation，受力超过Connectivity Value则破坏连接</p>
<ul>
<li>Impact Point向外扩散
<img src="/images/games104/L11_DamageRange.png" alt="L11_DamageRange" style="zoom:15%;" />
<span class="math display">\[
D_d=\left\{\begin{aligned}
&amp;D &amp;&amp;d\le R_\min\\
&amp;D\cdot\left(\dfrac{R_\max-d}{R_\max-R_\min}\right)^K
&amp;&amp;R_\min&lt;d&lt;R_\max\\
&amp;0 &amp;&amp;d\ge R_\max\quad
\end{aligned}\right.
\]</span></li>
</ul></li>
<li><p>Pin住某些与世界的连接</p></li>
<li><p>Voronoi生成Chunk</p>
<ul>
<li><span class="citation" data-cites="PBA">@PBA</span>
随机取点，等距垂平面</li>
<li>断面纹理生成
<ul>
<li>实时的3D Texture生成</li>
<li>离线生成，runtime切换</li>
</ul></li>
<li>Chunk的分布 =&gt; 取点的分布</li>
</ul></li>
<li><p>Pipeline
<img src="/images/games104/L11_DestructionPipeline.jpg" alt="L11_DestructionPipeline" style="zoom: 50%;" /></p></li>
<li><p>增加其他真实感效果</p>
<ul>
<li>音效</li>
<li>粒子</li>
<li>Navigation更新</li>
</ul></li>
<li><p>谨慎使用，增加了大量Mesh，对算力要求很高</p></li>
</ul>
<h4 id="vehicle">Vehicle</h4>
<ul>
<li><p>A rigidbody actor
<img src="/images/games104/L11_RigidbodyVehicle.jpg" alt="L11_RigidbodyVehicle" style="zoom: 50%;" /></p></li>
<li><p>驱动力 Traction Force
<img src="/images/games104/L11_TractionForce1.png" alt="L11_TractionForce1" style="zoom: 20%;" /></p>
<ul>
<li>扭矩 Torque <span class="math inline">\(T=T_{\rm
engine}X_gX_dn\)</span>
<img src="/images/games104/L11_TractionForce2.png" alt="L11_TractionForce2" style="zoom:20%;" /></li>
<li>驱动力 Traction <span class="math inline">\(\vec F_{\rm
Traction}=\dfrac{T}{R_w}\vec u\)</span></li>
</ul></li>
<li><p>悬挂力 Suspension Force
<img src="/images/games104/L11_SuspensionForce1.png" alt="L11_SuspensionForce1" style="zoom:20%;" />
<span class="math display">\[
|\vec F_{\rm suspension}|=k(L_{\rm rest}-(L_{
\rm hit}-R_W))
\]</span>
<img src="/images/games104/L11_SuspensionForce2.png" alt="L11_SuspensionForce2" style="zoom:20%;" /></p></li>
<li><p>轮胎力 Tire Forces</p>
<ul>
<li>径向力 Longitudinal force <span class="math inline">\(F_{\rm
long}=F_{\rm traction}+F_{\rm drag}+F_{rr}\)</span>
<img src="/images/games104/L11_TireForce1.png" alt="L11_TireForce1" style="zoom:20%;" /></li>
<li>切向力 Lateral force <span class="math inline">\(F_{\rm
lateral}=C_c*a\)</span>
<img src="/images/games104/L11_TireForce2.png" alt="L11_TireForce2" style="zoom:20%;" />
<img src="/images/games104/L11_TireForce3.png" alt="L11_TireForce3" style="zoom:20%;" /></li>
</ul></li>
<li><p>重心 Center of Mass
<img src="/images/games104/L11_CenterOfMass1.png" alt="L11_CenterOfMass1" style="zoom:20%;" />
<span class="math display">\[
M=M_1+M_2\quad \vec x_{cm}=\dfrac{M_1\vec x_1+M_2\vec x_2}{M}
\]</span>
<img src="/images/games104/L11_CenterOfMass2.png" alt="L11_CenterOfMass2" style="zoom:20%;" /></p>
<ul>
<li>重心太靠前在飞跃时容易栽，重心准确则稳定</li>
<li>重心靠前转向力不足，靠后转向力过大</li>
<li>变速时重心会有偏移 Weight Transfer
加速时车身后仰重心靠后，刹车时车身前倾重心靠前</li>
</ul></li>
<li><p>转向角</p>
<ul>
<li><p>转向时，若内外侧轮转向角相同，则外侧轮打滑空转</p></li>
<li><p>转向时，外侧轮转向角要大于内侧轮</p></li>
<li><p>根据旋转中心计算
<img src="/images/games104/L11_SteeringAngles1.png" alt="L11_SteeringAngles1" style="zoom:20%;" />
<span class="math display">\[
\alpha_l=\tan^{-1}\dfrac{L_{wb}}{R_t+\frac{L_r}{2}}\\
\alpha_r=\tan^{-1}\dfrac{L_{wb}}{R_t-\frac{L_r}{2}}
\]</span>
<img src="/images/games104/L11_SteeringAngles2.png" alt="L11_SteeringAngles2" style="zoom:20%;" /></p></li>
</ul></li>
<li><p>轮胎接触
<img src="/images/games104/L11_WheelContact.gif" alt="L11_WheelContact" style="zoom:20%;" /></p>
<ul>
<li>单方向垂直向下的 Single Raycast 效果不真实，易发生穿插</li>
<li>球面 Spherecast 实现真实的接触</li>
</ul></li>
</ul>
<h4 id="advanced-physics-pbd-xpbd">Advanced Physics : PBD / XPBD</h4>
<ul>
<li>拉格朗日力学：用约束描述所有运动，把力学计算改变为求解约束问题</li>
<li>eg. 匀速圆周运动
<ul>
<li>位置约束 <span class="math inline">\(C(\mathbf x)=\|\mathbf
x\|-r=0\)</span></li>
<li>速度约束 <span class="math inline">\(\dfrac{\mathrm d}{\mathrm
dt}C(\mathbf x)=\dfrac{\mathrm dC}{\mathrm d\mathbf x}\cdot
\dfrac{d\mathbf x}{\mathrm dt}=\mathbf J\cdot\mathbf v=0\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathbf J\)</span> Jacobian
<ul>
<li><span class="math inline">\(\mathbf J^T\)</span> 与 <span
class="math inline">\(\mathbf v\)</span> 垂直 <span
class="math inline">\(\mathbf J^T\cdot\mathbf v=0\)</span></li>
<li>把速度转换成速度约束</li>
</ul></li>
<li>弹簧质点等系统也都可用约束表示 eg. 弹簧质点系统拉伸时：<span
class="math inline">\(C_{\rm stretch}(\mathbf x_1, \mathbf
x_2)=\|\mathbf x_1-\mathbf x_2\|-d\)</span>
<img src="/images/games104/L11_StringConstraints2.png" alt="L11_StringConstraints2" style="zoom:15%;" /><img src="/images/games104/L11_StringConstraints1.png" alt="L11_StringConstraints1" style="zoom:15%;" /></li>
</ul>
<h5 id="pbd-position-based-dynamics">PBD, Position Based Dynamics</h5>
<ul>
<li>约束投影</li>
<li>求解约束的方法：迭代法</li>
<li>Jacobi矩阵指向正确的方向，反复迭代直到满足约束（接近）</li>
<li>收敛相对稳定</li>
<li>布料应用广泛</li>
<li>NVIDIA Flex</li>
</ul>
<p><img src="/images/games104/L11_PBD2.png" alt="L11_PBD2" style="zoom:25%;" /></p>
<p><img src="/images/games104/L11_PBD1.png" alt="L11_PBD1" style="zoom:25%;" /></p>
<p><img src="/images/games104/L11_PBD3.jpg" alt="L11_PBD3" style="zoom: 67%;" /></p>
<h5 id="xpbd-extended-position-based-dynamics">XPBD, Extended Position
Based Dynamics</h5>
<ul>
<li><p>在PBD基础上引入stiffness量，表示硬约束还是软约束</p></li>
<li><p>硬约束：stiffness非常大，易爆炸</p></li>
<li><p>软约束：stiffness较小，布料等软体</p></li>
<li><p><span class="math display">\[
U(\mathbf x)=\dfrac{1}{2}\mathbf C(\mathbf x)^T\alpha^{-1}\mathbf
C(\mathbf x)\quad \alpha:\text{stiffness}
\]</span></p>
<p>将约束转换为服从性矩阵 Compliance Matrix</p></li>
<li><p>Unreal Engine Chaos</p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-25-GAMES104现代游戏引擎-Lecture10-Physics System - Basic Concepts</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-25-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture10-physicssystemconcepts/</link>
      <pubDate>Wed, 25 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-25-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture10-physicssystemconcepts/</guid>
      <description>Lecture10 Physics System - Basic Concepts 物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 + 环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料
Physics Actors and Shapes Actor Static Actor 静态固定的，不受物理影响 Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动 Trigger 根据碰撞触发Message从而产生Event Kinematic 反物理的自发运动（游戏设计师设计的运动） &amp;gt; Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉” Shape : 复杂形状物理计算过于复杂 Sphere Capsule 胶囊体 Box Convex Mesh 凸多面体 Trangle Mesh （一般只用于静态） Height Field ！尽量使用简单的Shape（从前到后越来越复杂）
Shape Properties Mass / Density 质量 / 密度 Center of Mass 质心 Friction / Restitution 摩擦力 / 弹力 (and more …) Forces Force eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture10-physics-system---basic-concepts">Lecture10 Physics
System - Basic Concepts</h3>
<p>物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 +
环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料</p>
<h4 id="physics-actors-and-shapes">Physics Actors and Shapes</h4>
<h5 id="actor">Actor</h5>
<ul>
<li>Static Actor 静态固定的，不受物理影响</li>
<li>Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动</li>
<li>Trigger 根据碰撞触发Message从而产生Event</li>
<li>Kinematic 反物理的自发运动（游戏设计师设计的运动） &gt;
Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉”</li>
</ul>
<h5 id="shape-复杂形状物理计算过于复杂">Shape :
复杂形状物理计算过于复杂</h5>
<ul>
<li>Sphere</li>
<li>Capsule 胶囊体</li>
<li>Box</li>
<li>Convex Mesh 凸多面体</li>
<li>Trangle Mesh （一般只用于静态）</li>
<li>Height Field</li>
</ul>
<p><img src="/images/games104/L10_ActorShapes.png" alt="L10_ActorShapes" style="zoom: 25%;" /></p>
<p>！尽量使用简单的Shape（从前到后越来越复杂）</p>
<h5 id="shape-properties">Shape Properties</h5>
<ul>
<li>Mass / Density 质量 / 密度</li>
<li>Center of Mass 质心</li>
<li>Friction / Restitution 摩擦力 / 弹力 (and more …)</li>
</ul>
<h4 id="forces">Forces</h4>
<ul>
<li><strong>Force</strong> eg. Gravity / Drag / Friction / …</li>
<li><strong>Impulse</strong> 冲量 eg. simulating an explosion</li>
</ul>
<h4 id="movements">Movements</h4>
<p>（略，<span class="citation"
data-cites="GAMES201/103">@GAMES201/103</span>）</p>
<h4 id="rigid-body-dynamics">Rigid Body Dynamics</h4>
<p>（略，<span class="citation"
data-cites="GAMES103">@GAMES103</span>）</p>
<h4 id="collision-detection">Collision Detection</h4>
<ul>
<li><p>Two phase
<img src="/images/games104/L10_TwoPhase.jpg" alt="L10_TwoPhase" style="zoom: 33%;" /></p></li>
<li><p>Broad Phase 方法</p>
<ul>
<li><strong>Space
partitioning</strong>：利用BVH查询，非常适合动态更新，但没有↓方法快</li>
<li><strong>Sort and Sweep</strong>
<ul>
<li>对所有Actor的AABB按<code>pmin</code>或<code>pmax</code>的x轴、y轴排序，查询重叠</li>
<li>排序后动态更新，局部调整计算量也很低</li>
</ul></li>
</ul></li>
<li><p>Narrow Phase 方法</p>
<ul>
<li><p><strong>Basic Shape Intersection Test</strong></p>
<ul>
<li>Sphere-Sphere 极易求</li>
<li>Sphere-Capsule 把Capsule拆成两端球和圆柱</li>
<li>Capsule-Capsule 同上</li>
</ul></li>
<li><p><strong>Minkowski Difference-based Methods</strong></p>
<ul>
<li><p>A形状中无穷多点坐标 + B形状中无穷多点坐标 = Minkowski Sum
<img src="/images/games104/L10_MinkowskiSum1.png" alt="L10_MinkowskiSum1" style="zoom:25%;" /><img src="/images/games104/L10_MinkowskiSum2.png" alt="L10_MinkowskiSum2" style="zoom: 25%;" />
<span class="math display">\[
A\oplus B=\{\vec a+\vec b:\vec a\in A,\vec b\in B\}
\]</span></p></li>
<li><p>A形状中无穷多点坐标 - B形状中无穷多点坐标 = Minkowski Difference
（将B关于原点对称得到-B，再求Minkowski Sum）
<img src="/images/games104/L10_MinkowskiDifference.png" alt="L10_MinkowskiDifference" style="zoom: 25%;" />
<span class="math display">\[
A\ominus B=\{\vec a-\vec b:\vec a\in A,\vec b\in B\}\\
A\ominus B=A \oplus(-B)
\]</span></p></li>
<li><p>观察：若AB有交点，则其Minkowski Difference一定过原点
<img src="/images/games104/L10_MinkowskiSumAndOrigin.png" alt="L10_MinkowskiSumAndOrigin" style="zoom: 25%;" /></p></li>
<li><p>GJK Algorithm</p>
<ul>
<li>分别取AB中Y轴方向最大最小的点，作差得到新的点C必为Minkowski
Difference上一顶点，判断O是否在C上，若否则下一步
<img src="/images/games104/L10_GJK1.png" alt="L10_GJK1" style="zoom: 25%;" /></li>
<li>连接点C和原点O，以OC方向取AB中最大最小的点，作差得到点D，判断O是否在CD上，若否则下一步
<img src="/images/games104/L10_GJK2.png" alt="L10_GJK2" style="zoom: 25%;" /></li>
<li>再作O到CD的垂线，以垂线方向取AB中最大最小的点，作差得到点E，判断O是否在CDE内，若否则下一步
<img src="/images/games104/L10_GJK3.png" alt="L10_GJK3" style="zoom: 25%;" /></li>
<li>Next
<img src="/images/games104/L10_GJK4.png" alt="L10_GJK4" style="zoom: 25%;" /></li>
<li>Next
<img src="/images/games104/L10_GJK5.png" alt="L10_GJK5" style="zoom: 25%;" /></li>
<li>…</li>
</ul></li>
</ul></li>
<li><p><strong>Separating Axis Theorem, SAT</strong></p>
<ul>
<li>定理：对两个分离的几何体，一定能找到分离轴将两者完全分开 =&gt;
2D情况下，对凸多边形而言，其中一个几何体的一条边可作为分离轴</li>
<li>2D情形：分别遍历AB的每条边，判断另一图形是否相交。若有任一分离轴，则两者不相交；否则相交
<img src="/images/games104/L10_SAT.png" alt="L10_SAT" style="zoom: 25%;" /><img src="/images/games104/L10_SATOptimized.png" alt="L10_SATOptimized" style="zoom: 25%;" /></li>
<li>3D情形：遍历AB的每个面，遍历AB的任两条边的叉积构成的平面</li>
</ul></li>
</ul></li>
</ul>
<h4 id="collision-resolution">Collision Resolution</h4>
<ul>
<li>Penalty Force （略，<span class="citation"
data-cites="PBA">@PBA</span>）</li>
<li>Constraints （略，<span class="citation"
data-cites="PBA">@PBA</span>）
<img src="/images/games104/L10_Constraints.png" alt="L10_Constraints" style="zoom:25%;" /></li>
</ul>
<h4 id="scene-query">Scene Query</h4>
<ul>
<li>Raycast
<ul>
<li>Multiple hits 返回所有交点</li>
<li>Closet hit 返回最近的交点</li>
<li>Any hit 返回交点，不需要排序</li>
</ul></li>
<li>Sweep 用几何体扫描</li>
<li>Overlap 重叠</li>
</ul>
<blockquote>
<p><strong>Collision Group</strong></p>
<ul>
<li>对Actor分组</li>
<li>Pawn / Static / Dynamic / Trigger</li>
<li>作判断时忽略无关的Actor</li>
</ul>
</blockquote>
<h4 id="efficiency-accuracy-and-determinism">Efficiency, Accuracy, and
Determinism</h4>
<h5 id="simulation-optimization">Simulation Optimization</h5>
<ul>
<li>Island 把一个个需要模拟的单元分离</li>
<li>Sleeping Island在不施加力的时候可以Sleep</li>
</ul>
<h5 id="continuous-collision-detection-ccd">Continuous Collision
Detection, CCD</h5>
<ul>
<li>部分Actor需开启CCD</li>
<li>移动速度过快时，下一时间步直接穿过碰撞物碰撞检测失效，Tunneling隧穿
Solution：
<ul>
<li>加厚碰撞物</li>
<li>CCD</li>
</ul></li>
<li>一种方法：Time-of-Impact, TOI
<ul>
<li>评估两步之间的“安全时间”</li>
<li>以“安全时间步”迭代</li>
<li>重复直到距离在碰撞物厚度之内</li>
</ul></li>
</ul>
<h5 id="deterministic-simulation-确定性模拟">Deterministic Simulation
确定性模拟</h5>
<ul>
<li>多人在线游戏中，各方须表现一致</li>
<li>same old states + same inputs = same new states</li>
<li>时间步、算法顺序、浮点数精度等等须保持一致</li>
<li>目前很难解决，大部分在线游戏中不用物理做游戏逻辑，而只做表现效果</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-19-GAMES104现代游戏引擎-Lecture9-Animation System - Advanced</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-19-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture9-advancedanimationsystem/</link>
      <pubDate>Thu, 19 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-19-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture9-advancedanimationsystem/</guid>
      <description>Lecture09 Animation System - Advanced Animation Blending LERP LERP / NLERP / SLERP 两个动画clip之间的LERP 权重 eg. 走路与跑步动画，依据运动速度切换 \[ {\rm weight_1=\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\ {\rm weight_2=\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\ \]
对齐时间线 eg.走路和跑步的步频不同，怎样对齐混合的帧 每一段动画为一步，对每一段动画时间线做归一化 Blend Space eg. 左右前后走/跑
1D Blend Space： eg. 左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）
2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置 双线性插值 Delaunay Triangulation 常用 根据设置的动画点，生成三角形划分 在空间内一点，由周围三角形插值 插值利用重心坐标 Skeleton Masked Blending 针对只应用于半身或身体局部的动画，实现多种动画的混合 eg.各种姿态下的鼓掌
绘制一个Mask，只应用于部分Joints Additive Blending eg. 向着摄影机点头
存储动画的变化量，在基础动画上叠加一层动画 需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果 Animation State Machine 状态机 两种核心元素 Node Clip Blend Space 脚本串接的单套动画系统 Translation 激活条件 Cross Fade Smooth transition 慢慢过渡，插值（各种插值曲线） Frozen transition 先停住动画A，再播放动画B 多层状态机 Animation Blend Tree 多层状态机在复杂动画中非常复杂 用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树 两种节点 Terminal Node 执行节点 (叶节点) Clip Blend Space ASM Non-terminal Node （非叶节点） LERP Blend Node Additive Blend Node Layered ASM to Blend Tree Blend Tree Control Parameters Variable 暴露变量，根据变量切换运动状态 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture09-animation-system---advanced">Lecture09 Animation
System - Advanced</h3>
<h4 id="animation-blending">Animation Blending</h4>
<h5 id="lerp">LERP</h5>
<ul>
<li>LERP / NLERP / SLERP</li>
<li>两个动画clip之间的LERP</li>
</ul>
<h5 id="权重">权重</h5>
<p>eg. 走路与跑步动画，依据运动速度切换 <span class="math display">\[
{\rm weight_1=\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\
{\rm weight_2=\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\
\]</span></p>
<h5 id="对齐时间线">对齐时间线</h5>
<ul>
<li>eg.走路和跑步的步频不同，怎样对齐混合的帧</li>
<li>每一段动画为一步，对每一段动画时间线做归一化</li>
</ul>
<h5 id="blend-space">Blend Space</h5>
<p>eg. 左右前后走/跑</p>
<ul>
<li><p>1D Blend Space： eg.
左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）</p></li>
<li><p>2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置
<img src="/images/games104/L09_2DBlendSpace.jpg" alt="L09_2DBlendSpace" style="zoom:33%;" /></p>
<ul>
<li><p>双线性插值
<img src="/images/games104/L09_Bilinear.jpg" alt="L09_Bilinear" style="zoom:33%;" /></p></li>
<li><p>Delaunay Triangulation 常用
<img src="/images/games104/L09_DelaunayTriangulation.jpg" alt="L09_DelaunayTriangulation" style="zoom:33%;" /></p>
<ul>
<li>根据设置的动画点，生成三角形划分</li>
<li>在空间内一点，由周围三角形插值</li>
<li>插值利用重心坐标</li>
</ul></li>
</ul></li>
</ul>
<h5 id="skeleton-masked-blending">Skeleton Masked Blending</h5>
<p>针对只应用于半身或身体局部的动画，实现多种动画的混合
eg.各种姿态下的鼓掌</p>
<ul>
<li>绘制一个Mask，只应用于部分Joints</li>
</ul>
<h5 id="additive-blending">Additive Blending</h5>
<p>eg. 向着摄影机点头</p>
<ul>
<li>存储动画的变化量，在基础动画上叠加一层动画</li>
<li>需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果</li>
</ul>
<h5 id="animation-state-machine-状态机">Animation State Machine
状态机</h5>
<p><img src="/images/games104/L09_ASM1.jpg" alt="L09_ASM1" style="zoom: 67%;" /><img src="/images/games104/L09_ASM2.jpg" alt="L09_ASM2" style="zoom: 40%;" /></p>
<ul>
<li>两种核心元素
<ul>
<li>Node
<ul>
<li>Clip</li>
<li>Blend Space</li>
<li>脚本串接的单套动画系统</li>
</ul></li>
<li>Translation
<ul>
<li>激活条件</li>
<li>Cross Fade
<ul>
<li>Smooth transition 慢慢过渡，插值（各种插值曲线）</li>
<li>Frozen transition 先停住动画A，再播放动画B</li>
</ul></li>
</ul></li>
</ul></li>
<li>多层状态机
<img src="/images/games104/L09_LayeredASM.jpg" alt="L09_LayeredASM" style="zoom: 50%;" /></li>
</ul>
<h5 id="animation-blend-tree">Animation Blend Tree</h5>
<ul>
<li>多层状态机在复杂动画中非常复杂</li>
<li>用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树
<img src="/images/games104/L09_ExpressionTree.png" alt="L09_ExpressionTree" style="zoom: 25%;" /></li>
<li>两种节点
<ul>
<li>Terminal Node 执行节点 (叶节点)
<ul>
<li>Clip</li>
<li>Blend Space</li>
<li>ASM</li>
</ul></li>
<li>Non-terminal Node （非叶节点）
<ul>
<li>LERP Blend Node
<img src="/images/games104/L09_ABTLERP.png" alt="L09_ABTLERP" style="zoom: 25%;" /></li>
<li>Additive Blend Node
<img src="/images/games104/L09_ABTAdditive.png" alt="L09_ABTAdditive" style="zoom: 25%;" /></li>
</ul></li>
</ul></li>
<li>Layered ASM to Blend Tree
<img src="/images/games104/L09_LayeredASM2ABT.png" alt="L09_LayeredASM2ABT" style="zoom: 25%;" /></li>
<li>Blend Tree Control Parameters
<ul>
<li>Variable
<ul>
<li>暴露变量，根据变量切换运动状态</li>
<li>eg. 速度、HP</li>
</ul></li>
<li>Event
<ul>
<li>外部传入激活状态的指令</li>
<li>eg. 持枪、开枪</li>
</ul></li>
</ul></li>
</ul>
<h4 id="inverse-kinematics">Inverse Kinematics</h4>
<ul>
<li>Forward Kinematics 前向传递动画</li>
<li>Inverse Kinematics 对末端Joint Key动画 eg.
崎岖地面走路，脚步顶点反向传递</li>
</ul>
<h5 id="two-bones-ik">Two Bones IK</h5>
<ul>
<li><p>2根Bone组成三角形的两边
<img src="/images/games104/L09_2BonesIK1.jpg" alt="L09_2BonesIK1" style="zoom:25%;" /></p></li>
<li><p>大腿根部的Joint到地面接触点距离为第三边</p></li>
<li><p>即可得到两根Bone的夹角 <span
class="math inline">\(\cos\theta=\dfrac{a^2+c^2-b^2}{2ac}\)</span>
<img src="/images/games104/L09_2BonesIK2.jpg" alt="L09_2BonesIK2" style="zoom: 25%;" /></p></li>
<li><p>问题：在3D空间，解有无数个，构成一个圆
<img src="/images/games104/L09_2BonesIK3.jpg" alt="L09_2BonesIK3" style="zoom:33%;" /></p>
<ul>
<li>设定Reference Vector</li>
<li>朝着Reference Vector方向取解
<img src="/images/games104/L09_2BonesIK4.jpg" alt="L09_2BonesIK4" style="zoom:20%;" /></li>
</ul></li>
<li><p>更多复杂的IK</p>
<ul>
<li>Look At</li>
<li>Hand</li>
<li>Foot</li>
<li>Full Body</li>
</ul></li>
</ul>
<h5 id="multi-joint-ik-solving">Multi-Joint IK Solving</h5>
<ul>
<li>更多种可能性
<img src="/images/games104/L09_MultiJointIK1.jpg" alt="L09_MultiJointIK1" style="zoom:33%;" /></li>
<li>首先检查是否能到达目标（最长、最短的触及范围）
<ul>
<li>最长（拉直）
<img src="/images/games104/L09_MultiJointIK2.jpg" alt="L09_MultiJointIK2" style="zoom: 25%;" /></li>
<li>最短（最长的单根Bone减去其他Bone）
<img src="/images/games104/L09_MultiJointIK3.jpg" alt="L09_MultiJointIK3" style="zoom:20%;" /><img src="/images/games104/L09_MultiJointIK4.jpg" alt="L09_MultiJointIK4" style="zoom:20%;" /></li>
</ul></li>
<li>约束 Constraints
关节有运动的约束，不能超出约束范围（比如依据人体的骨骼结构）</li>
<li>解法
<ul>
<li><strong>CCD, Cyclic Coordinate Decent</strong>
<img src="/images/games104/L09_CCD.gif" alt="L09_CCD" style="zoom: 25%;" />
<ul>
<li>逐个Joint遍历，每个Joint朝下一个Joint与目标点连线方向旋转</li>
<li>上述过程反复迭代，不断接近结果</li>
<li>优化：
<ul>
<li>每次旋转时，使用Tolerance region进行缩小或限制
<img src="/images/games104/L09_OptimizedCCD1.png" alt="L09_OptimizedCCD1" style="zoom: 20%;" /></li>
<li>越靠近根节点的限制越大，运动幅度越小（处理约束同理）
<img src="/images/games104/L09_OptimizedCCD2.png" alt="L09_OptimizedCCD2" style="zoom:20%;" /></li>
</ul></li>
</ul></li>
<li><strong>FABRIK, Forward And Backward Reaching Inverse
Kinematics</strong>
<img src="/images/games104/L09_FABRIK.gif" alt="L09_FABRIK" style="zoom:25%;" />
<ul>
<li>逐个Joint遍历，每个Joint朝目标点或上一个Joint位移，再将Bone还原设定下一个Joint</li>
<li>从末端Joint出发、从Root出发反复迭代</li>
<li>同样需要Tolerance优化</li>
<li>处理约束：将约束区域投影到Target所在平面，取可运动到的点
<img src="/images/games104/L09_FABRIKConstraint.gif" alt="L09_FABRIKConstraint" style="zoom:25%;" /></li>
</ul></li>
</ul></li>
</ul>
<h5 id="ik-with-multiple-end-effects">IK with Multiple End-Effects</h5>
<p>eg. 爬墙、攀岩灯多个目标点的IK
<img src="/images/games104/L09_IKwithMultipleEnd-Effectors.png" alt="L09_IKwithMultipleEnd-Effectors" style="zoom:20%;" /></p>
<ul>
<li><p>利用Jacobi矩阵求解：</p>
<p><img src="/images/games104/L09_Jacobi1.png" alt="L09_Jacobi1" style="zoom:20%;" /></p>
<p><img src="/images/games104/L09_Jacobi2.png" alt="L09_Jacobi2" style="zoom:15%;" /></p></li>
<li><p>其他解法</p>
<ul>
<li>基于物理的解法</li>
<li>PBD, Position Based Dynamics</li>
<li>Fullbody IK in UE5 (XPBD, Extended PBD)</li>
</ul></li>
</ul>
<h5 id="ik的挑战">IK的挑战</h5>
<ul>
<li>蒙皮后的自我穿插、交叠</li>
<li>对环境的感知</li>
<li>更自然的人类行为，例如平衡
<ul>
<li>基于数据的、AI的方法</li>
</ul></li>
</ul>
<h4 id="animation-pipeline-with-blending-and-ik">Animation Pipeline with
Blending and IK</h4>
<p><img src="/images/games104/L09_AnimationPipelineWithBlendingAndIK.png" alt="L09_AnimationPipelineWithBlendingAndIK" style="zoom: 25%;" /></p>
<h4 id="facial-animation">Facial Animation</h4>
<h5 id="facial-action-coding-system">Facial Action Coding System</h5>
<ul>
<li>把表情分成46种，并进行编码</li>
<li>多种表情可以进行组合</li>
<li>Apple归纳了28个核心的表情，其中有23个是有对称性的，可以压缩</li>
<li>混合时如果线性叠加：合到一起后效果折半 -&gt; 存储表情相对于“Neutral
Face”的Offset，实现Additive Blending 即<strong>Morph Target
Animation</strong></li>
</ul>
<h5 id="morph-target-animation">Morph Target Animation</h5>
<h5 id="facial-skeleton">Facial Skeleton</h5>
<p>骨骼非常复杂
<img src="/images/games104/L09_FacialSkeleton.png" alt="L09_FacialSkeleton" style="zoom: 15%;" /></p>
<h5 id="uv-texture-facial-animation">UV Texture Facial Animation</h5>
<p>简单用贴图实现</p>
<h5 id="muscle-model-animation">Muscle Model Animation</h5>
<p>前沿研究，如果运动脸部肌肉（影视行业开始使用）
<img src="/images/games104/L09_MuscleModelAnimation.jpg" alt="L09_MuscleModelAnimation" style="zoom: 50%;" /></p>
<h4 id="animation-retargeting">Animation Retargeting</h4>
<h5 id="skeleton-retargeting">Skeleton Retargeting</h5>
<ul>
<li>把同一个骨骼动画应用到不同角色</li>
<li>Source Character + Target Character Source Animation + Target
Animation</li>
<li>两幅骨骼比例、位置不同 -&gt; 一一对应</li>
<li>保持Binding Pose的旋转，Retarget相对运动，而不是绝对运动</li>
<li>Translation和Scale动画：考虑Bone的长度之比，进行动画的放缩</li>
<li>问题：腿部不同长度时出现浮空
<ul>
<li>以Pelvis到地面的距离之比为放缩比例，对动画、移动速度做放缩</li>
<li>Foot IK</li>
</ul></li>
<li>离线方法完成</li>
<li>对不同骨骼结构的Retargeting
<ul>
<li>以骨骼名字做对应</li>
<li>把有对应骨骼之间的部分做归一化
<img src="/images/games104/L09_DifferentSkeletonRetargeting.gif" alt="L09_DifferentSkeletonRetargeting" style="zoom: 33%;" /></li>
</ul></li>
<li>问题：
<ul>
<li>角色的自穿插</li>
<li>有语义动作偏移带来语义偏移，例如鼓掌动画，Retargeting后掌合不起来</li>
</ul></li>
</ul>
<h5 id="morph-animation-retargeting">Morph Animation Retargeting</h5>
<p>eg. 表情动画 + 直接存储的是相对于Neutral
Face的相对位移，直接Apply到Target上 + 有语义动作 eg.
闭眼，眼睛大小不同时，直接Apply可能无法闭上 + 增加约束条件 eg.
闭眼动画限制眼睛必须闭上 +
手动调整，利用拉普拉斯算子计算，拉眼睑使相近脸部一起运动</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-13-GAMES104现代游戏引擎-Lecture8-Animation System - Basics</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-13-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture8-basicanimationsystem/</link>
      <pubDate>Fri, 13 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-13-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture8-basicanimationsystem/</guid>
      <description>Lecture08 Animation System - Basics 挑战：
不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互 实时，计算和存储开销 真实感（表情、Ragdoll、Motion Matching …） 2D Animation Sprite Animation 逐帧绘制，循环播放 Sprite-like animation technique in pseudo-3D game 《Doom》 绘制各个视角的sprite，做伪3D Sprite Animation in Modern Game Live2D 把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴 仿射变换 图元的前后遮挡由深度决定 每一个图元有控制网格 Key frame 2D Skinned Animation 2D蒙皮动画 3D Animation DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation Pan/Yaw Tilt/Pitch Roll Rigid Hierarchical Animation 基于刚体的层次结构动画 “皮影戏” 直接连接Mesh，会导致Mesh互相产生穿插 Per-vertex Animation 旗帜、布料、流体等（从物理烘焙而来的顶点动画实现） VAT, Virtual Animation Texture：用贴图存储顶点 Morph Target Animation 顶点动画的变种 顶点带有权重，邻近顶点相互影响 3D Skinned Animation 2D蒙皮动画 （见下章） Physics-based Animation Ragdoll 布料和流体 IK, Inverse kinematics 反向动力学 Animation 创作方式 Key frame 动作捕捉 Skinned Animation Implementation 怎样将Mesh运动起来 创建一个绑定姿态的Mesh 创建绑定骨骼Skeleton 刷定点权重（蒙皮） 骨骼动画 顶点按骨骼动画和蒙皮权重运动 Different Spaces</description>
      <content:encoded><![CDATA[<h3 id="lecture08-animation-system---basics">Lecture08 Animation System
- Basics</h3>
<p>挑战：</p>
<ul>
<li>不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互</li>
<li>实时，计算和存储开销</li>
<li>真实感（表情、Ragdoll、Motion Matching …）</li>
</ul>
<h4 id="d-animation">2D Animation</h4>
<h5 id="sprite-animation">Sprite Animation</h5>
<ul>
<li>逐帧绘制，循环播放</li>
<li>Sprite-like animation technique in pseudo-3D game
<ul>
<li>《Doom》 绘制各个视角的sprite，做伪3D</li>
</ul></li>
<li>Sprite Animation in Modern Game</li>
</ul>
<h5 id="live2d">Live2D</h5>
<ul>
<li>把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴
<img src="/images/games104/L08_Live2D1.jpg" alt="L08_Live2D1" style="zoom: 50%;" /></li>
<li>仿射变换
<img src="/images/games104/L08_Live2D2.jpg" alt="L08_Live2D2" style="zoom: 67%;" /></li>
<li>图元的前后遮挡由深度决定</li>
<li>每一个图元有控制网格
<img src="/images/games104/L08_Live2D3.jpg" alt="L08_Live2D3" style="zoom: 50%;" /></li>
<li>Key frame</li>
</ul>
<h5 id="d-skinned-animation-2d蒙皮动画">2D Skinned Animation
2D蒙皮动画</h5>
<h4 id="d-animation-1">3D Animation</h4>
<blockquote>
<p>DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation
Pan/Yaw Tilt/Pitch Roll
<img src="/images/games104/L08_DoF.jpg" alt="L08_DoF" style="zoom: 67%;" /></p>
</blockquote>
<h5 id="rigid-hierarchical-animation-基于刚体的层次结构动画">Rigid
Hierarchical Animation 基于刚体的层次结构动画</h5>
<ul>
<li>“皮影戏”</li>
<li>直接连接Mesh，会导致Mesh互相产生穿插</li>
</ul>
<h5 id="per-vertex-animation">Per-vertex Animation</h5>
<ul>
<li>旗帜、布料、流体等（从物理烘焙而来的顶点动画实现）</li>
<li>VAT, Virtual Animation Texture：用贴图存储顶点</li>
</ul>
<h5 id="morph-target-animation">Morph Target Animation</h5>
<ul>
<li>顶点动画的变种</li>
<li>顶点带有权重，邻近顶点相互影响</li>
</ul>
<h5 id="d-skinned-animation-2d蒙皮动画-见下章">3D Skinned Animation
2D蒙皮动画 （见下章）</h5>
<h5 id="physics-based-animation">Physics-based Animation</h5>
<ul>
<li>Ragdoll</li>
<li>布料和流体</li>
<li>IK, Inverse kinematics 反向动力学</li>
</ul>
<h5 id="animation-创作方式">Animation 创作方式</h5>
<ul>
<li>Key frame</li>
<li>动作捕捉</li>
</ul>
<h4 id="skinned-animation-implementation">Skinned Animation
Implementation</h4>
<h5 id="怎样将mesh运动起来">怎样将Mesh运动起来</h5>
<ul>
<li>创建一个绑定姿态的Mesh</li>
<li>创建绑定骨骼Skeleton</li>
<li>刷定点权重（蒙皮）</li>
<li>骨骼动画</li>
<li>顶点按骨骼动画和蒙皮权重运动</li>
</ul>
<blockquote>
<p><strong>Different Spaces</strong></p>
<ul>
<li><strong>Local Space</strong> 每一个骨骼节点</li>
<li>Model Space</li>
<li>World Space</li>
</ul>
</blockquote>
<h5 id="骨骼">骨骼</h5>
<ul>
<li><p>Humanoid 两足动物
<img src="/images/games104/L08_HumanoidSkeleton.jpg" alt="L08_HumanoidSkeleton" style="zoom: 50%;" /></p></li>
<li><p>Non-humanoid 四足动物
<img src="/images/games104/L08_Non-humanoidSkeleton.jpg" alt="L08_Non-humanoidSkeleton" style="zoom: 50%;" /></p></li>
<li><p>Joint 和 Bone 关节和骨段，存储/处理的是Joint
<img src="/images/games104/L08_JointVsBone.png" alt="L08_JointVsBone" style="zoom: 25%;" /></p></li>
<li><p>真实情况中的附加骨骼</p>
<ul>
<li>复杂的表情</li>
<li>披风、翅膀、武器等外饰</li>
<li>eg. 武器可能是单个Joint绑定在手上</li>
</ul></li>
<li><p>Root节点 一般在地面
<img src="/images/games104/L08_RootJoint1.png" alt="L08_RootJoint1" style="zoom: 25%;" /><img src="/images/games104/L08_RootJoint2.png" alt="L08_RootJoint2" style="zoom: 25%;" /></p></li>
<li><p>物体之间的骨骼Attach，骑马/开车等情况
<img src="/images/games104/L08_AttachJoint.png" alt="L08_AttachJoint" style="zoom: 15%;" /></p></li>
<li><p>绑定初始状态 T-Pose和A-Pose</p>
<ul>
<li>T-Pose肩部受到挤压，精度不够</li>
<li>目前大多采用A-Pose
<img src="/images/games104/L08_TA-Pose.png" alt="L08_TA-Pose" style="zoom: 25%;" /></li>
</ul></li>
<li><p>Pose：一个骨骼的状态</p>
<ul>
<li><p>Joint Pose (9DoF)</p>
<ul>
<li>Position</li>
<li>Orientation</li>
<li>Scale &gt; Math of 3D Rotation （略）</li>
</ul></li>
<li><p>Affine Matrix 仿射矩阵 <span class="math display">\[
M=R_{HM}T_{HM}S_{HM}=\begin{bmatrix}SR &amp; T\\0&amp;1\end{bmatrix}
\]</span></p></li>
<li><p>从Local Space到Model Space <span class="math display">\[
M_J^{\rm Model}=\prod_{j=J}^0 M_{p(J)}^{\rm Local}
\]</span></p></li>
<li><p>Interpolation
<img src="/images/games104/L08_JointInterpolation.png" alt="L08_JointInterpolation" style="zoom: 25%;" />
左：Local Space 右：Model Space 故在Local Space进行插值，再转换至Model
Space</p></li>
</ul></li>
</ul>
<h5 id="skin---蒙皮怎样运动">Skin - 蒙皮怎样运动</h5>
<ul>
<li><p><strong>Skinning Matrix</strong></p>
<ul>
<li><p><span class="math inline">\(V^{\rm Local}(t)\)</span>：顶点 <span
class="math inline">\(V\)</span> 在Local Space，<span
class="math inline">\(t\)</span> 时间的位置： <span
class="math display">\[
V^{\rm Local}(t)\equiv V_b^{\rm Local}=(M_{b(j)}^{\rm Model})^{-1}\cdot
V_b^{\rm Model}
\]</span>
<img src="/images/games104/L08_SkinningMatrix.jpg" alt="L08_SkinningMatrix" style="zoom: 33%;" /></p></li>
<li><p><span class="math inline">\(M_J^{\rm Model}(t)\)</span>：Joint
<span class="math inline">\(J\)</span> 在Model Space，<span
class="math inline">\(t\)</span> 时间的pose： <span
class="math display">\[
M_J^{\rm Model}(t)=\prod_{j=J}^0 M_{p(j)}^{\rm Local}(t)
\]</span></p></li>
<li><p><span class="math inline">\(V^{\rm Model}(t)\)</span>：顶点 <span
class="math inline">\(V\)</span> 在Model Space，<span
class="math inline">\(t\)</span> 时间的位置： <span
class="math display">\[
V^{\rm Model}(t)=M_J^{\rm Model}(t)\cdot V_J^{\rm Local}=M_J^{\rm
Model}(t)\cdot(M_{b(j)}^{\rm Model})^{-1}\cdot V_b^{\rm Model}
\]</span></p></li>
<li><p><strong>Skinning Matrix</strong> <span class="math display">\[
K_J=M_J^{\rm Model}(t)\cdot(M_{b(j)}^{\rm Model})^{-1}
\]</span></p></li>
</ul></li>
<li><p>Skinning Matrix Palette</p>
<ul>
<li><p>存储每个Joint的Skinning Matrix</p></li>
<li><p>Model Space to World Space <span class="math display">\[
K_J&#39;=M^{\rm World}\cdot M_J^{\rm Model}(t)\cdot(M_{b(j)}^{\rm
Model})^{-1}
\]</span> 存储该Skinning Matrix’</p></li>
<li><p>Bind Pose Matrix的逆需提前计算存储，以提高效率
<img src="/images/games104/L08_InverseBindPoseMatrix.jpg" alt="L08_InverseBindPoseMatrix" style="zoom: 50%;" /></p></li>
</ul></li>
<li><p><strong>Weighted Skinning with Multi-joints</strong></p>
<ul>
<li><p>加权平均（一般不超过4个），加权总和为1</p></li>
<li><p>Weighted Skinned Blend</p>
<ul>
<li><p>顶点 <span class="math inline">\(V\)</span> 关于Joint <span
class="math inline">\(J_i\)</span> 的Local Space to Model Space： <span
class="math display">\[
V_{J_i}^M(t)=K_{J_i}(t)\cdot V_{b_{J_i}}^M
\]</span></p></li>
<li><p>顶点 <span class="math inline">\(V\)</span> 在Model Space： <span
class="math display">\[
V^M(t)=\sum_{i=0}^{N-1}W_i\cdot V_{J_i}^M(t)
\]</span></p></li>
</ul></li>
</ul></li>
</ul>
<h5 id="clips-动画片段">Clips 动画片段</h5>
<ul>
<li><p>Interpolation</p>
<ul>
<li><p>LERP - Translation / Scale <span class="math display">\[
f(x)=(1-\alpha)f(x_1)+\alpha f(x_2)\\
\alpha=\dfrac{x-x_1}{x_2-x_1},\,x_1&lt;x_2,\,x\in[x_1,x_2];\quad
f(x):T(t),S(t)
\]</span></p></li>
<li><p>NLERP for Quaternion - Rotation
<img src="/images/games104/L08_LerpVsNLerp.png" alt="L08_LerpVsNLerp" style="zoom: 25%;" /></p>
<ul>
<li><p>Linear Interpolation <span class="math display">\[
q_t={\rm Lerp}(q_{t_1},q_{t_2},t)=(1-\alpha)q_{t_1}+\alpha q_{t_2}\\
\]</span></p></li>
<li><p>Normalization <span class="math display">\[
q_t&#39;={\rm NLerp}(q_{t_1},q_{t_2},t)=\dfrac{(1-\alpha)q_{t_1}+\alpha
q_{t_2}}{\|(1-\alpha)q_{t_1}+\alpha q_{t_2}\|}
\]</span></p></li>
<li><p>最短路径
<img src="/images/games104/L08_ShortestPath.png" alt="L08_ShortestPath" style="zoom: 33%;" /></p></li>
</ul></li>
<li><p>SLERP for Quaternion - Rotation</p>
<ul>
<li><p>NLERP在弦上插值，故旋转不均匀；SLERP在球面上插值，但开销较大</p></li>
<li><p><span class="math display">\[
q_t={\rm
SLerp}(q_{t_1},q_{t_2},t)=\dfrac{\sin((1-t)\theta)}{\sin\theta}\cdot
q_{t_1}+\dfrac{\sin(t\theta)}{\sin\theta}\cdot q_{t_2}\\
\theta=\arccos(q_{t_1}\cdot q_{t_2})
\]</span>
<img src="/images/games104/L08_SLERP.jpg" alt="L08_SLERP" style="zoom: 25%;" /></p></li>
<li><p>一般设置阈值，插值角度小，则NLerp，插值角度非常大时使用SLerp</p></li>
</ul></li>
</ul></li>
</ul>
<h5 id="simple-animation-runtime-pipeline">Simple Animation Runtime
Pipeline</h5>
<p><img src="/images/games104/L08_SimpleAnimationRuntimePipeline.png" alt="L08_SimpleAnimationRuntimePipeline" style="zoom: 33%;" /></p>
<h4 id="animation-compression">Animation Compression</h4>
<ul>
<li><p>大部分数据不变</p>
<ul>
<li>部分Joint整个固定</li>
<li>部分Joint的Translation/Rotation/Scale有部分保持不变（尤其是Translation和Scale）</li>
</ul></li>
<li><p>DoF Reduction 减少不变的自由度</p></li>
<li><p>Keyframe 记录关键帧，其他帧插值</p>
<ul>
<li><p>使用插值方法测试</p>
<ul>
<li>若插值结果与真实结果差异小于阈值，则不记录为关键帧</li>
<li>若插值结果与真实结果差异较大，则以真实结果为关键帧
<img src="/images/games104/L08_Keyframe1.jpg" alt="L08_Keyframe1" style="zoom: 80%;" />
<img src="/images/games104/L08_Keyframe2.png" alt="L08_Keyframe2" style="zoom: 33%;" /></li>
</ul></li>
<li><p>采用Catmull-Rom Spline插值 ——
比线性插值更平滑（开销大但这里不是Runtime） <span
class="math display">\[
P(t)=\begin{bmatrix}1&amp;t&amp;t^2&amp;t^3\end{bmatrix}
\begin{bmatrix}0&amp;1&amp;0&amp;0\\
-\alpha&amp;0&amp;\alpha&amp;0\\
2\alpha&amp;\alpha-3&amp;3-2\alpha&amp;-\alpha\\
-\alpha&amp;2-\alpha&amp;\alpha-2&amp;\alpha
\end{bmatrix}
\begin{bmatrix}P_0\\P_1\\P_2\\P_3\end{bmatrix}
\]</span>
<img src="/images/games104/L08_Catmull-RomSpline.png" alt="L08_Catmull-RomSpline" style="zoom: 33%;" /></p>
<ul>
<li>减少了关键帧</li>
</ul></li>
</ul></li>
<li><p>Float Quantization</p>
<ul>
<li>32bit浮点存储量大</li>
<li>将关键帧中数据的最小值、最大值mapping到 <span
class="math inline">\([0, 1]\)</span></li>
<li>所有数值mapping到16bit unsigned int来存储</li>
<li>四元数的特性： <span class="math display">\[
a^2+b^2+c^2+d^2=1,\,|a|\ge\max(|b|,|c|,|d|)\\
\Rightarrow b,c,d\in[-\frac{\sqrt 2}{2}, \frac{\sqrt 2}{2}]
\]</span> 因此，经验证四元数中除模最大的数 <span
class="math inline">\(a\)</span> 以外的三个数 <span
class="math inline">\(b,c,d\)</span>
可以用15bit精度表示，另有2bit表示哪个数最大；三个元共用48bit表示
<img src="/images/games104/L08_QuaternionQuantization.jpg" alt="L08_QuaternionQuantization" style="zoom: 67%;" /></li>
<li>经过压缩：
<img src="/images/games104/L08_SizeReduction.png" alt="L08_SizeReduction" style="zoom: 20%;" /></li>
</ul></li>
<li><p>误差传播
<img src="/images/games104/L08_ErrorPropagation.png" alt="L08_ErrorPropagation" style="zoom: 25%;" /></p>
<ul>
<li><p>结果会导致人物手部、手上武器等末端Joint发生抖动</p></li>
<li><p>特殊情况需要高精度存储</p>
<ul>
<li>最简单的判定方法 —— 直接给误差设定阈值</li>
<li>Visual Error 视觉误差
<ul>
<li>为Joint在两个垂直方向设定两个Fake Vertex，计算运动后Fake
Vertex的距离
<img src="/images/games104/L08_FakeVertex.png" alt="L08_FakeVertex" style="zoom: 25%;" /></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>误差补偿</p>
<ul>
<li>处理方法：
<ul>
<li>除Root外，每根bone上选一个点</li>
<li>计算每根压缩后的bone的旋转，使标记点在Model Space中接近实际位置</li>
<li>增加一个旋转来补偿误差
<img src="/images/games104/L08_ErrorCompensation.png" alt="L08_ErrorCompensation" style="zoom: 25%;" /></li>
</ul></li>
<li>问题：末端骨骼的信息变成高频</li>
<li>更新的方法：FIK, Forward Inverse Kinematics</li>
</ul></li>
</ul>
<h4 id="animation-dcc">Animation DCC</h4>
<ul>
<li>Mesh
<ul>
<li>关节处Mesh更细分</li>
</ul></li>
<li>Skeleton Binding 骨骼绑定
<ul>
<li>DCC的基础骨架</li>
<li>增加武器等Gameplay中特殊的Joint</li>
</ul></li>
<li>Skinning 蒙皮，刷权重
<ul>
<li>自动计算 —— 结果会像橡皮</li>
<li>手动部分校正权重</li>
</ul></li>
<li>设计关键帧动画</li>
<li>Root要保持在Model Space中不变</li>
<li>FBX File</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-12-25-影片技术分析Pre-基于物理的动画-影视制作中的FX流程-byLLY</title>
      <link>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C%E4%B8%AD%E7%9A%84fx%E6%B5%81%E7%A8%8B-bylly/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C%E4%B8%AD%E7%9A%84fx%E6%B5%81%E7%A8%8B-bylly/</guid>
      <description>注：本篇由同组同学LLY编写，本人代完成格式化
电影制作流程中的物理模拟 视效制作流程 在了解物理模拟在视效中的流程之前，我们需要先了解一下整个视效制作的大框架。
FXPipeline 特效（FX）部门简述 动力学和模拟技术是数字特效的核心组成部分。从广义上讲，它们试图在数字领域复制真实世界的物理特征，这样就可以通过让软件计算适当的结果而不需要关键帧动画来实现真实的行为和交互。
这可能是因为实际拍摄的话，成本过高（可能需要多个模型来允许重新拍摄），无法提供所需的可控性与可指导性，或者新一代监管人员对数字技术比传统的实际效果更满意。不管是什么原因，自20世纪90年代初以来，实际效果越来越被数字所取代，以至于模拟物体、流体和火的复杂相互作用现在已司空见惯。Dante的Peak（1997）使用简单的粒子系统对模型和微缩模型进行数字增强，同时使用真实拍摄，2012（2009）模拟了整个数字城市的大规模破坏。
虽然模拟技术通常与毁灭和混乱联系在一起，包括破裂和变形物体、爆炸、火灾、烟雾和液体，但它们也被用来给角色穿衣服、造型和移动头发，以及移动皮肤下的肌肉。可以预期，通过模拟比通过关键帧更容易实现真实的复杂交互。
3D动画中特效的种类 毛发模拟 Hair and Fur Simulation 模拟系统创建头发或毛发的模拟，不仅对环境因素作出反应，还对其附着角色头部或身体的运动作出反应。这是一个极其复杂的模拟，除了高预算项目以外，通常没有条件获取这样的资源。
刚体&amp;amp;柔体模拟 Body Simulation 包括刚体模拟和柔体模拟。刚体用于模拟木材、石头、玻璃，或者其他形变不大的物体。刚体模拟处理的是物体间的相互作用、碰撞、破碎等效果。柔体模拟包括模拟刚性较低的材料，如布料、皮肤、土壤、身体组织等其他任何可能弯曲、扭曲活波动的材料。
流体模拟 Fluid Simulation 流体模拟不仅包括水或液体，还包括气体、凝胶，或任何其他流体运动的物质。包括浓雾、明胶、燕麦等其他类似的物质。流体模拟器通常基于真实世界流体物理中涉及的方程进行计算。
粒子模拟 Particle Simulation 粒子模拟器在空间中创建点，这些点具有分散的特征，如雨、烟、灰尘、群集、人群、前进的军队、飞溅的火花等等。艺术家将行为和视觉属性指定给粒子，使其外观和移动与艺术家想要的一样。与其他类型模拟相同，艺术家定义了基于物理的参数，如重力、风力等，粒子会做出相应的反应，创造出令人惊讶的逼真的效果，如暴风雪、迁徙的蜜蜂、攻击的鸟类，或者任何所需要的效果。
我们今天主要从粒子、刚体、流体三个方面来讲，基本上从原理上涵盖了上述所有类型物体的模拟。
FX部门流程与分工 RnD：Research and Development 研发部门。负责创新研发解决棘手问题的新方案，不断发展现有的能力。根据画面需求，对学术界现有的算法进行调研，寻找、整合可用于生产的解决方案。
TD：Techinal Director 技术指导。TD是科学家与艺术家之间的桥梁，将研发部门开发的算法编写成艺术家能够上手使用的工具。他们使爆炸、浓烟、激流等效果更加容易使用。FX TD构建和测试工具，然后将其整合到VFX工作流程的制作pipeline当中。所有TD都是问题解决者。每个项目都有其复杂的地方，他们确保效果一致并且令人信服。
FX Artist FX 艺术家。艺术家们使用TD创建出来的工具，通过自身的艺术造诣和导演的要求，为单个镜头创建效果。他们是视觉效果的生产者。
FX 工作流程 因为今天演讲的主题是模拟相关，所以我们关注的FX部门的流程将不涉及到特效评估、数据统计、特效整理、测试、预演等细化工作。
FX部门流程 首先，导演提出视效需求给视效总监，由视效总监判断现阶段视效能否实现。若不能实现，则交给RnD部门研发该效果，并准备可行备用方案。若可以实现，则将其交给视效制片规划制作方案。当RnD研发好算法后，将算法交给TD。TD询问艺术家的工作习惯、预期希望可以调整的方面等需求，编程、制作成实现容易，并为艺术家暴露出可修改的参数。在制作阶段，视效制片将相应的特效镜头派发给FX部门，相应的镜头将被派发给不同的FX艺术家。FX艺术家在制作时会收到来自其他部门的模型文件、跟踪数据、关键帧动画等信息，进行特效的制作。其中，每一个部门都有相应的组长，会对艺术家所制作的镜头进行评估和审核。全部制作完成的特效镜头，会经过各个监管的层层审核与反馈迭代，最后给到剪辑进行素材的回插。</description>
      <content:encoded><![CDATA[<blockquote>
<p>注：本篇由同组同学LLY编写，本人代完成格式化</p>
</blockquote>
<h2 id="电影制作流程中的物理模拟">电影制作流程中的物理模拟</h2>
<h3 id="视效制作流程">视效制作流程</h3>
<p>在了解物理模拟在视效中的流程之前，我们需要先了解一下整个视效制作的大框架。</p>
<figure>
<img src="/images/filmtechanalysis-PBA/FXPipeline.jpg"
alt="FXPipeline" />
<figcaption aria-hidden="true">FXPipeline</figcaption>
</figure>
<h3 id="特效fx部门简述">特效（FX）部门简述</h3>
<p>动力学和模拟技术是数字特效的核心组成部分。从广义上讲，它们试图在数字领域复制真实世界的物理特征，这样就可以通过让软件计算适当的结果而不需要关键帧动画来实现真实的行为和交互。</p>
<p>这可能是因为实际拍摄的话，成本过高（可能需要多个模型来允许重新拍摄），无法提供所需的可控性与可指导性，或者新一代监管人员对数字技术比传统的实际效果更满意。不管是什么原因，自20世纪90年代初以来，实际效果越来越被数字所取代，以至于模拟物体、流体和火的复杂相互作用现在已司空见惯。Dante的Peak（1997）使用简单的粒子系统对模型和微缩模型进行<strong>数字增强</strong>，同时使用真实拍摄，2012（2009）模拟了整个数字城市的大规模破坏。</p>
<p>虽然模拟技术通常与毁灭和混乱联系在一起，包括破裂和变形物体、爆炸、火灾、烟雾和液体，但它们也被用来给角色穿衣服、造型和移动头发，以及移动皮肤下的肌肉。可以预期，通过模拟比通过关键帧更容易实现真实的复杂交互。</p>
<h4 id="d动画中特效的种类">3D动画中特效的种类</h4>
<ul>
<li><p><strong>毛发模拟 Hair and Fur Simulation</strong>
模拟系统创建头发或毛发的模拟，不仅对环境因素作出反应，还对其附着角色头部或身体的运动作出反应。这是一个极其复杂的模拟，除了高预算项目以外，通常没有条件获取这样的资源。</p></li>
<li><p><strong>刚体&amp;柔体模拟 Body Simulation</strong>
包括刚体模拟和柔体模拟。刚体用于模拟木材、石头、玻璃，或者其他形变不大的物体。刚体模拟处理的是物体间的相互作用、碰撞、破碎等效果。柔体模拟包括模拟刚性较低的材料，如布料、皮肤、土壤、身体组织等其他任何可能弯曲、扭曲活波动的材料。</p></li>
<li><p><strong>流体模拟 Fluid Simulation</strong>
流体模拟不仅包括水或液体，还包括气体、凝胶，或任何其他流体运动的物质。包括浓雾、明胶、燕麦等其他类似的物质。流体模拟器通常基于真实世界流体物理中涉及的方程进行计算。</p></li>
<li><p><strong>粒子模拟 Particle Simulation</strong>
粒子模拟器在空间中创建点，这些点具有分散的特征，如雨、烟、灰尘、群集、人群、前进的军队、飞溅的火花等等。艺术家将行为和视觉属性指定给粒子，使其外观和移动与艺术家想要的一样。与其他类型模拟相同，艺术家定义了基于物理的参数，如重力、风力等，粒子会做出相应的反应，创造出令人惊讶的逼真的效果，如暴风雪、迁徙的蜜蜂、攻击的鸟类，或者任何所需要的效果。</p></li>
</ul>
<p>我们今天主要从粒子、刚体、流体三个方面来讲，基本上从原理上涵盖了上述所有类型物体的模拟。</p>
<h3 id="fx部门流程与分工">FX部门流程与分工</h3>
<ul>
<li><p><strong>RnD：Research and Development</strong>
研发部门。负责创新研发解决棘手问题的新方案，不断发展现有的能力。根据画面需求，对学术界现有的算法进行调研，寻找、整合可用于生产的解决方案。</p></li>
<li><p><strong>TD：Techinal Director</strong>
技术指导。TD是科学家与艺术家之间的桥梁，将研发部门开发的算法编写成艺术家能够上手使用的工具。他们使爆炸、浓烟、激流等效果更加容易使用。FX
TD构建和测试工具，然后将其整合到VFX工作流程的制作pipeline当中。所有TD都是问题解决者。每个项目都有其复杂的地方，他们确保效果一致并且令人信服。</p></li>
<li><p><strong>FX Artist</strong> FX
艺术家。艺术家们使用TD创建出来的工具，通过自身的艺术造诣和导演的要求，为单个镜头创建效果。他们是视觉效果的生产者。</p></li>
</ul>
<h4 id="fx-工作流程">FX 工作流程</h4>
<p>因为今天演讲的主题是模拟相关，所以我们关注的FX部门的流程将不涉及到特效评估、数据统计、特效整理、测试、预演等细化工作。</p>
<figure>
<img src="/images/filmtechanalysis-PBA/FX部门流程.jpg"
alt="FX部门流程" />
<figcaption aria-hidden="true">FX部门流程</figcaption>
</figure>
<p>首先，导演提出视效需求给视效总监，由视效总监判断现阶段视效能否实现。若不能实现，则交给RnD部门研发该效果，并准备可行备用方案。若可以实现，则将其交给视效制片规划制作方案。当RnD研发好算法后，将算法交给TD。TD询问艺术家的工作习惯、预期希望可以调整的方面等需求，编程、制作成实现容易，并为艺术家暴露出可修改的参数。在制作阶段，视效制片将相应的特效镜头派发给FX部门，相应的镜头将被派发给不同的FX艺术家。FX艺术家在制作时会收到来自其他部门的模型文件、跟踪数据、关键帧动画等信息，进行特效的制作。其中，每一个部门都有相应的组长，会对艺术家所制作的镜头进行评估和审核。全部制作完成的特效镜头，会经过各个监管的层层审核与反馈迭代，最后给到剪辑进行素材的回插。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY</title>
      <link>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly/</guid>
      <description>注：本篇由同组同学LLY编写，本人代完成格式化
刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。
刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \(\mathbf x\) 和速度 \(\mathbf v\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。
质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \(\mathbf x\) 和 方向 \(R\) 。局部坐标为 \(\mathbf p_0\) 的点，世界坐标系下的坐标为：\(\mathbf p = \mathbf x + R \mathbf p_0\)
物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = + R + p_0 $
因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $
所以我们只需要求出每个时间的 \(\mathbf v\) 和 $ $ 就可以描述刚体随时间的运动状态了。
为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。
角速度 我们知道 \(R\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \[ \displaystyle\dot{R} = [\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ] \] 于是 \(\dot{R}\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \(\mathbf x\) ，旋转点位置是 \(\mathbf p\) ，旋转中心到位置 \(\mathbf p\) 的向量为 \(r\) 。我们的目的是测定 \(r\) 的变化率。由于 \(\mathbf p\) 以角速度 \(\omega\) 旋转，所以其瞬时速度与 \(r\) 和 \(\omega\) 垂直。瞬时速度方向由 \(\omega\times r\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$</description>
      <content:encoded><![CDATA[<blockquote>
<p>注：本篇由同组同学LLY编写，本人代完成格式化</p>
</blockquote>
<h2 id="刚体">刚体</h2>
<p>在物理学里，<strong>刚体</strong>是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。</p>
<h3 id="刚体属性与表达">刚体属性与表达</h3>
<p>为了表示一个刚体，我们首先需要知道刚体的<strong>质心</strong>。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标
<span class="math inline">\(\mathbf x\)</span> 和速度 <span
class="math inline">\(\mathbf v\)</span>
。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为<strong>局部坐标系</strong>。刚体及模拟的其他对象被放置在<strong>世界坐标系</strong>中。</p>
<figure>
<img src="/images/filmtechanalysis-PBA/质心.png" alt="质心" />
<figcaption aria-hidden="true">质心</figcaption>
</figure>
<p>为了指定刚体在世界坐标系中的放置方式，我们指定其位置 <span
class="math inline">\(\mathbf x\)</span> 和 方向 <span
class="math inline">\(R\)</span> 。局部坐标为 <span
class="math inline">\(\mathbf p_0\)</span>
的点，世界坐标系下的坐标为：<span class="math inline">\(\mathbf p =
\mathbf x + R \mathbf p_0\)</span></p>
<figure>
<img src="/images/filmtechanalysis-PBA/物体坐标系和世界坐标系.png"
alt="物体坐标系和世界坐标系" />
<figcaption aria-hidden="true">物体坐标系和世界坐标系</figcaption>
</figure>
<p>我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出：
$ = + R + p_0 $</p>
<p>因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $</p>
<p>所以我们只需要求出每个时间的 <span class="math inline">\(\mathbf
v\)</span> 和 $ $ 就可以描述刚体随时间的运动状态了。</p>
<p>为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。</p>
<figure>
<img src="/images/filmtechanalysis-PBA/角速度.png" alt="角速度" />
<figcaption aria-hidden="true">角速度</figcaption>
</figure>
<p>我们知道 <strong><span class="math inline">\(R\)</span>
的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标</strong>，因此，
$ $ 由这些方向向量的导数组成： <span class="math display">\[
\displaystyle\dot{R} =
[\dot{\hat{u_x}}\quad\dot{\hat{u_y}}\quad\dot{\hat{u_z}} ]
\]</span> 于是 <span class="math inline">\(\dot{R}\)</span>
就被简化成为求旋转矢量的导数的问题。旋转中心位置是 <span
class="math inline">\(\mathbf x\)</span> ，旋转点位置是 <span
class="math inline">\(\mathbf p\)</span> ，旋转中心到位置 <span
class="math inline">\(\mathbf p\)</span> 的向量为 <span
class="math inline">\(r\)</span> 。我们的目的是测定 <span
class="math inline">\(r\)</span> 的变化率。由于 <span
class="math inline">\(\mathbf p\)</span> 以角速度 <span
class="math inline">\(\omega\)</span> 旋转，所以其瞬时速度与 <span
class="math inline">\(r\)</span> 和 <span
class="math inline">\(\omega\)</span> 垂直。瞬时速度方向由 <span
class="math inline">\(\omega\times r\)</span>
表示，大小与向量积大小一致。于是我们可以得到： $ = r$</p>
<figure>
<img src="/images/filmtechanalysis-PBA/半径的变化率.png"
alt="半径的变化率" />
<figcaption aria-hidden="true">半径的变化率</figcaption>
</figure>
<p>将结果应用到旋转矩阵中，我们能写出旋转矩阵按时间的导数： <span
class="math display">\[
\dot R=[\omega\times\hat{\mathbf u}_x,\ \omega\times\hat{\mathbf u}_y,\
\omega\times\hat{\mathbf u}_z]
\]</span> 根据向量积表示法，我们可以化简得到： <span
class="math display">\[
\dot
R=\omega^*R\quad其中a^*=\begin{bmatrix}0&amp;-a_z&amp;a_y\\a_z&amp;0&amp;-a_x\\-a_y&amp;a_x&amp;0\end{bmatrix}
\]</span> 现在，我们只需要知道 <span class="math inline">\(\mathbf
v\)</span> 和 <span class="math inline">\(\omega\)</span>
就能表示描述刚体的运动状态了。</p>
<h3 id="刚体运动">刚体运动</h3>
<p>前面我们讲到，刚体有线性状态（ <span class="math inline">\(\mathbf
v\)</span> ）和角度状态（ <span class="math inline">\(\omega\)</span>
）。在模拟刚体时，必须更新这两种状态。刚体的运动可以拆分称平移运动和旋转运动。</p>
<h4 id="平移运动">平移运动</h4>
<p>平移运动非常简单。根据牛顿第二定律 <span
class="math inline">\(F=ma\)</span>
，逐时间步地更新我们的加速度、速度和位置即可。我们用前面提到过的时间积分方法迭代计算即可。</p>
<h4 id="旋转运动">旋转运动</h4>
<h5 id="惯性张量">惯性张量</h5>
<p><strong>线性动量</strong> <span class="math inline">\(P=mv\)</span>
，在有角度的情况下，有一个接近的类比，其中<strong>角动量 <span
class="math inline">\(L\)</span> </strong>
被定义为<strong>惯性张量</strong> <span class="math inline">\(I\)</span>
和<strong>角速度</strong> <span class="math inline">\(\omega\)</span>
的乘积： <span class="math inline">\(L=I\omega\)</span>
。惯性张量<em>I</em>描述质量如何在物体中分布，是一个 <span
class="math inline">\(3\times 3\)</span> 的矩阵。 <span
class="math inline">\(I\)</span>
的矩阵形式描述了惯性因方向而变化。局部坐标系中惯性张量的公式如下： <span
class="math display">\[
\mathbf I_{ref}=\sum m_i(\mathbf R_i^T\mathbf R_i\mathbf 1-\mathbf
R_i\mathbf R_i^T)
\]</span> 刚体在局部坐标系中的惯性张量 <span
class="math inline">\(I_0\)</span>
不会改变，但在世界坐标系中，惯性张量却会随着物体当前的方向而发生变化。根据线性空间转换可得，在世界坐标系中，物体的惯性张量为：
<span class="math display">\[
\mathbf I=\mathbf R\mathbf I_0\mathbf R^T
\]</span> 线性运动与旋转运动中，有这样的对应关系：</p>
<p><img src="/images/filmtechanalysis-PBA/线运动和角运动物理量对比.png" alt="线运动和角运动物理量对比" style="zoom:75%;" /></p>
<h5 id="力矩">力矩</h5>
<p><strong>线性动量</strong> <span class="math inline">\(P=mv\)</span>
，对于 <span class="math inline">\(F\)</span> ，有 $ F = ma = m = $ ，即
<span class="math inline">\(F\)</span>
是线性动量的时间变化率。角动量变化有类似的过程，角动量的时间变化率是<strong>力矩
</strong> <span class="math inline">\(\tau\)</span>。</p>
<p>力矩对应力的旋转 <span class="math inline">\(\tau =
\dot{L}\)</span></p>
<p><img src="/images/filmtechanalysis-PBA/力矩_1.png" alt="力矩_1" style="zoom:67%;" /></p>
<p>已知质心为 <span class="math inline">\(\mathbf x\)</span> ，假定在点
<span class="math inline">\(\mathbf p\)</span> 施加力 <span
class="math inline">\(F\)</span>
。任何不作用于刚体质心的力都将产生力矩。为测定力矩，首先计算<strong>力臂</strong>
<span class="math inline">\(r\)</span> ，<span
class="math inline">\(\tau = r \times f\)</span>
。力矩是一个矢量，方向同时垂直于力臂及作用力。方向为物体因力矩旋转时围绕的轴的方向。</p>
<p>力矩作用于整个刚体，可理解为力矩通过了质心。力矩的叠加满足矢量加法。</p>
<p><img src="/images/filmtechanalysis-PBA/力矩_2.png" alt="力矩_2" style="zoom: 80%;" /></p>
<p>于是，我们很容易就能得出 <span
class="math inline">\(\displaystyle\Delta \omega = \frac{\Delta L}{I} =
\Delta t \frac{\tau}{I}\)</span></p>
<h5 id="表示旋转的方法">表示旋转的方法</h5>
<p>我们到此为止一直在使用旋转矩阵来表示旋转。但其实旋转有很多种表示方式。</p>
<ul>
<li><p><strong>旋转矩阵</strong></p>
<ol type="1">
<li>会有太多数据冗余：表示旋转矩阵需要九个元素，但是只表示了三个自由度。</li>
<li>表示方法不符合直觉。</li>
<li>定义它的时间导数很困难。</li>
</ol></li>
<li><p><strong>欧拉角</strong></p>
<ul>
<li>优势：表示是符合直觉的。它用三个轴的旋转角度来表达一个旋转。</li>
<li>劣势：可能会导致万向锁问题，并且定义它的时间导数也很困难。</li>
</ul></li>
<li><p><strong>四元数：</strong>
一个四元数的第一位表示旋转角度，后三位表示旋转轴方向。
<img src="/images/filmtechanalysis-PBA/旋转的四元数表示_1.png" alt="旋转的四元数表示_1" style="zoom: 45%;" /></p>
<p>并且四元数可以和旋转矩阵互相转换：
<img src="/images/filmtechanalysis-PBA/旋转的四元数表示_2.png" alt="旋转的四元数表示_2" style="zoom: 50%;" /></p>
<p>于是我们用四元数来表示旋转的状态更新方程可以表示为：
<img src="/images/filmtechanalysis-PBA/旋转的四元数表示_3.png" alt="旋转的四元数表示_3" style="zoom: 50%;" /></p></li>
</ul>
<p>总结一下，我们的刚体运动模拟过程由下图所示：线性运动和角度运动的物理量都有相互对应的关系。</p>
<p><img src="/images/filmtechanalysis-PBA/线性运动与角度运动的对比.png" alt="线性运动与角度运动的对比" style="zoom:50%;" /></p>
<h3 id="刚体的碰撞与接触">刚体的碰撞与接触</h3>
<h4 id="rigid-collision-detection-and-response-by-impulse">Rigid
Collision Detection and Response by Impulse</h4>
<p>之前我们在粒子系统中已经介绍了一个点与面的两种碰撞方式，在Mesh表达的刚体碰撞处理中，我们一般采用Impulse的碰撞响应方式。</p>
<p>当物体有许多点构成时，我们可以检测每个点是否发生碰撞。</p>
<p><img src="/images/filmtechanalysis-PBA/碰撞_1.png" alt="碰撞_1" style="zoom:50%;" /></p>
<p><img src="/images/filmtechanalysis-PBA/碰撞_2.png" alt="碰撞_2" style="zoom:50%;" /></p>
<p>每一个点由 $x_i $ 表示，计算点到表面的距离 $ (x) $
是否小于0。若大于零，说明没有发生碰撞。若小于零，则发生碰撞。</p>
<p>然后将线性速度与角速度合成为此时该点的速度，若速度方向远离刚体内部，则不需要改变力，碰撞结束。若方向继续深入刚体内部，则继续运算。</p>
<p>首先强行创造一个离 $ x_i $ 最近的接触点 $ x_i^{new} $
，然后计算出当前速度的 <span class="math inline">\(xyz\)</span>
分量。新的点的垂直速度反向，并且乘以衰减参数 $ _N $
；平行速度乘以摩擦衰减参数 $ a $ 。将速度分量重新合成为 $ v_i^{new} $
此速度即为当前点的速度。 <span class="math display">\[
{\rm collision}\quad\mathbf x^{new}\leftarrow\mathbf x+|\phi(\mathbf
x)|\mathbf N=\mathbf x=\phi(\mathbf x)\nabla\phi(\mathbf x)
\]</span>
<img src="/images/filmtechanalysis-PBA/Impulse碰撞.png" alt="Impulse碰撞" style="zoom:67%;" /></p>
<p>又因为刚体的属性中只有线性速度和角速度，求得的点速度无法用于更新，所以引入冲量
<span class="math inline">\(j\)</span> 。因为冲量 $ j = Ft $</p>
<p>易得 $ v = t = j $ ， $ = t= t = I^{-1}(r j)$</p>
<p>列出方程组： <span class="math inline">\(\begin{array}{l}\mathbf
v^{new}=\mathbf v+\dfrac{1}{M}\mathbf j\\\mathbf \omega^{new}=\mathbf
\omega+\mathbf I^{-1}(\mathbf Rr_i\times \mathbf j)\\\mathbf
v_i^{new}=\mathbf v^{new}+\omega^{new}\times\mathbf R\mathbf
r_i\end{array}\)</span></p>
<p>即可求出 $ v^{new} $ 与 $ ^{new} $ 。</p>
<h4 id="shape-matching">Shape Matching</h4>
<p>Shape Matching
方法将物体上的点当作粒子进行状态更新，允许点有自己的速度，点与点之间没有任何相互作用力，然后再强行将其约束成为一个刚体。将点云的质心作为下一时刻刚体的质心，然后让刚体尽可能接近点云的形态。但是因为实际应用不多，具体方法不再赘述。</p>
<p><img src="/images/filmtechanalysis-PBA/ShapeMatching.png" alt="ShapeMatching" style="zoom:75%;" /></p>
<h3 id="约束">约束</h3>
<p>到目前为止，我们都讨论的是无约束系统的动力学。意思就是说，粒子或者刚体可以沿任何方向运动，仅受外力影响。但在基于物理的动画中，存在许多内在和约束有关的问题。比如轨道上的列车，车轮因为钢轨施加的作用力受到约束，沿轨道运行。轨道产生向上的作用力，支撑列车的重量，在转弯时，轨道也会产生横向作用力，保证车轮沿轨道前行。</p>
<p>我们把约束视为减少运动的<strong>自由度</strong>。没有约束的刚体存在6个自由度——3个平移自由度和3个旋转自由度。刚体可以沿
<span class="math inline">\(xyz\)</span> 方向移动、旋转。</p>
<h4 id="罚函数">罚函数</h4>
<p>罚函数法是维持约束最简单的方法。这种方法本质上就是先让刚体自由运动，当运动和约束有偏差的时候，再施加一个外力，使运动回到约束。因为这种方法是基于偏差而产生的校正力，所以不能维持<strong>刚性约束</strong>。刚性约束指永远不可能违反的约束。实现刚性约束需要使用其他方法（之后会讲到）。但很多例子中会使用暂时允许产生小幅偏差的<strong>柔性约束</strong>。</p>
<h5 id="p比例控制器">P（比例）控制器</h5>
<p><strong>P控制器</strong>是罚函数法使用的最简单的控制系统。这张图表示的是灰珠受到约束而沿线运动的例子。细线表示线的约束路径，粗线表示灰珠的实际路径。灰珠的中心位置为
<span class="math inline">\(\mathbf x(t)\)</span>
，约束路径上离灰珠最近的点为 <span class="math inline">\(\mathbf
c(\mathbf x)\)</span> 表示和约束误差的向量为 <span
class="math inline">\(\mathbf e(\mathbf x)=\mathbf c(\mathbf x)-\mathbf
x(t)\)</span> 。强度常量为 $ k_p $
的<strong>P控制器</strong>将施加以下校正力： <span
class="math display">\[
\mathbf F_p=-k_p\mathbf e
\]</span>
使用这种方法，灰珠会沿着约束路径运动，但两者之间仍存在较大的偏差，灰珠会在约束路径附近振动。并且当灰珠趋于静止时，和路径有一个恒定的偏差，此时控制器施加的力正好与重力抵消。</p>
<p><img src="/images/filmtechanalysis-PBA/P控制器.png" alt="P控制器" style="zoom: 25%;" /></p>
<h5 id="pd比例微分控制器">PD（比例微分）控制器</h5>
<p>给P控制器加一个微分项可以预防未来的误差变化。施加一个误差向量方向上的力，该力正比于误差变化率，因此控制器合力为：
<span class="math display">\[
\mathbf F_{pd}=-[k_p\mathbf e+k_d(\dot{\mathbf e}\cdot\hat{\mathbf
e})\hat{\mathbf e}]
\]</span> $ k_d $ 为误差微分的可调增益。一般而言误差函数 <span
class="math inline">\(\mathbf e(\mathbf x)\)</span>
没有直接的解析式，只要我们能计算 <span class="math inline">\(\mathbf
e\)</span> ，即可用两个时间步的误差估计当前时步的误差变化率： <span
class="math display">\[
\dot{\mathbf e}^{[n]}\approx(\mathbf e^{[n]}-\mathbf e^{[n-1]})/h
\]</span>
使用PD控制器仍然解决不了当灰珠趋于静止时，和路径有一个恒定的偏差。因为除非误差在一直变化，否则微分项不会施加力。</p>
<p><img src="/images/filmtechanalysis-PBA/PD控制器.png" alt="PD控制器" style="zoom:25%;" /></p>
<h5 id="pid比例积分微分控制器">PID（比例积分微分）控制器</h5>
<p>静止状态下的误差问题可以通过添加积分项解决。这意味着只要灰珠与约束路径存在误差，就会施加作用力：
<span class="math display">\[
\mathbf F_{pid}=-\left[k_p\mathbf e+k_d(\dot{\mathbf e}\cdot\hat{\mathbf
e})\hat{\mathbf e}+k_i\int_0^t\mathbf edt\right]
\]</span>
<img src="/images/filmtechanalysis-PBA/PID控制器.png" alt="PID控制器" style="zoom:25%;" /></p>
<p>使用PID控制器的小球运动如图所示。最初小球的运动路径与PD控制器基本一致，担当小球减速，其运动轨迹更接近约束路径。当小球最终静止时，几乎完全符合约束。这是因为只要未回到约束，积分项将一直施加逐渐变大的力，使其刚好抵消重力。</p>
<h4 id="约束动力学">约束动力学</h4>
<p>约束动力学通过产生作用力来抵消所施加的力，防止违反约束从而确保维持刚性约束。</p>
<p>我们首先关注模拟平面内运动钟摆的约束动力学问题。钟摆轴位置为 $ x_0 $
，因此所有的运动都应围绕该位置旋转。质量为 m 的摆球安装在长度为 r
的杆末端，杆是刚性的且质量忽略不计。摆球中心记为变量 $ x $
，所有施加在摆球上的合外力为 $ f_a $ 。我们的目标是产生一个刚好可以抵消
$ f_a $ 中可能导致杆长度发生变化的约束力 $ f_c $ 。</p>
<p><img src="/images/filmtechanalysis-PBA/约束动力学_1.png" alt="约束动力学_1" style="zoom: 33%;" /></p>
<p>约束动力学的关键是创建一个约束函数。这个函数是一个判定函数，当满足约束条件时，该函数值
=
0。我们想要让系统永远满足约束条件，也就是约束函数恒为0。故该函数对时间的一阶导数始终为0。同时，我们还必须确保该函数的变化率也恒为0，也就是没有发生变化的趋势，所以我们需要该函数对时间的二阶导数也为0。对于钟摆问题，我们选择一个最为明显的约束函数：
<span class="math display">\[
\mathbf c(\mathbf x)=\|\mathbf x-\mathbf x_0\|-r
\]</span> 该函数计算导数非常困难，故我们使用该约束函数： <span
class="math display">\[
\mathbf c(\mathbf x)=\dfrac{1}{2}[(\mathbf x-\mathbf x_0)^2-r^2]
\]</span> 当x与 $ x_0 $
的距离刚好为r时，约束函数为0。约束函数对x的一阶导数为: $ x - x_0 $
，根据链式法则，约束函数对时间的一阶导数为： <span
class="math display">\[
\dot {\mathbf c}=(\mathbf x-\mathbf x_0)\cdot\dot {\mathbf x}
\]</span> 二阶导数为： <span class="math display">\[
\ddot {\mathbf c}=\dot{\mathbf x}^2+(\mathbf x-\mathbf x_0)\cdot\ddot
{\mathbf x}
\]</span> 施加在摆球上的合力是外力与约束力的总和。根据牛顿第二定律：
<span class="math display">\[
\ddot{\mathbf x}=\dfrac{1}{m}{\mathbf f_a + \mathbf f_c}
\]</span> 因为联立以上三式，又因为 $ = 0,   = 0 $ ，经整理得： <span
class="math display">\[
\dfrac{1}{m}(\mathbf x - \mathbf x_0)\cdot \mathbf f_c = -\dot{\mathbf
x}^2-\dfrac{1}{m}(\mathbf x-\mathbf x_0)\cdot\mathbf f_a
\]</span> 又因为约束力必须与杆平行，可得： <span class="math display">\[
\mathbf f_c=\lambda(\mathbf x - \mathbf x_0)
\]</span> 其中，<span class="math inline">\(\lambda\)</span>
为待定的比例因子。再联立以上两式，即可求解 <span
class="math inline">\(\lambda\)</span> ： <span class="math display">\[
\displaystyle\lambda=-\frac{m\dot{\mathbf x}^2+(\mathbf x-\mathbf
x_0)\cdot\mathbf f_a}{(\mathbf x-\mathbf x_0)^2}
\]</span> 因此钟摆的系统动力学函数首先要求计算作用于钟摆的外力 $ f_a
$，然后计算出比例因子 <span
class="math inline">\(\lambda\)</span>，再计算出约束力 $ f_c $ 。已知 $
f_a <span class="math inline">\(，\)</span> f_c $
，在计算出摆球的总加速度。</p>
<p>该单一约束的问题也可以推广到多约束的复杂系统。设定多个约束函数来求解多个约束力。由于篇幅限制，所以我们不再过多介绍。</p>
<p><strong>总结</strong></p>
<p>约束会减少系统的自由度。</p>
<p>罚函数法先不考虑任何约束，直接计算运动，当运动与约束有所偏差时，再添加外力抵消。</p>
<p>约束动力学通过计算约束力来维持刚性约束。</p>
<p>以上，我们讲解了刚体的表示方法、表示刚体运动的方法、如何更新刚体运动状态、如何处理刚体运动的碰撞，以及如何对刚体创建约束。相信大家对刚体模拟都有了更深层次的了解。</p>
<h3 id="vfx中的刚体模拟">VFX中的刚体模拟</h3>
<p>刚才，我们从底层原理的角度讲述了刚体的表示和模拟的计算方法，那么，这节课我们就来详细讲讲我们该如何实际使用刚体模拟来实现我们想要的一些效果。在VFX中，刚体模拟最常用的地方，就是创建物体毁灭的效果，英文中这个效果叫做Destruction。</p>
<h3 id="destruction">Destruction</h3>
<p>电影《2012》是大范围的破坏视觉效果的分水岭，直到那时，还没有人看到过如此大规模的毁灭影像。这部电影加速了Bullet作为主要物理引擎的重要性和行业接受度。自2009年以后，视觉特效工作室、学术机构和开源项目继续为destruction工具做出贡献。</p>
<h4
id="实现destruction效果的两种方法">实现Destruction效果的两种方法</h4>
<p><strong>RBS方法。</strong>这种方法主要有两种实现形式。</p>
<p>第一种叫标准的RBS方法，最为广泛使用。此方法围绕现有物理库（如Bullet、PhysX或ODE）定制。其中，Bullet库最受欢迎。SPI、Frameworks、Weta和Dneg等公司是使用此方法的代表。这个方法还被众多商业软件和引擎如Houdini等使用。</p>
<p>还有一种RBS方法是使用专业物理库的RBS方法，主要使用此方法的公司有：皮克斯、迪士尼、Industrial
Light &amp;
Magic等。这种方法与标准RBS方法的区别体现在碰撞检测中，他们使用了水平集方法。</p>
<p><strong>有限元分析（FEA）</strong>。这种方法又被称为传统的大规模真实世界工程方法。这种方法目前只被MPC公司在电影视效中广泛使用。虽然这种方法在影视中不常见，但有许多游戏已经开始使用这种方法。</p>
<h4 id="rbs方法">RBS方法</h4>
<ul>
<li><strong>RBS的三个阶段</strong>
<ul>
<li>第一阶段：分解RBS对象（预破碎）</li>
<li>第二阶段：设置约束和设计编排</li>
<li>第三阶段：运行模拟并进行碰撞检测</li>
</ul></li>
</ul>
<p><strong>第一阶段：分解RBS对象（预破碎）</strong></p>
<p>在RBS中，物体不会受力自行发生破碎，而是在进行模拟前需要先人为的破碎成小块，再在模拟中进行解算。RBS的第一阶段是准备几何体，换句话说，就是研究如何将几何体分解为“小块”。埃尔文·库曼斯（Erwin
Coumans）在加拿大温哥华SIGGRAPH提出了四种分解几何体的方法：</p>
<ul>
<li><p>A. 维诺图 Voronoi Diagrams</p></li>
<li><p>B.CSG constructive solid
geometry：使用布尔运算切割几何图形。</p></li>
<li><p>C.凸分解 Convex
Decomposition：这可以由艺术家手工或使用自动工具执行。</p></li>
<li><p>D.四面体化，也可以通过将3D模型转换为tetras来实现。</p></li>
</ul>
<p><strong>A.维诺图 Voronoi Diagrams </strong></p>
<p>维诺图是一个数学概念，广泛用于生成看起来自然的断裂形状。这个原理非常简单，看起来非常自然。在两个点之间画一条等距离的线，与两点连线成直角。初始点（或称粒子）可以通过多种方式生成，包括随机生成。
这有效地将对象简化为点云，然后生成一组多边形的破碎子几何体。这一概念是RBS/刚体动力学<strong>程序化破碎的核心</strong>。</p>
<p><strong>B.CSG Constructive Solid Geometry</strong></p>
<p>这是一种已经存在多年的技术。它使用简单加法、减法和异或运算。这些数学运算称为<strong><em>布尔运算</em></strong>，这个方法称为<em>构造立体几何或CSG</em>。它可以在三维模型之间执行体积运算，使几个简单的几何图形或对象构建为更复杂、更自然的细分形状。可以将两个体积相加，或计算两个对象之间的差值，或求它们的交集。这些操作可以将原始三维模型分解为更小的部分，类似于饼干切割器。这个方法的<strong>优点</strong>是可以精确控制物体破碎后的几何形状，<strong>缺点</strong>是操作繁琐，不够程序化，并且在多边形中进行布尔运算容易出现问题。</p>
<p><strong>C.凸分解 Convex Decomposition</strong></p>
<p>“convex”一词的意思是向外弯曲或凸出，与向内弯曲的concave相反。凸分解是一种通常用于将复杂模型简化为更易于处理的较小子模型的技术。凸分解<strong><em>将一个复杂多面体划分为多个凸面几何体</em></strong>。由于凸对象的重要性质，许多算法在凸对象上比在非凸对象上更有效。因此，此种方法处理的几何体<strong>主要用于计算碰撞检测</strong>。艺术家可以使用简单的凸面图元（如长方体、球体和胶囊）手动创建凸面分解。也可以自动创建凸分解。</p>
<p><strong>D.四面体化 Tetrahedralization</strong></p>
<p>这种处理几何体的方法用于<strong>有限元分析</strong>，在传统的RBS流程中不会使用。但因这也是预处理几何体的方法之一，故在此做简单介绍。一个mesh可以使用<strong><em>德洛内（Delaunay）三角剖分</em></strong>分解为<strong>四面体网格</strong>。有一些开源软件实现可用，包括Netgen和Tetgen。Pixelux的Maya
2012 DMM数字分子物质插件在内部使用Netgen执行四面体化。</p>
<p><strong>第二阶段：设置约束并控制约束力的大小</strong></p>
<p>在几何体准备好并分解为预破碎的小块后，如果直接进行模拟，它们就是一个个独立的碎块，还没来得及发生外力的碰撞，就在重力的作用下发生坍塌了。因此，在预破碎几何体后，还需要一个方式将它们约束在一起。直到外力超过了约束的限制时，约束才会消失，从而看起来发生了破碎。</p>
<ul>
<li><strong>设置约束的两种方法</strong>
<ul>
<li><strong>A.定义每个部件和其他部件之间的连接。</strong></li>
<li><strong>B.基于碰撞检测自动计算连接。</strong></li>
</ul></li>
</ul>
<p><strong>A.定义每个部件和其他部件之间的连接。</strong></p>
<p>这提供了最多的控制，但如果连接太多，性能可能会比较慢。如果使用维诺图的方法进行预破碎，可以自然而然地得到各个子几何体的连接。因为维诺图使用的是代表子几何体的点云，每个点的连接就是子几何体的连接。因此很容易对连接进行程序化约束。</p>
<p>现在，如果艺术家想要控制建筑的哪一侧倒塌，他们可以在约束上进行“绘制”，这是RBS设置的一部分。约束基本上是指导模拟的，比如说我们可以手动添加metaball来控制某一个区域的约束力大小，来削弱这个对象在这一帧这个区域内的所有约束。</p>
<p><strong>B.基于碰撞检测自动计算连接。</strong></p>
<p>计算相邻碎块之间的接触点，并且仅在存在接触点时创建连接。然后，你可以为这些连接创建中断阈值。一旦我们将这些片段粘合成一个刚体，我们就可以执行运行时断裂。如果发生碰撞，我们计算其冲量。如果该冲量大于所选阈值，我们将通过连接来传播该冲量。这些连接可能会减弱或断开。在此之后，需要确定断开连接的碎块，然后为每个单独的碎块创建新刚体。</p>
<p>放射状破碎就是一个很好的例子。某些类型的玻璃在破裂时会出现维诺图无法立即提供的径向图案。此效果可以通过蒙版或break
maps提供。径向裂纹是需要解决的较为典型的特殊情况之一。它们既有从碰撞点辐射的裂纹，也有围绕碰撞点的圆形裂纹。Dneg使用Dn-crack，这是一种程序化表面破碎器。它不像voronoi破碎器那样进行固体体积破碎，而是进行多边形表面破碎。</p>
<p>它的工作原理是用户提供一组用脚本编写的规则，这些规则描述裂纹如何出现在表面上，如何传播到子裂纹，以及每个裂纹如何生成，然后底层代码根据这些规则在表面上生成这些裂纹，将它们相交，重要的是在裂缝交汇处终止，等等。然后最终的设定是它将所有几何体分割为最终的破碎碎块。</p>
<p><strong>第三阶段：运行模拟和碰撞检测</strong></p>
<p>碰撞检测最简单形式是Bounding
Box。如果所有对象都包含在简单的boxes中，则避免boxes重叠从而避免物体碰撞。问题是，虽然这非常快，但大多数简单的长方体通常会生成过大的形状，无法生成高质量的模拟。显然，肉眼看起来不太靠近的物体似乎仍然会相互反弹。那么我们该怎么做才能使碰撞看起来尽可能精准，并且不太消耗算力呢？</p>
<p>大多数碰撞检测管道中分为两个主要阶段，分别是<strong>broad-phase</strong>和<strong>narrow-phase</strong>。</p>
<p><strong>Broad-phase:</strong></p>
<p>Broad-phase阶段根据<strong>边界体积重叠</strong>（bounding volume
overlap）减少潜在交互对象的总数。Bullet中有各种不同用途的broad-phase实现。最通用的broad-phase实现是基于<strong>动态边界体积层次结构</strong>（dynamic
bounding volume
hierarchies）：移动、添加或删除对象时更新<strong>轴对齐包围盒</strong>（axis
aligned bounding box）。</p>
<p>总的来说，就是先使用一个算法找到可能发生碰撞的物体，从而减少不必要的计算。</p>
<p><strong>Narrow-phase:</strong></p>
<p>Narrow-phase阶段处理的是<strong>成对碰撞对象之间精确接触点的生成</strong>。</p>
<p><strong>A.标准RBS方法</strong></p>
<p>最流行的解决方案是将<em>主对象细分为一组较小的对象，但都是单独凸面的</em>。这称为<strong>凸壳碰撞检测</strong>（Convex
hull collision detection）。</p>
<p>Bullet使用了一些通用算法，如GJK（Gilbert–Johnson–Keerthi）来实现<strong>两个凸面形状之间的快速距离</strong>，并处理各种碰撞形状类型。支持计算移动和旋转对象之间碰撞时间的连续碰撞检测，但默认情况下Bullet计算离散时间点的最近距离和穿透深度，以生成接触点信息或进行碰撞检测。</p>
<p>在确定可能发生碰撞的物体对后，将物体替换为它的凸壳，计算两个凸壳之间的距离以生成接触点信息。使用凸壳来计算是为了加快计算的速度，是模拟质量和模拟速度妥协的结果。</p>
<p><strong>B.水平集方法</strong></p>
<p><strong>有向距离场的概念</strong></p>
<p><strong>水平集的基本概念</strong></p>
<p>水平集数据结构用于表示<strong><em>离散采样的动态水平集函数</em></strong>。这种形式的数据结构通常用于高效的图像渲染。基本方法是构造一个从边界延伸的有向距离场，并可用于解算该场中边界的运动。</p>
<p>“术语‘LSV’（level set
value，水平集值）实际上是一个隐式曲面，用于模拟中的碰撞对象的倾向。PhysBAM使用水平集数据结构来实现它的<strong>narrow-phase
碰撞检测</strong>。当查询粒子与几何曲面的距离时，水平集具有<strong>快速查找</strong>的良好特性。PhysBAM使用的水平集数据结构将几何体的空域划分为box
cells，每个cell存储其到曲面的距离（φ）。从附近cells的集合中，我们可以计算梯度场，该梯度场产生指向几何体表面的法向量。通过水平集上的法向量和φ函数，我们可以计算到几何体表面的精确距离。”</p>
<p>通过查看这些向量和法线，可以判断你是在碰撞检测对象的内部还是外部。然后，ILM进一步利用这一点，使用水平集进行破碎。使用水平集可以轻松完成的一件事是在物体表面行走。我已经将所有空间分割成一个网格，在任何一点我都可以显示”我离表面有多近“，如果我不知道，那么我可以使用网格查找信息直接到达表面。”</p>
<p>对于单个物体，当粒子进入碰撞检测包围盒时，为物体设置一个水平集，很容易确定粒子是位于物体的内部还是外部，因此，粒子从物体上更精确地反弹，而不仅仅是从包围盒上反弹。但在破碎中，ILM并没有以同样的方式使用水平集，水平集不是表示单个对象，而是表示一组或一组称之为zero
iso contours的点，这些点在水平集中实际位于曲面上。</p>
<p>Zero iso
contours与voronoi等破碎工具非常相关。Voronoi点是用来破碎对象的，但ILM获取Voronoi点，然后找到刚好在模型曲面上的点，因为Voronoi种子点云通常不知道表面在哪，它只是负责将空间分割开，但在ILM中，水平集将这种分割带到下一个级别，不基于水平集创建子几何体，而是直接使用水平集分割高分辨率的几何图形。</p>
<p>斯坦福大学PhyBAM模拟软件的<strong>碰撞检测</strong>都基于水平集方法，基于SIGGRAPH
2003中Eran Guendelman的Nonconvex Rigid Bodies with
Stacking（非凸刚体的堆叠）。他们的RBS要求你有一个体积，以便对象正确碰撞，因此他们在模拟开始时使用水平集方法生成此体积数据结构，在模拟期间，他们将使用刚体表面的粒子来测试它们可能与之交互的对象的水平集的深度。它的分析查找速度很快，水平集的<strong>优点</strong>是，在空间中的任何一点，我都可以快速且准确地告诉你离曲面有多远，因此它是一个很好的碰撞查找模型。但<strong>缺点</strong>是它需要<em>很长的时间生成</em>，并且水平集的<em>存储空间</em>以立方方式增加。</p>
<p>幸运的是，水平集可以更改分辨率，ILM可以轻松控制此级别的精度。当你想让事情变得更复杂时，你必须不断增加水平集的存储空间。因此，与其他方法一样，ILM的艺术家和TD需要非常谨慎地在时间和准确性之间进行权衡。</p>
<h4 id="有限元分析-finite-element-analysis">3.有限元分析 Finite Element
Analysis</h4>
<p>FEA是一种物理上更精确的制作Destruction的方法，它使用<strong>有限元方法</strong>(finite
element
method)来求解控制弹性材料的动力学的偏微分方程。FEA是模拟变形的一种<em>物理上更正确</em>的方法，破碎是基于<strong>连续介质力学</strong>的。一个3D
mesh是用一组元素来近似的，通常是<strong>四面体</strong>。应变、应力和刚度矩阵用于计算力和变形的影响。</p>
<p><strong>有限元法</strong></p>
<p>有限元法最初被称为矩阵近似方法，应用于航空器的结构强度计算，并由于其方便性、实用性和有效性而引起从事力学研究的科学家的浓厚兴趣。经过短短数十年的努力，随着计算机技术的快速发展和普及，有限元方法迅速从结构工程强度分析计算扩展到几乎所有的科学技术领域，成为一种丰富多彩、应用广泛并且实用高效的数值分析方法。</p>
<p>FEA由R.Courant于1943年首次开发，并在20世纪70年代和80年代用于制造业，但直到21世纪10年代才找到了实现视觉效果的方法。MPC是FEA在视觉效果工作中的主要公司之一。“有可能这项技术现在才足够快，可以使用，别忘了RBS在VFX中花了相当长的时间才被采用。”</p>
<p>FEA使用一个称为<strong>节点</strong>的复杂点系统，该节点构成称为mesh的三维网格。该网格被设计并<strong>包含材料和结构属性</strong>，这些属性定义了结构如何对特定荷载条件作出反应。根据特定区域的预期应力水平，在整个材料中以特定密度指定节点。承受大量应力的区域通常比承受很少或没有应力的区域具有更高的节点密度。网格就像一张网络，每个节点都延伸一个网格单元到每个相邻节点。这张矢量网将材质属性带到对象上，创建了许多单元。</p>
<p><strong>DMM系统 Digital Molecular Matter system</strong></p>
<p>问题是，有限元分析曾经的计算非常昂贵。但一个新的系统诞生了。Pixelux是DMM数字分子物质系统的开发者，该系统使用基于有限元的方法处理柔体，使用四面体网格，并将应力张量直接转换为节点力。通过一些非常聪明的假设和技巧，DMM是可以是实时的。</p>
<p>DMM是从2004年开始，在六年半的时间里为<strong><em>电子游戏</em></strong>设计的。从2005年到2008年，作为《星球大战：原力释放计划》的一部分，Pixelux
DMM技术是卢卡斯艺术娱乐公司的独家技术。DMM中的有限元系统利用了加利福尼亚大学伯克利教授，James
F. O’Brien博士论文中的破碎和变形算法。Pixelux首席技术官Eric
Parker领导的团队对O’Brien算法进行了改进、优化，并将其应用到DMM中间件中，Pixelux首席执行官Mitchell
Bunnell领导的团队设计了DMM工具流程。</p>
<p>与传统的基于刚体运动学的实时仿真引擎不同，FEA允许DMM<strong>非常快速地模拟大量的物理特性</strong>。开发人员可以给给定的对象分配物理属性，从而允许对象像在现实世界中一样行为。此外，对象的属性可以在运行时更改，从而产生更多有趣的效果(参见下面的“chopping”)。</p>
<p><strong>MPC的Kali destruction tool</strong></p>
<p>《美少女特工队》中，巨武士战役中有大量木头破碎的镜头，木头的破碎不同于刚体，木头具有大量的形变能力。传统的RBS并不能达到预期的效果。MPC看到在SIGGRAPH中使用四面体FEA进行实时应用的文章，他们认为，如果FEA可以通过实时实现，那么如果再深入研究一下，说不定在VFX中就可以实现。”MPC直接与Pixelux合作，在他们自己的代码中使用Pixelux的解算器。</p>
<p>碰撞检测通常是由包围盒或凸面外壳（和水平集体积）实现的，但在FEA中，实际上完全使用网格，然后执行“tet-collision
detection（<strong>四面体网格碰撞检测</strong>）”。原始对象完全包围在<strong>固定大小或分辨率</strong>的四面体网格（
tetrahedral
mesh）中，这是一种基于速度/效率原因的非自适应网格解决方案。一个tet和另一个tet之间的碰撞检测比任意凸面和凸面的检测简单得多。</p>
<p>tet网格与物体几何体不同，但它很接近。但由于tet的数量是固定的，因此必须将细节放在你认为可能需要的地方。你可以做一个自适应解决方案，使解算器在物体破裂时切换并添加更多细节，但实际上，在帧间进行比较是相当困难的。但是如果你知道tet的数量是固定的，你可以使用它进行比较。MPC使用该技巧进行render
time chopping。“render time
chopping”指的是模拟使用固定分辨率的网格，在渲染时将几何体替换为完全不同的几何体的能力。</p>
<p><strong>在FEA中没有预破碎，没有voronoi或切割，从某种意义上说，这是一个更纯粹的解决方案。</strong>tet连接在一起，形成一个大的组，其中有一个共同的节点。该点被定义为具有一定的强度、结构鲁棒性，如果超过阈值，则会断开该连接。用tet填充体积的算法具有一定的随机性，足以满足需要。艺术家可以控制tet的密度，但精确的顶点在材质内部。</p>
<p><strong>FEA的优点：</strong>基于材料属性破碎。</p>
<p>破碎将取决于物体受力的方式。这是基于材料属性的，在传统的RBS方法中，在模拟发生前物体就已经被破碎了。你不需要使用FEA来实现这一点，因为你有明确的内力，因此碎块会按照你想要的方式，以及它应该的方式断裂。</p>
<p><strong>FEA的控制</strong>：</p>
<p>MPC有一个大小限制，它可以控制最小碎片的大小，以免物体变成粉末。</p>
<p>仍然可以预先破坏某些物体。MPC的TD基于voronoi贴图制作密度贴图，可以影响节点的密度云，但系统仍然基于实际材质断裂。</p>
<p><strong>FEA的附加效果：</strong></p>
<p>模拟的物体可以发生符合物理的塑性变形。结构蠕变、塑性或弹性变形可以作为标准系统的一部分进行，不需要任何造假和技巧。在MPC，艺术家可以通过对具有塑性变形的“钢”施加力来弯曲钢梁。</p>
<p>MPC系统更简单，弯曲效果不需要单独进行设置，传统的RBS需要对每一个不同的材质进行特殊的绑定和预破碎。而MPC将所有物体都放在一个tet网格框架中。所有模拟都可以统一进行，并且通过rendertime
chopping，随时可以替换框架中的几何体。这种抽象级别非常强大。</p>
<p>这个概念与传统的<strong>自由变形晶格</strong>（Free Form Deformation
lattice,
FFD）类似。FFD框架可以使其内部的任何几何体变形，因此很容易想象弯曲框架然后交换内部的几何体——可以从低模转换为高模。虽然将高分辨率几何体切分为与tet网格相对应的碎块非常昂贵，但因为tet网格不会改变，只需在最后一帧执行一次，然后就可以在整个模拟过程中将其应用到每一帧的动画中。</p>
<p><strong>为什么其他公司没有使用有限元分析</strong></p>
<p>1.员工和整个软件系统需要重新培训和重建。目前为止，还没有发现需要改变。</p>
<p>2.虽然传统RBS需要更多的设置，但是性能比FEA强很多。</p>
<h4 id="destruction-方法总结">Destruction 方法总结</h4>
<p>所有方法都是为了获得银幕上真实的效果。只要结果达到了，使用什么方法都是可行的。但随着计算力的发展，更符合物理的方法是必然的趋势。但就目前而言，是特效TD和动画师的技术、艺术以及经验使得影片的真实感达到了如此高的水平。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-12-05-影片技术分析Pre-基于物理的动画-最新进展与应用</title>
      <link>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/</guid>
      <description>影视制作中的最新进展与应用 学术界发展动向 在讨论影视工业中物理模拟的最新方向之前，我们先看看学界这两年都在做什么——技术的发展顺序大部分情况下都是先从学术界开始的。
我整理出了近三年国际图形学顶级学术会议Siggraph发表的论文中，基于物理的动画方向的所有论文：
Siggraph 2021 Revisiting Integration in the Material Point Method: A Scheme for Easier Separation and Less Dissipation 重新审视物质点法（MPM）：更易分离、更少耗散的方法 Mechanics-Aware Deformation of Yarn Pattern Geometry 纱织物几何体的力学感知变形 Kelvin Transformations for Simulations on Infinite Domains 无限域模拟的开尔文变换 QuanTaichi: A Compiler for Quantized Simulations QuanTaichi：一种量化模拟编译器 A Unified Second-Order Accurate in Time MPM Formulation for Simulating Viscoelastic Liquids with Phase Change 相变粘弹性液体模拟的统一二阶时间精确MPM公式 Bijective and Coarse High-Order Tetrahedral Meshes 双射和粗高阶四面体网格 Physical validation of simulators in Computer Graphics: A new framework dedicated to slender elastic structures and frictional contact 计算机图形学模拟器的物理验证：一种细长弹性结构和摩擦接触的新型框架 Stream-Guided Smoke Simulations 流向烟雾模拟 Solid-Fluid Interaction with Surface-Tension-Dominant Contact 表面张力主导接触的固液相互作用 Fire in Paradise: Mesoscale Simulation of Wildfires 天堂之火：野火尺度模拟 Systematically Differentiating Parametric Discontinuities 系统区分参数不连续性 Thin-Film Smoothed Particle Hydrodynamics Fluid 薄膜平滑粒子流体动力学（SPH）流体 Clebsch Gauge Fluid Clebsch规范流体 Incompressible Flow Simulation on Vortex Segment Clouds 涡段云上的不可压缩流体 Codimensional Incremental Potential Contact 共维增量潜在接触（C-IPC） Intersection-free Rigid Body Dynamics 无交点刚体动力学 Medial IPC: Accelerated Incremental Potential Contact With Medial Elastics Medial IPC：结合Medial Elastics的IPC方法 High-order Differentiable Autoencoder for Nonlinear Model Reduction 非线性模型重建的高阶可微自动编码器 Fast Linking Numbers for Topology Verification 拓扑验证的快速链接数 of Loopy Structures 环状结构 Learning Contact Corrections for Handle-Based Subspace Dynamics 基于句柄的子空间动力学的接触修正学习 The Shape Matching Element Method: Direct Animation of Curved Surface Models 形状匹配元素方法：曲面模型的直接动画 GPU-Based Simulation of Cloth Wrinkles at Submillimeter Levels 基于 GPU 的亚毫米级布料皱纹模拟 Multiscale Cholesky Preconditioning for Ill-conditioned Problems 病态问题的多尺度Cholesky预处理 A Momentum-Conserving Implicit Material Point Method for Surface Tension with Contact Angles and Spatial Gradients 具有接触角和空间梯度的表面张力动量守恒隐式材料点法 SANM: A Symbolic Asymptotic Numerical Solver with Applications in Mesh Deformation SANM：网格变形中应用的符号渐近数值求解器 Learning Meaningful Controls for Fluids 流体有意义控制学习 Unified Particle System for Multiple-fluid Flow and Porous Material 多流体流动和多孔材料的统一粒子系统 Constrained Projective Dynamics: Real-time Simulation of Deformable Objects With Energy-momentum Conservation 约束投影动力学：能量-动量守恒的可形变物体的实时模拟 TOG:</description>
      <content:encoded><![CDATA[<h2 id="影视制作中的最新进展与应用">影视制作中的最新进展与应用</h2>
<h3 id="学术界发展动向">学术界发展动向</h3>
<p>在讨论影视工业中物理模拟的最新方向之前，我们先看看学界这两年都在做什么——技术的发展顺序大部分情况下都是先从学术界开始的。</p>
<p>我整理出了近三年国际图形学顶级学术会议Siggraph发表的论文中，基于物理的动画方向的所有论文：</p>
<blockquote>
<h3 id="siggraph-2021">Siggraph 2021</h3>
<ul>
<li><a href="http://yunfei.work/asflip/">Revisiting Integration in the
Material Point Method: A Scheme for Easier Separation and Less
Dissipation</a> 重新审视物质点法（MPM）：更易分离、更少耗散的方法</li>
<li><a
href="https://visualcomputing.ist.ac.at/publications/2021/MADYPG/">Mechanics-Aware
Deformation of Yarn Pattern Geometry</a> 纱织物几何体的力学感知变形</li>
<li><a
href="http://cseweb.ucsd.edu/~viscomp/projects/SIG21KelvinTransform/">Kelvin
Transformations for Simulations on Infinite Domains</a>
无限域模拟的开尔文变换</li>
<li><a
href="https://yuanming.taichi.graphics/publication/2021-quantaichi/">QuanTaichi:
A Compiler for Quantized Simulations</a>
QuanTaichi：一种量化模拟编译器</li>
<li><a href="https://orionquest.github.io/papers/USOSVLPC/paper.html">A
Unified Second-Order Accurate in Time MPM Formulation for Simulating
Viscoelastic Liquids with Phase Change</a>
相变粘弹性液体模拟的统一二阶时间精确MPM公式</li>
<li><a href="https://cs.nyu.edu/~yixinhu/">Bijective and Coarse
High-Order Tetrahedral Meshes</a> 双射和粗高阶四面体网格</li>
<li><a href="http://elan.inrialpes.fr/people/vromerog/">Physical
validation of simulators in Computer Graphics: A new framework dedicated
to slender elastic structures and frictional contact</a>
计算机图形学模拟器的物理验证：一种细长弹性结构和摩擦接触的新型框架</li>
<li><a
href="http://nishitalab.org/user/syuhei/StreamGuidedSmoke/streamguided_smoke.html">Stream-Guided
Smoke Simulations</a> 流向烟雾模拟</li>
<li><a href="https://arxiv.org/abs/2105.08471">Solid-Fluid Interaction
with Surface-Tension-Dominant Contact</a>
表面张力主导接触的固液相互作用</li>
<li><a
href="http://computationalsciences.org/publications/haedrich-2021-wildfires.html">Fire
in Paradise: Mesoscale Simulation of Wildfires</a>
天堂之火：野火尺度模拟</li>
<li><a
href="https://people.csail.mit.edu/sbangaru/projects/teg-2021/">Systematically
Differentiating Parametric Discontinuities</a> 系统区分参数不连续性</li>
<li><a
href="https://wang-mengdi.github.io/proj/thin-film-sph/">Thin-Film
Smoothed Particle Hydrodynamics Fluid</a>
薄膜平滑粒子流体动力学（SPH）流体</li>
<li><a href="https://y-sq.github.io/proj/clebsch_gauge_fluid/">Clebsch
Gauge Fluid</a> Clebsch规范流体</li>
<li><a
href="https://shiyingxiong.github.io/proj/VortexSegments/VortexSegments">Incompressible
Flow Simulation on Vortex Segment Clouds</a> 涡段云上的不可压缩流体</li>
<li><a href="https://ipc-sim.github.io/C-IPC/">Codimensional Incremental
Potential Contact</a> 共维增量潜在接触（C-IPC）</li>
<li><a href="https://ipc-sim.github.io/rigid-ipc/">Intersection-free
Rigid Body Dynamics</a> 无交点刚体动力学</li>
<li><a href="https://www.seas.upenn.edu/~minchenl/">Medial IPC:
Accelerated Incremental Potential Contact With Medial Elastics</a>
Medial IPC：结合Medial Elastics的IPC方法</li>
<li><a href="https://yangzzzy.github.io/">High-order Differentiable
Autoencoder for Nonlinear Model Reduction</a>
非线性模型重建的高阶可微自动编码器</li>
<li><a
href="https://graphics.stanford.edu/papers/fastlinkingnumbers/">Fast
Linking Numbers for Topology Verification</a> 拓扑验证的快速链接数</li>
<li><a
href="https://graphics.stanford.edu/papers/fastlinkingnumbers/">of Loopy
Structures</a> 环状结构</li>
<li><a
href="http://mslab.es/projects/LearningContactCorrections/">Learning
Contact Corrections for Handle-Based Subspace Dynamics</a>
基于句柄的子空间动力学的接触修正学习</li>
<li><a
href="https://www.dgp.toronto.edu/projects/shape-matching-element-method/">The
Shape Matching Element Method: Direct Animation of Curved Surface
Models</a> 形状匹配元素方法：曲面模型的直接动画</li>
<li><a
href="https://web.cse.ohio-state.edu/~wang.3602/publications.html">GPU-Based
Simulation of Cloth Wrinkles at Submillimeter Levels</a> 基于 GPU
的亚毫米级布料皱纹模拟</li>
<li><a href="http://www.geometry.caltech.edu/pubs/CSHD21.pdf">Multiscale
Cholesky Preconditioning for Ill-conditioned Problems</a>
病态问题的多尺度Cholesky预处理</li>
<li><a href="https://dabh.io/">A Momentum-Conserving Implicit Material
Point Method for Surface Tension with Contact Angles and Spatial
Gradients</a> 具有接触角和空间梯度的表面张力动量守恒隐式材料点法</li>
<li><a href="https://arxiv.org/abs/2105.08535">SANM: A Symbolic
Asymptotic Numerical Solver with Applications in Mesh Deformation</a>
SANM：网格变形中应用的符号渐近数值求解器</li>
<li><a
href="https://people.mpi-inf.mpg.de/~mchu/projects/den2vel/">Learning
Meaningful Controls for Fluids</a> 流体有意义控制学习</li>
<li>Unified Particle System for Multiple-fluid Flow and Porous Material
多流体流动和多孔材料的统一粒子系统</li>
<li>Constrained Projective Dynamics: Real-time Simulation of Deformable
Objects With Energy-momentum Conservation
约束投影动力学：能量-动量守恒的可形变物体的实时模拟</li>
</ul>
<p>TOG:</p>
<ul>
<li><a
href="http://faculty.sist.shanghaitech.edu.cn/faculty/liuxp/projects/ss_dbnn/index.htm">Dynamic
Upsampling of Smoke through Dictionary-based Learning</a>
烟雾动态上采样的基于字典的学习</li>
<li><a
href="https://elrnv.com/projects/frictional-contact-on-smooth-elastic-solids/">Frictional
Contact on Smooth Elastic Solids</a> 光滑弹性固体的摩擦接触</li>
<li><a href="https://yangzzzy.github.io/">A Safe and Fast Repulsion
Method for GPU-based Cloth Self Collisions</a>
一种安全快速的基于GPU的布料自碰撞排斥方法</li>
<li><a
href="https://www.cg.informatik.uni-siegen.de/en/publications">Optimized
Refinement for Spatially Adaptive SPH</a> 空间自适应SPH的优化细化</li>
<li><a href="https://www.cs.ubc.ca/~ascher/">SIERE: A Hybrid
Semi-implicit Exponential Integrator for Efficiently Simulating Stiff
Deformable Objects</a>
SIERE：刚性可形变对象有效模拟的混合半隐式指数积分器</li>
</ul>
<h3 id="siggraph-2020"><strong>SIGGRAPH 2020</strong></h3>
<ul>
<li><a
href="https://visualcomputing.ist.ac.at/publications/2020/HYLC/">Homogenized
Yarn-Level Cloth</a> 均质纱织物</li>
<li><a
href="https://sadashigeishida.bitbucket.io/soapfilm_with_thickness/">A
Model for Soap Film Dynamics with Evolving Thickness</a>
变化厚度的皂膜动力学模型</li>
<li><a href="http://www.geometry.caltech.edu/pubs.html">Fast and
Scalable Turbulent Flow Simulation with Two-Way Coupling</a>
双向耦合的快速可扩展湍流模拟</li>
<li><a
href="https://cs.uwaterloo.ca/~rgoldade/reducedfluids/">Constraint
Bubbles and Affine Regions: Reduced Fluid Models for Efficient Immersed
Bubbles and Flexible Spatial Coarsening</a>
约束气泡和仿射区域：有效浸入气泡和灵活空间粗化的简化流体模型</li>
<li><a href="http://gmrv.es/Publications/2020/SRBO20/">Robust
Eulerian-on-Lagrangian Rods</a> 具有鲁棒性的EoL棒</li>
<li><a href="http://www.byungsoo.me/project/lnst/index.html">Lagrangian
Neural Style Transfer for Fluids</a> 流体的拉格朗日神经风格迁移</li>
<li><a href="http://www.paramathic.com/">NASOQ: Numerically Accurate
Sparsity-Oriented QP Solver</a>
NASQQ：数值精确的面向稀疏性的QP求解器</li>
<li><a href="https://sites.google.com/view/siggraph2020-multigpu">A
Massively Parallel and Scalable Multi-GPU Material Point Method</a>
一种大规模并行和可扩展的多GPU物质点法</li>
<li><a href="https://hal.inria.fr/hal-02563307/">Projective Dynamics
with Dry Frictional Contact</a> 干性摩擦接触的投影动力学</li>
<li><a href="https://marctenbosch.com/ndphysics/">N-Dimensional Rigid
Body Dynamics</a> N维刚体动力学</li>
<li><a href="https://ipc-sim.github.io/">Incremental Potential Contact:
Intersection- and Inversion-free, Large-Deformation Dynamic</a>
增量潜在接触（IPC）：无交点无反转大变形动力学</li>
<li><a href="https://cs.nyu.edu/~yixinhu/">Fast Tetrahedral Meshing in
the Wild</a> 自然环境快速四面体网格化</li>
<li><a
href="https://light.cs.uni-bonn.de/chemomechanical-simulation-of-soap-film-flow-on-spherical-bubbles/">Chemomechanical
Simulation of Soap Film Flow on Spherical Bubbles</a>
肥皂膜在球形气泡上流动的化学动力学模拟</li>
<li><a href="http://pub.ist.ac.at/group_wojtan/index.html">Wave Curves:
Simulating Lagrangian Water Waves on Dynamically Deforming Surfaces</a>
波曲线：模拟动态变形表面上的拉格朗日水波</li>
<li><a href="https://cg.informatik.uni-freiburg.de/publications.htm">An
Implicit Compressible SPH Solver for Snow Simulation</a>
一种雪体模拟的隐式可压缩SPH求解器</li>
<li><a href="https://www.youtube.com/watch?v=ugJhLMlyctc">Codimensional
Surface Tension Flow Using Moving-Least-Squares Particles</a>
使用移动最小二乘粒子的共维表面张力流</li>
<li><a href="https://joshuahwolper.com/anisompm">AnisoMPM: Animating
Anisotropic Damage Mechanics</a> AnisoMPM：各向异性损伤力学动画</li>
<li><a href="http://vcl.pku.edu.cn/publication/2020/magnetism">A
Level-Set Method for Magnetic Substance Simulation</a>
一种磁体模拟的水平集方法</li>
<li><a href="https://graphics.pixar.com/library/PhongDefo/">Phong
Deformation: A Better C0 Interpolant for Embedded Deformation</a>
Phong变形：一种更好的嵌入变形C0插值方法</li>
<li><a href="http://gdaviet.fr/">Simple and Scalable Frictional Contacts
for Thin Nodal Objects</a> 薄节点对象</li>
<li><a href="https://ryichando.graphics/">A Practical Octree Liquid
Simulator With Adaptive Surface Resolution</a>
一种具有自适应表面分辨率的实用八叉树液体模拟器</li>
<li>Adaptive Merging for Rigid Body Simulation 刚体模拟的自适应合并</li>
<li><a href="https://www.seas.upenn.edu/~minchenl/">IQ-MPM: An Interface
Quadrature Material Point Method for Non-sticky Strongly Two-way Coupled
Nonlinear Solids and Fluids</a>
IQ-MPM：一种非粘性强双向耦合非线性固体和流体的接口正交物质点方法</li>
</ul>
<p>TOG:</p>
<ul>
<li><a href="https://www.seas.upenn.edu/~minchenl/">Hierarchical
Optimization Time Integration for CFL-rate MPM Stepping</a>
CFL率物质点法步进的分层优化时间积分</li>
<li><a
href="http://www.cse.chalmers.se/~marcof/publication/tog2020/">Medial
Elastics: Efficient and Collision-ready Deformation via Medial Axis
Transform Medial Elastics</a>：通过中性轴变换的高效可碰撞变形</li>
<li><a href="https://www.cs.umd.edu/~akader/pubs.html">VoroCrust:
Voronoi Meshing without Clipping</a>
VoroCrust：无需裁剪的Voronoi网格化</li>
</ul>
<h3 id="siggraph-2019"><strong>SIGGRAPH 2019</strong></h3>
<ul>
<li><a href="http://www.tkim.graphics/">Anisotropic Elasticity for
Inversion-Safety and Element Rehabilitation</a>
反转安全、元素恢复的各向异性弹性</li>
<li><a href="http://joshuahwolper.com/publications">CD-MPM: Continuum
Damage Material Point Methods for Dynamic Fracture Animation</a>
CD-MPM：动态断裂动画的连续损伤物质点法</li>
<li><a href="http://squarefk.com/">Silly Rubber: An Implicit Material
Point Method for Simulating Non-equilibrated Viscoelastic and
Elastoplastic Solids</a> Silly
Rubber：模拟非平衡粘弹性和塑弹性固体的隐式物质点法</li>
<li><a href="https://www.seas.upenn.edu/~minchenl/">Decomposed
Optimization Time Integrator for Large-Step Elastodynamics</a>
大步长弹性动力学的分解优化时间积分器</li>
<li><a href="https://www.seas.upenn.edu/~cffjiang/">Efficient and
Conservative Fluids Using Bidirectional Mapping</a>
使用双向映射的高效保守流体</li>
<li><a
href="https://www3.math.tu-berlin.de/geometrie/wp_padilla/on_bubble_rings_and_ink_chandeliers/">On
Bubble Rings and Ink Chandeliers</a> 气泡环和水墨吊灯</li>
<li><a
href="http://mns.k.u-tokyo.ac.jp/~yonghao/sig19/abstsig19.html">Mixing
Sauces: A Viscosity Blending Model for Shear Thinning Fluids</a> Mixing
Sauces：一种剪切稀化流体的粘度</li>
<li><a
href="http://computationalsciences.org/publications/huang-2019-ferrofluids.html">On
the Accurate Large-scale Simulation of Ferrofluids</a>
磁流体的大规模精确模拟</li>
<li><a href="https://cs.uwaterloo.ca/~rgoldade/adaptiveviscosity/">An
Adaptive Variational Finite Difference Framework for Efficient Symmetric
Octree Viscosity</a> 一种高效对称八叉树粘度的自适应可变有限差分方法</li>
<li><a href="http://faculty.cs.tamu.edu/sueda/projects/redmax/">REDMAX:
Efficient and Flexible Approach for Articulated Dynamics</a>
REDMAX：铰接体动力学的高效灵活方法</li>
<li><a
href="https://research-explorer.app.ist.ac.at/record/6442">Fundamental
solutions for water wave animation</a> 水波动画的基础解决方案</li>
<li><a href="https://hal.archives-ouvertes.fr/hal-02129156/">Implicit
Untangling: A Robust Solution for Modeling Layered Clothing</a>
隐式分解：一种分层服装建模的稳健解决方案</li>
<li><a
href="https://www.cg.tu-berlin.de/harmonic-triangulations/">Harmonic
Triangulations</a> 谐波三角化</li>
<li><a href="http://run.usc.edu/hand-mri/">Hand Modeling and Simulation
Using Stabilized Magnetic Resonance Imaging</a>
使用稳定磁共振成像的手部建模和模拟</li>
</ul>
<p>TOG:</p>
<ul>
<li><a
href="http://graphics.pixar.com/library/AnalyticEigensystems/index.html">Analytic
Eigensystems for Isotropic Distortion Energies</a>
各向同性畸变能量的解析特征系统</li>
<li><a
href="http://nishitalab.org/user/syuhei/FlowInterpolation/flow_interpolation.html">Editing
Fluid Animation using Flow Interpolation</a> 使用流插值编辑流体动画</li>
<li><a
href="https://cg.informatik.uni-freiburg.de/publications.htm">Interlinked
SPH Pressure Solvers for Strong Rigid-Fluid Coupling</a>
强刚性流体耦合的互连SPH压力求解器</li>
<li><a
href="http://www.mverschoor.nl/wp/projects/efficient-and-accurate-collision-response-for-elastically-deformable-models/">Efficient
and Accurate Collision Response for Elastically Deformable Models</a>
弹性可形变模型的高效准确碰撞响应</li>
<li><a
href="https://www.jdumas.org/publication/2019/polyspline/">Poly-Spline
Finite Element Method</a> 多边形样条有限元方法</li>
</ul>
</blockquote>
<p>我们可以看到，其中就有我们刚刚提到的<strong>MPM</strong>方法的数学论证和进一步优化。整理下来，整体来说主要有以下几个方面的工作：</p>
<ul>
<li>特殊材料、特殊问题的新型算法</li>
<li>更加精确的模拟算法</li>
<li>GPU/数学优化加速算法</li>
<li>某个方法的数学物理原理</li>
</ul>
<p>那么我们就前三个（很显然数理原理的分析对我们制作不会太重要：我们知道方法对就行）讨论一下在我们电影制作中的发展方向。</p>
<p>第一个，特殊材料、特殊问题的新型算法。参考《冰雪奇缘》对<strong>MPM</strong>的应用，我认为这类方法投入工业一般是具备了这两个条件：影片中出现了大量该特殊材料的镜头需要模拟；制作者具备足够的科研能力和时间成本、金钱成本去做工程化实践。因此，这件事我了解到的通常只会出现在一家公司的动画影片中，那就是Disney，尤其是旗下的Pixar公司。Disney不仅拥有非常棒的动画团队，还拥有目前全球可以说最强大的图形学科研团队Disney
Research，前面的大量论文那就是他们产出的。同时他们还具有良好的营收情况，适合各种新方法实践的动画创意型影片生产线。这些条件都是很难复刻的。</p>
<p>第二个，更精确的模拟算法。大家都知道，我们做娱乐用途的图形学领域有一句话说：“如果它看起来是对的，那么它就是对的”，我们观影看到各种大楼轰塌、水漫金山，也只是为了“好看”，而不会说“这滴水真的能溅到这么远吗，让我算算”。因此，我认为在模拟方法达到一定精确性的情况下，更精确的模拟算法对影视工业的意义并不很大。更多的用于工业生产的仿真工作中，例如导弹的弹道计算、桥梁的受冲击能力等等，这些更加需要精确性的行业。关于这一点大家也可以提出自己的看法。</p>
<p>最后一个GPU/数学优化加速算法，我认为是对目前影视制作意义最大的一个方向，说白了就是更快。目前视效与动画制作最大的问题就在于速度，无论是物理模拟还是渲染，都是调整一次等待许久才能看到结果的一个离线工作流——当然渲染依托于GPU的渐进式渲染已经可以在很短的时间内看到结果，甚至借助实时渲染引擎已经开始有机会实现所见即所得的实时工作流。而基于物理的动画环节却还差得很远，我认为，物理模拟的实时化也是必然的趋势。</p>
<h3
id="影视游戏中的物理模拟实时化的发展趋势">影视/游戏中的物理模拟：实时化的发展趋势</h3>
<p>在目前的影视/游戏的FX（特效）中，只有少数游戏具有简单的实时的交互物理动画，例如角色的Ragdoll系统（死亡后自然倒下）、刚体的掉落碰撞、简单的流体交互等等。大部分物理动画都是预先模拟完烘焙好的动画序列。那么在影视制作中，实时的物理模拟能够为哪些流程带来优势呢？</p>
<h4 id="传统的视效动画工作流">传统的视效/动画工作流</h4>
<p>在传统的视效/动画制作中，FX的制作方式前面已经提到。我在这里可以给大家演示一个简单的物理模拟程序，仅仅几十个节点组成的一个场景模拟，在我的5950X主机上，计算一帧就需要约4-6秒的时间。而在我们的影视制作中，一个镜头可能是几百个、甚至上千个节点组成的，其模拟的时间可想而知。在这种情况下，反复地调整参数是一件非常痛苦的事情，很多情况下，就只能靠经验判断。</p>
<p>通过GPU或算法的优化、模型的简化提高模拟速率（甚至达到实时）在这里起到的作用和渲染领域中相似：预览和最终的高质量输出分离，用简化后的快速方法来获得预览画面——预览画面的基本动画要能保证与最终效果是一致的。如此，我们的FX艺术家就可以通过参数的调整，实时地来看参数的结果，从而细致化地调参，来达到更加精细的结果。</p>
<h4 id="电影虚拟化制作">电影虚拟化制作</h4>
<p>电影虚拟化制作是相对较新的制作方式，从On-set
Previz（实时交互预演）到今天的基于LED背景墙的电影虚拟化制作，实时渲染的内容的重要性进一步提升。</p>
<p>在On-set
Previz中，我们用实时渲染画面作为预览用的合成背景。在绿幕拍摄现场，通过摄影机跟踪将真实摄影机与实时渲染引擎中的摄影机绑定，使得现场画面的与实时渲染画面的运动匹配，再将绿幕画面实时抠像后作为前景、实时渲染画面作为背景实时合成输出至监看设备，提供给现场制作人员参考。这一流程中的实时渲染背景仅作为现场的制作者预览使用，不会作为真实的成片内容。因此，无论是模拟还是渲染的精度都不需要很高，目的在于告诉摄影师“爆炸的炸点在这”。因此在On-set
Previz中应用游戏中常见的简单交互特效是可行的。这样我们可以设计与实时渲染引擎交互的触发装置，让演员能够比较轻松地判断与虚拟物体的交互。</p>
<p>而在基于LED背景墙的电影虚拟化制作中，实时渲染画面需要用于最终成片。在On-set
Previz的基础上，我们将实时渲染的场景通过mapping的方式投影至LED背景墙上，那么摄影机内就能直接拍摄得到正确透视、视差的背景画面，我们称为“摄影机内视效拍摄”，直接就完成了合成工作。这也意味着，我们实时渲染引擎产出的画面要用于最终的成片了，对资产的质量要求大大提高了——因此目前，涉及到基于物理的动画的资产，都是预先完成模拟计算、烘焙成动画的，仅在引擎中设计触发播放，无法产生交互。因而，我们也期待着物理模拟的实时化、以及实时化模拟的结果可以很快地转换至Mesh完成实时的光照与渲染，从而实现基于LED背景墙的电影虚拟化制作中的交互物理动画。</p>
<h3 id="总结">总结</h3>
<p>通过今天的课程，希望能给大家带来对基于物理的动画的一些认识。我们从视效/动画制作中的FX流程，到粒子、刚体、流体为代表的各种模拟系统发展及其在各类影片中的应用案例，最后我们畅想了一下基于物理的动画在影视工业应用中的发展方向。也算是基本涵盖了基于物理的动画的方方面面了。</p>
<p>我们知道，这门课的内容对大家相对来说有些难，有很多的数学公式、很多的程序代码，要相信，课程的内容对我们俩也是困难的，但我们这几个月来不断地啃书本、Paper、代码，坚持着看教程、做实验，然后尽可能地为大家做简化——已经省去了大量的推导、求解和程序。最后，呈现到大家面前这样一个还算笼统的一个Pre，我们不求大家能完全听懂这个Pre的每一部分，只希望如果我们能展现那么几分在计算机中、在电影中重现物理世界这件事的魅力，能够让同学们对这个领域不再陌生，当进入行业后，如果有人提起相关的话题、工作中遇到相关的问题，可以想到当年有两位同学为我们介绍过，能应和两声，或者是回头想到我们这次提到的一些方法，去搜索学习就已经再好不过了。</p>
<p>最后，我们不可免俗地cue一下近期的热点。我们现在讨论在电影中重现物理世界，电影是一个二维的视觉内容，我们现在经常说要拓展我们的维度、拓展我们的感官，也就是三维的、多种感官交互的内容——也就是我们正在向着电影《头号玩家》的绿洲那样的内容迈进，或者说热点词汇就是我们的“元宇宙”，也就是在虚拟世界中重现物理世界，用到的仍然会是我们今天讨论的这些技术，所以我觉得基于物理的动画既是一个已经发展了数十年的技术领域，也是正在蓬勃发展中，将为我们未来的“元宇宙”提供基础物理定律的一个高新领域。期待引领我们俩进入图形学世界的闫令琪老师口中的“无限月读”的世界能够早日实现，谢谢大家。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-12-05-影片技术分析Pre-基于物理的动画-流体系统</title>
      <link>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F/</guid>
      <description>流体系统 最后，在相对简单的前两个部分介绍后，我们还是不得不面对一个需要更多数学的系统，流体。
流体与流体力学 首先第一个问题是什么是流体。流体的定义是在承受剪应力（物体在外力作用时，内部任一截面上会出现的相互作用力，“内力”）时将会发生连续变形的连续介质，包括气体和液体。
所有液体 所有气体 具备流动特征的固体：如沙丘 流体主要具备以下性质：
流动性（fluidity）：流体间的分子作用力较小，难以保持一定的形状，在受到外界的作用力或能量不平衡时，流体会发生流动。
变形性（deformability）：在受到剪切力持续作用时，与固体的微小变形或有限变形不同，流体产生程度很大的、甚至作用时间无限长的变形。
粘性（viscosity）：相邻两层流体之间发生相对运动时，在两层流体的接触面会产生对于变形的抗力，与固体的摩擦力不同，这种抗力不与流体的变形大小有关，而与流体的变形速度正相关，这种抵抗变形的特性称为粘性。
正相关的形式：
线性相关 - 牛顿流体 \(\tau=\mu\dfrac{du}{dy}\) 非线性相关 - 非牛顿流体 \(\tau=\mu(T,p)\left(\dfrac{du}{dy}\right)^2\) 可压缩性（compressibility）/不可压缩性（incompressibility）：在一定的温度下，单位压强增量引起的体积变化率定义为流体的压缩性系数(coefficients of compressibility)，其值越大，流体越容易压缩，反之，不容易压缩。
在影视制作的物理模拟中，一般模拟的是不可压缩流体。
Navier-Stokes 方程 一般形式 \[ 动量方程\quad\displaystyle\underbrace{\frac{\mathrm D\mathbf u}{\mathrm Dt}}_{\frac{\partial\mathbf u}{\partial t}+\mathbf u\cdot\nabla\mathbf u}=\frac{1}{\rho}\nabla\cdot\underbrace\sigma_{应力加速度张量}+\mathbf g\\ 质量方程\quad\nabla\cdot\mathbf u=0 \]
不可压缩流体 Navier-Stokes 方程 \[ 动量方程\quad\displaystyle\overbrace{\underbrace{\frac{\partial\mathbf u}{\partial t}}_{非稳态加速度}+\underbrace{\mathbf u\cdot\nabla\mathbf u}_{对流加速度}}^{惯性加速度\frac{\mathrm D\mathbf u}{\mathrm Dt}}+\underbrace{\frac{1}{\rho}\nabla p}_{压强梯度}=\underbrace{\mathbf g}_{外力加速度}+\underbrace{\nu\nabla\cdot\nabla\mathbf u}_{粘滞力加速度(经常忽略)}\\ 质量方程\quad\nabla\cdot\mathbf u=0 \]
补充数学： \[ 哈密顿算子\quad\nabla=\left(\dfrac{\partial}{\partial x},\ \dfrac{\partial}{\partial y},\ \dfrac{\partial}{\partial z}\right)\quad\\ {\bf散度}\ \nabla\cdot \vec F\quad{\bf旋度}\ \nabla\times \vec F\ \\ 拉普拉斯算子\quad\Delta=\nabla\cdot\nabla=\nabla^2=\left(\dfrac{\partial}{\partial x},\ \dfrac{\partial}{\partial y},\ \dfrac{\partial}{\partial z}\right)^2\\ {\bf梯度}的{\bf散度}\ \Delta\vec F \]</description>
      <content:encoded><![CDATA[<h2 id="流体系统">流体系统</h2>
<p>最后，在相对简单的前两个部分介绍后，我们还是不得不面对一个需要更多数学的系统，流体。</p>
<h3 id="流体与流体力学">流体与流体力学</h3>
<p>首先第一个问题是什么是流体。流体的定义是在承受剪应力（物体在外力作用时，内部任一截面上会出现的相互作用力，“内力”）时将会发生连续变形的连续介质，包括气体和液体。</p>
<ul>
<li>所有液体</li>
<li>所有气体</li>
<li>具备流动特征的固体：如沙丘</li>
</ul>
<p>流体主要具备以下性质：</p>
<ul>
<li><p><strong>流动性（fluidity）</strong>：流体间的分子作用力较小，难以保持一定的形状，在受到外界的作用力或能量不平衡时，流体会发生流动。</p></li>
<li><p><strong>变形性（deformability）</strong>：在受到剪切力持续作用时，与固体的微小变形或有限变形不同，流体产生程度很大的、甚至作用时间无限长的变形。</p></li>
<li><p><strong>粘性（viscosity）</strong>：相邻两层流体之间发生相对运动时，在两层流体的接触面会产生对于变形的抗力，与固体的摩擦力不同，这种抗力不与流体的变形大小有关，而与流体的变形速度正相关，这种抵抗变形的特性称为粘性。</p>
<p><strong>正相关</strong>的形式：</p>
<ul>
<li>线性相关 - <strong>牛顿流体</strong> <span
class="math inline">\(\tau=\mu\dfrac{du}{dy}\)</span></li>
<li>非线性相关 - <strong>非牛顿流体</strong> <span
class="math inline">\(\tau=\mu(T,p)\left(\dfrac{du}{dy}\right)^2\)</span></li>
</ul></li>
<li><p><strong>可压缩性（compressibility）/不可压缩性（incompressibility）</strong>：在一定的温度下，单位压强增量引起的体积变化率定义为流体的压缩性系数(coefficients
of compressibility)，其值越大，流体越容易压缩，反之，不容易压缩。</p>
<p>在影视制作的物理模拟中，一般模拟的是<strong>不可压缩流体</strong>。</p></li>
</ul>
<h4 id="navier-stokes-方程">Navier-Stokes 方程</h4>
<p><strong>一般形式</strong> <span class="math display">\[
动量方程\quad\displaystyle\underbrace{\frac{\mathrm D\mathbf u}{\mathrm
Dt}}_{\frac{\partial\mathbf u}{\partial t}+\mathbf u\cdot\nabla\mathbf
u}=\frac{1}{\rho}\nabla\cdot\underbrace\sigma_{应力加速度张量}+\mathbf
g\\
质量方程\quad\nabla\cdot\mathbf u=0
\]</span></p>
<p><strong>不可压缩流体 Navier-Stokes 方程</strong> <span
class="math display">\[
动量方程\quad\displaystyle\overbrace{\underbrace{\frac{\partial\mathbf
u}{\partial t}}_{非稳态加速度}+\underbrace{\mathbf u\cdot\nabla\mathbf
u}_{对流加速度}}^{惯性加速度\frac{\mathrm D\mathbf u}{\mathrm
Dt}}+\underbrace{\frac{1}{\rho}\nabla p}_{压强梯度}=\underbrace{\mathbf
g}_{外力加速度}+\underbrace{\nu\nabla\cdot\nabla\mathbf
u}_{粘滞力加速度(经常忽略)}\\
质量方程\quad\nabla\cdot\mathbf u=0
\]</span></p>
<blockquote>
<p>补充数学： <span class="math display">\[
哈密顿算子\quad\nabla=\left(\dfrac{\partial}{\partial x},\
\dfrac{\partial}{\partial y},\ \dfrac{\partial}{\partial
z}\right)\quad\\
{\bf散度}\ \nabla\cdot \vec F\quad{\bf旋度}\ \nabla\times \vec F\ \\
拉普拉斯算子\quad\Delta=\nabla\cdot\nabla=\nabla^2=\left(\dfrac{\partial}{\partial
x},\ \dfrac{\partial}{\partial y},\ \dfrac{\partial}{\partial
z}\right)^2\\
{\bf梯度}的{\bf散度}\ \Delta\vec F
\]</span></p>
</blockquote>
<h4 id="流体模拟的两种视点">流体模拟的两种视点</h4>
<p>前面我们一直在用拉格朗日视点在考虑粒子和刚体的模拟，也就是“盯着运动物体看”。那在流体中，我们终于可以聊到两种视点。</p>
<p>流体是一种连续介质——什么叫连续介质，简单来说就是很难分割，你没法把一杯水分成一块一块的独立件去模拟，除非细到分子程度——我们的第一种思路就有点像：用超大规模的粒子去模拟流体。那就回归到了我们第一节课讲过的粒子系统，又由于粒子之间是要考虑相互作用力的，那么就是一个比较复杂的交互粒子系统。这就是我们流体模拟的<strong>拉格朗日方法</strong>。<strong>拉格朗日方法</strong>的优势在于非常直观，相对来说更加精确，但是问题是很难追溯流体中的某一部分，或者说某一区域的粒子，要选取范围来做粒子操作——永远需要遍历每一个粒子，需要用非常复杂的数据结构来优化。</p>
<p>另一种方法之前也给大家介绍过了：考虑空间网格而不是考虑单体的<strong>欧拉方法</strong>。在流体模拟中，也就是把流体运动的空间分割为网格，考虑每一个网格中是否有流体、流体的速度、加速度、受力等状态，然后迭代更新每一个网格的状态。<strong>欧拉方法</strong>则可以方便地调取某一区域的流体。后面会提到这个“方便调取”带来的优势。</p>
<p>近两年也出现了<strong>拉格朗日</strong>和<strong>欧拉</strong>的混合方法，就是一会<strong>拉格朗日</strong>、一会<strong>欧拉</strong>，来结合两者的优点。后面也会给大家介绍。</p>
<ul>
<li><strong>拉格朗日方法</strong></li>
<li><strong>欧拉方法</strong></li>
<li><strong>混合方法</strong></li>
</ul>
<h3 id="拉格朗日方法光滑粒子动力学">拉格朗日方法：光滑粒子动力学</h3>
<p>那么首先我们就为大家介绍一种最简单的拉格朗日流体模拟方法：SPH
(Smoothed Particle Hydrodynamics)[2]。</p>
<p>SPH的核心思想就是把流体考虑成一个个相互作用的粒子：每一个粒子根据周围一定范围的粒子的位置、受力、粘力等状态来更新自己的状态，从而计算出加速度和速度，进行反复迭代。</p>
<p>首先我们来解释一下“光滑”的概念。先给大家讲一种比较形象的解释方式，两个小球，不接触（手做演示）时互不影响，一旦接触就反弹，这叫<strong>不光滑</strong>；而如果这两个小球接触时不会立即弹开，而是有一个缓冲，先接触、重合然后慢慢地弹开，就叫做<strong>光滑</strong>。严谨的表述是，两个粒子的相互影响在相近一定距离时发生（接触），相互影响的程度随着距离的接近从0开始逐渐增大（缓冲），即形成下图右图这样的相互影响程度
- 距离函数，我们称之为<strong>光滑核函数</strong>。</p>
<center>
<img src="/images/filmtechanalysis-PBA/不光滑核函数.png" alt="不光滑核函数" style="zoom:40%;" /><img src="/images/filmtechanalysis-PBA/光滑核函数.png" alt="光滑核函数" style="zoom:40%;" />
<center/>
<p><img src="/images/filmtechanalysis-PBA/光滑核函数3D.png" alt="光滑核函数3D" style="zoom:10%;" /></p>
<p>设第 <span class="math inline">\(i\)</span> 个粒子的坐标是 <span
class="math inline">\(\mathbf x_i\)</span> ，对空间中任一点 <span
class="math inline">\(\mathbf x\)</span> ， <span
class="math inline">\(\mathbf r =\mathbf x - \mathbf x_i\)</span>
，<strong>核函数</strong>即为： <span class="math display">\[
\omega_i(\mathbf r)=\omega(\|\mathbf r\|)\\
\]</span></p>
<p>“最大半径”的概念我们也称为<strong>有限支撑</strong>，设该最大半径/有限支撑为
<span class="math inline">\(r_{max}\)</span> 。 <span
class="math display">\[
r\ge r_{max}时,\quad\omega(r)=0\\
\oint \omega_{(r)}d\mathbf r=1
\]</span></p>
<p><strong>光滑核函数</strong>选择是很多的，只要满足以上条件的函数都可以用于核函数，一般根据我们的动画需要来选择，也可以根据动画效果来做一些参数的调整。可以是我们上图中这样的，也可以是接近0时趋向正无穷的。</p>
<p>那么有空间中的任意场 <span class="math inline">\(A\)</span> 、场梯度
<span class="math inline">\(\nabla A\)</span> 及密度 <span
class="math inline">\(\rho\)</span> 计算方法分别为： <span
class="math display">\[
A(\mathbf x)=\sum_i A_i \dfrac{m_i}{\rho_i}\omega(\|\mathbf x-\mathbf
x_i\|),\quad\rho_i=\sum_j m_j\omega(\|\mathbf x_i-\mathbf x_j\|)\\
\nabla A_i=\rho_i\sum_j
m_j\left(\dfrac{A_i}{\rho_i^2}+\dfrac{A_j}{\rho_j^2}\right)\nabla_{\mathbf
x_i}\omega(\|\mathbf x_i-\mathbf x_j\|)\quad (\nabla_{\mathbf
x_i}\omega指核函数在位置{\mathbf x_i}的梯度)
\]</span></p>
<p>则我们就可以来做最简单的SPH算法了：<strong>WCSPH (Weakly Compressible
SPH)</strong>。最终在程序中每一个时间步的计算步骤为：</p>
<ul>
<li><p>对于每个粒子 <span class="math inline">\(i\)</span> ，计算其密度
<span class="math inline">\(\rho_i\)</span> ，从而得到压强 <span
class="math inline">\(p_i\)</span> ，进一步计算得到压强梯度 <span
class="math inline">\(\nabla p_i\)</span> ： <span
class="math display">\[
\rho_i=\sum_j m_j\omega(\|\mathbf x_i-\mathbf x_j\|)\\
p_i=B((\dfrac{\rho_i}{\rho_0}))
\]</span></p></li>
<li><p>对于每个粒子 <span class="math inline">\(i\)</span>
，计算所在位置的压强梯度 <span class="math inline">\(\nabla p_i\)</span>
，即： <span class="math display">\[
\nabla p_i=\rho_i\sum_j
m_j\left(\dfrac{p_i}{\rho_i^2}+\dfrac{p_j}{\rho_j^2}\right)\nabla_{\mathbf
x_i}\omega(\|\mathbf x_i-\mathbf x_j\|)
\]</span></p></li>
<li><p>代入N-S方程（忽略了粘度项 <span
class="math inline">\(\nu\nabla\cdot\nabla\mathbf u\)</span>
），计算每个粒子 <span class="math inline">\(i\)</span> 的材料加速度
<span class="math inline">\(\dfrac{\mathrm D\mathbf u}{\mathrm
Dt}\)</span> ，从而直接计算当前时间步的速度与位移： <span
class="math display">\[
a=-\dfrac{\nabla p}{\rho}+g\\
以显式时间积分方法为例\quad\begin{array}{l}\mathbf v_{t+1}=\mathbf
v_t+\Delta t\left(-\dfrac{\nabla p}{\rho}+\mathbf g\right)\\
\mathbf x_{t+1}=\mathbf x_t+\Delta t\mathbf v_{i+1}\end{array}
\]</span></p></li>
</ul>
<p>除了我们最简单的<strong>WCSPH</strong>，还有一些拓展方法。</p>
<ul>
<li><strong>WCSPH, Weakly Compressible SPH</strong>
最简单的显式求解</li>
<li><strong>PCISPH, Predictive-Corrective Incompressible SPH</strong>
不断调整压力值控制密度，保证不可压缩性，循环修正过程即为“预估矫正
(Predictive-Corrective)”</li>
<li><strong>IISPH, Implicit Incompressible SPH</strong> 隐式求解，使用
Relaxed Jacobi Method 求解，PCISPH</li>
<li><strong>DFSPH, Divergence-Free SPH</strong>
不仅保证密度恒定，还要保证速度的散度为0</li>
</ul>
<figure>
<img src="/images/filmtechanalysis-PBA/PCISPH.gif" alt="PCISPH" />
<figcaption aria-hidden="true">PCISPH</figcaption>
</figure>
<p>如这张图中的效果就是PCISPH方法在二维中的一个呈现，通过Taichi编程显示。</p>
<p>SPH方法的优势在于理解起来相对简单，再加以一定的条件后也能够达到相当的精确性。但SPH方法在粒子量较大时计算会比较慢，尤其是在搜索附近粒子时没有很好的加速方法的话。此外，SPH想要保证流体的不可压缩性，只能通过PCISPH那种预估矫正的方法来保证。</p>
<h4 id="案例分享">案例分享</h4>
<p>近年来，SPH方法主要还是用于建筑、桥梁等土木工程流体仿真计算中，在电影中应用较少。我能搜到的一个应用粒子是《超人：英雄归来》中，Tweak
(Shotgrid) 在一些流体镜头中应用了SPH方法。</p>
<h3 id="欧拉方法stable-fluids">欧拉方法：Stable Fluids</h3>
<p>纯拉格朗日方法有什么问题呢？前面我们提到过，我们无法对其中某些部分粒子单独操作，一旦模拟开始了，就无法控制，只能通过初始参数的设定来调整效果。我们看一个欧拉方法的案例：<a
href="https://zcyemi.github.io/webgl2-stablefluids/">WebGL2-StableFluids</a>。在网格化的方法中，我们就能比较方便地操作某一个区域的流体——网格是固定不动的，这一时间步的
<span class="math inline">\((0.5,0.5)\)</span>
和下一时间步的都是指的同一个网格。</p>
<p>在欧拉方法中，我们不再关注流体本身，而是关注流体流过的空间。那么我们就要把前面用到的材料导数拆开：
<span class="math inline">\(\displaystyle \frac{\mathrm D\mathbf
u}{\mathrm Dt}=\frac{\partial\mathbf u}{\partial t}+\mathbf
u\cdot\nabla\mathbf u\)</span> ，我们现在要在网格里存的是 <span
class="math inline">\(\dfrac{\partial\mathbf u}{\partial t}\)</span>
，也就是我们比起拉格朗日方法直接得到 <span
class="math inline">\(\dfrac{\mathrm D\mathbf u}{\mathrm Dt}\)</span>
，现在要多计算 <span class="math inline">\(-\mathbf u\cdot\nabla\mathbf
u\)</span> 这一项了，这一项叫做<strong>对流项</strong>。</p>
<p>我们这里用欧拉方法中最经典的一篇Paper，Stable
Fluids[3]的实现为例来讲解欧拉方法的细节，Stable
Fluids把N-S方程先做了一个变形： <span class="math display">\[
\displaystyle\frac{\partial\mathbf u}{\partial t}=-\frac{1}{\rho}\nabla
p-\mathbf u\cdot\nabla\mathbf u+\nu\nabla\cdot\nabla\mathbf u+\mathbf
g\\
\Rightarrow\quad\displaystyle\frac{\partial\mathbf u}{\partial
t}=\mathbf P(-\mathbf u\cdot\nabla\mathbf u+\nu\nabla\cdot\nabla\mathbf
u+\mathbf g)\\
(\mathbf P 表示压强的投影算子，消去了单独的压强项-\frac{1}{\rho}\nabla
p)
\]</span>
在拉格朗日方法中，我们把粒子的所有受力计算出来、叠加得到合力，最后再来做时间积分的。然而欧拉方法中我们是逐项逐步来做计算，每一步得到一次速度，每一步的输出要作为下一步的输入，如下图依次执行。
<img src="/images/filmtechanalysis-PBA/StableFluidsSteps.png" alt="Semi-StableFluidsSteps" style="zoom:20%;" /></p>
<ul>
<li><strong>Add force</strong>
处理统一的外力，这一步相对简单，就是给流体一个统一的外力，比如重力</li>
<li><strong>Advection</strong> 步进，计算对流项 <span
class="math inline">\(-\mathbf u\cdot\nabla\mathbf u\)</span>
，更新粒子速度和位置。</li>
<li><strong>Diffusion</strong> 耗散，计算粘度项 <span
class="math inline">\(\nu\nabla\cdot\nabla\mathbf u\)</span>
，这一条我们在这次讲解中就简单带过了，一般在模拟高粘度的流体比如胶水时，才比较需要这一项。</li>
<li><strong>Projection</strong> 投影，计算投影算子 <span
class="math inline">\(\mathbf P\)</span> 或者压强项 <span
class="math inline">\(-\dfrac{1}{\rho}\nabla p\)</span> 。</li>
</ul>
<p>在具体讲解之前呢，我们还是先了解一下，“网格化”的一些细节。网格化本身是一个很容易的事情，能够产生不一样的地方在于，我们怎样存储网格化的流体的状态。</p>
<ul>
<li>最简单的一种方式就是我们把所有属性：速度、压强存在每一个网格的中心；</li>
<li>另一种稍微复杂一些的方式是我们把压强存在网格的中心，而把速度拆成垂直分量和水平分量，分别存储在网格的左右两边中点和上下两边中点，这种方式我们也称为<strong>MAC网格</strong>。
这样能够避免掉简单的中心存储可能出现的“棋盘格图案 Checkerboard
Pattern”。</li>
</ul>
<center>
<img src="/images/filmtechanalysis-PBA/均匀网格-中心.png" alt="均匀网格-中心" style="zoom:20%;" /><img src="/images/filmtechanalysis-PBA/均匀网格-周围.png" alt="均匀网格-周围" style="zoom:20%;" />
<center/>
<h4 id="grid">Grid</h4>
<p>在这个基础上，我们的下一个问题是，我在空间中任意取一点并不在网格存储点位置的点，怎样去求其状态——这里我们使用的就是简单的双线性插值。就像下图，用它周围的四个点的状态计算、用面积作为权重。</p>
<p><img src="/images/filmtechanalysis-PBA/双线性插值.png" alt="双线性插值" style="zoom:25%;" /></p>
<h4 id="advection">Advection</h4>
<p>在计算对流项这一步，Stable
fluid实现的方法被称为<strong>半拉格朗日法</strong>，为什么又要“拉格朗日”？</p>
<p>我们考虑某一个网格位置当前的速度是什么？这里我们用粒子来考虑：就是一个粒子从上一个地方流到了这一个地方——就是粒子在的上一个地方的速度（要注意，我们这里计算的是对流项，因此不考虑压强带来的速度变化）。那<strong>Advection</strong>的思路就出来了：</p>
<p>如下图，首先假定一个网格中心 <span class="math inline">\(\mathbf
x\)</span> 处存在粒子 <span class="math inline">\(p\)</span> ，由处当
<span class="math inline">\(p\)</span> 前的速度 <span
class="math inline">\(\mathbf u\)</span> 反向追溯得 <span
class="math inline">\(p\)</span> 前一个时间步的位置 <span
class="math inline">\(\mathbf x_{old}\)</span> ，这个 <span
class="math inline">\(\mathbf x_{old}\)</span>
就不一定在网格中心了，用它周围的速度场插值得到它的速度 <span
class="math inline">\(\mathbf u_{old}\)</span> 也就是我们要更新的 <span
class="math inline">\(\mathbf u_{new}\)</span> 。</p>
<p><img src="/images/filmtechanalysis-PBA/Semi-Lagrangian_1.png" alt="Semi-Lagrangian_1" style="zoom:24%;" /></p>
<p>但是这时可能会存在下图这种现象，尤其是时间步长较大时非常明显：运动方向与我们的追溯方向偏差较大，不断地偏差下去就会一次比一次大，最终出现整个流体速度场的整体性偏移。那么怎么解决它呢：</p>
<p><img src="/images/filmtechanalysis-PBA/Semi-Lagrangian_2.png" alt="Semi-Lagrangian_2" style="zoom:15%;" /></p>
<p>那根据我们之前做正向速度更新时的经验，我们就可以“往回走两步”，或者说是“先走半步、再走半步”，即我们熟悉的“中点法”，这样我们就能够追溯地更加精准。当然也可以走三步，相对来说就没那么必要了。这个过程，其实本质上是在解非线性常微分方程的数值解，用的方法叫做Runge-Kutta方法，我们最简单的走一步就是RK1，走两步就是RK2，三步就是RK3方法。</p>
<p>此外呢，在插值问题上，后来也有人用样条插值（比如Catmull-Rom）来对线性插值做改进。</p>
<h4 id="diffusion">Diffusion</h4>
<p><strong>Diffusion</strong>这一步相对简单，如果要做的话。我们就直接逐网格求得粘度加速度，再在<strong>Advection</strong>得到的速度基础上做时间积分即可。
<span class="math display">\[
\dfrac{\partial\mathbf u}{\partial t}=\nu\nabla^2\mathbf u
\]</span> 以简单的前向时间积分为例就是： <span class="math display">\[
\mathbf u^{n+1}=\mathbf u^n+\Delta t \nu\nabla^2\mathbf u^n
\]</span>
当然，这个前向时间积分也可以用隐式的时间积分方法（比如后向欧拉）来完成，Stable
Fluids就是把上面这个计算过程换成用后向欧拉方法、使用共轭梯度法迭代来计算的，这里我们就省略过程了。</p>
<h4 id="projection">Projection</h4>
<p>在<strong>Projection</strong>这一步，我们求的其实是压强，压强这一项其实是为了保证流体的不可压缩性，因此我们有条件：速度的散度为0。我们这一步的条件其实就是：
<span class="math display">\[
\dfrac{\partial\mathbf u}{\partial t}=-\dfrac{1}{\rho}\nabla p\
,\quad\nabla\mathbf u=0
\]</span> 那么我们用后向欧拉的思路就得到了压强的泊松方程（Pressure
Poisson equation, PPE）： <span class="math display">\[
\mathbf u^{n+1}-\mathbf u^n=-\Delta t\dfrac{\nabla p}{\rho}\ ,\quad
\nabla\mathbf u^{n+1}=0\\
\Rightarrow\ 泊松方程\ \nabla\cdot\nabla p=\dfrac{\rho}{\Delta
t}\nabla\cdot\mathbf u
\]</span>
我们用中心差分方法代替其中的哈密顿算子和拉普拉子算子后，这个泊松方程又是一个形如
<span class="math inline">\(Ax=b\)</span>
的超大规模线性方程，我们用各种迭代方法去解它就好了。 <span
class="math display">\[
\begin{aligned}(\mathbf Ap)_{i,j,k}&amp;=(\nabla\cdot\nabla
p)_{i,j,k}\\&amp;=\dfrac{1}{\Delta
x^2}(-6p_{i,j,k}+p_{i+1,j,k}+p_{i-1,j,k}+p_{i,j+1,k}+p_{i,j-1,k}+p_{i,j,k+1}+p_{i,j,k-1})\\\\
\mathbf b_{ij}&amp;=\left(\dfrac{\rho}{\Delta t}\nabla\cdot\mathbf
u\right)_{i,j,k}\\&amp;=\dfrac{\rho}{\Delta t\Delta x}(\mathbf
u_{i+1,j,k}^x-
\mathbf u_{i,j,k}^x+\mathbf u_{i,j+1,k}^y-\mathbf u_{i,j,k}^y+\mathbf
u_{i,j,k+1}^z-\mathbf u_{i,j,k}^z)\end{aligned}
\]</span> 不过这里的 <span class="math inline">\(A\)</span>
是一个超大规模的稀疏对称正定矩阵（ <span class="math inline">\(nml\times
nml,\ nml\ 分别为\ xyz\ 方向的网格数量\)</span>
），我们也会有一些计算方法去优化它。</p>
<p>不过在烟雾这样的流体模拟中，温度也会带来变量。因此在模拟烟雾等流体时，压强场的泊松方程还需要做一些小变化：密度
<span class="math inline">\(\rho\)</span>
不是固定的了，针对每一网格要通过温度去计算浮力、从而得到新的 <span
class="math inline">\(\rho\)</span> 来参与计算。这里不再赘述。</p>
<h4 id="案例分享-1">案例分享</h4>
<p>欧拉方法在混合方法出现之前，一度是电影工业界最流行的模拟方法。这里给大家讲一个趣事，就是我们前面分析的Stable
Fluids这篇paper，刚投递到Siggraph时，审稿人直接给毙了：这写的什么东西啊，尤其是对它用半拉格朗日法求对流项速度的方法意见颇大——也太不精确了。但是很快，这一方法就在工业界被大量使用了：我们电影、游戏要多少物理精确啊，速度快、好看、好用才是对的。因此直到这一方法已经几乎成为工业界的成熟方案，才被会议接收发表。</p>
<p>欧拉方法非常适合用于烟雾、火焰等流体的模拟，我们利用Houdini中的Pyro工具架也制作了一个简单的烟雾模拟DEMO：给大家演示一下。</p>
<h3 id="混合欧拉-拉格朗日方法">混合欧拉-拉格朗日方法</h3>
<p>整体上来说，一个流体模拟系统总体来说大致主要就是<strong>Advection</strong>（步进：根据速度更新粒子状态或进行场的流动）和<strong>Projection</strong>（投影：更新速度，维持物质守恒/不可压缩性）两步。在拉格朗日方法的SPH中，我们虽然没有强调这两个概念，因为<strong>Advection</strong>步骤很轻松就完成了，但是<strong>Projection</strong>时需要复杂的数据结构（或者逐个遍历）来实现邻域的访问，因此很难保证流体的不可压缩性——直到PCISPH中引入了一个有点复杂的预估校正系统才能保证这一点。而在欧拉方法中的<strong>Advection</strong>步骤中却很难精确地处理场的流动，我们用RK2甚至RK3才能够消除误差，甚至还不能完全消除图形上的Artifact，而且很容易丢失能量和几何的细节；<strong>Projection</strong>却因为我们可以很方便地调取周边网格的状态变得非常好操作。所以我们就想，能不能将这两个方法混合一下。</p>
<p>当然可以，那么这类混合方法的思路就是：在粒子上做速度与状态更新，在网格上做压强计算与边界条件处理。算法的核心是
P2G 和 G2P
两个函数，分别是把粒子上的信息转换到网格上和把网格上的信息转换到粒子上，然后在粒子上和网格上分别做适合的工作。</p>
<ul>
<li>Particle to Grid transfer (P2G)</li>
<li>Grid Operation
<ul>
<li>Pressure projection</li>
<li>Boundary conditions</li>
<li>…</li>
</ul></li>
<li>Grid to Particle transfer (G2P)</li>
<li>Particle operation
<ul>
<li>Move particles</li>
<li>Update material</li>
<li>…</li>
</ul></li>
</ul>
<h4 id="pic-particle-in-cell-粒子元胞法">PIC, Particle in Cell
粒子元胞法</h4>
<p>那么我们以最古老也最简单的一种混合欧拉-拉格朗日方法：PIC[4]，Particle
in Cell，粒子元胞法为例，先给大家介绍 P2G 和 G2P 两个函数的实现。</p>
<p>从这两张图就可以清晰地看到 P2G 和 G2P 的过程。</p>
<ul>
<li>我们通常先选择一个网格范围，这里是二维的 <span
class="math inline">\(3\times 3\)</span> 的网格，作为 P2G 或 G2P
中的网格作用范围，把粒子的状态“摊”到这些网格上或者是把这些网格的状态收集起来作为粒子的状态。</li>
<li>这里我们就会又一次用到前面介绍的“核函数”。这里粒子对每一个网格、每一个网格对粒子的“贡献”是不一样的，所以我们在“分摊”或者“收集”时要用一个权重，这个权重就是我们关于距离的核函数
<span class="math inline">\(\omega\|\mathbf x_i-\mathbf x_p\|\)</span>
。</li>
</ul>
<p><img src="/images/filmtechanalysis-PBA/P2G&G2P.png" alt="P2G&G2P" style="zoom:50%;" /></p>
<p>那么我们就可以实现我们的想法：在网格中做<strong>Projection</strong>（就如欧拉方法中那样），在粒子中做<strong>Advection</strong>（直接使用粒子携带的速度值移动）了。程序变得简单了起来（二维）：</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># P2G</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> x:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    base <span class="op">=</span> (x[p] <span class="op">*</span> inv_dx <span class="op">-</span> <span class="fl">0.5</span>).cast(<span class="bu">int</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fx <span class="op">=</span> x[p] <span class="op">*</span> inv_dx <span class="op">-</span> base.cast(<span class="bu">float</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Quadratic B-spline</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> [<span class="fl">0.5</span> <span class="op">*</span> (<span class="fl">1.5</span> <span class="op">-</span> fx) <span class="op">**</span> <span class="dv">2</span>, <span class="fl">0.75</span> <span class="op">-</span> (fx <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> <span class="dv">2</span>, <span class="fl">0.5</span> <span class="op">*</span> (fx <span class="op">-</span> <span class="fl">0.5</span>) <span class="op">**</span> <span class="dv">2</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> ti.static(<span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> ti.static(<span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            offset <span class="op">=</span> ti.Vector([i, j])</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            weight <span class="op">=</span> w[i][<span class="dv">0</span>] <span class="op">*</span> w[j][<span class="dv">1</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            grid_v[base <span class="op">+</span> offset] <span class="op">+=</span> weight <span class="op">*</span> v[p]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            grid_m[base <span class="op">+</span> offset] <span class="op">+=</span> weight</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Grid normalize</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, j <span class="kw">in</span> grid_m:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grid_m[i, j] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        inv_m <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> grid_m[i, j]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        grid_v[i, j] <span class="op">=</span> inv_m <span class="op">*</span> grid_v[i, j]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># G2P</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> p <span class="kw">in</span> x:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    base <span class="op">=</span> (x[p] <span class="op">*</span> inv_dx <span class="op">-</span> <span class="fl">0.5</span>).cast(<span class="bu">int</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    fx <span class="op">=</span> x[p] <span class="op">*</span> inv_dx <span class="op">-</span> base.cast(<span class="bu">float</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Quadratic B-spline</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> [<span class="fl">0.5</span> <span class="op">*</span> (<span class="fl">1.5</span> <span class="op">-</span> fx) <span class="op">**</span> <span class="dv">2</span>, <span class="fl">0.75</span> <span class="op">-</span> (fx <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">**</span> <span class="dv">2</span>, <span class="fl">0.5</span> <span class="op">*</span> (fx <span class="op">-</span> <span class="fl">0.5</span>) <span class="op">**</span> <span class="dv">2</span>]</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    new_v <span class="op">=</span> ti.Vector.zero(ti.f32, <span class="dv">2</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> ti.static(<span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> ti.static(<span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>            weight <span class="op">=</span> w[i][<span class="dv">0</span>] <span class="op">*</span> w[j][<span class="dv">1</span>]</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>            new_v <span class="op">+=</span> weight <span class="op">*</span> grid_v[base <span class="op">+</span> ti.Vector([i, j])]</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    x[p] <span class="op">=</span> clamp_pos(x[p] <span class="op">+</span> v[p] <span class="op">*</span> dt)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    v[p] <span class="op">=</span> new_v</span></code></pre></div>
<p>但是这种方法有一个什么问题呢？试想如果同一个 <span
class="math inline">\(3\times 3\)</span>
网格中有两个粒子，它们的速度都被均摊到了这九个网格上，在迭代完成后再次从这九个网格中收集到新的速度时，A粒子的新速度就包含了B粒子的旧速度的一部分，同理B也是——因此，在不断地迭代过程中，其实是一个速度的细节丢失、不断平均化的过程——尤其是旋转、拉伸等运动，动着动着可能就停下来了。</p>
<p>换一种理解方式，我们的二维中9个网格有18个运动的自由度（每个网格xy两个方向），而转换到的粒子却只有2个移动的自由度，如果是三维的话这个数字会是：81/3——因此信息就会丢失掉非常多。</p>
<p><img src="/images/filmtechanalysis-PBA/2DoF.png" alt="2DoF" style="zoom:25%;" /></p>
<p>所以人们就带来了新的思路，主要分为这两类：</p>
<ul>
<li><strong>APIC</strong>、<strong>PolyPIC</strong>：让粒子携带更多自由度的信息</li>
<li><strong>FLIP</strong>：不直接传递值，而是传递前后时间步的差分或物理量的梯度/倒数</li>
</ul>
<h4 id="apic-affine-particle-in-cell">APIC, Affine Particle in Cell</h4>
<p>第一种思路我们先说说<strong>APIC</strong>[5]。<strong>APIC</strong>其实就是通过给粒子增加一个<strong>Affine矩阵</strong>，来存储粒子的更多种速度信息——网格的不同自由度的作用中，就有下图（二维）这几种，刚好可以通过仿射变换包含进来。从而就将粒子的自由度拓展为原来的三倍，二维中就是6自由度，三维就是9个。</p>
<p><img src="/images/filmtechanalysis-PBA/6DoF.png" alt="2DoF" style="zoom:33%;" /></p>
<p>当然这个方法还涉及到怎样来计算这个Affine矩阵的问题，数学推导非常复杂就不给大家讲解了。代码实现却非常简单：用一个张量积来计算这个Affine矩阵即可。也不演示了。效果上带来的区别非常明显：流体可以正常的旋转、拉伸、剪切运动了。</p>
<center>
<img src="/images/filmtechanalysis-PBA/APIC_math_P2G.jpg" alt="APIC_math_P2G" style="zoom:22.5%;" /><img src="/images/filmtechanalysis-PBA/APIC_math_G2P.jpg" alt="APIC_math_G2P" style="zoom:22.5%;" />
<center/>
<p><img src="/images/filmtechanalysis-PBA/APIC_pipeline.png" alt="APIC_pipeline" style="zoom: 25%;" /></p>
<img src="/images/filmtechanalysis-PBA/APIC_code.png" alt="APIC_code" style="zoom:20%;" />
<center/>
<p>而<strong>PolyPIC</strong>[6]则是进一步拓展了粒子的自由度——达到与网格一样的级别，当然复杂度也进一步提升了。</p>
<figure>
<img src="/images/filmtechanalysis-PBA/PolyPIC.jpg" alt="PolyPIC" />
<figcaption aria-hidden="true">PolyPIC</figcaption>
</figure>
<p><strong>APIC</strong>也逐渐在影视制作中使用，尤其适合海洋、瀑布等水体的模拟，在迪士尼影片《海洋奇缘》中就有应用。</p>
<h4 id="flip-fluid-implicit-particles-隐式粒子流体法">FLIP, Fluid
Implicit Particles 隐式粒子流体法</h4>
<p><strong>影视工业目前最常用的方法</strong></p>
<p><strong>FLIP</strong>方法[7][8]的核心想法在于，我们不把表述粒子状态的物理量直接与网格传递，而是传递一个时间步里的增量。</p>
<p>还是以速度为例，我们在<strong>PIC</strong>系列方法中的 P2G 是 <span
class="math display">\[
\mathbf v_p^n={\rm gather}(\mathbf v_i^n)
\]</span> 而<strong>FLIP</strong>方法中，则 <span
class="math display">\[
\mathbf v_p^{n+1}={\rm gather}(\mathbf v_i^{n+1}-\mathbf v_i^n)
\]</span>
这样，A粒子中包含B粒子的速度成分就只有B粒子速度对加速度的一点点影响，而不会被“平均”掉了。</p>
<p>但是<strong>FLIP</strong>方法中，由于加速度的因素“成分”和原速度“成分”不一致，最终得到的结果会有很大的噪声——大家可以看到：毛毛刺刺的。到这里呢，我们刚好可以做一个多种常用模拟水的流体方法的对比（欧拉、PIC、APIC、FLIP）：</p>
<center>
<img src="/images/filmtechanalysis-PBA/Demo_Eulerian.gif" alt="Demo_Eulerian" style="zoom:25%;" /><img src="/images/filmtechanalysis-PBA/Demo_PIC.gif" alt="Demo_PIC" style="zoom:25%;" /><img src="/images/filmtechanalysis-PBA/Demo_APIC.gif" alt="Demo_APIC" style="zoom:25%;" /><img src="/images/filmtechanalysis-PBA/Demo_FLIP.gif" alt="Demo_FLIP" style="zoom:25%;" />
<center/>
<p>那么怎么办呢：非常简单，我们把PIC方法和我们的FLIP做一个Blend，而且这个比例呢只需要混一点点PIC，可以通过这个网站例子来玩一下<a
href="http://yuanming-hu.github.io/fluid/">GPU-based Fluid Simulation
(yuanming-hu.github.io)</a>： <span class="math display">\[
\rm FLIP0.99=0.99*FLIP+0.01*PIC
\]</span> 这是跟前面对比的<strong>FLIP0.97</strong>方法的效果</p>
<p><img src="/images/filmtechanalysis-PBA/Demo_FLIP0.97.gif" alt="Demo_FLIP0.97" style="zoom:25%;" /></p>
<p><strong>FLIP</strong>方法其实只是一个<strong>Advection</strong>步骤的实现方法，影视工业界通常把结合了<strong>FLIP</strong>的<strong>Advection</strong>和<strong>Chorin-Style
pressure
projection</strong>，再加上相应需要的粒子网格的工程实现（例如OpenVDB…）的整个流体解算器也称为<strong>FLIP</strong>——比如我们Houdini工具架上的<strong>FLIP</strong>模块。我们也利用这个工具制作了一小段流体动画。</p>
<p>在我们的Houdini中，大家可以看到一个完整的FLIP
Fluid包括了Geometry的导入、渲染和一个AutoDopNetwork，AutoDopNetwork中是我们的流体解算环节，其中最核心的节点是Filpsolver，大家可以看看这个Flipsolver中，是非常复杂的一个解算结构——但是在学习完前面的所有过程之后，根据每一个部分的名字，我们就逐渐能够看懂了。</p>
<p><img src="/images/filmtechanalysis-PBA/Houdini_FLIP_1.png" alt="Houdini_FLIP_1" style="zoom:25%;" /></p>
<p><img src="/images/filmtechanalysis-PBA/Houdini_FLIP_2.png" alt="Houdini_FLIP_2" style="zoom: 25%;" /></p>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_3.png"
alt="Houdini_FLIP_3" />
<figcaption aria-hidden="true">Houdini_FLIP_3</figcaption>
</figure>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_4.png"
alt="Houdini_FLIP_4" />
<figcaption aria-hidden="true">Houdini_FLIP_4</figcaption>
</figure>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_5.png"
alt="Houdini_FLIP_5" />
<figcaption aria-hidden="true">Houdini_FLIP_5</figcaption>
</figure>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_6.png"
alt="Houdini_FLIP_6" />
<figcaption aria-hidden="true">Houdini_FLIP_6</figcaption>
</figure>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_7.png"
alt="Houdini_FLIP_7" />
<figcaption aria-hidden="true">Houdini_FLIP_7</figcaption>
</figure>
<figure>
<img src="/images/filmtechanalysis-PBA/Houdini_FLIP_8.png"
alt="Houdini_FLIP_8" />
<figcaption aria-hidden="true">Houdini_FLIP_8</figcaption>
</figure>
<h4 id="mpm-material-point-method-物质点法">MPM, Material Point Method
物质点法</h4>
<p>最后呢，我们来讲一点学术前沿，特别适合用于模拟雪、沙子这种带一点固体性质的流体的方法<strong>MPM物质点法</strong>[9]，甚至有人拿<strong>物质点法</strong>去模拟刚体，做我们上一节课介绍的破碎等效果。为什么这样一个流体方法可以用于模拟固体性质呢？</p>
<p>原因在于，我们的粒子域过程中不再只有速度、加速度、受力、温度这些外部属性，而是加入了质量、体积这样的物质属性。而且不再局限于不可压缩流体的<strong>Advection</strong>和<strong>Projection</strong>。</p>
<p>经典<strong>MPM</strong>方法的流程如下：</p>
<ol type="1">
<li>P2G，传递质量、速度等信息 <span
class="math inline">\(\begin{array}{l}m_i=\sum\nolimits_pm_p\omega_{ip}^n\\\mathbf
v_i=\sum\nolimits_p\mathbf
v_p^nm_p\omega_{ip}^n/m_i^n\end{array}\)</span></li>
<li>计算粒子体积和密度 <span
class="math inline">\(\begin{array}{l}\rho_i=m_i^0/h^3\\\rho_p^0=\sum\nolimits_im_i^0\omega_{ip}^0/h^3\\V_p^0=m_p/\rho_p^0\end{array}\)</span></li>
<li>计算网格受力</li>
<li>更新网格速度场</li>
<li>基于网格的碰撞计算</li>
<li>求解线性方程（迭代法）</li>
<li>更新形变梯度 <span class="math inline">\(\begin{array}{l}\mathbf
F_p^{n+1}=(\mathbf I+\Delta t\nabla\mathbf v_p^{n+1})\mathbf
F_p^n\\\nabla\mathbf v_p^{n+1}=\sum\nolimits_i\mathbf
v_i^{n+1}(\nabla\omega_{ip}^n)\end{array}\)</span></li>
<li>更新粒子速度 <span class="math inline">\(\begin{array}{l}\mathbf
v_p^{n+1}=(1-\alpha)\mathbf v_{\mathrm{PIC}p}^{n+1}+\alpha\mathbf
v_{\mathrm{FLIP}p}^{n+1}\\\mathbf
v_{\mathrm{PIC}p}^{n+1}=\sum\nolimits_i\mathbf
v_i^{n+1}\omega_{ip}^n\\\mathbf v_{\mathrm{FLIP}p}^{n+1}=\mathbf
v_p^n+\sum\nolimits_i(\mathbf v_i^{n+1}-\mathbf
v_i^n)\omega_{ip}^n\end{array}\)</span></li>
<li>基于粒子的碰撞计算</li>
<li>更新粒子位置 <span class="math inline">\(\mathbf
x_p^{n+1}=x_p^n+\Delta t \mathbf v_p^{n+1}\)</span></li>
</ol>
<p><img src="/images/filmtechanalysis-PBA/MPM_Overview.png" alt="MPM_Overview" style="zoom:50%;" /></p>
<p>而近年，又有人在<strong>APIC</strong>的基础上简化了这么复杂的一套<strong>MPM</strong>方法，提出了<strong>MLS-MPM(Moving
Least Squares MPM) 移动最小二乘物质点法</strong>。</p>
<center>
<img src="/images/filmtechanalysis-PBA/APIC_pipeline.png" alt="APIC_pipeline" style="zoom:20%;" /><img src="/images/filmtechanalysis-PBA/MPM_pipeline.png" alt="MPM_pipeline" style="zoom: 20%;" />
<center/>
<p>从代码上呈现，就是在前面<strong>APIC</strong>的代码上，除了Affine分量，还增加一个Stress分量，在更新速度和Affine分量时，利用该Stress分量参与计算，并且需要加上体积的更新。因此实现上相比较经典的<strong>MPM</strong>方法简单了非常多，也是目前比较流行的一个方法。</p>
<p>这里MPM的数学原理相对复杂了非常多，就不再给大家推导了。</p>
<p>MPM方法非常适合多种材质固体、流体的耦合模拟，处理自碰撞、大形变等等，因此也逐渐在影视工业中投入使用。其中最著名的一个应用案例，就是《冰雪奇缘》中的雪的交互。大家可以欣赏一下影片。当然，发明<strong>MLS-MPM</strong>的胡渊明博士还有非常火的一篇知乎分享，叫做《99行代码实现〈冰雪奇缘〉》，其实就是<strong>MLS-MPM</strong>的一个Taichi实现。</p>
<center>
<img src="/images/filmtechanalysis-PBA/mls-mpm88-lowres.gif" alt="mls-mpm88-lowres" style="zoom:40%;" /><img src="/images/filmtechanalysis-PBA/mls-mpm88-highres.gif" alt="mls-mpm88-highres" style="zoom:40%;" />
<center/>
<center>
<img src="/images/filmtechanalysis-PBA/MPMDemo_water_wheel.gif" alt="MPMDemo_water_wheel" style="zoom: 50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_sand_paddles.gif" alt="MPMDemo_sand_paddles" style="zoom: 50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_banana.gif" alt="MPMDemo_banana" style="zoom: 50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_robot_forward.gif" alt="MPMDemo_robot_forward" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_bunny.gif" alt="MPMDemo_bunny" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_sand_stir.gif" alt="MPMDemo_sand_stir" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_sand-sweep.gif" alt="MPMDemo_sand-sweep" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_debris_flow.gif" alt="MPMDemo_debris_flow" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_armodillo.gif" alt="MPMDemo_armodillo" style="zoom:50%;" /><img src="/images/filmtechanalysis-PBA/MPMDemo_cheese.gif" alt="MPMDemo_cheese" style="zoom:50%;" />
<center/>
<h3 id="案例分析与欣赏">案例分析与欣赏</h3>
<p>最后还是为大家准备了一些影片中的流体案例。包括《夏日友情天》《寻龙传说》《蜘蛛侠：英雄归来》《沙丘》等。</p>
<p><strong>参考文献</strong> [1] Particle-Based Fluid Simulation for
Interactive Applications [2] Smoothed Particle Hydrodynamics Techniques
for the Physics Based Simulation of Fluids and Solids [3] Stable fluids
[4] Harlow, F.H. (1964) The Particle-in-Cell Computing Method for Fluid
Dynamics. Methods in Computational Physics, 3, 319-343. [5] The Affine
Particle-In-Cell Method [6] A Polynomial Particle-In-Cell Method [7]
FLIP a method for adaptively zoned, particle-in-cell calculations of
fluid flows in two dimensions [8] Animating Sand as a Fluid [9] A
material point method for snow simulation</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-11-23-影片技术分析Pre-基于物理的动画-粒子系统与基于粒子的模型</title>
      <link>https://elderlyaugustus.github.io/posts/2021-11-23-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-11-23-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/</guid>
      <description>这节课开始我们将花两节课的时间从粒子、刚体、流体三种系统，来简要介绍一些基于物理的动画的基本原理与实现，并给大家展示一些具体的制作方法和成果。
粒子系统 基于粒子的模型是基于物理的动画的一个基础模型，是拉格朗日方法中最典型的一种。这里的粒子系统个人认为广义地来说就是基于粒子的模型，是以粒子视点对物理现象做点采样的所有动画系统，但业界我们往往狭义地认为其典型就是特指由发射器发射大规模粒子、通过外力驱动运动、渲染成具体的无定形形象的系统。我们这一章的陈述主要还是以典型的粒子系统为主，会拓展些基于粒子的、但并不一定称为粒子系统的模型。
粒子系统一般用来表现雨、雪、火、烟、尘、沙尘暴、烟花、水花、喷雾等等“无定形现象（Amorphous Phenomena[1]）”，当然也包括我们常见的一些“非物理现象”，诸如哥斯拉的吐息、猩红女巫的魔法光效等等，这些非物理现象同样要通过我们的物理系统去驱动粒子来产生这些效果。
一个粒子 在开始讲粒子系统之前，我们还是要讲一下一个粒子的运动：粒子的运动只有位移——就如我们中学物理中常做的质点模型一样，对一个粒子而言，所需要的动力学参数仅有、位置、速度、加速度、受力、质量等。在这之中，质量将受力与加速度联系为同一个概念，位置的变化（位移）是速度的积分、速度的变化又是加速度的积分。而且与中学物理不同的是，这里的每一个量都是三维空间中的向量了。
那么在这里，我们就第一次涉及到了时间积分概念的应用，也就是我们上节课刚刚讲过的如何在时间离散系统里做积分。
我们用上图这样的近似积分方式，就能够表达粒子随着时间的运动。那么知道了如何描述一个粒子的运动，我们就能够描述一堆粒子的运动了——换言之，我们可以开始了解一个基本的粒子系统。
基本粒子系统 我们来了解一个基本的粒子系统。在一个基本粒子系统的模拟过程中，通常包含了生成、模拟、消失三个过程，再加上把模拟过程渲染出来的渲染环节，我们分别讲解。
粒子生成 粒子生成器 粒子生成字面含义就是粒子是怎样初始化的，怎样给大量的粒子赋予初始的参数。因此我们设计了“生成器”，或者也可以称为“发射器”。
从发射器的形状说起，我们一般有点发射、平面发射、三维表面发射三种。
点发射顾名思义就是从同一个位置发射所有粒子，方向上有朝单一矢量、全方向两种。 平面发射中，平面主要有圆盘平面和多边形（三角形）平面两种。 三维表面发射中，以模型表面为发射器，可以认为是多个多边形平面发射的组合；另一种是在体积内发射，即在一个区域内随即发射。 生成器分类 粒子生成的随机算法 我们想象，以相同的质量、速度、加速度、方向、位置等参数来初始化大量粒子会出现什么现象：所有粒子会以相同或平行的轨迹运动。所以我们这里需要使用随机算法来初始化粒子的参数、方向矢量、位置，也就是需要生成随机数、随机矢量和随机点三种数据类型。
随机数 —— 为了控制粒子形态，我们一般不会直接使用系统的 rand() 来产生均匀分布的随机数，这就涉及到随机分布的概念：
均匀分布：均匀分布即每一个数出现的概率是均等的，经典案例就是抛硬币。只有我们希望空间中充满随机的点运动时才会使用。
高斯分布 / 正态分布：概率密度函数 \(p(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{\frac{(x-\mu)^2}{2\sigma^2}}\) （概率密度函数 PDF 指的是概率密度 - 数值，概率密度大家可以类比中学统计中的概率/区间宽度，区间宽度 -&amp;gt; 0） 利用高斯分布，我们就可以得到一个“大部分粒子以这个参数运动，少量随机发散”的结果，比如火花飞溅时，大部分火花都会溅射在一个区域范围内，有少量迸发到外面的样子。能够让我们更好地控制粒子的运动。
随机矢量：首先我们要了解如何生成一个均匀的球面分布，大家想象我们的地球上的任意一个点，做与球心的连线投影到赤道平面上得到长度 \(r\) ，与子午分割线成 \(\theta\) 角，那么我们只要随机 \(h=\sqrt{1-r^2}\) 和 \(\theta\) 两个值就能够得到随机矢量 \(\begin{bmatrix}r\cos\theta\\h\\r\sin\theta\end{bmatrix}\) ，经数学证明，球面上的点随 \(\theta\) 和 \(h\) 线性分布，因此，只要控制这两个随机数就可以控制球面的随机矢量。
同理我们可以得到控制下图两种：点向圆盘方向发射、圆盘发射时控制随机矢量的参数，分别是\(\theta \ \phi\) 和 \(\theta\ r\) 。也就是把随机向量转换成了两个随机数的问题。
随机点：三维空间中的一个点其实就是三个数，我们按照需要来生成三个随机数即可。当然也可以用一个随机矢量（两个随机数）+随机长度（一个随机数）的方式生成。随机点主要应用于表面发射的偏移和体积内发射。
粒子模拟 碰撞 在不考虑交互的情况下（后面会专门讨论），粒子在模拟过程中除了随着力场一步一步地迭代和人工控制之外的会产生剧变的现象就是碰撞了。粒子系统通常工作在含有模型的场景中，我们就需要考虑与模型的碰撞，其实也就是与一个个平面三角形的碰撞。问题在于，粒子是一个无体积的点，而粒子所处的位置又是离散的点，粒子恰好停在一个表面的概率微乎其微，那么我们如何判定碰撞而不是让粒子直接穿越表面呢？下面我们就会讲到。
碰撞主要分为两个步骤，分别是碰撞检测和碰撞响应。首先我们得发现产生了碰撞，在发现碰撞之后，就可以执行相应的碰撞响应，这里的响应可以是让粒子消失、吸附、飞出去各种，下面举例说最简单的反弹这种。
处理一个点与一个面的碰撞主要有Penalty（惩罚）和Impulse（冲击）两种思路：
Penalty 碰撞检测：通过点与面的距离 \(\phi(x)\) 判断 碰撞响应：更新 \(f\) ，判定碰撞后的下一个时间步更新粒子状态</description>
      <content:encoded><![CDATA[<p>这节课开始我们将花两节课的时间从粒子、刚体、流体三种系统，来简要介绍一些基于物理的动画的基本原理与实现，并给大家展示一些具体的制作方法和成果。</p>
<h2 id="粒子系统">粒子系统</h2>
<p>基于粒子的模型是基于物理的动画的一个基础模型，是拉格朗日方法中最典型的一种。这里的粒子系统个人认为广义地来说就是基于粒子的模型，是以粒子视点对物理现象做点采样的所有动画系统，但业界我们往往狭义地认为其典型就是特指由发射器发射大规模粒子、通过外力驱动运动、渲染成具体的无定形形象的系统。我们这一章的陈述主要还是以典型的粒子系统为主，会拓展些基于粒子的、但并不一定称为粒子系统的模型。</p>
<p>粒子系统一般用来表现雨、雪、火、烟、尘、沙尘暴、烟花、水花、喷雾等等“无定形现象（Amorphous
Phenomena[1]）”，当然也包括我们常见的一些“非物理现象”，诸如哥斯拉的吐息、猩红女巫的魔法光效等等，这些非物理现象同样要通过我们的物理系统去驱动粒子来产生这些效果。</p>
<h3 id="一个粒子">一个粒子</h3>
<p>在开始讲粒子系统之前，我们还是要讲一下一个粒子的运动：粒子的运动只有位移——就如我们中学物理中常做的质点模型一样，对一个粒子而言，所需要的动力学参数仅有、<strong>位置</strong>、<strong>速度</strong>、<strong>加速度</strong>、<strong>受力</strong>、<strong>质量</strong>等。在这之中，<strong>质量</strong>将<strong>受力</strong>与<strong>加速度</strong>联系为同一个概念，<strong>位置</strong>的变化（<strong>位移</strong>）是<strong>速度</strong>的积分、<strong>速度</strong>的变化又是<strong>加速度</strong>的积分。而且与中学物理不同的是，这里的每一个量都是三维空间中的向量了。</p>
<p>那么在这里，我们就第一次涉及到了时间积分概念的应用，也就是我们上节课刚刚讲过的如何在时间离散系统里做积分。</p>
<center>
<img src="/images/filmtechanalysis-PBA/时间积分1.png" alt="时间积分1" style="zoom: 15%;" /><img src="/images/filmtechanalysis-PBA/时间积分2.png" alt="时间积分2" style="zoom:15%;" /><img src="/images/filmtechanalysis-PBA/时间积分3.png" alt="时间积分3" style="zoom:15%;" />
</center>
<p>我们用上图这样的近似积分方式，就能够表达粒子随着时间的运动。那么知道了如何描述一个粒子的运动，我们就能够描述一堆粒子的运动了——换言之，我们可以开始了解一个基本的粒子系统。</p>
<h3 id="基本粒子系统">基本粒子系统</h3>
<p>我们来了解一个基本的粒子系统。在一个基本粒子系统的模拟过程中，通常包含了生成、模拟、消失三个过程，再加上把模拟过程渲染出来的渲染环节，我们分别讲解。</p>
<h4 id="粒子生成">粒子生成</h4>
<h5 id="粒子生成器">粒子生成器</h5>
<p>粒子生成字面含义就是粒子是怎样初始化的，怎样给大量的粒子赋予初始的参数。因此我们设计了“生成器”，或者也可以称为“发射器”。</p>
<p>从发射器的形状说起，我们一般有<strong>点发射</strong>、<strong>平面发射</strong>、<strong>三维表面发射</strong>三种。</p>
<ul>
<li><strong>点发射</strong>顾名思义就是从同一个位置发射所有粒子，方向上有<strong>朝单一矢量</strong>、<strong>全方向</strong>两种。</li>
<li><strong>平面发射</strong>中，平面主要有<strong>圆盘平面</strong>和<strong>多边形（三角形）平面</strong>两种。</li>
<li><strong>三维表面发射</strong>中，以<strong>模型表面</strong>为发射器，可以认为是多个多边形平面发射的组合；另一种是在<strong>体积内</strong>发射，即在一个区域内随即发射。</li>
</ul>
<figure>
<img src="/images/filmtechanalysis-PBA/生成器分类.png"
alt="生成器分类" />
<figcaption aria-hidden="true">生成器分类</figcaption>
</figure>
<h5 id="粒子生成的随机算法">粒子生成的随机算法</h5>
<p>我们想象，以相同的质量、速度、加速度、方向、位置等参数来初始化大量粒子会出现什么现象：所有粒子会以相同或平行的轨迹运动。所以我们这里需要使用随机算法来初始化粒子的参数、方向矢量、位置，也就是需要生成<strong>随机数</strong>、<strong>随机矢量</strong>和<strong>随机点</strong>三种数据类型。</p>
<ul>
<li><p><strong>随机数</strong> ——
为了控制粒子形态，我们一般不会直接使用系统的 rand()
来产生均匀分布的随机数，这就涉及到随机分布的概念：</p>
<ul>
<li><p><strong>均匀分布</strong>：均匀分布即每一个数出现的概率是均等的，经典案例就是抛硬币。只有我们希望空间中充满随机的点运动时才会使用。</p></li>
<li><p><strong>高斯分布 / 正态分布</strong>：概率密度函数 <span
class="math inline">\(p(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{\frac{(x-\mu)^2}{2\sigma^2}}\)</span>
（概率密度函数 PDF 指的是概率密度 -
数值，概率密度大家可以类比中学统计中的<strong>概率/区间宽度</strong>，区间宽度
-&gt; 0）
利用高斯分布，我们就可以得到一个“大部分粒子以这个参数运动，少量随机发散”的结果，比如火花飞溅时，大部分火花都会溅射在一个区域范围内，有少量迸发到外面的样子。能够让我们更好地控制粒子的运动。</p>
<p><img src="/images/filmtechanalysis-PBA/高斯分布.png" alt="高斯分布" style="zoom: 15%;" /></p></li>
</ul></li>
<li><p><strong>随机矢量</strong>：首先我们要了解如何生成一个均匀的球面分布，大家想象我们的地球上的任意一个点，做与球心的连线投影到赤道平面上得到长度
<span class="math inline">\(r\)</span> ，与子午分割线成 <span
class="math inline">\(\theta\)</span> 角，那么我们只要随机 <span
class="math inline">\(h=\sqrt{1-r^2}\)</span> 和 <span
class="math inline">\(\theta\)</span> 两个值就能够得到随机矢量 <span
class="math inline">\(\begin{bmatrix}r\cos\theta\\h\\r\sin\theta\end{bmatrix}\)</span>
，经数学证明，球面上的点随 <span class="math inline">\(\theta\)</span>
和 <span class="math inline">\(h\)</span>
线性分布，因此，只要控制这两个随机数就可以控制球面的随机矢量。</p>
<p><img src="/images/filmtechanalysis-PBA/球面均匀随机矢量.png" alt="球面均匀随机矢量" style="zoom:15%;"/></p>
<p>同理我们可以得到控制下图两种：点向圆盘方向发射、圆盘发射时控制随机矢量的参数，分别是<span
class="math inline">\(\theta \ \phi\)</span> 和 <span
class="math inline">\(\theta\ r\)</span>
。也就是把随机向量转换成了两个随机数的问题。</p>
<center>
<p><img src="/images/filmtechanalysis-PBA/随机矢量1.png" alt="随机矢量1" style="zoom:15%;" /><img src="/images/filmtechanalysis-PBA/随机矢量2.png" alt="随机矢量2" style="zoom:15%;" /></p>
<center/></li>
<li><p><strong>随机点</strong>：三维空间中的一个点其实就是三个数，我们按照需要来生成三个随机数即可。当然也可以用一个随机矢量（两个随机数）+随机长度（一个随机数）的方式生成。随机点主要应用于表面发射的偏移和体积内发射。</p></li>
<li><p><img src="/images/filmtechanalysis-PBA/表面偏移.png" alt="表面偏移" style="zoom:25%;" /></p></li>
</ul>
<h4 id="粒子模拟">粒子模拟</h4>
<h5 id="碰撞">碰撞</h5>
<p>在不考虑交互的情况下（后面会专门讨论），粒子在模拟过程中除了随着力场一步一步地迭代和人工控制之外的会产生剧变的现象就是碰撞了。粒子系统通常工作在含有模型的场景中，我们就需要考虑与模型的碰撞，其实也就是与一个个平面三角形的碰撞。问题在于，粒子是一个无体积的点，而粒子所处的位置又是离散的点，粒子恰好停在一个表面的概率微乎其微，那么我们如何判定碰撞而不是让粒子直接穿越表面呢？下面我们就会讲到。</p>
<p>碰撞主要分为两个步骤，分别是碰撞检测和碰撞响应。首先我们得发现产生了碰撞，在发现碰撞之后，就可以执行相应的碰撞响应，这里的响应可以是让粒子消失、吸附、飞出去各种，下面举例说最简单的反弹这种。</p>
<p>处理一个点与一个面的碰撞主要有<strong>Penalty</strong>（惩罚）和<strong>Impulse</strong>（冲击）两种思路：</p>
<ul>
<li><p><strong>Penalty</strong> 碰撞检测：通过点与面的距离 <span
class="math inline">\(\phi(x)\)</span> 判断 碰撞响应：更新 <span
class="math inline">\(f\)</span>
，判定碰撞后的下一个时间步更新粒子状态</p>
<ul>
<li><strong>Quadratic Penalty Method</strong> 碰撞条件 <span
class="math inline">\(\phi(x)&lt;0\)</span> ，状态更新 <span
class="math inline">\(f\leftarrow -k\phi(\mathbf x)\mathbf N\quad
(\mathbf N为法线方向单位向量)\)</span>
这种方法仅当粒子在面内时才能完成碰撞检测，就会出现粒子穿越表面的问题。</li>
<li><strong>Quadratic Penalty Method with a Buffer</strong> 碰撞条件
<span class="math inline">\(\phi(x)&lt;\epsilon\)</span> ，状态更新
<span class="math inline">\(f\leftarrow k(\epsilon-\phi(\mathbf
x))\mathbf N\)</span> 虽然缓解了粒子穿越表面的问题，但很可能会出现由于
<span class="math inline">\(k\)</span> 过大带来的 Overshooting
现象，导致碰撞响应时，粒子就飞出去了。</li>
<li><strong>Log-Barrier Penalty Method</strong> 假定 <span
class="math inline">\(\phi(x)\ge0\)</span> 恒成立，碰撞条件 <span
class="math inline">\(\phi(x)&lt;\epsilon\)</span> ，状态更新 <span
class="math inline">\(f\leftarrow \dfrac{\rho}{\phi(\mathbf x)}\mathbf
N\)</span> 相当于在<strong>Quadratic Penalty Method with a
Buffer</strong>的基础上，使Buffer的区域是可变的，一定程度上优化了上面提到的问题，但并不能根治。</li>
</ul></li>
<li><p><strong>Impulse</strong> 碰撞检测：通过点与面的距离 <span
class="math inline">\(\phi(x)\)</span> 判断 碰撞响应：立即更新 <span
class="math inline">\(\mathbf x\)</span> 和 <span
class="math inline">\(\mathbf v\)</span>
（相当于在下一个时间步前增加一个时间步）并重新得到 <span
class="math inline">\(f\)</span>
，判定碰撞后的“下一个时间步”直接使用已经更新完的粒子状态计算。</p>
<p><strong>另一种理解方式是：</strong>
我们以无碰撞系统考虑两步，也就是粒子的当前位置和下一个位置，如果这两个位置分别在某个表面的两侧，那么在这个两个时间步之间一定会产生碰撞。
如下图计算，直接将下一个时间步的位置改为反弹后的位置，速度、加速度垂直于表面的分量做相应的反向即可。</p>
<center>
<p><img src="/images/filmtechanalysis-PBA/碰撞检测.png" alt="碰撞检测" style="zoom:15%;" /><img src="/images/filmtechanalysis-PBA/碰撞响应.png" alt="碰撞响应" style="zoom:15%;" /></p>
<center/></li>
</ul>
<h5 id="粒子编排">粒子编排</h5>
<p>在前面的介绍中，我们介绍了粒子的初始化和自动运行过程中的迭代、碰撞，下面我们具体来介绍我们怎样通过<strong>加速度操作</strong>和<strong>速度操作</strong>[2]来控制粒子的运动过程。</p>
<ul>
<li><p><strong>加速度操作</strong>：加速度的改变即力的改变，也即通过力场来操作粒子。例如最典型的引力，构建一个趋向于某一点的力场，粒子可能会被吸引，可能会绕它旋转，这都取决于初始速度和合力的改变，这要求我们能够熟练应用力学才能够非常熟练地操作粒子。</p>
<p>当然我们也可以构造一些“奇怪的力场”，比如对不同的粒子随机施加不同的加速度、为强行限制粒子的速度调整加速度、给粒子赋予一些自驱动力达到一些特殊效果（比如烟雾活起来了）之类。</p></li>
<li><p><strong>速度操作</strong>：速度操作则是更加违背物理学的操作，但在视觉创作时，我们当然可以这么干——创造一些不存在的物理规律达到想要的效果。当然，通常我们不会直接将点的速度突变为一个其他值，而是不只用加速度这一个加法维度来描述速度的改变，而是用仿射变换去实现速度的变化。从而就可以得到许多奇特的效果，比如《变形金刚4》中粒子变形法的惊破天——也即让粒子塑造成一些具体的形象。</p></li>
</ul>
<h4 id="粒子渲染">粒子渲染</h4>
<p>这应该是我们这次课程唯一一次提到渲染——大家对三维模型的渲染都非常熟悉，体积渲染今天我们不会讲，但应该也比较容易理解。但没有体积的粒子怎样渲染呢？</p>
<ul>
<li>一个经典的想法是用球体渲染，把每一个粒子当作一颗球体。但是这样不好，为什么不好，这里告诉大家如果要得到一个看起来像球体的球，我们至少需要96个面。我们知道粒子系统通常是极大规模的，再乘以一百倍，这个渲染量显然是不可接受的。</li>
<li>那么我们考虑直接以点投影到屏幕上呢。一个问题是无法看出来深度感了——深度感的来源：近大远小、近亮远暗。那么我们就可以根据深度，渲染不同半径的圆（称为面元渲染）；此外还可以渲染不同的透明度。从而实现三维的感觉。但是仍然存在问题：帧率不够高时没有动态模糊，看起来就会非常卡，要知道我们大部分电影只有24帧。</li>
<li>因此，还有一种思路是“点即划痕”，也就是不渲染点，而是渲染粒子的两次时间步迭代之间的两个位置之间的连线——渲染线段，这样就自然而然带来了动态模糊。</li>
<li>粒子不只能表述一个点，还可以用于表述以点方式运动的物体。那么这个物体我们可以在渲染时表现出来。第一种是用材质，每一个粒子渲染一个矩形（也就是两个三角形），在矩形上上一个材质。这种渲染我们称之为“精灵”。</li>
<li>当然，“精灵”的渲染方式只能将粒子替换成平面，有时候我们还是需要用三维的东西去表现旋转等运动，比如落叶。所以我们也可以用几何形体去替换粒子，最后渲染模型。</li>
<li>最后一种思维是体积渲染，一般用于极大规模的粒子系统，比如流体、核爆。极大规模的渲染中对粒子逐个渲染显然不现实，我们把粒子所处的区域体素化，再渲染体积，也可以在体积上去处理材质。</li>
</ul>
<h3 id="案例分析与欣赏">案例分析与欣赏</h3>
<h4 id="pyro烟雾案例自制">Pyro烟雾案例（自制）</h4>
<h4 id="粒子影片案例">粒子影片案例</h4>
<h3 id="交互粒子系统">交互粒子系统</h3>
<p>前面我们介绍了没有交互的基本粒子系统，现在我们进一步提高一下复杂度，给粒子之间加上交互。粒子之间的交互换句话说就是：每一个粒子都对其他每一个粒子施加了力，也就是每一次迭代，对每一个粒子都要做
<span class="math inline">\(n-1\)</span>
次力的叠加。复杂度上相较无交互的粒子系统 <span
class="math inline">\(O(N)\)</span> 大幅提高至 <span
class="math inline">\(O(N^2)\)</span> ，计算量急剧增加。</p>
<pre class="pseudocode"><code>foreach particle i do
    Calculate the resultant force F on i;
    foreach particle j do
        Calculate the sum of the forces j acting on i 
    end
end
foreach particle j do
    Update status of i
end</code></pre>
<h4 id="减少计算量的可能性">减少计算量的可能性</h4>
<p>这种复杂度是无法通过计算方法的优化来减少复杂度：每一个数据读取一遍就是
<span class="math inline">\(O(N^2)\)</span>
了。因此我们只能考虑减少参与计算的数据。我们考虑到在真实物理世界中，粒子间的效应（即力）随着物理距离的增加急剧变弱——也就是我们常见的平方反比定律，引力场、电磁场均满足这条定律。因此我们可以忽略距离粒子足够远的粒子，或者是将远处的外围粒子做一簇一簇的近似计算而非精确计算。要完成这样的优化方法，我们首先得把粒子组成一簇一簇的，组合方法这里介绍<strong>均匀空间网格</strong>、<strong>八叉树</strong>、<strong>kd树</strong>三种。</p>
<ul>
<li><strong>均匀空间网格</strong>：最为简单的组合方法，将空间按一定的长方体网格分割，来组合粒子。这样网格利用率很低。</li>
<li><strong>八叉树</strong>：八叉树则是经典的一分八方法，就如我们能把一个矩形同样宽高比地分成四份一样，把一个长方体分割成八份，从而建立树结构。这样我们可以根据粒子的不均匀排布来分割空间。</li>
<li><strong>kd树</strong>：kd树则是一种二叉树，也是渲染领域光线追踪算法中BVH的构建基础。我们生成一个能够恰好包含所有粒子的包围盒，再以其中某一个维度上所有点的中位值分割。这种分割方法的每个单元粒子数量相近，范围搜索非常方便。利用kd树忽略或近似部分计算，可以减少计算复杂到
<span class="math inline">\(O(N\log N)\)</span> 。</li>
</ul>
<p><img src="/images/filmtechanalysis-PBA/均匀空间分割.png" alt="均匀空间分割" style="zoom:10%;" /><img src="/images/filmtechanalysis-PBA/八叉树.png" alt="八叉树" style="zoom:10%;" /><img src="/images/filmtechanalysis-PBA/kd树.png" alt="kd树" style="zoom:15%;" /></p>
<h4
id="以天文系统群集系统为例的交互粒子系统">以天文系统、群集系统为例的交互粒子系统</h4>
<h5 id="天文系统">天文系统</h5>
<p>天文系统是最典型的简单交互粒子系统：天体的大小相比较之间的距离可以抽象化为质点；粒子之间存在相互引力——且只有相互引力。天体
<span class="math inline">\(i\)</span> 收到天体 <span
class="math inline">\(j\)</span> 的引力为 <span
class="math inline">\(F_i^j = G\dfrac{m_im_j}{r_{ij}^2}\hat\mathbf
x_{ij}\)</span> 。</p>
<p>而天文系统中，天体之间的质量差距、两个星系之间的距离都非常之大——大到可以忽略掉很大部分的力。比如地球受到最近的恒星系比邻星的引力已经微乎其微，就算需要精确计算，也只需要将比邻星系作为一个整体来考虑。</p>
<p>因此，天文系统非常适合实践我们前面提到的空间优化方法，我们将这种远距离的粒子聚成的整体称为“聚簇”，我们可以很快地估算一个聚簇带来的引力。根据天体系统的特征，我们还可以用不同大小的簇：例如仙女星系对太阳的引力，和一个相邻星系的引力，各自用一个簇来计算是合理的，这两个簇的大小显然不一样。</p>
<h5 id="群集系统">群集系统</h5>
<p>另一个例子是：给粒子赋予生命，或者说赋予一些“意识力”。这个力显然不是一个物理力学上的力，而是我们用粒子系统来模拟大规模生物的运动，例如鸟群。模拟生命体的运动，就会有更加复杂的逻辑表达。</p>
<p>[3]我们将群集系统中的一个被模拟生命体称为“boid”，假定每个boid遵循三个规则：<strong>碰撞规避</strong>、<strong>速度匹配</strong>、<strong>集中</strong>，根据这三个规则得到三个加速度，根据三个加速度的有权或无权加和作为迭代用的加速度。</p>
<ul>
<li><strong>碰撞规避</strong>：越靠近另一个“boid”，反向飞离的速度就越大
<span
class="math inline">\(a_{ij}^a=-\dfrac{k_a}{d_{ij}}\hat{x}_{ij}\)</span></li>
<li><strong>速度匹配</strong>：与“同伴”保持相对速度，保持群体运动一致性
<span class="math inline">\(a_{ij}^v=k_v(\mathbf v_j-\mathbf
v_i)\)</span></li>
<li><strong>集中</strong>：朝向近邻的加速度，以保持群体完整 <span
class="math inline">\(a_{ij}^c=k_c\mathbf x_{ij}\)</span></li>
</ul>
<p><strong>距离与视域</strong>：现在我们要考虑需要计算哪些 <span
class="math inline">\(boid_j\)</span>
。考虑真实生物，就会发现距离远的看不到、视线外的看不到。按照这两条，我们可以分别得到两个关于距离和视域的近邻boid的计算权重，以加权值来作为最终迭代使用的加速度。</p>
<p><strong>加速度的权重</strong>：根据不同生物、环境的特点，三种加速度的“紧迫程度”不一样，而生物能达到的加速度是有限的。那么可以根据具体情况，分配三种加速度最终加权计算的权重。</p>
<p><strong>外界干扰：绕过障碍</strong>：如果没有外界干扰，上述条件就能使我们的群集系统运作起来了。但环境中往往出现障碍——在“有生命”的群集中，不太可能傻乎乎地直接就碰撞了。所以我们可以为环境中的障碍物建立带有斥力的<strong>势场</strong>、<strong>操控</strong>粒子根据“观察角度”中出现的障碍更新加速度等方式处理避障。</p>
<h3 id="案例分析与欣赏-1">案例分析与欣赏</h3>
<h4 id="群集系统影片案例">群集系统影片案例</h4>
<p>交互粒子系统还可以引入黏度等更加复杂的交互力，来模拟更加复杂的系统。在流体的章节中，我们会再次见到基于交互粒子系统的流体模拟方法。</p>
<h3 id="弹性网格">弹性网格</h3>
<p>粒子这一节的最后，我们来讲一种基于粒子的其他模型——严格说就不再是典型的粒子系统了。我们在粒子之间添加了一根线、比如一根“弹簧”，就构成了我们的<strong>可形变弹性网格</strong>[4]。这种结构可以就可以用于我们的头发、布料、软体模拟，再比如我们在DCC软件中常用的晶格变形器：驱动刚体的扭曲变形。由于时间的关系，我们这次的课程没有单开对应的章节，只是在粒子这一章，介绍其中的一种基于粒子的方法。</p>
<p><img src="/images/filmtechanalysis-PBA/弹性网格.png" alt="弹性网格" style="zoom:10%;" /></p>
<h4 id="弹簧-质量-阻尼模型">弹簧-质量-阻尼模型</h4>
<p><strong>弹簧-质量-阻尼模型</strong>是可形变弹性网格的核心系统，即粒子之间的连接所施加的力由<strong>弹力</strong>和<strong>阻力</strong>两种。</p>
<ul>
<li><strong>弹力</strong>： <span class="math inline">\(\mathbf
f_k=-kx\)</span> ， <span class="math inline">\(k\)</span>
为劲度系数（<span class="math inline">\(x\)</span> 为形变长度）</li>
<li><strong>阻力</strong>： <span class="math inline">\(\mathbf
f_d=-dv\)</span> ， <span class="math inline">\(d\)</span>
为阻尼系数（通常得到的是阻尼因子 <span
class="math inline">\(\zeta=\dfrac{d}{2\sqrt{km}}\)</span>）</li>
</ul>
<p>设其他外力和为 <span class="math inline">\(\mathbf f_e\)</span>
，则有 <span class="math inline">\(ma=\mathbf f_e-kx-dv\)</span> 即
<span class="math inline">\(m\ddot{x}+d\dot{x}+kx=\mathbf f_e\)</span>
，又是一个二阶微分方程。</p>
<h4 id="面的受力">面的受力</h4>
<p>当我们将点连接起来时，不可避免地就出现了面。虽然面不参与与粒子的交互，但面受到阻力、风等外部力的作用效果也需要参与到粒子的迭代计算中去。这里主要是有<strong>升力</strong>和<strong>空气阻力</strong>两种力，前者推动网格运动，后者阻碍。这里时间原因我们就不再详细分析。</p>
<ul>
<li>升力： <span class="math inline">\(\mathbf f_d=-C_dA(\hat \mathbf
n\dot\ \mathbf v_r)\mathbf v_r\)</span></li>
<li>拖拽力： <span class="math inline">\(\mathbf f_l=-C_lA(\hat \mathbf
n\dot\ \mathbf v_r)(\mathbf v_r\times\dfrac{\hat \mathbf n\times\mathbf
v_r}{\left \|\hat \mathbf n\times\mathbf v_r\right \| })\)</span></li>
</ul>
<h4 id="弹性网格模拟">弹性网格模拟</h4>
<p>对每一个粒子，逐连接体、逐面计算合力。</p>
<pre class="pseudocode"><code>foreach particle do
    Calculate F_e;
    foreach rod do
        Calculate F_k and F_d
        foreach face do
            Calculate F_face
        end
    end
end
foreach particle i do
    Update status of i
end</code></pre>
<h4 id="碰撞-1">碰撞</h4>
<p>这里，我们需要用一个形体的观点来看待弹性网格了，这与粒子的碰撞截然不同了。对于一个几何形体，我们需要从<strong>点</strong>、<strong>线</strong>、<strong>面</strong>三个结构上来判定碰撞。实际情况中，“<strong>顶点与顶点</strong>”、“<strong>顶点与线</strong>”、“<strong>线与面</strong>”的碰撞情况非常少——概率几乎为零，因此我们一般只会判断“<strong>顶点与面</strong>”和“<strong>边与边</strong>”。</p>
<ul>
<li><strong>顶点-面检测</strong>：这种检测我们在介绍粒子碰撞时就已经提过。</li>
<li><strong>边-边检测</strong>：思路上是取两条线上面到另一条线最近的点（作垂面交点），求这两个点的距离。</li>
</ul>
<h3 id="案例分析与欣赏-2">案例分析与欣赏</h3>
<h4 id="布料系统影片案例">布料系统影片案例</h4>
<p>[1] Particle systems - A technique for modeling a class of fuzz
objects [2] Particle animation and rendering using data parallel
computation [3] Flocks, Herds, and Schools: A Distributed Behavioral
Model [4] The behavioral test-bed: Obtaining complex behavior from
simple rules</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-11-18-影片技术分析Pre-基于物理的动画-发展历史与基本概念</title>
      <link>https://elderlyaugustus.github.io/posts/2021-11-18-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-11-18-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>基于物理的动画/物理模拟 Physically Based Animation
今天我和李乐游给大家讲一下基于物理的动画这个题目。首先我们来解释一下这个题目，这个动画指的不是一部动画片的那个动画，是指在动画片/视效制作中的一个环节，也是计算机图形学的三个大方向之一：建模Modeling、动画Animation、渲染Rendering。也就是驱动我们的模型动起来的过程——那么怎样驱动我们的模型动起来呢。大家最熟悉的一种方式就是Key关键帧，比如大家建了一个肖翱的模型，要驱动我去运动，那自然是要把我绑定到骨骼上，对每个关节去打关键帧，比如把我的手十秒后挪到这里。但是呢，不是所有的动画都适合用关键帧来驱动，比如窗外雪花飘飘、一辆车跌落悬崖、瀑布飞流直下，这样的镜头如果用Key关键帧的方法去完成，那就不是Key我身上的几十个关节这么“容易”的事了。但这种物理现象往往是遵循物理规律的，我们想让他看起来真实，那么我们就可以用物理规律去驱动它运动；又或者是一个非自然的物理现象，我们也可以创造非自然的物理规律去驱动它运动。这样的动画方法我们称之为基于物理的动画，也称为物理模拟，也有人将模拟Simulation单独作为图形学的第四个方向。下面我们说到这两个词大家知道都是指同一个东西就行了。
那么基于物理的动画，在我们的电影中能做出什么样的效果呢，我们剪了一段经典影片中的Showreel给大家欣赏一下。然后我们将从发展历史、基本概念出发，介绍影视制作中的物理模拟制作流程、几种系统的算法原理与实现、展示一些我们自己制作的和经典影片中的基于物理的动画镜头，最后对物理模拟这项技术的未来再做一个分析和展望。
发展历史 1940年代和1950年代 基于物理的动画来源于计算机模拟技术。它的首次大规模开发是著名的曼哈顿计划中的一个重要部分。在第二次世界大战中，为了模拟核爆炸的过程，人们应用蒙特·卡罗方法用12个坚球模型进行了模拟。计算机模拟最初被作为其他的方面研究的补充，但当人们发现它的重要性之后，它便作为一门单独的课题被使用得相当广泛。 之后便逐渐应用于军事和制造业。但在很长一段时间内，计算机计算非常昂贵，通常只有军事会使用这项技术。
20世纪70年代和80年代初 计算机图像生成技术兴起，1972年，第一部计算机生成的动画《A Computer Animated Hand》诞生，其中的一部分在1976年的电影《未来世界》中出现。这是电影第一次使用计算机生成图像。1982年《星际迷航II：可汗之怒》中的“创世纪”片段被普遍认为是VFX和计算机图形学的里程碑。这个片段首次使用了粒子系统，用CG的形式表现了爆炸效果。它是SIGGRAPH军事研究和电影工业早期交叉的产物之一。
20世纪80年代初至90年代 20世纪80年代的技术进步使电脑比前几十年更便宜、功能更强，这促进了Xbox游戏等的兴起。1985年，任天堂发布了任天堂娱乐系统（NES），NES成为视频游戏史上最畅销的游戏机之一。20世纪90年代，随着模拟人生、命令与征服等游戏的发布，以及台式电脑的不断增强，电脑游戏变得越来越流行。
1993年，电影《侏罗纪公园》成为第一部广泛使用计算机生成图形的电影，将计算机模拟的模拟恐龙几乎无缝地融入到实景中，这一事件改变了电影业。1995年，《玩具总动员》是第一部只使用计算机生成图像的电影，1998年，《蚁哥正传》第一次在动画中使用流体模拟。到了21世纪，计算机生成图像成为电影特效的主要选择。
21世纪初至今 计算机图形学技术走向成熟，游戏和电影领域普遍使用基于物理的动画，在虚拟世界中模拟真实世界中物体之间的相互作用。
基本概念 讲完发展历史，我们要开始正式进入基于物理的动画的世界。我把影视制作中基于物理的动画的制作归结为：“在计算机系统中、建立一定的物理模型、模拟生成动画并渲染成画面”。那么我们就需要首先了解一些基本概念。
物理学的运动 在进入计算机之前，我们就需要把我们想要表现的画面、或者说想要模拟的现象，依据物理定律建构为物理模型。所以我们所有模拟首先要依赖于物理定律，由于目前影视制作的物理特效还很少涉及微观物理世界和超宏观物理世界（《蚁人2》、《星际穿越》这样的影片也仅仅是通过物理学家作为顾问来补齐一些“科幻设定”），所以我们使用的物理定律主要还是一般宏观视角的规律，如牛顿三大运动定律、各种守恒：
牛顿运动定律 第一定律 假若施加于某物体的外力为零，则该物体的运动速度不变（惯性定律）【力是改变物体运动状态的原因】 第二定律 \(F = ma\) 【核心】 第三定律 当两个物体相互作用于对方时，彼此施加于对方的力，其大小相等、方向相反（作用力与反作用力定律） 三大守恒 质量守恒 动量守恒 \(\dfrac{d}{dt}mv=0\Rightarrow mv={\bf constant}\) 【来源自牛二定律】 能量守恒 在力学模拟中常常体现为机械能守恒 \(\dfrac{1}{2}mv^2+mgh+\dfrac{1}{2}k\Delta x^2(\Delta x=\int adt)+\dots={\bf constant}\) 有了基本定律，我们就可以考虑要建构怎样的模型了。不同性质的物体，所形成的物理模型显然是不同的，典型的物体性质按材料分有刚体、软体、流体等等，针对不同的物体，我们有不同的物理模型，用各种系统去做模拟方法，第二节课我们就会说到其中一些代表性的模拟系统。
计算机的离散系统 计算机与真实的物理世界最大的不同在于离散与连续。真实世界是一个连续的世界，我手在空中划过，我可以任取无数个时间点、我的手所在的位置，我的手的运动轨迹上的每一个点都是存在的。而如果在计算机系统中，这就是不可能的，我的手在计算机中一定会有一个计算精度，导致大量的点是不存在的，我手的运动其实是一次次“瞬移”组合而成的。这种离散化体现在两个方面：空间上和时间上。
空间上的离散化 两种基本的观察视点 我们在观测一个物理现象时，一般有两种观察的方法：一种是盯着某个物体，观察物体的运动，视线随着物体走；一种是盯着某个区域，观察物体在这个区域的运动。到计算机中离散存储空间运动时，也需要用这两种观察方法：记录物体、把物体的状态信息存储在物体上，即拉格朗日视点；把空间网格化，记录某一位置是否有物体、物体的属性是什么，即欧拉视点（需要强调，这里的欧拉与前面的欧拉法解线性方程并不一样，我们伟大的数学、物理学家的名字可不能只用在一种地方啊）。
拉格朗日视点 欧拉视点 视效工作中常用的三种表达方法 我们再具体一点，在视效工作中，离散化一个物理系统通常有以下几种：
粒子 Particle 粒子就是把物体作为一个个“质点”的组合，假设还是观察挥手这个动作，那么把我的手当成一群点组成的点集（大家可以理解为细胞？或者我手上的所有分子？），追溯每一个点的位置、速度、加速度，对每一个点去迭代。这是一个很典型的拉格朗日视点方法。 物体网格 Mesh （粒子的复合体） 第二种大家应该是比较熟悉的。我们在雪松老师的建模课上、在MAYA中处理的大多数模型都是这种离散化方法。用一个个的面去组成我们的风车、无人机、甲壳虫，再如我的手。而我们建模课上，雪松老师无数次强调要用“四边面”来方便进一步细分曲面处理，但无论是四边面还是最终渲染管线中的三角面，都是由一个个的点组成的。我们在模拟迭代计算时，仍然考虑点的状态，因此这也是一种拉格朗日视点的方法。 空间网格/体素 Grid/Voxel 现在大家考虑把我手的运动的这个区域框成一个空间，把这个空间网格化，这个过程可以类比二维情况下的像素化，我们称为“体素”，以1mm*1mm*1mm的立方体作为一个体素来描述这个空间。我的手从左到右挥过这个空间，首先是左边的空间有物体存在，然后中间，最后右边。我们记录每一个体素上是否有物体、物体的运动速度、加速度等信息，来迭代。这种方法就是欧拉视点的方法了。 在后面我们的具体方法介绍中，大多数都使用的拉格朗日视点的方法，到流体部分会涉及到欧拉视点和两种视点混合的新型方法。
时间上的离散化 时间维度上，我们用“时间步”的概念来离散化我们的物理模型，每一次需要计算的“点”称为一个时间步。假定我们的时间步长是1/24s，那么我们就会对相应物理模型每1/24s做一次计算（这个1/24s是物理模型的1/24s，不是我计算花的时间，事实上计算一个时间步所花的时间一般要比时间步长长得多），例如我的手花了1s挥过，那么我只计算其中的24个点、我的手位于什么位置，最终组合成一个动画。</description>
      <content:encoded><![CDATA[<h1 id="基于物理的动画物理模拟">基于物理的动画/物理模拟</h1>
<p><strong>Physically Based Animation</strong></p>
<p>今天我和李乐游给大家讲一下基于物理的动画这个题目。首先我们来解释一下这个题目，这个动画指的不是一部动画片的那个动画，是指在动画片/视效制作中的一个环节，也是计算机图形学的三个大方向之一：建模Modeling、动画Animation、渲染Rendering。也就是驱动我们的模型动起来的过程——那么怎样驱动我们的模型动起来呢。大家最熟悉的一种方式就是Key关键帧，比如大家建了一个肖翱的模型，要驱动我去运动，那自然是要把我绑定到骨骼上，对每个关节去打关键帧，比如把我的手十秒后挪到这里。但是呢，不是所有的动画都适合用关键帧来驱动，比如窗外雪花飘飘、一辆车跌落悬崖、瀑布飞流直下，这样的镜头如果用Key关键帧的方法去完成，那就不是Key我身上的几十个关节这么“容易”的事了。但这种物理现象往往是遵循物理规律的，我们想让他看起来真实，那么我们就可以用物理规律去驱动它运动；又或者是一个非自然的物理现象，我们也可以创造非自然的物理规律去驱动它运动。这样的动画方法我们称之为<strong>基于物理的动画</strong>，也称为<strong>物理模拟</strong>，也有人将模拟Simulation单独作为图形学的第四个方向。下面我们说到这两个词大家知道都是指同一个东西就行了。</p>
<p>那么基于物理的动画，在我们的电影中能做出什么样的效果呢，我们剪了一段经典影片中的Showreel给大家欣赏一下。然后我们将从发展历史、基本概念出发，介绍影视制作中的物理模拟制作流程、几种系统的算法原理与实现、展示一些我们自己制作的和经典影片中的基于物理的动画镜头，最后对物理模拟这项技术的未来再做一个分析和展望。</p>
<h2 id="发展历史">发展历史</h2>
<h3 id="年代和1950年代">1940年代和1950年代</h3>
<p>基于物理的动画来源于计算机模拟技术。它的首次大规模开发是著名的曼哈顿计划中的一个重要部分。在第二次世界大战中，为了模拟核爆炸的过程，人们应用蒙特·卡罗方法用12个坚球模型进行了模拟。计算机模拟最初被作为其他的方面研究的补充，但当人们发现它的重要性之后，它便作为一门单独的课题被使用得相当广泛。
之后便逐渐应用于军事和制造业。但在很长一段时间内，计算机计算非常昂贵，通常只有军事会使用这项技术。</p>
<h3 id="世纪70年代和80年代初">20世纪70年代和80年代初</h3>
<p>计算机图像生成技术兴起，1972年，第一部计算机生成的动画《A Computer
Animated
Hand》诞生，其中的一部分在1976年的电影《未来世界》中出现。这是电影第一次使用计算机生成图像。1982年《星际迷航II：可汗之怒》中的“创世纪”片段被普遍认为是VFX和计算机图形学的里程碑。这个片段首次使用了粒子系统，用CG的形式表现了爆炸效果。它是SIGGRAPH军事研究和电影工业早期交叉的产物之一。</p>
<h3 id="世纪80年代初至90年代">20世纪80年代初至90年代</h3>
<p>20世纪80年代的技术进步使电脑比前几十年更便宜、功能更强，这促进了Xbox游戏等的兴起。1985年，任天堂发布了任天堂娱乐系统（NES），NES成为视频游戏史上最畅销的游戏机之一。20世纪90年代，随着模拟人生、命令与征服等游戏的发布，以及台式电脑的不断增强，电脑游戏变得越来越流行。</p>
<p>1993年，电影《侏罗纪公园》成为第一部广泛使用计算机生成图形的电影，将计算机模拟的模拟恐龙几乎无缝地融入到实景中，这一事件改变了电影业。1995年，《玩具总动员》是第一部只使用计算机生成图像的电影，1998年，《蚁哥正传》第一次在动画中使用流体模拟。到了21世纪，计算机生成图像成为电影特效的主要选择。</p>
<h3 id="世纪初至今">21世纪初至今</h3>
<p>计算机图形学技术走向成熟，游戏和电影领域普遍使用基于物理的动画，在虚拟世界中模拟真实世界中物体之间的相互作用。</p>
<h2 id="基本概念">基本概念</h2>
<p>讲完发展历史，我们要开始正式进入基于物理的动画的世界。我把影视制作中基于物理的动画的制作归结为：“在计算机系统中、建立一定的物理模型、模拟生成动画并渲染成画面”。那么我们就需要首先了解一些基本概念。</p>
<h3 id="物理学的运动">物理学的运动</h3>
<p>在进入计算机之前，我们就需要把我们想要表现的画面、或者说想要模拟的现象，依据物理定律建构为物理模型。所以我们所有模拟首先要依赖于物理定律，由于目前影视制作的物理特效还很少涉及微观物理世界和超宏观物理世界（《蚁人2》、《星际穿越》这样的影片也仅仅是通过物理学家作为顾问来补齐一些“科幻设定”），所以我们使用的物理定律主要还是一般宏观视角的规律，如牛顿三大运动定律、各种守恒：</p>
<ul>
<li><strong>牛顿运动定律</strong>
<ul>
<li><strong>第一定律</strong>
假若施加于某物体的外力为零，则该物体的运动速度不变（惯性定律）【力是改变物体运动状态的原因】</li>
<li><strong>第二定律</strong> <span class="math inline">\(F =
ma\)</span> <strong>【核心】</strong></li>
<li><strong>第三定律</strong>
当两个物体相互作用于对方时，彼此施加于对方的力，其大小相等、方向相反（作用力与反作用力定律）</li>
</ul></li>
<li><strong>三大守恒</strong>
<ul>
<li><strong>质量守恒</strong></li>
<li><strong>动量守恒</strong> <span
class="math inline">\(\dfrac{d}{dt}mv=0\Rightarrow mv={\bf
constant}\)</span> 【来源自牛二定律】</li>
<li><strong>能量守恒</strong>
在力学模拟中常常体现为<strong>机械能守恒</strong> <span
class="math inline">\(\dfrac{1}{2}mv^2+mgh+\dfrac{1}{2}k\Delta
x^2(\Delta x=\int adt)+\dots={\bf constant}\)</span></li>
</ul></li>
</ul>
<p>有了基本定律，我们就可以考虑要建构怎样的模型了。不同性质的物体，所形成的物理模型显然是不同的，典型的物体性质按材料分有<strong>刚体、软体、流体</strong>等等，针对不同的物体，我们有不同的物理模型，用各种系统去做模拟方法，第二节课我们就会说到其中一些代表性的模拟系统。</p>
<h3 id="计算机的离散系统">计算机的离散系统</h3>
<p>计算机与真实的物理世界最大的不同在于离散与连续。真实世界是一个连续的世界，我手在空中划过，我可以任取无数个时间点、我的手所在的位置，我的手的运动轨迹上的每一个点都是存在的。而如果在计算机系统中，这就是不可能的，我的手在计算机中一定会有一个计算精度，导致大量的点是不存在的，我手的运动其实是一次次“瞬移”组合而成的。这种离散化体现在两个方面：空间上和时间上。</p>
<h4 id="空间上的离散化">空间上的离散化</h4>
<h5 id="两种基本的观察视点">两种基本的观察视点</h5>
<p>我们在观测一个物理现象时，一般有两种观察的方法：一种是盯着某个物体，观察物体的运动，视线随着物体走；一种是盯着某个区域，观察物体在这个区域的运动。到计算机中离散存储空间运动时，也需要用这两种观察方法：记录物体、把物体的状态信息存储在物体上，即<strong>拉格朗日视点</strong>；把空间网格化，记录某一位置是否有物体、物体的属性是什么，即<strong>欧拉视点</strong>（需要强调，这里的欧拉与前面的欧拉法解线性方程并不一样，我们伟大的数学、物理学家的名字可不能只用在一种地方啊）。</p>
<ul>
<li><strong>拉格朗日视点</strong></li>
<li><strong>欧拉视点</strong></li>
</ul>
<h5 id="视效工作中常用的三种表达方法">视效工作中常用的三种表达方法</h5>
<p>我们再具体一点，在视效工作中，离散化一个物理系统通常有以下几种：</p>
<ul>
<li><strong>粒子 Particle</strong>
粒子就是把物体作为一个个“质点”的组合，假设还是观察挥手这个动作，那么把我的手当成一群点组成的点集（大家可以理解为细胞？或者我手上的所有分子？），追溯每一个点的位置、速度、加速度，对每一个点去迭代。这是一个很典型的拉格朗日视点方法。</li>
<li><strong>物体网格 Mesh</strong> （粒子的复合体）
第二种大家应该是比较熟悉的。我们在雪松老师的建模课上、在MAYA中处理的大多数模型都是这种离散化方法。用一个个的面去组成我们的风车、无人机、甲壳虫，再如我的手。而我们建模课上，雪松老师无数次强调要用“四边面”来方便进一步细分曲面处理，但无论是四边面还是最终渲染管线中的三角面，都是由一个个的点组成的。我们在模拟迭代计算时，仍然考虑点的状态，因此这也是一种拉格朗日视点的方法。</li>
<li><strong>空间网格/体素 Grid/Voxel</strong>
现在大家考虑把我手的运动的这个区域框成一个空间，把这个空间网格化，这个过程可以类比二维情况下的像素化，我们称为“体素”，以1mm*1mm*1mm的立方体作为一个体素来描述这个空间。我的手从左到右挥过这个空间，首先是左边的空间有物体存在，然后中间，最后右边。我们记录每一个体素上是否有物体、物体的运动速度、加速度等信息，来迭代。这种方法就是欧拉视点的方法了。</li>
</ul>
<p>在后面我们的具体方法介绍中，大多数都使用的拉格朗日视点的方法，到流体部分会涉及到欧拉视点和两种视点混合的新型方法。</p>
<h4 id="时间上的离散化">时间上的离散化</h4>
<p>时间维度上，我们用“时间步”的概念来离散化我们的物理模型，每一次需要计算的“点”称为一个时间步。假定我们的时间步长是1/24s，那么我们就会对相应物理模型每1/24s做一次计算（这个1/24s是物理模型的1/24s，不是我计算花的时间，事实上计算一个时间步所花的时间一般要比时间步长长得多），例如我的手花了1s挥过，那么我只计算其中的24个点、我的手位于什么位置，最终组合成一个动画。</p>
<p>而离散化的多种方法主要是来源于考虑基于“何时”的状态来做下一步的计算。我们要计算当前时刻物体的位置，即上一个已知位置之后发生的位移，那么我们理应得到速度发生的变化，对其积分得到总的位置，但现在我们只知道上一个时间步的位置和速度，那么显而易见的，我们可以直接用上一个时间步的参数来计算——这就是我们所谓的<strong>显式时间积分</strong>；但显式时间积分很容易出问题：容易发生发散、不收敛的现象，导致数值爆炸，但如果我们硬要用当前时间步的状态，数值就稳定了，但我们的当前状态是“隐藏的”——因此要称为<strong>隐式时间积分</strong>。</p>
<ul>
<li><strong>显式时间积分</strong>
<ul>
<li><strong>前向欧拉</strong> <span
class="math inline">\(v_{t+1}=v_t+a_t\Delta t \\ x_{t+1}=x_t+v_t\Delta
t\)</span> 这就是完全使用前一时间步的速度、加速度来计算</li>
<li><strong>半隐式欧拉</strong> <span
class="math inline">\(v_{t+1}=v_t+a_t\Delta t \\
x_{t+1}=x_t+v_{t+1}\Delta t\)</span>
这里，我们先算出了当前时间步的速度，这样我们就可以用当前时间步的速度来计算了，称之为“半隐式”是因为速度这个参数确实是隐藏的，但其确实是通过前一个时间步的加速度“顺着”算出来的，本质上仍然是一个明显的量，所以本质上还是显示的时间积分方法。那么什么样是“不明显的”呢，我们接着看。</li>
</ul></li>
<li><strong>隐式时间积分</strong>
<ul>
<li><strong>后向欧拉</strong> <span
class="math inline">\(v_{t+1}=v_t+a_{t+1}\Delta t \\
x_{t+1}=x_t+v_{t+1}\Delta t\)</span>
可以看到我们这里把加速度也换成当前时间步的加速度了，除了上一时间步的位置作为初值，不再有使用前一时间步的任何状态参数，那么怎么求解呢？我们把这个公式替换、变形、泰勒展开，最终得到了
<span class="math inline">\([{\bf I}-\Delta t^2 {\bf
M}^{-1}\dfrac{\partial f(x_t)}{\partial x}]v_{t+1}=v_t+\Delta t{\bf
M}^{-1}{\bf f}(x_t)\)</span> ，形如 <span
class="math inline">\(Ax=b\)</span>
的一个线性方程：至于怎么解线性方程，大家大一是学过其中的数值解法的，也即Gauss消元、三角分解这些，但这些方法在解这样庞大、复杂的方程显得无能为力。因此我们引入迭代法去求解，也即再把式子做一些变形，得到一个满足迭代条件的结构，任给其一个初值，去不断重复计算，来逼近真实的解——迭代次数越多，越精准。经典的迭代方法有牛顿迭代法、Jacobi迭代法、共轭梯度法等等。这里就不再展开了。</li>
</ul></li>
</ul>
<p>有了这些基本概念，我们终于可以进入到具体的基于物理的动画的介绍中了。接下来，我们会轻松一会，远离数理概念一段时间，介绍在一个电影制作流程中、一家影视视效公司里，基于物理的动画、或者说物理模拟工作的制作流程、分工。然后我们会就粒子系统、刚体系统、流体系统三种物理模拟系统来给大家介绍一些物理模拟的基本算法与效果。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-03-GAMES104现代游戏引擎-Lecture7-Rendering Pipeline, Post-Process and Everything</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture7-postprocessingandothers/</link>
      <pubDate>Mon, 03 May 2021 11:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture7-postprocessingandothers/</guid>
      <description>Lecture07 Rendering Pipeline, Post-Process and Everything Ambient Occlusion 接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。
AO：单目视觉中形成3D感的重要元素
不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。
Precomputed AO 使用Ray Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。
效果好，计算复杂，且无法处理多物体之间的AO。
SSAO, Screen Space AO @GAMES202 SSAO
HBAO, Horizon-based Ambient Occlusion 在法线方向半球空间内积分 \[ A=1-\dfrac{1}{2\pi}\int_{\theta=-\pi}^\pi\int_{\alpha=t(\theta)}^h(\theta)W(\vec\omega)\cos\alpha\,\mathrm d\alpha\mathrm d\theta \] 利用深度图做Ray Marching GTAO, Ground Truth - based AO SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)
\[ \hat A(x)=\dfrac{1}{\pi}\int_0^\pi\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\,\mathrm d\theta\mathrm d\phi\\\gamma={\rm angle}(\vec n, \vec v) \]
根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO
Ray-Tracing AO @GAMES202 RTRT
Fog Depth Fog 随着深度透明度下降
Linear fog: factor = (end-z) / (end - start) Exp fog: factor = exp(- density * z) Exp Squared fog: factor = exp(- (density * z) ^ 2) Height Fog 设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减</description>
      <content:encoded><![CDATA[<h3
id="lecture07-rendering-pipeline-post-process-and-everything">Lecture07
Rendering Pipeline, Post-Process and Everything</h3>
<h4 id="ambient-occlusion">Ambient Occlusion</h4>
<p>接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。</p>
<blockquote>
<p>AO：单目视觉中形成3D感的重要元素</p>
</blockquote>
<p><img src="/images/games104/L07_AO.png" alt="L07_AO" style="zoom: 33%;" /></p>
<p>不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。</p>
<h5 id="precomputed-ao">Precomputed AO</h5>
<p>使用Ray
Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。</p>
<p>效果好，计算复杂，且无法处理多物体之间的AO。</p>
<h5 id="ssao-screen-space-ao">SSAO, Screen Space AO</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
SSAO</p>
<h5 id="hbao-horizon-based-ambient-occlusion">HBAO, Horizon-based
Ambient Occlusion</h5>
<ul>
<li><p>在法线方向半球空间内积分 <span class="math display">\[
A=1-\dfrac{1}{2\pi}\int_{\theta=-\pi}^\pi\int_{\alpha=t(\theta)}^h(\theta)W(\vec\omega)\cos\alpha\,\mathrm
d\alpha\mathrm d\theta
\]</span>
<img src="/images/games104/L07_HBAO2.jpg" alt="L07_HBAO2" style="zoom:30%;" /><img src="/images/games104/L07_HBAO1.jpg" alt="L07_HBAO1" style="zoom:23%;" /></p></li>
<li><p>利用深度图做Ray Marching
<img src="/images/games104/L07_HBAO3.png" alt="L07_HBAO3" style="zoom: 50%;" /></p></li>
</ul>
<h5 id="gtao-ground-truth---based-ao">GTAO, Ground Truth - based AO</h5>
<p>SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)</p>
<ul>
<li><p><img src="/images/games104/L07_GTAO.jpg" alt="L07_GTAO" style="zoom: 50%;" />
<span class="math display">\[
\hat
A(x)=\dfrac{1}{\pi}\int_0^\pi\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\,\mathrm
d\theta\mathrm d\phi\\\gamma={\rm angle}(\vec n, \vec v)
\]</span></p></li>
<li><p>根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO</p></li>
</ul>
<h5 id="ray-tracing-ao">Ray-Tracing AO</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
RTRT</p>
<h4 id="fog">Fog</h4>
<h5 id="depth-fog">Depth Fog</h5>
<p>随着深度透明度下降</p>
<ul>
<li>Linear fog: <code>factor = (end-z) / (end - start)</code></li>
<li>Exp fog: <code>factor = exp(- density * z)</code></li>
<li>Exp Squared fog: <code>factor = exp(- (density * z) ^ 2)</code></li>
</ul>
<p><img src="/images/games104/L07_DepthFog.png" alt="L07_DepthFog" style="zoom: 50%;" /></p>
<h5 id="height-fog">Height Fog</h5>
<p>设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减</p>
<ul>
<li><p>观察方向的Height Fog积分 <span class="math display">\[
\begin{array}{c}D(h)=D_\max\cdot e^{-\sigma\cdot\max(h-H_s, 0)}\\
\begin{aligned}{\rm FogDensityIntegration}=&amp;\ D_\max\cdot d\int_0^1
e^{-\sigma\cdot\max(v_z+t\cdot d_z-H_s, 0)}\,\mathrm dt\\=&amp;\
D_\max\cdot de^{-\sigma\cdot\max(v_z-H_s, 0)}\dfrac{1-e^{-\sigma\cdot
d_z}}{\sigma\cdot d_z}
\end{aligned}\end{array}
\]</span>
<img src="/images/games104/L07_HeightFog.png" alt="L07_HeightFog" style="zoom: 33%;" /></p></li>
<li><p>Fog颜色 <span class="math display">\[
{\rm FogInscatter}=1-\exp^{- \rm FogDensityIntegration}\\
{\rm FinalColor} = {\rm FogColor}\cdot{\rm FogInscatter}
\]</span></p></li>
</ul>
<h5 id="voxel-based-volumetric-fog">Voxel-based Volumetric Fog</h5>
<p>现代的雾效，可以实现丁达尔效应</p>
<ul>
<li>对整个相机空间Voxelize，以不同大小的四棱台作Voxel
<img src="/images/games104/L07_VoxelFog1.jpg" alt="L07_VoxelFog1" style="zoom: 67%;" /></li>
<li>计算方法与Atmosphere计算相似</li>
<li>用一个3D Texture存储，长宽尽量与屏幕成整数倍（eg. 160*90）</li>
</ul>
<h4 id="anti-aliasing">Anti-aliasing</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> AA</p>
<p>三种走样：Edge Sampling, Texture Sampling（MIPMAP可解决）, Specular
Sampling</p>
<h4 id="post-process">Post-process</h4>
<h5 id="bloom-光晕">Bloom 光晕</h5>
<ul>
<li>检测提取高光区域（计算灰度，比较阈值）</li>
<li>对高光区域作Gaussian Blur（横向/纵向各一轮减少计算） -&gt;
<strong>Pyramid Gaussian Blur</strong>
<img src="/images/games104/L07_PyramidGuassianBlur.png" alt="L07_PyramidGuassianBlur" style="zoom: 33%;" /></li>
<li>将模糊完的图像叠加到图像上</li>
</ul>
<h5 id="tone-mapping">Tone Mapping</h5>
<p>HDR to SDR</p>
<ul>
<li>flimic s-curve
<img src="/images/games104/L07_Filmic.png" alt="L07_Filmic" style="zoom: 33%;" /></li>
<li>ACES</li>
</ul>
<h5 id="color-grading">Color Grading</h5>
<ul>
<li>LUT</li>
</ul>
<blockquote>
<p>Tone Mapping and Color Grading is my area hhhhh (at DFTT of BFA)</p>
</blockquote>
<h4 id="rendering-pipeline">Rendering Pipeline</h4>
<h5 id="forward-rendering">Forward Rendering</h5>
<ul>
<li>Shadow Pass -&gt; Shading -&gt; Post-process</li>
<li>逐物体绘制</li>
<li>透明材质排序，由远及近绘制 -&gt; 各种问题</li>
<li>多光源绘制复杂</li>
</ul>
<h5 id="deferred-rendering">Deferred Rendering</h5>
<ul>
<li><p>Pass 1</p>
<pre class="pseudocode"><code>for each object:
  write G-Buffer;</code></pre></li>
<li><p>Pass 2</p>
<pre class="pseudocode"><code>for each pixel:
  gbuffer = readGBuffer(G-Buffer);
  for each light:
      computeShading(gbuffer, light);</code></pre></li>
</ul>
<h5 id="tiled-based-rendering">Tiled-based Rendering</h5>
<ul>
<li><p>移动端读写能耗大</p></li>
<li><p>切成小块，小块渲染、小块读写</p></li>
<li><p>光源也可以被切割成Tile</p></li>
<li><p>深度上也可对光源优化</p></li>
<li><h5 id="tiled-deferred-rendering">Tiled Deferred Rendering</h5></li>
<li><h5 id="forward-tiled-forward-rendering">Forward+ (Tiled Forward)
Rendering</h5></li>
</ul>
<h5 id="cluster-based-rendering">Cluster-based Rendering</h5>
<p><img src="/images/games104/L07_ClusterBasedRendering.png" alt="L07_ClusterBasedRendering" style="zoom: 50%;" /></p>
<h5 id="visibility-buffer">Visibility Buffer</h5>
<ul>
<li>V-Buffer
<ul>
<li>Depth</li>
<li>PrimitiveID</li>
<li>Barycentrics</li>
</ul></li>
<li><img src="/images/games104/L07_VisibilityBuffer.jpg" alt="L07_VisibilityBuffer" style="zoom: 67%;" /></li>
</ul>
<blockquote>
<p><strong>Unreal Engine Rendering Pipeline</strong> <img
src="/images/games104/L07_UnrealRenderingPipeline.png"
alt="L07_UnrealRenderingPipeline" /></p>
</blockquote>
<h5 id="v-sync-freesync-vrr">V-Sync / FreeSync / VRR</h5>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-30-GAMES104现代游戏引擎-Lecture6.2-Sky and Atmosphere</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-30-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.2-atmospherecloud/</link>
      <pubDate>Fri, 30 Apr 2021 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-30-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.2-atmospherecloud/</guid>
      <description>Lecture06-2 Sky and Atmosphere Atmosphere 大气 Analytic Atmosphere Appearance Modeling 不必按照物理模拟，根据观察找模型拟合
两个参数
观察向量与垂直向上向量的夹角 \(\theta\) 观察向量与太阳方向的夹角 \(\gamma\) \[ \mathbb{F}(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})\cdot(C+De^{E\gamma}+F\cos^2\gamma+G\cdot\chi(H,\gamma)+I\cdot\cos^{\frac{1}{2}}\theta)\\ L_\lambda = \mathbb{F}(\theta,\gamma)\cdot L_{M\lambda} \]
优势：简单快捷，直接代入计算即可
劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气
Participating Media 物理属性 大气中：空气、气溶胶，形成各种折射和反射
光在Participating Media中：
Absorption 吸收 \[ \dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm x}=-\sigma_\alpha\cdot L(\mathrm x,\omega)\\ \sigma_\alpha:\text{Absorption Coeffcient} \]
Out-scattering 对外散射 \[ -\sigma_sL(\mathrm x,\omega)\\ \sigma_s:\text{Scattering Coeffcient} \]
Emission 自发光（火焰、辉光等） \[ \sigma_\alpha L_e(\mathrm x,\omega) \]
In-Scattering 对内散射 接收周围分子的Out-Scattering \[ \sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&amp;#39;)L(\mathrm x,\omega&amp;#39;)\,\mathrm d\omega&amp;#39;\\ f_p(\mathrm x,\omega,\omega&amp;#39;):\text{Phase Function} \]</description>
      <content:encoded><![CDATA[<h3 id="lecture06-2-sky-and-atmosphere">Lecture06-2 Sky and
Atmosphere</h3>
<h4 id="atmosphere-大气">Atmosphere 大气</h4>
<h5 id="analytic-atmosphere-appearance-modeling">Analytic Atmosphere
Appearance Modeling</h5>
<ul>
<li><p>不必按照物理模拟，根据观察找模型拟合</p></li>
<li><p>两个参数</p>
<ul>
<li>观察向量与垂直向上向量的夹角 <span
class="math inline">\(\theta\)</span></li>
<li>观察向量与太阳方向的夹角 <span
class="math inline">\(\gamma\)</span></li>
</ul>
<p><img src="/images/games104/L06_AtmosphereAngles.jpg" alt="L06_AtmosphereAngles" style="zoom: 50%;" /></p></li>
<li><p><span class="math display">\[
\mathbb{F}(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})\cdot(C+De^{E\gamma}+F\cos^2\gamma+G\cdot\chi(H,\gamma)+I\cdot\cos^{\frac{1}{2}}\theta)\\
L_\lambda = \mathbb{F}(\theta,\gamma)\cdot L_{M\lambda}
\]</span></p></li>
<li><p>优势：简单快捷，直接代入计算即可</p></li>
<li><p>劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气</p></li>
</ul>
<h5 id="participating-media">Participating Media</h5>
<h6 id="物理属性">物理属性</h6>
<ul>
<li><p>大气中：空气、气溶胶，形成各种折射和反射</p></li>
<li><p>光在Participating Media中：</p>
<ul>
<li><p><strong>Absorption 吸收</strong> <span class="math display">\[
\dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm
x}=-\sigma_\alpha\cdot L(\mathrm x,\omega)\\
\sigma_\alpha:\text{Absorption Coeffcient}
\]</span></p></li>
<li><p><strong>Out-scattering 对外散射</strong> <span
class="math display">\[
-\sigma_sL(\mathrm x,\omega)\\
\sigma_s:\text{Scattering Coeffcient}
\]</span></p></li>
<li><p><strong>Emission 自发光（火焰、辉光等）</strong> <span
class="math display">\[
\sigma_\alpha L_e(\mathrm x,\omega)
\]</span></p></li>
<li><p><strong>In-Scattering 对内散射</strong>
接收周围分子的Out-Scattering <span class="math display">\[
\sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&#39;)L(\mathrm
x,\omega&#39;)\,\mathrm d\omega&#39;\\
f_p(\mathrm x,\omega,\omega&#39;):\text{Phase Function}
\]</span></p></li>
</ul></li>
<li><p><strong>Radiative Transfer Equation, RTE</strong> <span
class="math display">\[
\sigma_t(\mathrm x)=\sigma_\alpha(\mathrm x)+\sigma_s(\mathrm x)\\
\dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm x}=-\sigma_t\cdot
L(\mathrm x,\omega)+\sigma_\alpha L_e(\mathrm
x,\omega)+\sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&#39;)L(\mathrm
x,\omega&#39;)\,\mathrm d\omega&#39;
\]</span></p></li>
<li><p><strong>Volume Rendering Equation, VRE</strong>
<img src="/images/games104/L06_VRE.png" alt="L06_VRE" style="zoom: 25%;" />
对RTE梯度的路径积分 <span class="math display">\[
L(P,\omega)=\int_{\mathrm x=0}^\mathrm d T(\mathrm x)[\sigma_\alpha\cdot
L_e(\mathrm x,\omega)+\sigma_s\cdot L_i(\mathrm x,\omega)]\,\mathrm
d\mathrm x + T(M)L(M,\omega)\\
T(\mathrm x)=e^{-\int_\mathrm x ^P\sigma_t(s)\,\mathrm d s}\\
L_i(\mathrm x,\omega)=\int_{S^2}f_p(\mathrm
x,\omega,\omega&#39;)L(\mathrm x,\omega&#39;)\,\mathrm d\omega&#39;
\]</span></p>
<p>两个关键部分</p>
<ul>
<li>Transmitters：远处物体有多少能透视到眼睛</li>
<li>光打到空气中的散射、折射后，沿观察方向的光路有多少能进入眼睛</li>
</ul></li>
<li><p><strong>Rayleigh Scattering 瑞利散射</strong>
空气中介质尺寸远小于光的波长时，光形成较为均匀的散射；波长越短（蓝紫色）散射越强，波长越长（红色）散射越弱</p>
<p><img src="/images/games104/L06_RayleighScatteringDistribution.jpg" alt="L06_RayleighScatteringDistribution" style="zoom: 80%;" />
<span class="math display">\[
S(\lambda,\theta,h)=\dfrac{\pi^2(n^2-1)}{2}\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1}{\lambda^4}\cdot(1+\cos^2\theta)\\
\lambda\,\text{波长}\ h\,\text{海拔高度}\ N\,\text{标准大气压}\
\theta\,\text{观察方向与光传播方向夹角}
\]</span> 左半边固定，只需求右半边Phase Function部分</p>
<ul>
<li>Scattering Coefficient <span
class="math inline">\(\sigma_s^\text{Rayleigh}(\lambda,h)=\dfrac{8\pi^3(n^2-1)}{3}\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1}{\lambda^4}\)</span></li>
<li>Phase Function 腰果形函数 <span
class="math inline">\(F_\text{Rayleigh}(\theta)=\dfrac{3}{16\pi}(1+\cos^2\theta)\)</span></li>
</ul></li>
<li><p><strong>Mie Scattering 米氏散射</strong>
主要针对气溶胶，介质尺寸接近或大于光的波长时，光形成有一定方向性的散射、沿着光的方向较强；但对波长不敏感</p>
<p><img src="/images/games104/L06_MieScatteringDistribution.jpg" alt="L06_MieScatteringDistribution" style="zoom: 80%;" />
<span class="math display">\[
S(\lambda,\theta,h)=\pi^2(n^2-1)\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1-g}{2+g^2}\cdot\dfrac{(1+\cos^2\theta)}{(1-g^2-2g\cos\theta)^\frac{3}{2}}\\
g\,\text{几何参数，一般由艺术家控制}
\]</span></p>
<ul>
<li>Scattering Coefficient <span
class="math inline">\(\sigma_s^\text{Mie}(\lambda,h)=\dfrac{8\pi^3(n^2-1)}{3}\cdot\dfrac{\rho(h)}{N}\)</span></li>
<li>Phase Function <span
class="math inline">\(F_\text{Mie}(\theta)=\dfrac{3}{8\pi}\cdot\dfrac{1-g}{2+g^2}\cdot\dfrac{(1+\cos^2\theta)}{(1-g^2-2g\cos\theta)^\frac{3}{2}}\)</span></li>
<li><span class="math inline">\(g=0\)</span>
时，退化成与瑞利散射分布相同的形状（类似花生豆）； <span
class="math inline">\(g&gt;0\)</span> 时，沿米氏散射方向更多 <span
class="math inline">\(g&lt;0\)</span> 时，反向更多</li>
</ul>
<blockquote>
<p>eg. 雾：即一种气溶胶，对太阳光不同波长无差别散射，故呈白色</p>
<p>eg. 日晕也是米氏散射带来的</p>
</blockquote></li>
<li><p><strong>光的吸收</strong></p>
<ul>
<li>臭氧吸收长波，红橙黄；甲烷吸收红光</li>
<li>假设：臭氧和甲烷均匀分布在大气中</li>
</ul></li>
<li><p><strong>单次散射和多次散射 Single Scattering &amp; Multiple
Scattering</strong></p>
<p><img src="/images/games104/L06_SingleScatteringMultiScattering.jpg" alt="L06_SingleScatteringMultiScattering" style="zoom:67%;" /></p>
<ul>
<li><p>Single Scattering <span class="math display">\[
L_1=\int_A^BL_{P\to A}\,\mathrm ds
\]</span></p></li>
<li><p>Multiple Scattering <span class="math display">\[
L_{n+1}=\int_A^B\int_{4\pi}L_n(P,v&#39;)\cdot S(\lambda,\theta,h)\cdot
T(P\to A)\,\mathrm dv&#39;\mathrm ds
\]</span></p></li>
<li><p>Single Scattering的背阳面呈现死黑，Multi Scattering有亮度
<img src="/images/games104/L06_SingleScatteringMultiScatteringComparison.png" alt="L06_SingleScatteringMultiScatteringComparison" style="zoom: 25%;" /></p></li>
</ul></li>
</ul>
<h6 id="解决方法">解决方法</h6>
<ul>
<li><p>Ray Marching：沿着观察视线，一步一步积分</p></li>
<li><p><strong>Precomputed Atmospheric Scattering</strong></p>
<ul>
<li>把大气散射用Ray Marching预计算成 <span
class="math inline">\(\cos\theta\)</span> 和 <span
class="math inline">\(h\)</span> 为维度的LUT，计算时直接查表（<span
class="math inline">\(\theta\)</span>
为观察视角与垂直向上方向夹角）</li>
<li>大气散射的两个部分：通透度Transmittance、散射度Scattering</li>
<li><strong>通透度 Transmittance</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringT.png" alt="L06_PrecomputedAtmosphericScatteringT" style="zoom: 25%;" />
<ul>
<li>预计算 <span class="math inline">\(T(\mathrm x)=e^{-\int_\mathrm
x^P\sigma_t(s)\,\mathrm ds}\)</span></li>
<li>查表 <span class="math inline">\(T(\mathrm x_\mathrm v\to \mathrm
x_\mathrm m)=\dfrac{T(\mathrm x_\mathrm v\to B)}{T(\mathrm x_\mathrm
m\to B)}\)</span></li>
<li>二维LUT</li>
</ul></li>
<li><strong>Single Scattering</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringSingleScattering.png" alt="L06_PrecomputedAtmosphericScatteringSingleScattering" style="zoom:25%;" />
<ul>
<li>预计算 <span
class="math inline">\(L_\text{sun}\displaystyle\int_A^BS(\lambda,\theta,h)\cdot(T(\text{sun}\to
P)+T(P\to A))\,\mathrm ds\)</span></li>
<li>查表 <span class="math inline">\(L(\mathrm x_\mathrm v\to \mathrm
x_\mathrm m)=L(\mathrm x_\mathrm v\to B)-L(\mathrm x_\mathrm m\to
B)\cdot T(\mathrm x_\mathrm v\to \mathrm x_\mathrm m)\)</span></li>
<li>四维LUT，但数值平滑，可以低精度插值，用Virtual
Texture放在一张图上</li>
</ul></li>
<li><strong>Multi Scattering</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringMultiScattering.png" alt="L06_PrecomputedAtmosphericScatteringMultiScattering" style="zoom:25%;" />
<ul>
<li>利用前面两张LUT，积分预计算得Multi Scattering
LUT（一般计算3-4次结果即可）</li>
</ul></li>
<li>问题
<ul>
<li>预计算开销大</li>
<li>天气变化时难以均匀过渡</li>
<li>查表插值计算开销也不够小</li>
</ul></li>
</ul></li>
<li><p><a
href="https://diglib.eg.org/bitstream/handle/10.1111/cgf14050/v39i4pp013-022.pdf">A
Scalable and Production Ready Sky and Atmosphere Rendering
Technique</a></p>
<p>核心思想：</p>
<ul>
<li><p>假设：对于空气中的一个分子，来自各个方向的散射是等同的</p>
<p>问题转换为能量衰减问题，每次衰减百分之多少，Multi
Scattering计算衰减百分比的级数求和即可</p></li>
<li><p>取消海拔高度和太阳位置两个参数，不计算全部情况；只保留天顶角和环方向角两个维度</p></li>
<li><p>Ray marching预计算LUT</p></li>
</ul>
<p>不物理正确，但效率高、效果好，符合艺术家需要</p></li>
</ul>
<h4 id="cloud-云">Cloud 云</h4>
<p>云的种类：层云、积云、卷云</p>
<p><img src="/images/games104/L06_Clouds.jpg" alt="L06_Clouds" style="zoom:50%;" /></p>
<p>早期：Mesh、Billboard 片状贴图</p>
<h5 id="volumetric-cloud-modeling">Volumetric Cloud Modeling</h5>
<ul>
<li><p>优势：全动态，runtime生成 劣势：算法复杂开销大</p></li>
<li><p><strong>Weather Texture</strong>
<img src="/images/games104/L06_WeatherTexture.jpg" alt="L06_WeatherTexture" style="zoom: 67%;" /></p>
<ul>
<li><p>是否有值表示云的分布 0-1值表示当前位置云的厚度</p></li>
<li><p>云的运动：Texture位移、扰动</p></li>
</ul></li>
<li><p>Noise Function</p>
<ul>
<li>Perlin Noise
<img src="/images/games104/L06_PerlinNoise.png" alt="L06_PerlinNoise" style="zoom:33%;" /></li>
<li>Worley Noise
<img src="/images/games104/L06_WorleyNoise.png" alt="L06_WorleyNoise" style="zoom:33%;" /></li>
</ul></li>
<li><ol type="1">
<li>先用Weather Texture生成柱状图</li>
<li>再用低频Noise Map腐蚀</li>
<li>最后加以高频Noise Map增加细节</li>
</ol>
<p><img src="/images/games104/L06_CloudDensityModel.png" alt="L06_CloudDensityModel" style="zoom:33%;" /></p></li>
<li><p>Ray Marching渲染云</p>
<p><img src="/images/games104/L06_CloudRendering.png" alt="L06_CloudRendering" style="zoom:33%;" /></p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-28-GAMES104现代游戏引擎-Lecture6.1-Terrain Rendering</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-28-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.1-terrain/</link>
      <pubDate>Wed, 28 Apr 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-28-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.1-terrain/</guid>
      <description>Lecture06 Rendering of Mother Nature Lecture06-1 Terrain Rendering 地形渲染 Simple Idea - Heightfield Height Map Contour Map
符合分形原则 渲染 均匀网格，依据Heightfield位移每一个顶点 问题：世界过大时过于复杂
解决方法：LoD -&amp;gt; 非均匀网格 -&amp;gt; 保证场景连续，保证LoD过渡均匀 Adaptive Mesh Tessellation
优化原则
依据Distance to Camera和FoV做LoD Error Bound：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小） Tessellation Triangle-Based Subdivision 在等腰直角三角形的长边切割 -&amp;gt; 得到两个新的等腰直角三角形 二叉树结构，因此又称Binary Triangle-Based Subdivision T-Junctions 解决方法：判断若邻边切分更密，则当前边也需同样进行切分 实际应用中不广泛 QuadTree-Based Subdivision 四叉树分割 优势 易于建构 易于管理几何分区数据，Objects Culling和Data Streaming 符合Texture存储规范 劣势 Mesh细分没有三角形细分灵活 叶子节点的网格层级锁定 符合直觉，应用主流 T-Junctions 与三角形分割类似的问题，细分层级边界处产生 解决方法：Stitching 吸附 吸附生成的三角形：退化三角形 Triangulated Irregular Network (TIN) 几何细节不丰富处，用较粗的三角形 优势 易于Runtime渲染 更少的三角形 劣势 需要预计算 不够通用 特殊的游戏会用 GPU-Based Tessellation DX11开始： Hull-Shader Stage：生成Subdivision用的Patch，告诉Control point数据和Tessellation数量 Tessellator Stage：做Tessellation Domain-Shader Stage：根据高度图移动顶点 Geometry Shader Stage：算Vertex Mesh Shader Pipeline (DX12) GPU-Based Tessellation -&amp;gt; Runtime Tessellation -&amp;gt; Real-Time Deformable Terrain 假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation</description>
      <content:encoded><![CDATA[<h2 id="lecture06-rendering-of-mother-nature">Lecture06 Rendering of
Mother Nature</h2>
<h3 id="lecture06-1-terrain-rendering-地形渲染">Lecture06-1 Terrain
Rendering 地形渲染</h3>
<h4 id="simple-idea---heightfield">Simple Idea - Heightfield</h4>
<p>Height
Map<img src="/images/games104/L06_HeightMap.jpg" alt="L06_HeightMap" style="zoom:22.5%;" />
Contour
Map<img src="/images/games104/L06_ContourMap.jpg" alt="L06_ContourMap" style="zoom:15%;" /></p>
<ul>
<li>符合分形原则</li>
<li>渲染
<ul>
<li><p>均匀网格，依据Heightfield位移每一个顶点
问题：世界过大时过于复杂</p></li>
<li><p>解决方法：LoD -&gt; 非均匀网格 -&gt;
保证场景连续，保证LoD过渡均匀 <strong>Adaptive Mesh
Tessellation</strong></p>
<p><img src="/images/games104/L06_AdaptiveMeshTessellation.jpg" alt="L06_AdaptiveMeshTessellation" style="zoom: 33%;" /></p></li>
<li><p>优化原则</p>
<ul>
<li>依据Distance to Camera和FoV做LoD</li>
<li><strong>Error
Bound</strong>：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="tessellation">Tessellation</h4>
<h5 id="triangle-based-subdivision">Triangle-Based Subdivision</h5>
<p><img src="/images/games104/L06_TriangleBasedSubdivision.jpg" alt="L06_TriangleBasedSubdivision" style="zoom: 33%;" /></p>
<ul>
<li>在等腰直角三角形的长边切割 -&gt; 得到两个新的等腰直角三角形
<img src="/images/games104/L06_TriangleBasedSubdivisionLevels.jpg" alt="L06_TriangleBasedSubdivisionLevels" style="zoom:30%;" /></li>
<li>二叉树结构，因此又称<strong>Binary Triangle-Based
Subdivision</strong></li>
<li><strong>T-Junctions</strong>
<img src="/images/games104/L06_T-Junction.jpg" alt="L06_T-Junction" style="zoom: 20%;" />
解决方法：判断若邻边切分更密，则当前边也需同样进行切分
<img src="/images/games104/L06_T-JunctionSolution.jpg" alt="L06_T-JunctionSolution" style="zoom: 50%;" /></li>
<li>实际应用中不广泛</li>
</ul>
<h5 id="quadtree-based-subdivision-四叉树分割">QuadTree-Based
Subdivision 四叉树分割</h5>
<p><img src="/images/games104/L06_QuadTreeBasedSubdivision.jpg" alt="L06_QuadTreeBasedSubdivision" style="zoom: 33%;" /></p>
<ul>
<li>优势
<ul>
<li>易于建构</li>
<li>易于管理几何分区数据，Objects Culling和Data Streaming</li>
<li>符合Texture存储规范</li>
</ul></li>
<li>劣势
<ul>
<li>Mesh细分没有三角形细分灵活</li>
<li>叶子节点的网格层级锁定</li>
</ul></li>
<li>符合直觉，应用主流
<img src="/images/games104/L06_QuadTreeTerrain.png" alt="L06_QuadTreeTerrain" style="zoom:25%;" /></li>
<li><strong>T-Junctions</strong>
<ul>
<li>与三角形分割类似的问题，细分层级边界处产生</li>
<li>解决方法：<strong>Stitching 吸附</strong>
<img src="/images/games104/L06_Stitching.png" alt="L06_Stitching" style="zoom: 25%;" />
吸附生成的三角形：<strong>退化三角形</strong></li>
</ul></li>
<li><strong>Triangulated Irregular Network (TIN)</strong>
<img src="/images/games104/L06_TIN.jpg" alt="L06_TIN" style="zoom:33%;" />
<ul>
<li>几何细节不丰富处，用较粗的三角形</li>
<li>优势
<ul>
<li>易于Runtime渲染</li>
<li>更少的三角形</li>
</ul></li>
<li>劣势
<ul>
<li>需要预计算</li>
<li>不够通用</li>
</ul></li>
<li>特殊的游戏会用</li>
</ul></li>
</ul>
<h5 id="gpu-based-tessellation">GPU-Based Tessellation</h5>
<ul>
<li><p>DX11开始：
<img src="/images/games104/L06_GPUBasedTessllation.jpg" alt="L06_GPUBasedTessllation" style="zoom: 33%;" /></p>
<ul>
<li>Hull-Shader Stage：生成Subdivision用的Patch，告诉Control
point数据和Tessellation数量</li>
<li>Tessellator Stage：做Tessellation</li>
<li>Domain-Shader Stage：根据高度图移动顶点</li>
<li>Geometry Shader Stage：算Vertex
<img src="/images/games104/L06_DX11TerrainShaders.png" alt="L06_DX11TerrainShaders" style="zoom: 50%;" /></li>
</ul></li>
<li><p><strong>Mesh Shader Pipeline</strong> (DX12)
<img src="/images/games104/L06_MeshShaderPipeline.jpg" alt="L06_MeshShaderPipeline" style="zoom: 80%;" /></p></li>
<li><p>GPU-Based Tessellation -&gt; Runtime Tessellation -&gt;
<strong>Real-Time Deformable Terrain</strong>
假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation</p></li>
</ul>
<h4 id="non-heightfield-terrain-悬崖山洞等">Non-Heightfield Terrain
悬崖、山洞等</h4>
<ul>
<li>传统做法：在悬崖、山洞处悬空插入物体</li>
<li>一种Trick：山洞处的顶点做标记，GPU处理退化消除；再向山洞中加入物体</li>
<li>目前用的较少一种的方法——体素化
<ul>
<li>体素化表达世界，在每个体素上存当前空间物质密度</li>
<li><strong>Marching Cube</strong>：14种方法把cube切分成三角面
<img src="/images/games104/L06_MarchingCube.jpg" alt="L06_MarchingCube" style="zoom:50%;" /></li>
<li>问题：Marching Cube怎么解决近密远疏并保证密封，LUT方法解决</li>
<li>全动态地形——支持打洞</li>
</ul></li>
</ul>
<h4 id="paint-terrain-materials">Paint Terrain Materials</h4>
<h5 id="混合贴图">混合贴图</h5>
<ul>
<li><p>问题：边缘过渡羽化
<img src="/images/games104/L06_SimpleTextureSplatting.jpg" alt="L06_SimpleTextureSplatting" style="zoom: 67%;" /></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> a1 <span class="op">+</span> texture2<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> a2<span class="op">;</span></span></code></pre></div></li>
<li><p>解决：Height作为Alpha
<img src="/images/games104/L06_HeightMapsAlphaBlending.png" alt="L06_HeightMapsAlphaBlending" style="zoom: 33%;" /></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> height1 <span class="op">&gt;</span> height2 <span class="op">?</span> texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">:</span> texture2<span class="op">.</span><span class="fu">rgb</span></span></code></pre></div></li>
<li><p>问题：0-1切换信息高频，在远观时过于Sharp 解决：Biased 扰动
<img src="/images/games104/L06_HeightMapsAlphaBlendingBiased.png" alt="L06_HeightMapsAlphaBlendingBiased" style="zoom: 33%;" /></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> depth <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> <span class="co">//Height Bias</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ma <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture1<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height1<span class="op">,</span> texture2<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height2<span class="op">)</span> <span class="op">-</span> depth<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b1 <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture1<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height1 <span class="op">-</span> ma<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b2 <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture2<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height2 <span class="op">-</span> ma<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> <span class="op">(</span>texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> b1 <span class="op">+</span> texture2<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> b2<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>b1 <span class="op">+</span> b2<span class="op">);</span></span></code></pre></div></li>
<li><p>实战中：更多Texture -&gt; <strong>Texture Array</strong>
<code>TextureArray[Index]</code></p></li>
<li><p><strong>Parallax and Displacement Mapping</strong>
由于表面高度，看到位置B而非A
<img src="/images/games104/L06_ParallaxMapping.jpg" alt="L06_ParallaxMapping" style="zoom: 33%;" />
更彻底的方法：Displacement Mapping，直接改变Mesh
<img src="/images/games104/L06_ParallaxAndDisplacementMapping.png" alt="L06_ParallaxAndDisplacementMapping" style="zoom: 33%;" /></p></li>
<li><p>大量材质图读写的性能开销 -&gt; <strong>Virture
Texture</strong></p>
<ul>
<li>核心思想：把用到的部分装载在内存中，不用的放在硬盘上</li>
<li>把地形分成块（2的幂次切割），只加载能看到的地形</li>
<li><img src="/images/games104/L06_VirtualTexture.jpg" alt="L06_VirtualTexture" style="zoom: 50%;" /></li>
</ul></li>
</ul>
<h5 id="virtual-texture-implementation-directstorage-dma">Virtual
Texture Implementation, DirectStorage &amp; DMA</h5>
<ul>
<li>GPU cache管理
<img src="/images/games104/L06_GPUCacheManagement.jpg" alt="L06_GPUCacheManagement" style="zoom: 25%;" /></li>
<li>DirectStorage
<img src="/images/games104/L06_DirectStorage.jpg" alt="L06_DirectStorage" style="zoom: 67%;" /></li>
<li>DMA
<img src="/images/games104/L06_DMA.jpg" alt="L06_DMA" style="zoom: 50%;" /></li>
</ul>
<h5 id="浮点数精度溢出">浮点数精度溢出</h5>
<ul>
<li><p>浮点数数值小时精度高、数值大时精度低</p></li>
<li><p>摄影机离物体过远时，出现严重抖动与闪烁</p></li>
<li><p><strong>Camera-Relative Rendering 相机相对性渲染</strong>
在MVP变换之前，将相机位置设为世界坐标系原点；重新计算MVP矩阵</p></li>
<li><p>其他方法 eg. UE Sublevels，每个Sublevel重置坐标系</p></li>
</ul>
<h4 id="tree-rendering">Tree Rendering</h4>
<h4 id="decorator-rendering-装饰物草灌木等">Decorator Rendering
装饰物，草、灌木等</h4>
<h4 id="road-and-decals-rendering">Road and Decals Rendering</h4>
<ul>
<li>Road
<ul>
<li>Spline</li>
<li>Spline to Mesh，放置在地形上</li>
<li>路面侵蚀地形，处理高度场</li>
</ul></li>
<li>Decal 贴片，贴花</li>
<li>全部直接Bake到Virtual Texture上</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture5-Lighting, Materials and Shaders</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/</link>
      <pubDate>Sat, 17 Apr 2021 12:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/</guid>
      <description>Lecture05 Lighting, Materials and Shaders The Rendering Equation \[ {\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int _{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n} )\operatorname {d} \omega _{\text{i}}} \]
多重挑战：
如何得到入射光 Visibility to Lights, Shadow Light Source Complexity, 尤其面光源 如何快速地积分 如何计算次级光源，全局光照，无限递归 从简单开始 Ambient + Simple Light == Result
环境光贴图反射
相当于Rendering Equation特例化
Blinn-Phong \[ \begin{aligned}L&amp;amp;=L_{\text{ambient}}+L_{\text{diffuse}}+L_{\text{specular}}\\ &amp;amp;=k_{\text{ambient}}I_{\text{ambient}}+k_{\text{diffuse}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)+k_{\text{specular}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)^p \end{aligned} \] 问题：</description>
      <content:encoded><![CDATA[<h3 id="lecture05-lighting-materials-and-shaders">Lecture05 Lighting,
Materials and Shaders</h3>
<h4 id="the-rendering-equation">The Rendering Equation</h4>
<p><span class="math display">\[
{\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda
,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int
_{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega
_{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega
_{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n}
)\operatorname {d} \omega _{\text{i}}}
\]</span></p>
<p><img src="/images/games104/L05_Rendering.jpg" alt="L05_Rendering" style="zoom:50%;" /></p>
<p>多重挑战：</p>
<ul>
<li>如何得到入射光
<ul>
<li>Visibility to Lights, Shadow</li>
<li>Light Source Complexity, 尤其面光源</li>
</ul></li>
<li>如何快速地积分</li>
<li>如何计算次级光源，全局光照，无限递归</li>
</ul>
<h4 id="从简单开始">从简单开始</h4>
<ul>
<li><p>Ambient + Simple Light == Result</p></li>
<li><p>环境光贴图反射</p></li>
<li><p>相当于Rendering Equation特例化</p></li>
<li><p><strong>Blinn-Phong</strong> <span class="math display">\[
\begin{aligned}L&amp;=L_{\text{ambient}}+L_{\text{diffuse}}+L_{\text{specular}}\\
&amp;=k_{\text{ambient}}I_{\text{ambient}}+k_{\text{diffuse}}(I/r^2)\max(0,\mathbf
n\cdot\mathbf l)+k_{\text{specular}}(I/r^2)\max(0,\mathbf n\cdot\mathbf
l)^p
\end{aligned}
\]</span> 问题：</p>
<ul>
<li>能量不守恒/保守（离线渲染时能量会超出）</li>
<li>质感太塑料</li>
</ul></li>
<li><p><strong>Shadow Map</strong> 从灯光位置渲染深度Buffer</p>
<p>问题：</p>
<ul>
<li>采样问题 -&gt; 自遮挡</li>
<li>加入阈值 -&gt; 阴影与实体有距离</li>
</ul></li>
</ul>
<h4 id="预计算gi">预计算GI</h4>
<ul>
<li><p><span class="citation" data-cites="GAME202">@GAME202</span>
PRT</p></li>
<li><p>利用SH，用24bit就可以存储一个点的光场</p></li>
</ul>
<h5 id="sh-lightmap">SH Lightmap</h5>
<ul>
<li>UV Atlas
<img src="/images/games104/L05_UVAtlas.jpg" alt="L05_UVAtlas" style="zoom:50%;" /></li>
<li>烘焙光照</li>
<li>优点：高效、细节
缺点：预计算量大；只能处理静态（动态物体可以有Hack方法，但有问题）；GPU存储量大</li>
</ul>
<h5 id="light-probe">Light Probe</h5>
<ul>
<li>在空间中撒采样点（Probe）</li>
<li>每个Probe计算其光照</li>
<li>自动均匀撒采样点</li>
<li>反射Probe 一种特殊的Probe
<ul>
<li>采样精度高</li>
<li>分布密度低</li>
<li>提供非常好的反射效果</li>
</ul></li>
<li>优点：高效，静态动态均可用，可以处理diffuse和specular
缺点：效果没有Lightmap好（采样稀疏）</li>
</ul>
<h4 id="physical-based-material">Physical-Based Material</h4>
<p><span class="citation" data-cites="GAME202">@GAME202</span>
Physically-Based Material</p>
<ul>
<li><p>Microfacet BRDF</p></li>
<li><p>Disney Principled BRDF</p></li>
<li><p>主流应用：Specular Glossiness模型</p>
<ul>
<li>Diffuse - RGB - sRGB</li>
<li>Specular - RGB - sRGB</li>
<li>Glossiness - Grayscale - Linear</li>
<li>问题：过于灵活，Specular项易导致Fresnel项错乱</li>
</ul>
<p><img src="/images/games104/L05_SG.png" alt="L05_SG" style="zoom: 33%;" /></p></li>
<li><p>主流应用：Metallic Roughness模型</p>
<ul>
<li>Base Color - RGB - sRGB</li>
<li>Roughness - Grayscale - Linear</li>
<li>Metallic - Grayscale - Linear</li>
<li>在SG基础上封装，Metallic限制Specular的应用</li>
<li>非金属和金属过渡时可能有白边</li>
</ul>
<p><img src="/images/games104/L05_MR.png" alt="L05_MR" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="image-based-lighting">Image-Based Lighting</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
Environment Lighting</p>
<ul>
<li>Diffuse Irradiance Map</li>
<li>Specular : Split Sum</li>
</ul>
<h4 id="classic-shadow-solution">Classic Shadow Solution</h4>
<h5 id="cascaded-shadow-map">Cascaded Shadow Map</h5>
<p><img src="/images/games104/L05_CSM.png" alt="L05_CSM" style="zoom: 25%;" /></p>
<p>挑战：不同层级之间的Blend</p>
<p>缺点：计算开销大（4ms）</p>
<h5 id="软阴影">软阴影</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> Soft
Shadow</p>
<ul>
<li>PCF -&gt; PCSS</li>
<li>Variance Soft Shadow Map</li>
</ul>
<h4 id="上一世代的3a游戏渲染">上一世代的3A游戏渲染</h4>
<ul>
<li>Lightmap + Lightprobe</li>
<li>PBR + IBL</li>
<li>CSM + VSSM</li>
</ul>
<h4 id="现代3a游戏渲染">现代3A游戏渲染</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> GI
&amp; RTRT</p>
<ul>
<li>RTRT</li>
<li>Real-Time GI
<ul>
<li>SSGI</li>
<li>SDF GI</li>
<li>VXGI</li>
<li>RSM</li>
<li>RTXGI</li>
<li>…</li>
</ul></li>
<li>更复杂的材质模型
<ul>
<li>BSDF 头发</li>
<li>BSSRDF</li>
</ul></li>
<li>Virtual Shadow Maps 把Shadow Maps放到一个巨大的Shadow
Map上（类似Virtual Texture）</li>
</ul>
<h4 id="shader管理">Shader管理</h4>
<ul>
<li>Uber Shader 宏定义做分支，GPU不适合分支，再将Uber
Shader编译成大量Shader。需要修改时，只需要修改Uber
Shader，一次编译所有结果。</li>
<li>跨平台的Shader编译
<ul>
<li>SPIR-V</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture4-Rendering in Game Engine</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/</link>
      <pubDate>Sat, 17 Apr 2021 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/</guid>
      <description>Lecture04 Rendering in Game Engine 挑战
场景极其复杂 实时，帧率稳定 大纲
基础 硬件架构 渲染数据结构 可见性 材质、Shader、光照 PBR Shader Permutation 光照 点/方向光照 IBL / Simple GI 特殊的渲染 地形 天空 / 雾 后处理 Pipeline 前向渲染 Forward、延迟渲染 Deferred、Forward Plus Ring buffer and V-Sync Tiled-based Rendering @GAMES101
Vertex Data -&amp;gt; Triangle Data -&amp;gt; Material Parameters -&amp;gt; Textures
投影 -&amp;gt; 光栅化
eg. Computation - Texture Sampling
Step 1 : 使用相邻两层MIPMAP Step 2 : 在两层MIPMAP之间双线性插值 Step 3 : 结果像素之间的线性插值 GPU SIMD and SIMT SIMD : Single Instruction Multiple Data eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture04-rendering-in-game-engine">Lecture04 Rendering in Game
Engine</h3>
<p><strong>挑战</strong></p>
<ul>
<li>场景极其复杂</li>
<li>实时，帧率稳定</li>
</ul>
<p><strong>大纲</strong></p>
<ul>
<li>基础
<ul>
<li>硬件架构</li>
<li>渲染数据结构</li>
<li>可见性</li>
</ul></li>
<li>材质、Shader、光照
<ul>
<li>PBR</li>
<li>Shader Permutation</li>
<li>光照</li>
<li>点/方向光照</li>
<li>IBL / Simple GI</li>
</ul></li>
<li>特殊的渲染
<ul>
<li>地形</li>
<li>天空 / 雾</li>
<li>后处理</li>
</ul></li>
<li>Pipeline
<ul>
<li>前向渲染 Forward、延迟渲染 Deferred、Forward Plus</li>
<li>Ring buffer and V-Sync</li>
<li>Tiled-based Rendering</li>
</ul></li>
</ul>
<blockquote>
<p><span class="citation" data-cites="GAMES101">@GAMES101</span></p>
<p>Vertex Data -&gt; Triangle Data -&gt; Material Parameters -&gt;
Textures</p>
<p>投影 -&gt; 光栅化</p>
</blockquote>
<p>eg. Computation - Texture Sampling</p>
<ul>
<li>Step 1 : 使用相邻两层MIPMAP</li>
<li>Step 2 : 在两层MIPMAP之间双线性插值</li>
<li>Step 3 : 结果像素之间的线性插值</li>
</ul>
<h4 id="gpu">GPU</h4>
<h5 id="simd-and-simt">SIMD and SIMT</h5>
<ul>
<li><p>SIMD : Single Instruction Multiple Data
eg.四维向量同时加减</p></li>
<li><p>SIMT : Single Instruction Multiple Threads
同时处理大量SIMD任务</p></li>
</ul>
<h5 id="计算单元">计算单元</h5>
<ul>
<li>GPC Graphics Processing Cluster</li>
<li>SM Streaming Multiprocessor</li>
<li>Texture Units</li>
<li>CUDA Core</li>
<li>Warp (a collection of threads)</li>
</ul>
<p>Application Performance is limited by:</p>
<ul>
<li>Memory Bounds</li>
<li>ALU Bounds</li>
<li>TMU(Texture Mapping Unit) Bound</li>
<li>BW(Bandwidth) Bound</li>
</ul>
<h4 id="renderable---可渲染的内容component">Renderable -
可渲染的内容（Component）</h4>
<ul>
<li>Mesh
<ul>
<li>Mesh Primitives</li>
<li>Vertex and Index Buffer &gt;
每顶点存储法向：避免有两个顶点重合时法向错乱</li>
</ul></li>
<li>Material
<ul>
<li>Textures</li>
<li>Shaders</li>
</ul></li>
</ul>
<p><img src="/images/games104/L04_Renderable1.png" alt="L04_Renderable1" style="zoom:33%;" /></p>
<p>一个Mesh有多种材质 —— SubMesh</p>
<p><img src="/images/games104/L04_Renderable2.png" alt="L04_Renderable2" style="zoom: 25%;" /></p>
<p>节约空间：Mesh / Shader / Texture 各存储一个Pool，使用时用索引 ——
<strong>Instance</strong></p>
<p><img src="/images/games104/L04_Renderable3.png" alt="L04_Renderable3" style="zoom: 25%;" /></p>
<p>对场景按场景排序渲染 —— 对GPU友好，可以加速</p>
<p>GPU Batch Rendering 渲染一次，再做Offset</p>
<h5 id="visibility-culling">Visibility Culling</h5>
<ul>
<li>View Frustum之外的不渲染</li>
<li>对空间做划分（前文介绍，四叉树 / <strong>BVH</strong>）
BVH构建块，应用多</li>
<li>PVS, Potential Visibility Set 根据房间门是否可见裁剪
<img src="/images/games104/L04_PVS.png" alt="L04_PVS" style="zoom: 25%;" />
现在已应用不广，但思想可以用于资源加载等场景</li>
<li>GPU Culling 利用G-Buffer，延迟渲染</li>
</ul>
<h5 id="纹理压缩">纹理压缩</h5>
<ul>
<li>不能用JPG/PNG等复杂压缩</li>
<li>Block Compression：将图片切分为一个个小块（例如4*4）压缩 eg.
在小块中保留最大值最小值，其他值使用这两值的线性插值</li>
</ul>
<h5 id="authoring-tools-of-modeling">Authoring Tools of Modeling</h5>
<ul>
<li><strong>Polygon</strong> : MAX / MAYA / Blender</li>
<li><strong>Sculpting</strong> : Zbrush</li>
<li><strong>Scanning</strong></li>
<li><strong>Procedural</strong> : Houdini</li>
</ul>
<h5 id="cluster-based-mesh-pipeline">Cluster-Based Mesh Pipeline</h5>
<ul>
<li>核心思想：对于非常精细的模型，将其分成无数一组面片组成的Cluster</li>
<li>提供Mesh Shader：GPU处理同样的Cluster，实现更精细的细节</li>
<li>可以基于Cluster做裁剪</li>
<li>Nanite in UE5</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture2-3-游戏引擎架构</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/</link>
      <pubDate>Sat, 17 Apr 2021 08:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/</guid>
      <description>Lecture02 游戏引擎分层结构 工具层 Tool Layer 编辑器
功能层 Function Layer 渲染/模拟/玩法/交互/…
资源层 Resource Layer 数据和文件
核心层 Core Layer 内存管理/资源分配/数学模块
平台层 Platform Layer 硬件设备的调用
PS：中间件/第三方库
情景：制作一个动画角色
Resource 怎么获取数据
Offline Importing resource -&amp;gt; assets 将resource转换为asset的文件格式 asset读取更快 建构所有资产的关联关系（reference） GUID 实时/运行时（Runtime）资产管理器 基于路径加载/卸载asset 通过Handle系统管理asset的生命周期和参考 Function 怎么使世界动起来
tick() tickLogic() tickRender() 有大量系统组成 必定属于引擎功能层的：渲染/模拟等 引擎功能层/游戏Gameplay有时有一定冲突 多线程 固定线程：不同线程作不同功能 主流用法，Job join：将模拟/动画等适合多线程的任务平均分配 原子化/任务系统：转换为一个个Job分配给所有线程 Core
数学库
线性代数
为什么要单独写数学库 - 效率
eg. 卡马克快速平方根（牛顿迭代）
SIMD 一条指令完成四个数操作（非常适合齐次坐标运算）
数据结构
vector / map / tree / … 为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作 内存管理 - 追求最高效率</description>
      <content:encoded><![CDATA[<h3 id="lecture02-游戏引擎分层结构">Lecture02 游戏引擎分层结构</h3>
<ul>
<li><p><strong>工具层 Tool Layer</strong> 编辑器</p></li>
<li><p><strong>功能层 Function Layer</strong>
渲染/模拟/玩法/交互/…</p></li>
<li><p><strong>资源层 Resource Layer</strong> 数据和文件</p></li>
<li><p><strong>核心层 Core Layer</strong>
内存管理/资源分配/数学模块</p></li>
<li><p><strong>平台层 Platform Layer</strong> 硬件设备的调用</p></li>
<li><p>PS：<strong>中间件/第三方库</strong></p></li>
</ul>
<p>情景：制作一个动画角色</p>
<ul>
<li><p>Resource 怎么获取数据</p>
<ul>
<li>Offline Importing resource -&gt; assets
<ul>
<li>将resource转换为asset的文件格式</li>
<li>asset读取更快</li>
<li>建构所有资产的关联关系（reference）</li>
<li>GUID</li>
</ul></li>
<li>实时/运行时（Runtime）资产管理器
<ul>
<li>基于路径加载/卸载asset</li>
<li>通过Handle系统管理asset的生命周期和参考</li>
</ul></li>
</ul></li>
<li><p>Function 怎么使世界动起来</p>
<ul>
<li>tick()
<ul>
<li>tickLogic()</li>
<li>tickRender()</li>
</ul></li>
<li>有大量系统组成
<ul>
<li>必定属于引擎功能层的：渲染/模拟等</li>
<li>引擎功能层/游戏Gameplay有时有一定冲突</li>
</ul></li>
<li>多线程
<ul>
<li>固定线程：不同线程作不同功能</li>
<li>主流用法，Job join：将模拟/动画等适合多线程的任务平均分配</li>
<li>原子化/任务系统：转换为一个个Job分配给所有线程</li>
</ul></li>
</ul></li>
<li><p>Core</p>
<ul>
<li><p>数学库</p>
<ul>
<li><p>线性代数</p></li>
<li><p>为什么要单独写数学库 - 效率</p>
<ul>
<li><p>eg. 卡马克快速平方根（牛顿迭代）</p></li>
<li><p>SIMD 一条指令完成四个数操作（非常适合齐次坐标运算）</p></li>
</ul></li>
</ul></li>
<li><p>数据结构</p>
<ul>
<li>vector / map / tree / …</li>
<li>为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作</li>
</ul></li>
<li><p>内存管理 - 追求最高效率</p>
<ul>
<li>性能的主要瓶颈
<ul>
<li>内存池 / 分配器</li>
<li>减少cache浪费</li>
<li>内存对齐</li>
</ul></li>
<li>PMR 多种内存资源 cache level 1 / 2 / 3 / RAM / Storage</li>
<li>优化核心思路
<ul>
<li>把数据放一起</li>
<li>按顺序读取数据</li>
<li>按块分配/释放内存</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Platform</p>
<ul>
<li>文件系统（路径）</li>
<li>图形API
<ul>
<li>OpenGL / Vulkan / DirectX / Metal</li>
<li>RHI (Render Haraware Interface) 实现一套“API”，封装各种底层API</li>
</ul></li>
<li>硬件架构
<ul>
<li>PC / PlayStation / 手机 / …</li>
<li>多核逻辑（大小核）</li>
</ul></li>
</ul></li>
<li><p>Tool 允许他人创作游戏</p>
<ul>
<li>开发相对灵活，根据用户需求，工具层的代码量和工作量可能比其他四层还大</li>
<li>DCC, Asset Conditioning Pipeline
引擎工具层的编辑器和DCC的编辑器要数据通畅</li>
</ul></li>
</ul>
<p>为什么游戏引擎要分层</p>
<ul>
<li>解耦并减少复杂度
<ul>
<li>上下层相互独立</li>
<li>上层不需要知道底层怎样实现</li>
</ul></li>
<li>迎合不断变化的需求
<ul>
<li>上层变化大，底层较稳定</li>
</ul></li>
</ul>
<h3 id="lecture03-如何构建游戏世界">Lecture03 如何构建游戏世界</h3>
<h4 id="game-object-go-游戏对象">Game Object (GO) 游戏对象</h4>
<ul>
<li>动态游戏对象 eg.坦克、飞机…</li>
<li>静态游戏对象 eg.建筑、陈设…</li>
<li>环境 eg.场景、天空、植被（随风运动，也可以是动态游戏对象）…</li>
<li>其他对象 eg.空气墙、规则区…</li>
</ul>
<p>以一个无人机为例</p>
<ul>
<li>Property 属性
<ul>
<li>外形</li>
<li>位置</li>
<li>血量</li>
<li>电池量</li>
<li>…</li>
</ul></li>
<li>Behaviors 行为
<ul>
<li>运动</li>
<li>侦察</li>
<li>…</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Drone <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Properties */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    vec3 position<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> health<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fuel<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Behavior */</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> move<span class="op">();</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> scout<span class="op">();</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>拓展一个武装无人机：继承</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArmedDrone <span class="op">:</span> <span class="kw">public</span> Drone <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> ammo<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fire<span class="op">();</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>游戏复杂后，没有那么清晰的从属关系——<strong>组件化</strong></p>
<p><img src="/images/games104/L03_Component.png" alt="L03_Component" style="zoom:25%;" /></p>
<h4 id="如何让世界动起来">如何让世界动起来</h4>
<p>Tick()</p>
<ul>
<li>每个物体、每个组件Tick()</li>
<li>工程中，以系统为单位Tick()：Gameplay、模拟、渲染…</li>
</ul>
<p>GO之间的交互 eg.坦克击中人</p>
<ul>
<li>Hardcode：坦克发射，生成新的子弹GO，逐个碰撞对象判断、处理。但工程复杂后非常难用。</li>
<li><strong>Events事件机制</strong>：用Event标记伤害，Tick()时读取Event作出响应执行回调函数
——解耦合，可扩展的消息系统，每个component对接消息进行处理</li>
</ul>
<p>如何管理GO</p>
<ul>
<li>在场景中标记GO
<ul>
<li>UID</li>
<li>空间位置</li>
</ul></li>
<li>场景管理方法
<ul>
<li>不分割 效率低，适合小游戏</li>
<li>Grid分割 适合不是特别大的游戏</li>
<li>GO分布不均匀时 -&gt; <strong>层级结构</strong>
<ul>
<li><strong>BVH</strong></li>
<li><strong>BSP Binary Space Partitioning</strong></li>
<li><strong>四叉/八叉树</strong></li>
<li><strong>Scene Graph</strong></li>
</ul></li>
</ul></li>
</ul>
<p>还有很多问题…</p>
<ul>
<li><p>GO的绑定 eg.人在车上时，人和车应共同移动</p></li>
<li><p>Event系统GO互相发消息的问题：多个消息冲突，引入中心发信机构，“邮局”</p></li>
<li><p>GO之间的循环依赖</p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-16-GAMES202高质量实时渲染-Lecture5-6-Environment Light</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-16-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture5-6-environmentlight/</link>
      <pubDate>Fri, 16 Apr 2021 16:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-16-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture5-6-environmentlight/</guid>
      <description>Lecture 5-6 Environment Lighting Recap
环境光贴图 球面贴图 Spherical Map / 立方体贴图 Cube Map Shading from Environment Lighting / Image-Based Lighting (IBL) 解渲染方程（不考虑阴影） \[ L_o(\mathrm p,\omega_o)=\int_{\Omega^+}L_i(\mathrm p,\omega_i)f_r(\mathrm p,\omega_i,\omega_o)\cos\theta_i\xcancel{V(\mathrm p,\omega_i)}\,\mathrm d\omega_i \]
蒙特卡洛积分——数值解、大量采样，非常慢 PS: 一旦涉及采样，就很难实时，近年开始有一些进展 观察：
glossy BRDF : BRDF覆盖很小 diffuse BRDF : BRDF覆盖大，但是平滑 因此考虑近似方法 \[ \int_\Omega f(x)g(x)\,\mathrm dx\approx\dfrac{\int_{\Omega_G}f(x)\,\mathrm dx}{\int_{\Omega_G}\,\mathrm d x}\cdot\int_\Omega g(x)\,\mathrm dx \] （该式在 \(g(x)\) 范围小/结果平滑时较为准确）
则有 \[ L_o(\mathrm p,\omega_o)\approx\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm d\omega_i}\int_{\Omega^+}f_r(\mathrm p,\omega_i,\omega_o)\cos\theta_i\,\mathrm d\omega_i \]
\(\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm d\omega_i}\) 表示对环境光贴图做模糊化处理，即滤波</description>
      <content:encoded><![CDATA[<h3 id="lecture-5-6-environment-lighting">Lecture 5-6 Environment
Lighting</h3>
<blockquote>
<p>Recap</p>
<ul>
<li>环境光贴图</li>
<li>球面贴图 Spherical Map / 立方体贴图 Cube Map</li>
</ul>
</blockquote>
<h4
id="shading-from-environment-lighting-image-based-lighting-ibl">Shading
from Environment Lighting / Image-Based Lighting (IBL)</h4>
<ul>
<li><p>解渲染方程（不考虑阴影） <span class="math display">\[
L_o(\mathrm p,\omega_o)=\int_{\Omega^+}L_i(\mathrm
p,\omega_i)f_r(\mathrm
p,\omega_i,\omega_o)\cos\theta_i\xcancel{V(\mathrm p,\omega_i)}\,\mathrm
d\omega_i
\]</span></p>
<ul>
<li>蒙特卡洛积分——数值解、大量采样，非常慢 PS:
一旦涉及采样，就很难实时，近年开始有一些进展</li>
</ul></li>
<li><p>观察：</p>
<ul>
<li>glossy BRDF : BRDF覆盖很小</li>
<li>diffuse BRDF : BRDF覆盖大，但是平滑</li>
</ul>
<p><img src="/images/games202/IBL1.jpg" alt="IBL1" style="zoom:30%;" /></p></li>
<li><p>因此考虑近似方法 <span class="math display">\[
\int_\Omega f(x)g(x)\,\mathrm
dx\approx\dfrac{\int_{\Omega_G}f(x)\,\mathrm
dx}{\int_{\Omega_G}\,\mathrm d x}\cdot\int_\Omega g(x)\,\mathrm dx
\]</span> （该式在 <span class="math inline">\(g(x)\)</span>
范围小/结果平滑时较为准确）</p>
<p>则有 <span class="math display">\[
L_o(\mathrm p,\omega_o)\approx\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm
p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm
d\omega_i}\int_{\Omega^+}f_r(\mathrm
p,\omega_i,\omega_o)\cos\theta_i\,\mathrm d\omega_i
\]</span></p></li>
<li><p><span class="math inline">\(\dfrac{\int_{\Omega_{f_r}}L_i(\mathrm
p,\omega_i)\,\mathrm d\omega_i}{\int_{\Omega_{f_r}}\,\mathrm
d\omega_i}\)</span> 表示对环境光贴图做模糊化处理，即滤波</p>
<ul>
<li><strong>Prefiltering</strong>：在渲染之前就做好滤波</li>
<li>多种大小滤波核的结果，类似MIPMAP，计算时再做查询插值
【积分某区域的结果 = 先做区域的求和再取值】</li>
</ul>
<p><img src="/images/games202/IBL2.jpg" alt="IBL2" style="zoom:30%;" /></p></li>
<li><p><span class="math inline">\(\int_{\Omega^+}f_r(\mathrm
p,\omega_i,\omega_o)\cos\theta_i\,\mathrm d\omega_i\)</span>
部分则做预计算</p>
<ul>
<li><p>eg. Microfacet BRDF : <strong>Fresnel</strong> +
<strong>NDF</strong> + Shadowing-Masking
需要一个巨大的表（至少五维参数）</p></li>
<li><p>Fresnel : Schlick’s approximation <span class="math display">\[
R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\
R_0=\left(\dfrac{n_1-n_2}{n_1+n_2}\right)^2
\]</span></p></li>
<li><p>NDF : eg. Beckmann distribution <span class="math display">\[
D(h)=\dfrac{e^{-\frac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}\quad\text{$\alpha$:Roughness}
\]</span></p></li>
<li><p>将半程向量与入射出射光夹角、法线与入射出射光夹角、入射出射光夹角的一半都近似认为是
<span class="math inline">\(\theta\)</span>
，则减少至三维参数表</p></li>
<li><p>将Fresnel项写在原式中作近似： <span class="math display">\[
\begin{aligned}&amp;\int_{\Omega^+}f_r(\mathrm
p,\omega_i,\omega_o)\cos\theta_i\,\mathrm d\omega_i\\
\approx&amp;
R_0\int_{\Omega^+}\dfrac{f_r}{F}(1-(1-\cos\theta_i)^5)\cos\theta_i\,\mathrm
d\omega_i\\
+&amp;\int_{\Omega^+}\dfrac{f_r}{F}(1-\cos\theta_i)^5\cos\theta_i\,\mathrm
d\omega_i\end{aligned}
\]</span> 将基础反射率 <span class="math inline">\(R_0\)</span> （Base
Color）解放出来 -&gt; 二维参数表</p></li>
<li><p>二维参数表：<span class="math inline">\(\text{Roughness}(\alpha)
- \cos\theta\)</span>
<img src="/images/games202/IBL3.jpg" alt="IBL3" style="zoom:50%;" /></p></li>
</ul></li>
<li><p>这一方法称为 <strong>Split Sum</strong> （积分 -&gt;
求和）</p></li>
</ul>
<h4 id="precomputed-radiance-transfer-prt">Precomputed Radiance
Transfer, PRT</h4>
<p>实时渲染中很难做到环境光下的阴影</p>
<ul>
<li>把环境光看作大量光源：需要大量的shadow map</li>
<li>把问题看成一个采样问题：有不同的遮挡情况、不同的Visibility，Visibility项也不能用近似方法分离出来</li>
<li>一个解决思路：从最亮的光源下生成阴影（例如太阳）</li>
<li>相关工作
<ul>
<li>Imperfect shadow maps</li>
<li>Light cuts</li>
<li>RTRT (might be the Ultimate Solution)</li>
<li><strong>PRT</strong></li>
</ul></li>
</ul>
<h5 id="spherical-harmonics-sh-球面谐波函数">Spherical Harmonics, SH
球面谐波函数</h5>
<blockquote>
<ul>
<li>傅里叶级数：把一个函数拆成无数sin/cos函数（基函数）之和</li>
<li>Filtering 滤波</li>
<li>形如 <span class="math inline">\(\int_{\Omega}f(x)g(x)\,\mathrm
dx\)</span> 可以视作滤波操作
<ul>
<li>低频信息 == 平滑的函数</li>
<li>积分后频率是两个相乘的函数中较低的那个</li>
</ul></li>
<li><strong>基函数</strong>：<span
class="math inline">\(f(x)=\sum_ic_i\cdot B_i(x)\)</span> ，则 <span
class="math inline">\(B_i(x)\)</span> 称基函数</li>
</ul>
</blockquote>
<p><strong>SH</strong>：定义在球面上的一系列二维的基函数（理解为关于方向的函数，球面上的方向用
<span class="math inline">\(\theta\,\phi\)</span> 描述）</p>
<ul>
<li><p>很像一维的傅里叶级数
<img src="/images/games202/SH.png" alt="SH1" style="zoom:50%;" />
（颜色深度表示值，黄蓝表示正负？；l：阶数）</p></li>
<li><p>SH的基函数，用勒让德多项式表示（这里不必写出公式）</p></li>
<li><p>用基函数 <span class="math inline">\(B_i(\omega)\)</span>
的线性组合，即可表示二维函数</p></li>
<li><p>基函数 <span class="math inline">\(B_i(\omega)\)</span> 的系数用
<span class="math inline">\(f(\omega)\)</span> 表示，则有 <span
class="math display">\[
c_i=\int_\Omega f(\omega)B_i(\omega)\,\mathrm d\omega
\]</span> （求系数的过程数学上称为“投影”）</p></li>
<li><p>用前 <span class="math inline">\(n\)</span>
阶系数可恢复出近似的原函数， <span class="math inline">\(n\)</span>
越大，保留系数越多</p></li>
</ul>
<h5 id="对diffuse材质应用sh">对Diffuse材质应用SH</h5>
<ul>
<li><p><strong>Recall</strong> : Prefiltering of Envirnment Light
Prefiltering + single query == No filtering + Multiple queries</p></li>
<li><p>Diffuse BRDF
很像低通滤波器（光照与BRDF做逐点相乘再积分，即Product Integrate）</p>
<p>考虑用少量SH来描述Diffuse BRDF（例如前3阶）</p></li>
<li><p>高频函数与低频函数Product Integrate，频率由低频函数决定 -&gt;
既然Diffuse BRDF是低频的，那么光照也无需记录高频</p>
<p>考虑也用SH来描述来描述光照（例如前3阶）</p></li>
<li><p>非常简单的实现</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>surface float1 <span class="fu">irradmat</span><span class="op">(</span>matrix4 M<span class="op">,</span> float3 v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  float4 n <span class="op">=</span> <span class="op">{</span>v<span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">dot</span><span class="op">(</span>n<span class="op">,</span> M<span class="op">*</span>n<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
<h5
id="解决阴影不限制diffuse的方法prt">解决阴影、不限制Diffuse的方法：PRT</h5>
<p><span class="math display">\[
L_o(\mathrm p,\omega_o)=\int_{\Omega^+}L_i(\mathrm p,\omega_i)V(\mathrm
p,\omega_i)f_r(\mathrm p,\omega_i,\omega_o)\cos\theta_i\,\mathrm
d\omega_i
\]</span></p>
<ul>
<li><p>Light、Visibility、BRDF三项均描述成球面函数</p></li>
<li><p>eg. 用Cubemap存时，每个shading point的计算量过大</p></li>
<li><p>考虑用SH来预计算部分内容</p>
<ul>
<li>认为Light在场景中可变；Visibility、BRDF等无关项认为是Light
Transport，不可变</li>
<li>Light：用SH近似 <span class="math inline">\(L_i\approx\sum
l_iB_i\)</span></li>
<li>Light Transport：渲染之前做预计算</li>
</ul></li>
<li><p><strong>Diffuse情况</strong>
<img src="/images/games202/PRT1.png" alt="PRT1" style="zoom:50%;" /></p>
<ul>
<li><p>运行时则只需要算点乘</p></li>
<li><p>但是Visibility项固定意味着场景不能动</p></li>
<li><p>Light：光源本身旋转不可用（后面会说可以计算）</p></li>
<li><p>重新理解</p>
<ul>
<li>Light : <span
class="math inline">\(L(\omega_i)\approx\sum_pc_pB_p(\omega_i)\)</span>
Light Transport : <span
class="math inline">\(T(\omega_i)\approx\sum_qc_qB_q(\omega_i)\)</span></li>
<li>则渲染方程 <span class="math display">\[
L_o(\mathrm
p,\omega_o)=\sum_p\sum_qc_pc_q\int_{\Omega^+}B_p(\omega_i)B_q(\omega_i)\,\mathrm
d\omega_i
\]</span> 由于SH基函数正交，则仅当 <span
class="math inline">\(p=q\)</span>
时，右边积分结果有意义，否则为零。复杂度 <span
class="math inline">\(O(n^2)\)</span> 降低至 <span
class="math inline">\(O(n)\)</span> 。</li>
</ul></li>
</ul></li>
<li><p>SH的性质</p>
<ul>
<li>基函数相互正交</li>
<li>易于计算投影（函数与任一基函数做Product Integrate即可）</li>
<li>易于计算旋转
<ul>
<li>相当于旋转每一个SH基函数</li>
<li>SH基函数的旋转可以用同阶基函数的线性组合表示</li>
<li>打表格</li>
</ul></li>
<li>易于卷积</li>
<li>少量基函数代表低频</li>
</ul></li>
<li><p>把多次Bounce的过程也视作Light
Transport，预计算，可实现GI</p></li>
<li><p><strong>Glossy情况</strong></p>
<ul>
<li><p>Light Transport 包含Visibility和BRDF，对于给定的出射方向 <span
class="math inline">\(\mathrm o\)</span> ，BRDF都不一样 -&gt; <span
class="math inline">\(T_i(\mathrm o)\)</span></p></li>
<li><p><span class="math display">\[
T_i(\mathbf o)=\sum t_{ij}B_j(\mathbf o)\\
L_o\approx\sum l_iT_i(\mathbf o)\approx\sum\left(\sum l_i
t_{ij}\right)B_j(\mathbf o)
\]</span></p></li>
<li><p>对于不同的出射方向 <span class="math inline">\(\mathrm o\)</span>
，得到一个Transport matrix。</p></li>
</ul>
<p><img src="/images/games202/PRT2.png" alt="PRT2" style="zoom:50%;" /></p>
<ul>
<li>代价：存储的Transport
matrix，且一般用五阶SH，因此存储量大；且渲染需要计算向量与矩阵乘，相对复杂。</li>
</ul></li>
<li><p>Transport Paths</p>
<ul>
<li><span class="math inline">\(LE\)</span> : Light -&gt; Eye</li>
<li><span class="math inline">\(LGE\)</span> : Light -&gt; Glossy -&gt;
Eye</li>
<li><span class="math inline">\(L(D|G)^*E\)</span></li>
<li><span class="math inline">\(LS^*(D|G)^*E\)</span> <span
class="math inline">\(LSDE\)</span> Caustics “焦散”（翻译不好）</li>
<li>可以预计算任意复杂的Light Transport</li>
</ul></li>
<li><p>另一种理解 <span
class="math inline">\(T_i\approx\int_{\Omega}B_i(\mathbf i)V(\mathbf
i)\max(0,\mathbf n\cdot\mathbf i)\,\mathrm d\mathbf i\)</span> 中，将
<span class="math inline">\(B_i(\mathbf i)\)</span>
视作入射光，预计算过程就相当于用这些“奇怪”的光照渲染场景。</p>
<p><img src="/images/games202/PRT3.png" alt="PRT3" style="zoom:50%;" /></p></li>
<li><p>限制</p>
<ul>
<li>SH只适合描述低频信息（镜面反射）</li>
<li>固定场景</li>
<li>大量的预计算和存储</li>
</ul></li>
<li><p>进一步的工作</p>
<ul>
<li>新型基函数</li>
<li>两项点乘 -&gt; 三项相乘</li>
<li>动态场景</li>
<li>动态材质</li>
<li>透明材质、头发、…</li>
<li>预计算 -&gt; 不做预计算的解析解</li>
<li>…</li>
</ul></li>
<li><p>其他基函数</p>
<ul>
<li>小波 Wavelet
<ul>
<li>二维小波
<img src="/images/games202/Wavelet1.png" alt="Wavelet1" style="zoom: 20%;" /></li>
<li>投影
<ul>
<li>小波变换</li>
<li>大量系数为零 -&gt; 用于压缩</li>
</ul></li>
<li>全频率的表示</li>
<li>用Cubemap存储光照，6张图每张做小波变换</li>
<li>把低频存在图左上1/4，剩下3/4存高频，对低频的1/4图递归地做这样的操作
-&gt; 发现高频信息很少，非常适合压缩 <img
src="/images/games202/Wavelet2.jpg" alt="Wavelet2" /></li>
<li>问题：不支持快速旋转</li>
</ul></li>
<li>Zonal Harmonics</li>
<li>Spherical Gaussian</li>
<li>Piecewise Constant</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-14-GAMES202高质量实时渲染-Lecture14-Practical Industrial Solutions</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture14-industry/</link>
      <pubDate>Wed, 14 Apr 2021 12:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture14-industry/</guid>
      <description>Lecture 14 Practical Industrial Solutions Temporal Anti-Aliasing, TAA Recall: why aliasing
光栅化的采样数不够 终极解决方案：加样本（MSAA） TAA：应用Temporal信息，与RTRT的降噪思路一致
每四帧复用：
（如果不是4个固定位置而是是随机生成，引入了其他高频信息，效果并不好）
Notes on AA
MSAA vs SSAA SSAA：按几倍分辨率渲染场景，再下变换，效果好开销大 MSAA：对SSAA的效率改进 对一个像素内的一个Primitive，只采样一次（取中心或其他代表点） 空间上的Sample Reuse：样本分布上的Trick 基于图像的反走样方法 SMAA, Enhanced Subpixel Morphological AA FXAA -&amp;gt; MLAA(Morphological AA) -&amp;gt; SMAA G-Buffer一定不能反走样！（信息会出错） Temporal Super Resolution Super resolution == Super sampling
提升分辨率 eg. DLSS DLSS 1.0 全靠猜，每个游戏/场景单独训练一个网络 DLSS 2.0 利用Temporal信息 应用类似TAA的思路 重用Samples 问题：Temporal failure时不能clamp——因为每一个像素需要一个明确的值 DL不输出图像，而是输出关于上一帧的Temporal信息如何利用 Deferred Shading 延迟渲染 提高Shading效率 传统管线 Triangles -&amp;gt; Fragments -&amp;gt; Depth Test -&amp;gt; Shading -&amp;gt; Pixel 每一个Fragment都需要做Shading 复杂度：\(O(\text{\#Fragment}*\text{\#Light})\) 关键想法：有很多Fragment不会被看到 -&amp;gt; 只对被看到的Fragment做Shading 修改管线 光栅化两次场景 Pass 1 : 不做Shading，更新Depth Buffer Pass 2 : 对可见的Fragment做Shading 复杂度：\(O(\text{\#Vis.</description>
      <content:encoded><![CDATA[<h3 id="lecture-14-practical-industrial-solutions">Lecture 14 Practical
Industrial Solutions</h3>
<h4 id="temporal-anti-aliasing-taa">Temporal Anti-Aliasing, TAA</h4>
<p>Recall: why aliasing</p>
<ul>
<li>光栅化的采样数不够</li>
<li>终极解决方案：加样本（MSAA）</li>
</ul>
<p>TAA：应用Temporal信息，与RTRT的降噪思路一致</p>
<p>每四帧复用：</p>
<p><img src="/images/games202/TAA.png" alt="TAA" style="zoom:30%;" /></p>
<p>（如果不是4个固定位置而是是随机生成，引入了其他高频信息，效果并不好）</p>
<p>Notes on AA</p>
<ul>
<li>MSAA vs SSAA
<ul>
<li>SSAA：按几倍分辨率渲染场景，再下变换，效果好开销大</li>
<li>MSAA：对SSAA的效率改进
<ul>
<li>对一个像素内的一个Primitive，只采样一次（取中心或其他代表点）
<img src="/images/games202/MSAA1.jpg" alt="MSAA1" style="zoom: 50%;" /></li>
<li>空间上的Sample Reuse：样本分布上的Trick
<img src="/images/games202/MSAA2.png" alt="MSAA2" style="zoom: 20%;" /></li>
</ul></li>
</ul></li>
<li>基于图像的反走样方法
<ul>
<li>SMAA, Enhanced Subpixel Morphological AA</li>
<li>FXAA -&gt; MLAA(Morphological AA) -&gt; SMAA
<img src="/images/games202/ImageBasedAA.png" alt="ImageBasedAA" style="zoom:25%;" /></li>
</ul></li>
<li><strong>G-Buffer一定不能反走样！</strong>（信息会出错）</li>
</ul>
<h4 id="temporal-super-resolution">Temporal Super Resolution</h4>
<p>Super resolution == Super sampling</p>
<ul>
<li>提升分辨率</li>
<li>eg. <strong>DLSS</strong>
<ul>
<li><strong>DLSS 1.0</strong> 全靠猜，每个游戏/场景单独训练一个网络</li>
<li><strong>DLSS 2.0</strong> 利用Temporal信息
<ul>
<li>应用类似TAA的思路</li>
<li>重用Samples</li>
<li>问题：Temporal
failure时不能clamp——因为每一个像素需要一个明确的值</li>
<li>DL不输出图像，而是输出<strong>关于上一帧的Temporal信息如何利用</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="deferred-shading-延迟渲染">Deferred Shading 延迟渲染</h4>
<ul>
<li>提高Shading效率</li>
<li>传统管线
<ul>
<li>Triangles -&gt; Fragments -&gt; Depth Test -&gt; Shading -&gt;
Pixel</li>
<li>每一个Fragment都需要做Shading</li>
<li>复杂度：<span
class="math inline">\(O(\text{\#Fragment}*\text{\#Light})\)</span></li>
</ul></li>
<li>关键想法：有很多Fragment不会被看到 -&gt;
只对被看到的Fragment做Shading</li>
<li>修改管线
<ul>
<li>光栅化两次场景</li>
<li>Pass 1 : 不做Shading，更新Depth Buffer</li>
<li>Pass 2 : 对可见的Fragment做Shading</li>
<li>复杂度：<span
class="math inline">\(O(\text{\#Vis.Fragment}*\text{\#Light})\)</span></li>
<li>问题：难以做AA，可以用TAA/图像AA</li>
</ul></li>
<li>【疑惑：延迟渲染更广义地应该是指两次光栅化，一次记录G-Buffer，一次着色的渲染方式？这里闫老师只讲了深度Buffer的应用。】</li>
</ul>
<h4 id="tiled-shading">Tiled Shading</h4>
<ul>
<li>在Deferred Shading基础上，考虑减少光源的复杂度</li>
<li>把屏幕分成Tile
减少了每一个Tile中光源的数量：光源强度距离平方衰减（设定半径范围内有效）</li>
<li>复杂度：<span
class="math inline">\(O(\text{\#Vis.Fragment}*\text{avg(\#Light per
tile)})\)</span></li>
</ul>
<p><img src="/images/games202/TiledShading.png" alt="TiledShading" style="zoom:25%;" /></p>
<h4 id="clustered-shading">Clustered Shading</h4>
<ul>
<li>在Tiled Shading基础上，把空间分成网格</li>
<li>进一步减少了需要计算的光源数量</li>
<li>复杂度：<span
class="math inline">\(O(\text{\#Vis.Fragment}*\text{avg(\#Light per
cluster)})\)</span></li>
</ul>
<p><img src="/images/games202/ClusteredShading.png" alt="ClusteredShading" style="zoom:25%;" /></p>
<h4 id="lod-level-of-detail-solutions">LoD, Level of Detail
Solutions</h4>
<ul>
<li>在工业界，也称这种思路为“Cascaded”</li>
<li>eg. Cascaded Shadow Maps 离Camera越远的，用更粗糙的Shadow Map
<img src="/images/games202/CSM.jpg" alt="CSM" style="zoom:25%;" /></li>
<li>eg. Cascaded LPV 传播越远，用更粗的格子传播
<img src="/images/games202/CascadedLPV.png" alt="CascadedLPV" style="zoom:25%;" /></li>
<li>Geometric LoD</li>
<li>困难：过渡的Blending，可以用TAA</li>
<li>eg. <strong>Nanite</strong> in UE5</li>
</ul>
<h4 id="global-illumination-solutions">Global Illumination
Solutions</h4>
<ul>
<li>SSR的问题（参考相关章节）</li>
<li>用Ray Tracing解决
<ul>
<li>软件Tracing
<ul>
<li><strong>SDF Trace, HQ for individual obj, SQ for
global</strong></li>
<li><strong>RSM 方向性/点光源</strong></li>
<li>空间网格中存储Irradiance的Probe（DDGI, Dynamic Diffuse GI）</li>
</ul></li>
<li>硬件Tracing
<ul>
<li><strong>用简化模型Tracing</strong></li>
<li>RTXGI</li>
</ul></li>
<li>eg. <strong>Lumen</strong> in UE5：加粗条</li>
</ul></li>
</ul>
<blockquote>
<h4 id="more-topics">More Topics</h4>
<ul>
<li>Texturing an SDF</li>
<li>透明材质，透明材质的渲染顺序</li>
<li>Particle Rendering</li>
<li>Post Processing</li>
<li>随机数/蓝噪声</li>
<li>Foveated Rendering</li>
<li>Probe based GI (DDGI/RTXGI…)</li>
<li>ReSTIR, Neural Radiance Caching …</li>
<li>多光源理论，Light Cuts</li>
<li>Participating Media, SSSSS</li>
<li>Hair</li>
<li>…</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-12-GAMES202高质量实时渲染-Lecture12-13-Real Time Ray Tracing</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture12-13-rtrt/</link>
      <pubDate>Mon, 12 Apr 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture12-13-rtrt/</guid>
      <description>Lecture 12-13 Real-Time Ray-Tracing RTX : 10G rays per second == 1 sample per pixel
1 SPP path tracing == 1 rasterization (primary) + 1 ray (primary visibility) + 1 ray (primary bounce) + 1 ray (primary vis.) +
1 SPP is Extremely Noisy
Key Tech : Denosing
Goals : + Quality (no overblur, no artifacts, keep all details) + Speed (&amp;lt; 2ms to denoise per frame)
==&amp;gt; Temporal !</description>
      <content:encoded><![CDATA[<h3 id="lecture-12-13-real-time-ray-tracing">Lecture 12-13 Real-Time
Ray-Tracing</h3>
<p>RTX : 10G rays per second == 1 sample per pixel</p>
<p>1 SPP path tracing == 1 rasterization (primary) + 1 ray (primary
visibility) + 1 ray (primary bounce) + 1 ray (primary vis.) +</p>
<p>1 SPP is <strong>Extremely Noisy</strong></p>
<p>Key Tech : <strong>Denosing</strong></p>
<p>Goals : + Quality (no overblur, no artifacts, keep all details) +
Speed (&lt; 2ms to denoise per frame)</p>
<p>==&gt; <strong>Temporal !</strong></p>
<h4 id="temporal-filtering">Temporal Filtering</h4>
<p>Key idea ：</p>
<ul>
<li>假定前一帧已完成降噪，直接使用</li>
<li>使用<strong>motion vectors</strong>找前一位置</li>
<li>增加了SPP（引用前一帧的SPP，前一帧又引用了前两帧……）</li>
</ul>
<p><strong>Geometry buffer</strong></p>
<ul>
<li>渲染时生成的附加信息，消耗较少</li>
<li>像素深度、法线、世界坐标等</li>
<li>屏幕空间的信息</li>
</ul>
<p><strong>Back Projection</strong></p>
<ul>
<li>找到同一像素在上一帧的位置</li>
<li>直接使用G-Buffer： <span
class="math inline">\(s=M^{-1}V^{-1}P^{-1}E^{-1}x\ ({\rm Still\ with\
}z{\rm \ value})\)</span></li>
<li>Motion : <span
class="math inline">\(s^{&#39;}\xrightarrow{T}s\quad\Rightarrow\quad
s^{&#39;}=T^{-1}s\)</span></li>
<li>前一帧的屏幕坐标： <span
class="math inline">\(x^{&#39;}=E^{&#39;}P^{&#39;}V^{&#39;}M^{&#39;}s^{&#39;}\)</span></li>
</ul>
<p><strong>Temporal Accum. / Denoising</strong> <span
class="math display">\[
\overline{C}^{(i)}={\rm SpatialFilter}(\widetilde{C}^{(1)})\\
C^{(i)}=\alpha\overline{C}^{(i)}+(1-\alpha)C^{(i-1)}\quad
\alpha\approx0.1\sim0.2
\]</span></p>
<blockquote>
<p>滤波不会使画面改变亮度，低SPP的“暗”来源于超亮噪声被削波</p>
</blockquote>
<p><strong>Temporal Failure</strong></p>
<ul>
<li>切换场景/镜头：Burn-in period 黑帧预热</li>
<li>Dolly out / Zoom out，几何信息不断增多：尽量避免这种情况</li>
<li>突然出现被遮挡的物体，出现残影：
<ul>
<li>Clamping：把前一帧的结果“拉”近当前帧，减小残影</li>
<li>Detection：
<ul>
<li>使用Object ID检测Temporal failure（判断前后帧motion
vector对应的物体是否相同）</li>
<li>改变 <span class="math inline">\(\alpha\)</span> ，在Temporal
failure时减少对前一帧的依赖</li>
<li>增强Spatial filtering</li>
</ul></li>
<li>问题：重新带来了噪声</li>
</ul></li>
<li>光源移动时，阴影“拖影”</li>
<li>物体移动时，镜面反射“延迟”（Glossy材质）</li>
</ul>
<h4 id="spatial-filtering">Spatial Filtering</h4>
<p><strong>Low-pass
filter</strong>：减少高频噪声，但可能会导致高频信号丢失、低频噪声保留</p>
<p><strong>Gaussian filtering</strong></p>
<pre class="pseudocode"><code>For each pixel i
    sum_of_weights = sum_of_weighted_values = 0.0
    For each pixel j around i
        Calculate the weight w_ij = G(|i - j|, sigma)
        sum_of_weighted_values += w_ij * C^{input}[j]
        sum_of_weights += w_ij
    C^{output}[I] = sum_of_weighted_values / sum_of_weights</code></pre>
<p>*高斯模糊理论范围是无限远，但往往限制在周围一圈像素计算（远处权重极低，直接忽略）</p>
<h5 id="bilateral-filtering-双边滤波">Bilateral filtering 双边滤波</h5>
<p>Problem of Gaussian filtering：边界也被模糊，高频信息丢失</p>
<p>边界：颜色突变</p>
<p>做法：不让颜色突变的像素参与贡献</p>
<p>权重函数： <span class="math display">\[
\displaystyle w(i,j,k,l)={\rm
exp}\left(-\frac{(i-k)^2+(j-l)^2}{2\sigma_d^2}-\frac{\|I(i,j)-I(k,l)\|^2}{2\sigma_r^2}\right)\\
(i,j)为某一像素，(k,l)为其周边一像素
\]</span> Problem：如何区分边界/噪声？ 参考SVGF</p>
<p>==&gt; <strong>key
idea</strong>：增加滤波的条件——渲染过程中的G-Buffer
<strong>联合双边滤波</strong></p>
<p><strong>大滤波核计算方法</strong></p>
<ul>
<li><strong>Separate Passes</strong>：先做横向滤波、再做纵向滤波 <span
class="math inline">\(O(n^2)\to O(n+n)=O(n)\)</span>
<ul>
<li>二维高斯函数的定义 <span
class="math inline">\(G_{2D}(x,y)=G_{1D}(x)\cdot G_{1D}(y)\)</span></li>
<li>Filtering == convolution <span
class="math inline">\(\displaystyle\iint
F(x_0,y_0)G_{2D}(x_0-x,y_0-y)\,\mathrm dx\mathrm dy=\int\left(\int
F(x_0,y_0)G_{1D}(x_0-x)\,\mathrm dx\right)G_{1D}(y_0-y)\,\mathrm
dy\)</span></li>
<li>理论上复杂的双边滤波不能这么计算，但近似强行如此计算</li>
</ul></li>
<li><strong>Progressively Growing Sizes</strong>
<ul>
<li>多次滤波，逐渐增加大小</li>
<li>eg. <strong>a-trous wavelet</strong>
<ul>
<li>多次pass，每次都是 <span class="math inline">\(5\times 5\)</span>
大小</li>
<li>每次pass，采样间隔为 <span class="math inline">\(2^{i-1}\)</span>
<img src="/images/games202/A-Trous_Wavelet.jpg" alt="A-Trous_Wavelet" style="zoom: 33%;" /></li>
<li>eg. <span class="math inline">\(64^2\to5^2\times5\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>在Filter之前去除超亮/超暗像素（Outlier）</p>
<ul>
<li>Outlier detection
<ul>
<li>对 <span class="math inline">\(7\times7\)</span>
网格计算均值和方差</li>
<li>超出 <span class="math inline">\([\mu-k\sigma,\mu+k\sigma]\)</span>
-&gt; Outlier</li>
</ul></li>
<li>Outlier removal
<ul>
<li>clamp to <span
class="math inline">\([\mu-k\sigma,\mu+k\sigma]\)</span></li>
</ul></li>
</ul>
<h4 id="specific-filtering-approaches-for-rtrt">Specific Filtering
Approaches for RTRT</h4>
<h5 id="svgf-spatiotemporal-variance-guided-filtering">SVGF,
Spatiotemporal Variance-Guided Filtering</h5>
<ul>
<li><p>与前文基本时空降噪方法相似，多了一些Trick和Variance分析方法</p></li>
<li><p>联合双边滤波 - 3个因素</p>
<ul>
<li><p>深度 <span class="math display">\[
w_z=\exp\left(-\dfrac{|z(p)-z(q)|}{\sigma_z|\nabla
z(p)\cdot(p-q)|+\epsilon}\right)\quad \text{$z$为深度}
\]</span></p>
<ul>
<li><p>只要是衰减函数就可以，这里不是高斯函数</p></li>
<li><p><span class="math inline">\(\epsilon\)</span>
为了防止分母为零，一般为很小的值</p></li>
<li><p><span class="math inline">\(\nabla z(p)\)</span>
深度的梯度，为了防止如图AB点情况，斜侧面深度差异过大时出现误差，用关于垂直法线方向/切平面的深度变化（如图AB的物理空间距离即所在面上法线垂直方向的深度变化）
<img src="/images/games202/SVGF1.png" alt="SVGF1" style="zoom: 33%;" /></p></li>
</ul></li>
<li><p>法线 <span class="math display">\[
w_n=\max(0,n(p)\cdot n(q))^{\sigma_n}
\]</span> <span class="math inline">\(\sigma_n\)</span>
控制衰减快慢，即法线之间的差异要求是否严格
<img src="/images/games202/SVGF2.png" alt="SVGF2" style="zoom: 33%;" />
PS:
使用应用法线贴图之前的法线（应用法线贴图后表面凹凸不平，难以判断）</p></li>
<li><p>Luminance (gray scale) <span class="math display">\[
w_l=\exp\left(-\dfrac{|l_i(p)-l_i(q)|}{\sigma_l\sqrt{g_{3\times 3}({\rm
Var}(l_i(p)))+\epsilon}}\right)
\]</span>
<img src="/images/games202/SVGF3.png" alt="SVGF3" style="zoom: 33%;" /></p>
<p>亮度差异大的点不参与贡献——但单个像素亮度受噪声影响，故除以附近区域标准差（例如<span
class="math inline">\(7\times7\)</span>区域）（使用Temporal累计标准差，再进行一次<span
class="math inline">\(3\times3\)</span>滤波平均）。</p></li>
</ul></li>
<li><p>Tradeoff：相比较noise，宁愿选择overblur
改进：ASVGF，优化overblur的问题（也可以理解为选择noise）</p></li>
<li><p>问题：动态光源阴影残影</p></li>
</ul>
<h5 id="rae-recurrent-autoencoder">RAE, Recurrent AutoEncoder</h5>
<ul>
<li><p>基本想法：用Recurrent denoising AutoEncoder对Path
Tracing结果降噪，神经网络方法。</p>
<ul>
<li><p>后处理方法</p></li>
<li><p>利用部分G-Buffer信息（作为神经网络输入）</p></li>
<li><p>神经网络自动累计Temporal信息</p>
<ul>
<li><strong>AutoEncoder</strong> (U-Net)
<img src="/images/games202/RAE1.jpg" alt="RAE1" style="zoom:50%;" /></li>
<li><strong>Recurrent</strong>：每一层神经网络不止连接下一层，还要连接自身（Temporal）
<img src="/images/games202/RAE2.jpg" alt="RAE2" style="zoom: 50%;" /></li>
</ul></li>
</ul></li>
<li><p>问题：暗、存在边缘错误、overblur</p></li>
<li><p>优势：对于不同的spp数输入，结果稳定</p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-04-05-GAMES202高质量实时渲染-Lecture3-4-Soft Shadow</title>
      <link>https://elderlyaugustus.github.io/posts/2021-04-05-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture3-4-softshadow/</link>
      <pubDate>Mon, 05 Apr 2021 16:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-04-05-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture3-4-softshadow/</guid>
      <description>Lecture 3-4 Soft Shadow Recap of Shadow Mapping - 点光源 从“Light”处看向场景，生成场景关于光源的深度图，即Shadow Map； 从相机处看向场景渲染画面，利用Shadow Map判断像素是否在阴影中。 Feature：
基于二维图像的算法，而不需要三维几何场景 使用透视投影后Z值或透视投影前实际距离生成深度图皆可，Shadow Map与阴影生成时的深度判定方式一致即可 Problem
Self occlusion 自遮挡
Shadow Map的每一个像素记录同一深度，形成下图现象。在单个/行像素采样处，形成尺寸为像素宽高的遮挡面。 解决方案：在反射表面邻近区域不计算遮挡。不计算区域Light长度（Bias）由Light与反射表面法线夹角决定。（Light垂直于表面时不产生自遮挡问题）。——带来新问题：丢失遮挡关系。
Detached shadow 由解决自遮挡的Bias不计算带来的阴影残缺问题。
工业界无法彻底解决该问题，通过找到合适的Bias值减少视觉问题。
学术解决方案：Second-depth shadow mapping
存储第一深度和次级深度（离得第二近的表面距离），取中间值作为深度判断的值。 存在问题：要求所有物体watertight（有正反面）；计算量过大。 实时渲染不相信复杂度，只相信绝对速度！因此工业界不适用。 Aliasing 采样
The math behind shadow mapping 微积分中常见的不等式： \[ \begin{array}{c} Schwarz不等式： \displaystyle\left[\int_a^bf(x)g(x)\,\mathrm d x\right]^2\le\int_a^bf^2(x)\,\mathrm d x\cdot\int_a^bg^2(x)\,\mathrm d x\\ Minkowski不等式：\displaystyle\left\{\int_a^b\left[f(x)+g(x)\right]^2\,\mathrm d x\right\}^\frac{1}{2}\le\left\{\int_a^bf^2(x)\,\mathrm d x\right\}^\frac{1}{2}+\left\{\int_a^bg^2(x)\,\mathrm d x\right\}^\frac{1}{2} \end{array} \] Approximation in RTR: But we care more about “approximately equal”.</description>
      <content:encoded><![CDATA[<h3 id="lecture-3-4-soft-shadow">Lecture 3-4 Soft Shadow</h3>
<h4 id="recap-of-shadow-mapping---点光源">Recap of Shadow Mapping -
点光源</h4>
<ol type="1">
<li>从“Light”处看向场景，生成场景关于光源的深度图，即<strong>Shadow
Map</strong>；</li>
<li>从相机处看向场景渲染画面，利用Shadow Map判断像素是否在阴影中。</li>
</ol>
<p><strong>Feature</strong>：</p>
<ul>
<li>基于二维图像的算法，而不需要三维几何场景</li>
<li>使用透视投影后Z值或透视投影前实际距离生成深度图皆可，Shadow
Map与阴影生成时的深度判定方式一致即可</li>
</ul>
<p><strong>Problem</strong></p>
<ul>
<li><p><strong>Self occlusion 自遮挡</strong></p>
<p>Shadow
Map的每一个像素记录同一深度，形成下图现象。在单个/行像素采样处，形成尺寸为像素宽高的遮挡面。
<img src="/images/games202/SelfOcclusion1.png" alt="SelfOcclusion1" style="zoom:25%;" /></p>
<p><strong>解决方案</strong>：在反射表面邻近区域不计算遮挡。不计算区域Light长度（<strong>Bias</strong>）由Light与反射表面法线夹角决定。（Light垂直于表面时不产生自遮挡问题）。——带来新问题：丢失遮挡关系。<img src="/images/games202/SelfOcclusion2.png" alt="SelfOcclusion2" style="zoom:25%;" /></p></li>
<li><p><strong>Detached shadow</strong>
由解决自遮挡的Bias不计算带来的阴影残缺问题。</p>
<p>工业界无法彻底解决该问题，通过找到合适的Bias值减少视觉问题。</p>
<p>学术解决方案：<strong>Second-depth shadow mapping</strong></p>
<ul>
<li>存储第一深度和次级深度（离得第二近的表面距离），取中间值作为深度判断的值。</li>
<li>存在问题：要求所有物体watertight（有正反面）；计算量过大。</li>
<li><strong>实时渲染不相信复杂度，只相信绝对速度！</strong>因此工业界不适用。</li>
</ul>
<p><img src="/images/games202/SecondDepthSM1.png" alt="SecondDepthSM" style="zoom:25%;" /></p></li>
<li><p><strong>Aliasing 采样</strong></p></li>
</ul>
<h4 id="the-math-behind-shadow-mapping">The math behind shadow
mapping</h4>
<p>微积分中常见的不等式： <span class="math display">\[
\begin{array}{c}
Schwarz不等式： \displaystyle\left[\int_a^bf(x)g(x)\,\mathrm d
x\right]^2\le\int_a^bf^2(x)\,\mathrm d x\cdot\int_a^bg^2(x)\,\mathrm d
x\\
Minkowski不等式：\displaystyle\left\{\int_a^b\left[f(x)+g(x)\right]^2\,\mathrm
d x\right\}^\frac{1}{2}\le\left\{\int_a^bf^2(x)\,\mathrm d
x\right\}^\frac{1}{2}+\left\{\int_a^bg^2(x)\,\mathrm d
x\right\}^\frac{1}{2}
\end{array}
\]</span> <strong>Approximation in RTR</strong>: But we care more about
“approximately equal”. 实时渲染中常将不等式当作约等式使用。</p>
<p><strong>An important approximation</strong>: <span
class="math display">\[
\displaystyle\int_\Omega f(x)g(x)\,\mathrm d x\approx\frac{\int_\Omega
f(x)\,\mathrm d x}{\int_\Omega \,\mathrm d x}\cdot\int_\Omega
g(x)\,\mathrm d x
\]</span></p>
<p>其中 <span class="math inline">\(\int_\Omega \,\mathrm d x\)</span>
为归一化常数。</p>
<p>该式何时较准确：</p>
<ul>
<li>积分域较小时</li>
<li><span class="math inline">\(g(x)\)</span>
在积分域内变化不大（Smooth）</li>
</ul>
<p>Recall：<strong>Rendering Equation with Explicit Visibility</strong>
<span class="math display">\[
L_o(p,\omega_o)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_iV(p,\omega_i)\,\mathrm
d \omega_i
\]</span> Approximated as: <span class="math display">\[
L_o(p,\omega_o)\approx\frac{\int_{\Omega+}V(p,\omega_i)d\omega_i}{\int_{\Omega+}d\omega_i}\cdot\int_{\Omega+}L_i(p,L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_i\,\mathrm
d \omega_i
\]</span> 即将Visibility部分 <span
class="math inline">\(V(p,\omega_i)\)</span>
单独计算。则非Visibility部分为纯Shading部分，Visibility近似部分为“Shadow
Mapping”部分。</p>
<p>何时准确：</p>
<ul>
<li>点光源/方向光源（积分域小）</li>
<li>Diffuse/面光源（其中一个积分函数平滑）</li>
</ul>
<p><strong>Ambient Occlusion
环境光遮蔽</strong>中将再次用到类似的约等式</p>
<h4 id="pcss-percentage-closer-soft-shadows"><strong>PCSS: Percentage
Closer Soft Shadows</strong></h4>
<h5 id="pcf-percentage-closer-filtering">PCF: Percentage Closer
Filtering</h5>
<ul>
<li>[ For <strong>anti-aliasing</strong> at shadows’ edges - Not for
soft shadows ]</li>
<li>Filtering the result of shadow comparisons</li>
</ul>
<p><strong>[Solution]</strong></p>
<ul>
<li>根据Shadow
Map判断像素是否在阴影中：不判断一个像素，判断对应像素周围的一圈像素（如7*7网格）</li>
<li>得到该组像素判断的<strong>平均值</strong>，赋给中心像素（原判断像素）</li>
<li>计算量？PCSS时一并解决</li>
<li>将Filter范围再放大得到软阴影？！</li>
</ul>
<h5 id="pcss">PCSS</h5>
<ul>
<li><p>软阴影：近处锐利，远处模糊 —— Filter Size &lt;-&gt; Blocker
Distance</p></li>
<li><p><span
class="math inline">\(w_{Penumbra}=(d_{recevier}-d_{Blocker})\cdot
w_{Light}/d_{Blocker}\)</span>
<img src="/images/games202/PCSS1.png" alt="PCSS1" style="zoom:20%;" /></p></li>
<li><p>Block Depth: Average block depth 在一定范围内，一个Shading
Point被遮挡的平均深度值</p></li>
<li><p>Complete algorithm</p>
<ol type="1">
<li>Blocker search : Getting the average depth <strong>in a certain
region</strong> （视面光源中心为点光源生成Shadow Map）</li>
<li>Penumbra estimation : Use the average blocker depth to determine
filter size</li>
<li>Percentage Closer Filtering</li>
</ol></li>
<li><p>Blocker search的范围（得到Average block
depth的方式）如何确定？</p>
<ul>
<li><p>取固定范围，如5*5</p></li>
<li><p>[Better]
取决于<strong>光源面积</strong>和<strong>光照接收面到光源的距离</strong>
<img src="/images/games202/PCSS2.png" alt="PCSS2" style="zoom:20%;" />
<span class="math display">\[
\rm
size_{Blocker}=distance_{ShadowMap2Scene}/distance_{Light2Scene}\cdot
size_{Light}
\]</span></p></li>
</ul></li>
<li><p>开销巨大：下节课解决</p></li>
</ul>
<h5 id="a-deeper-look-at-pcf">A deeper look at PCF</h5>
<p>The math behind PCF: <strong>Filter/Convolution</strong> <span
class="math display">\[
[w*f](p)=\sum_{q\in\mathcal{N}(p)}w(p,q)f(q)\quad\quad N(p):p的邻域
\]</span> In PCSS <span class="math display">\[
V(x)=\sum_{q\in\mathcal{N}(p)}w(p,q)\cdot\chi^+[D_{SM}(q)-D_{scene}(x)]\quad\quad\chi^+(A)=A&gt;0?1:0
\]</span> 因此：</p>
<ul>
<li>PCF并不是对Shadow Map的滤波 <span class="math display">\[
V(x)\neq\chi^+\{[w*D_{SM}](q)-D_{scene}(x)\}
\]</span></li>
<li>PCF也不是对结果图像做滤波 <span class="math display">\[
V(x)\neq\sum_{q\in\mathcal{N}(p)}w(p,q)V(q)
\]</span></li>
</ul>
<h5 id="more-about-pcss">More about PCSS</h5>
<p>[Blocker Search] and [PCF] is slow to look at every texel.</p>
<ul>
<li>[Blocker Search] 随机取样 =&gt; Noise</li>
<li>[PCF] Filter范围过大，随机采样 -&gt;
<strong>图像空间降噪</strong></li>
</ul>
<h4 id="variance-soft-shadow-mapping">Variance Soft Shadow Mapping</h4>
<ul>
<li>Fast blocker search and filtering</li>
</ul>
<p><strong>[ Filter ]</strong> PCF：根据正态分布可估计 Percentage Closer
Value
正态分布由<strong>均值mean</strong>和<strong>方差variance</strong>定义</p>
<ul>
<li>Mean
<ul>
<li>Hardware Mipmaping 但只能正方形</li>
<li>Summed Area Tables (SAT)</li>
</ul></li>
<li>Variance
<ul>
<li><span class="math display">\[
Var(X)=E(X^2)-E^2(X)\quad E:期望=均值
\]</span></li>
<li>另一张“Shadow Map”记录深度的平方，称为“Square depth map”</li>
</ul></li>
</ul>
<p>由此得到正态分布图，求得<strong>CDF(x) of the Gaussian
PDF</strong>即可（即0-x的积分）。
该积分没有解析解只有数值解，可通过高斯分布积分表<strong>Error
Function</strong>得到CDF值。在<code>cpp</code>中使用<code>erf()</code>求数值解，但计算仍较复杂。</p>
<p>因此引入切比雪夫不等式估计值： <span class="math display">\[
P(x&gt;t)\le\frac{\sigma^2}{\sigma^2+(t-\mu)^2}\quad\quad\begin{aligned}\mu&amp;:
mean\\\sigma^2&amp;:variance\end{aligned}
\]</span> 对任意分布方式，通过切比雪夫不等式估得右侧积分值 <span
class="math inline">\(P(x&gt;t)\)</span> ，再由 <span
class="math inline">\(1-P(x&gt;t)\)</span> 得到 <span
class="math inline">\(CDF(x)\)</span> 。
仅t&gt;mean时较准，但工业界往往直接用。</p>
<p><img src="/images/games202/VSSM1.png" alt="VSSM1" style="zoom:33%;" /></p>
<blockquote>
<p>总结 + Shadow map generation + “Square depth map” + Runtime + Mean of
depth in a range: O(1) + Mean of depth square in a range: O(1) +
Chebychev: O(1) + No samples / loops needed + Perfectly ?
改变视角需要重新生成map 产生较大开销 GPU解决起来速度非常快</p>
</blockquote>
<p><strong>[ Block Search ]</strong></p>
<ul>
<li><p>Target: The average depth of <strong>blockers</strong> ( texels
whose depth z &lt; t, <span class="math inline">\(z_{occ}\)</span> )
<span
class="math inline">\(\Rightarrow\begin{array}{l}blocker:z_{occ}\\non-blocker:z_{unocc}\end{array}\)</span></p></li>
<li><p><span class="math display">\[
\displaystyle\frac{N_1}{N}z_{unocc}+\frac{N_2}{N}z_{occ}=z_{avg}
\]</span></p></li>
<li><p>Chebychev Approximation: <span
class="math inline">\(\displaystyle\frac{N_1}{N}=P(x&gt;t)\quad\frac{N_2}{N}=1-P(x&gt;t)\)</span></p></li>
<li><p>Approximation: <span
class="math inline">\(z_{unocc}=t\)</span></p></li>
</ul>
<h4 id="mipmap-and-summed-area-variance-shadow-maps">MIPMAP and
Summed-Area Variance Shadow Maps</h4>
<h5 id="recall-mipmap">Recall: MIPMAP</h5>
<ul>
<li><strong>fast, approx., square</strong> range queries</li>
<li>非 <span class="math inline">\(1/n^i\)</span>
方形区域，需使用线性插值</li>
<li>不精准，限制多</li>
</ul>
<h5 id="sat-summed-area-table">SAT (Summed-Area Table)</h5>
<ul>
<li><p>in 1D: 第 <span class="math inline">\(i\)</span> 位存储 <span
class="math inline">\(0-i\)</span> 的和</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>SAT<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> Arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> i <span class="op">&lt;</span> n<span class="op">,</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  SAT<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> SAT<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> Arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">//Sum of a to b</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> sum<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> SAT<span class="op">[</span>b<span class="op">]</span> <span class="op">-</span> SAT<span class="op">[</span>a<span class="op">-</span><span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span></code></pre></div></li>
<li><p>in 2D: 第 <span class="math inline">\((i,j)\)</span> 位存储 <span
class="math inline">\((0,0)-(i,j)\)</span> 的矩形区域和</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// m * n</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> i <span class="op">&lt;</span> n<span class="op">,</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  SAT<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> Arr<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">&lt;</span> n<span class="op">,</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        SAT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> SAT<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> Arr<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> i <span class="op">&lt;</span> n<span class="op">,</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">&lt;</span> n<span class="op">,</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        SAT<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> SAT<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">//Sum of a to b</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> sum<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> SAT<span class="op">[</span>a<span class="op">-</span><span class="dv">1</span><span class="op">][</span>b<span class="op">]</span> <span class="op">+</span> SAT<span class="op">[</span>a<span class="op">][</span>b<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> SAT<span class="op">[</span>a<span class="op">-</span><span class="dv">1</span><span class="op">][</span>b<span class="op">-</span><span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span></code></pre></div></li>
</ul>
<h4 id="moment-shadow-mapping">Moment Shadow Mapping</h4>
<p><strong>VSSM</strong> Problem:
遮挡物简单情况下，遮挡深度分布非正态/不符合切比雪夫估计 ，估计值不准</p>
<ul>
<li>与实际值相比较暗：视觉无影响</li>
<li>与实际值相比较亮：漏光（Light Leaking，工业界也有称Light
Bleeding）</li>
</ul>
<p>解决分布描述不准方法——引入高阶<strong>矩（Moments）</strong></p>
<ul>
<li>简单理解为“ <span class="math inline">\(x^i\)</span> 即 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(i\)</span> 阶矩”</li>
<li>使用前 <span class="math inline">\(m\)</span> 阶矩的组合（ <span
class="math inline">\(x^1,x^2,\dots,x^m\)</span> ）可以描述一个具有
<span class="math inline">\(m/2\)</span> 个“台阶”的阶跃函数</li>
<li>可视为一种展开，将原函数展开为前 <span
class="math inline">\(m\)</span> 阶矩的线性组合</li>
<li>在MSM中，前4阶矩可较好描述遮挡深度分布，在使用VSSM的想法计算所需值（可在Blocker
Search和PCF环节使用该方法）</li>
</ul>
<h4 id="distance-field-soft-shadows">Distance Field Soft Shadows</h4>
<p><strong>Distance Field / Distance Function</strong>: Minimum distance
to the closet location on an object SDF(Signed Distance Field)
是较好的混合方式，比线性插值得到结果更平滑连续——<strong>[ 最优传输理论
]</strong></p>
<p>Usages:</p>
<ul>
<li><p>Ray marching (Sphere Tracing)
在某一点，作SDF值（距离物体的最小距离）为半径的球，则球体内任意方向发射光线均不与物体相交，将该半径定义为“安全距离”（safe
distance）。则光线可以朝原方向走该半径长度的距离，得到新的点和SDF值，同理迭代。直到沿着同一方向与物体距离足够小，或光线路径过长（认为无物体与之相交）时停止追踪。
<img src="/images/games202/SDF1.png" alt="SDF1" style="zoom:33%;" /></p></li>
<li><p>Soft Shadows 类Ray Marching，对每一根光线，算出”安全角度”（safe
angle）。（光线上所有点的SDF值的最小值为半径，该点为圆心作圆，与光线发射点两条切线的夹角）
<span class="math inline">\(\text{smaller safe
angle}\Rightarrow\text{less visibility}\)</span>
<img src="/images/games202/SDF2.png" alt="SDF2" style="zoom:33%;" />
<img src="/images/games202/SDF3.png" alt="SDF3" style="zoom:33%;" />
<span class="math display">\[
\begin{array}{l}
\displaystyle V=\arcsin\frac{SDF(p)}{\|p-o\|}\quad \arcsin 计算量过大\\
\displaystyle V\approx \min\left\{\frac{k\dot
SDF(p)}{\|p-o\|},1.0\right\}\quad
直接使用比值近似，其中k值决定过渡带宽度，即阴影软硬程度\\
\end{array}
\]</span></p></li>
<li><p>优势：快</p></li>
<li><p>局限性：SDF的计算量、存储量，以及物体运动后重新计算的复杂度。（对多个物体的SDF，取最小值即可。）and
some artifact</p></li>
<li><p>misc：<a
href="https://github.com/protectwise/troika/tree/master/packages/troika-3d-text">利用SDF在实时渲染中生成矢量字符</a></p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-02-GAMES202高质量实时渲染-Lecture10-11-Physically-Based Material</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture10-11-pbm/</link>
      <pubDate>Fri, 02 Apr 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture10-11-pbm/</guid>
      <description>Lecture 10-11 Physically-Based Material Content
Real-Time Physically-Based Materials Microfacet BRDF Disney principled BRDF Shading with microfacet BRDFs under polygonal lighting Linearly Transformed Cosines (LTC) Concept
Physically-Based Rendering (PBR) Everything in rendering should be physically based Materials, lighting, camera, light transport, etc. Not just materials, but usually referred to as materials PBR materials in RTR The RTR community is much behind the offline community “PB” in RTR is usually not actually physically based PBR materials in RTR</description>
      <content:encoded><![CDATA[<h3 id="lecture-10-11-physically-based-material">Lecture 10-11
Physically-Based Material</h3>
<p><strong>Content</strong></p>
<ul>
<li>Real-Time Physically-Based Materials
<ul>
<li>Microfacet BRDF</li>
<li>Disney principled BRDF</li>
</ul></li>
<li>Shading with microfacet BRDFs under polygonal lighting
<ul>
<li>Linearly Transformed Cosines (LTC)</li>
</ul></li>
</ul>
<p><strong>Concept</strong></p>
<ul>
<li>Physically-Based Rendering (PBR)
<ul>
<li>Everything in rendering should be physically based</li>
<li>Materials, lighting, camera, light transport, etc.</li>
<li>Not just materials, but usually referred to as materials</li>
</ul></li>
<li>PBR materials in RTR
<ul>
<li>The RTR community is much behind the offline community</li>
<li>“PB” in RTR is usually not actually physically based</li>
</ul></li>
</ul>
<p><strong>PBR materials in RTR</strong></p>
<ul>
<li><p>For surfaces</p>
<ul>
<li>Microfacet models (used wrong so not “PBR”)</li>
<li>Disney principled BRDFs (artist friendly but still not “PBR”)</li>
</ul></li>
<li><p>For volumes (cloud, hair, skin, etc.)</p>
<p>focused on fast and approximate single scattering and multiple
scattering</p></li>
</ul>
<h4 id="recap-microfacet-brdf">Recap: Microfacet BRDF</h4>
<p><img src="/images/games202/MicrofacetBRDF.png" alt="MicrofacetBRDF" style="zoom: 25%;" /></p>
<h5 id="fresnel-term">Fresnel term</h5>
<ul>
<li><p>精确表达非常复杂，需要考虑S/P极化
<img src="/images/games202/FresnelTerm.png" alt="FresnelTerm" style="zoom:30%;" /></p></li>
<li><p>Schlick’s approximation 近似为基础反射率 <span
class="math inline">\(R_0\)</span> 的变化 <span class="math display">\[
R(\theta)=R_0+(1-R_0)(1-\cos\theta)^5\\
R_0=\left(\dfrac{n_1-n_2}{n_1+n_2}\right)^2
\]</span></p></li>
</ul>
<h5 id="normal-distribution-function-ndf">Normal Distribution Function
(NDF)</h5>
<blockquote>
<p>此处NDF中的Normal为“法线”，须与表示“正态分布”的“Normal
Distribution”中的Normal区分</p>
</blockquote>
<ul>
<li><p>法线分布集中 ==&gt; glossy
<img src="/images/games202/NDF1.png" alt="NDF1" style="zoom: 33%;" /></p>
<p>法线分布分散 ==&gt; diffuse
<img src="/images/games202/NDF2.png" alt="NDF2" style="zoom:33%;" /></p>
<p>（diffuse的微表面可以视作specular的微表面纵向scale而得到，而纵向scale使得diffuse的微表面“沟壑”较深）</p></li>
<li><p>描述NDF的模型</p>
<ul>
<li><p>Beckmann NDF <span class="math display">\[
D(h)=\dfrac{e^{-\frac{\tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2\cos^4\theta_h}\\
\alpha:\text{roughness of the surface}\\
\theta_h:\text{angle between half vector }h\text{ and normal }n
\]</span></p>
<ul>
<li>类似Gaussian</li>
<li>在slope space（坡度空间）上定义 如图即定义在 <span
class="math inline">\(\tan\theta\)</span>
所在平面上（可以保证不出现面朝下的微表面，但较难解决反射光朝下的情况）
<img src="/images/games202/NDF3.png" alt="NDF3" style="zoom: 25%;" /></li>
<li>在project solid angle上积分为1</li>
</ul></li>
<li><p>GGX （or Trowbridge-Reitz） <span class="math display">\[
D_{\rm GGX}(\theta_h) = \frac{\alpha^2}{\pi\cos^4\theta_ m(\alpha^2 +
\tan^2\theta_h)^2}\\
\alpha:\text{roughness}^2
\]</span></p>
<ul>
<li>特征：long tail 长尾巴
衰减到一定程度后非常慢，可使Specular出现“光晕”
<img src="/images/games202/NDF4.jpg" alt="NDF4" style="zoom: 50%;" /></li>
<li>对比
<img src="/images/games202/NDF5.png" alt="NDF5" style="zoom: 25%;" /></li>
</ul></li>
<li><p>Extending GGX</p>
<ul>
<li>GTR (Generalized Trowbridge-Reitz) （<span
class="math inline">\(\gamma\)</span>
较大时，接近Beckmann，相当于统一了两种model）
<img src="/images/games202/NDF6.jpg" alt="NDF6" style="zoom:50%;" /></li>
</ul></li>
</ul></li>
</ul>
<h5 id="shadowing-masking-term">Shadowing-Masking Term</h5>
<p>Or <strong>Geometry Term</strong> : <strong>G</strong></p>
<ul>
<li><p>解决微表面之间的自遮挡问题</p></li>
<li><p>Shadowing 光线照射到微表面 <img
src="/images/games202/ShadowingMaskingTerm1.jpg"
alt="ShadowingMaskingTerm1" /></p>
<p>Masking 光线反射进入眼睛 <img
src="/images/games202/ShadowingMaskingTerm2.jpg"
alt="ShadowingMaskingTerm2" /></p></li>
<li><p>变暗操作，靠近垂直方向时几乎不变暗（G值为1），Grazing
angle（掠视）时变暗（G值减小，直至接近0）</p></li>
<li><p>常用的Shadowing-Masking Term</p>
<ul>
<li><p>Smith Shadowing-Masking Term</p></li>
<li><p>把Shadowing和Masking拆开（假定两者无关，事实上有关） <span
class="math display">\[
G(i,o,m)\approx G_1(i,m)G_1(o,m)
\]</span></p></li>
<li><p>Beckmann（绿）和GGX（红）分别的Shadowing-Masking项
<img src="/images/games202/ShadowingMaskingTerm3.jpg" alt="ShadowingMaskingTerm3" style="zoom: 40%;" /></p></li>
<li><p>eg. 与GGX法线分布匹配的Smith模型 <span class="math display">\[
G_{\rm Smith}(\mathbf{i},\mathbf{o},\mathbf{h})=G_{\rm
Schlick}(\mathbf{l},\mathbf{h})G_{\rm Schlick}(\mathbf{v},\mathbf{h})\\
k=\dfrac{({\rm roughness}+1)^2}{8}\\
G_{\rm Schlick}(\mathbf{v},\mathbf{n})=\dfrac{\mathbf{n}\cdot
\mathbf{v}}{\mathbf{n}\cdot \mathbf{v}(1-k)+k}
\]</span></p></li>
</ul></li>
</ul>
<h5 id="问题能量损失">问题：能量损失</h5>
<blockquote>
<p><strong>白炉测试 White Furnace
Test</strong>：在完全均匀的全局环境光下渲染物体，若物体与背景同色，说明不存在能量损失，若变暗说明存在能量损失。</p>
</blockquote>
<ul>
<li><p>发现，Roughness值增大会导致能量损失（图2为白炉测试）
<img src="/images/games202/MissingEnergy1.jpg" alt="MissingEnergy1" style="zoom: 50%;" />
<img src="/images/games202/MissingEnergy2.jpg" alt="MissingEnergy2" style="zoom: 50%;" /></p></li>
<li><p>Roughness越大，微表面沟壑越多，越容易自遮挡（Shadowing-Masking程度大）
——而现实中，自遮挡的光线经过多次弹射最终会反射出来，不会损失能量，此时Microfacet模型中只考虑了一次弹射</p></li>
<li><p>精确地还原损失的能量（Heitz et
al. 2016）对实时渲染来说开销过大</p></li>
<li><p><strong>Kulla-County Approximation</strong></p>
<ul>
<li><p>被遮挡 ==
发生下次弹射，从而有该经验性补全多次反射丢失能量的方法</p></li>
<li><p>考虑一次反射时有多少能量能够保留：假定入射光 <span
class="math inline">\(L_i=1\)</span> ，BRDF项为 <span
class="math inline">\(f(\mu_o,\mu_i,\phi)\)</span>
，则出射能量（BRDF、cosine、Lighting乘积）的积分为： <span
class="math display">\[
E(\mu_0)=\int_0^{2\pi}\int_0^1f(\mu_o,\mu_i,\phi)\mu_i\,\mathrm d
\mu_i\mathrm d\phi\\\mu=\sin\theta\quad(\text{用}\ \theta,\phi\
\text{定义立体角，换元积分})
\]</span></p></li>
<li><p>则损失能量为 <span class="math inline">\(1-E(\mu_o)\)</span>
，则只需补上这部分能量</p></li>
<li><p><span class="math inline">\(E(\mu_o)\)</span>
的积分值与观察方向有关</p></li>
<li><p>由于BRDF的可逆性（入射出射互相可逆），则其表示应具有对称性，因此损失能量的形式为：
<span class="math display">\[
c(1-E(\mu_i))(1-E(\mu_o))
\]</span> （凑积分简化的一种思路）</p></li>
<li><p>可得： <span class="math display">\[
f_{\rm ms}(\mu_o,\mu_i)=\dfrac{(1-E(\mu_i))(1-E(\mu_o))}{\pi(1-E_{\rm
avg})},\quad E_{\rm avg}=2\int_0^1E(\mu)\mu\,\mathrm d \mu
\]</span> （推导略）</p></li>
<li><p>此时将 <span class="math inline">\(f_{\rm
ms}(\mu_o,\mu_i)\)</span>
作为<strong>补全BRDF</strong>加入到渲染方程的积分中，就能够补全丢失的能量</p></li>
<li><p><strong>总结：设计一个function，即“补充的BRDF”，使得其积分等于丢失能量</strong></p></li>
<li><p>问题1： <span class="math inline">\(E_{\rm
avg}=2\int_0^1E(\mu)\mu\,\mathrm d \mu\)</span> 未知且计算困难</p>
<ul>
<li>预计算/打表</li>
<li>维度/依赖的参数 —— <span class="math inline">\(\mu_o\)</span>
和roughness</li>
<li>形成一张二维的表在渲染时直接查询</li>
</ul></li>
<li><p>效果
<img src="/images/games202/MissingEnergy3.jpg" alt="MissingEnergy3" style="zoom:50%;" /></p></li>
<li><p>问题2：若BRDF含有颜色</p>
<ul>
<li><p>颜色意味着有额外的能量损失（属于应该损失的）</p></li>
<li><p>先考虑没有颜色的全局能量损失，求出补全BRDF，再考虑由于颜色造成的能量损失</p></li>
<li><p><strong>Average
Fresnel</strong>：不管入射角大小平均反射的能量占比 <span
class="math display">\[
F_{\rm avg}=\dfrac{\int_0^1F(\mu)\mu\,\mathrm d\mu}{\int_0^1\mu\,\mathrm
d\mu}=2\int_0^1F(\mu)\mu\,\mathrm d\mu
\]</span></p></li>
<li><p><span class="math inline">\(E_{\rm avg}\)</span>
不参与后续弹射，因此将能量逐步计算</p></li>
<li><p>可以直接看到的 <span class="math inline">\(F_{\rm avg}E_{\rm
avg}\)</span></p></li>
<li><p>1次弹射后可以看到 <span class="math inline">\(F_{\rm
avg}(1-E_{\rm avg})\cdot F_{\rm avg}E_{\rm avg}\)</span></p></li>
<li><p>k次弹射后可以看到 <span class="math inline">\(F_{\rm
avg}^k(1-E_{\rm avg})^k\cdot F_{\rm avg}E_{\rm avg}\)</span></p></li>
<li><p>求和求级数得<strong>Color Term</strong> <span
class="math inline">\(\dfrac{F_{\rm avg}E_{\rm avg}}{1-F_{\rm
avg}(1-E_{\rm avg})}\)</span></p></li>
<li><p>将Color
Term乘到没有考虑颜色的补全BRDF上，得到最终的补全BRDF，加入渲染方程积分</p></li>
<li><p>结果
<img src="/images/games202/MissingEnergy4.jpg" alt="MissingEnergy4" style="zoom:50%;" />
↓
<img src="/images/games202/MissingEnergy5.jpg" alt="MissingEnergy5" style="zoom:50%;" /></p></li>
</ul></li>
</ul></li>
<li><p>近年出现的不用Kulla-County方法的、不好的Hack： 直接对Microfacet
BRDF增加一个diffuse lobe</p>
<ul>
<li>eg. 在CV领域作材质识别时</li>
<li>“完全错误” “不能更糟糕” “我从来没有这么教过你”</li>
<li>物理错误，无法保证能量守恒</li>
</ul></li>
</ul>
<h4
id="shading-with-microfacet-brdfs-under-polygonal-lighting-linearly-transformed-cosines-ltc">Shading
with Microfacet BRDFs under polygonal lighting – Linearly Transformed
Cosines (LTC)</h4>
<p>解决微表面模型着色问题</p>
<ul>
<li>主要针对GGX的NDF时（当然其他NDF也可以）</li>
<li>不考虑阴影</li>
<li>在多边形光源的情况下（不需要采样的方法）</li>
</ul>
<p><img src="/images/games202/LTC1.png" alt="LTC1" style="zoom: 25%;" /></p>
<blockquote>
<p>Lobe：瓣，如图蓝色区域，表示从视点发射的光线反射的分布，分布的形状类似一片花瓣。严格定义：BRDF的二维切片（BRDF输入两维、输出两维，
<span class="math inline">\(\theta\)</span> 和 <span
class="math inline">\(\phi\)</span> ，共四维）。</p>
</blockquote>
<p><strong>核心想法</strong>：</p>
<ul>
<li>BRDF的入射/出射的Lobe可以通过线性变换转换成余弦函数（转换到顶部，90度时最大，逐步向外减小）</li>
<li>多边形光源也可以作同样的线性变换</li>
<li>在这种情况下，在余弦Lobe上积分变形后的光源可以得到<strong>解析解</strong></li>
</ul>
<p><img src="/images/games202/LTC2.png" alt="LTC2" style="zoom: 40%;" /></p>
<p><strong>具体做法</strong>：</p>
<ul>
<li><p><span class="math display">\[
{\rm BRDF}\xrightarrow{M^{-1}}{\rm Cosine}\\
方向:\omega_i\xrightarrow{M^{-1}}\omega_i&#39;\\
积分域:P\xrightarrow{M^{-1}}P&#39;
\]</span>
<img src="/images/games202/LTC3.jpg" alt="LTC3" style="zoom: 25%;" />
<img src="/images/games202/LTC4.png" alt="LTC4" style="zoom: 40%;" /></p></li>
<li><p>替换一个变量 假设多边形光源是uniform的，即<span
class="math inline">\(L_i\)</span>对各方向保持一致，则 <span
class="math display">\[
\text{渲染方程}\quad L(\omega_o)=L_i\cdot\int_P F(\omega_i)\,\mathrm
d\omega_i\text{（BRDF、Cosine合并为$F()$）}\\
\omega_i=\dfrac{M\omega&#39;_i}{\|M\omega&#39;_i\|}\quad\text{代入替换得}\\
\begin{aligned}L(\omega_o)&amp;=L_i\cdot\int_P\cos(\omega&#39;_i)\,\mathrm
d\dfrac{M\omega&#39;_i}{\|M\omega&#39;_i\|}\\&amp;=L_i\cdot\int_{P&#39;}\cos(\omega&#39;_i)J\,\mathrm
d\omega&#39;_i\end{aligned}
\]</span></p></li>
<li><p>如何得到<span
class="math inline">\(M\)</span>：预计算（给初始值通过优化方法计算）</p></li>
</ul>
<h4 id="disney-principled-brdf">Disney Principled BRDF</h4>
<p>为什么需要？</p>
<ul>
<li>Microfacet模型不能表征所有真实感材质
<ul>
<li>不够Diffuse</li>
<li>无法解释多层材质（eg.刷有清漆的表面）</li>
</ul></li>
<li>Microfacet模型不够Artist-friendly
<ul>
<li>eg. 定义折射率的<span class="math inline">\(n\)</span>和<span
class="math inline">\(k\)</span></li>
</ul></li>
</ul>
<p>Disney Principled BRDF设计原则</p>
<ul>
<li>Art directable，不必须物理真实</li>
<li>还是一定程度上基于物理的（在实时渲染中）</li>
</ul>
<p><strong>Principle 原则</strong></p>
<ul>
<li>看起来直观，不用物理量</li>
<li>尽可能减少参数</li>
<li>0-1范围</li>
<li>允许&lt;0和&gt;1情况，呈现特殊效果</li>
<li>具有稳健性</li>
</ul>
<p>Disney Principled BRDF建立在拟合的基础上，有开放源码</p>
<blockquote>
<p>sheen : 绒毛，在grazing angle上有类似羽化效果 clearcoat :
类似清漆的透明层</p>
</blockquote>
<p>维度多时，会出现多种参数呈现类似结果的现象</p>
<p><strong>优劣势</strong></p>
<ul>
<li>易于理解/控制</li>
<li>能描述的材质广泛</li>
<li>开源的实现</li>
<li>不完全基于物理</li>
<li>巨大的参数空间</li>
</ul>
<h4 id="non-photorealistic-rendering">Non-Photorealistic Rendering</h4>
<p>== (fast and reliable) stylization</p>
<p><strong>风格化</strong></p>
<ul>
<li>描边</li>
<li>模型简化、色块</li>
<li>阴影分界线</li>
</ul>
<p><strong>轮廓</strong></p>
<p><img src="/images/games202/NPR1.jpg" alt="NPR1" style="zoom: 25%;" /></p>
<ul>
<li><p>分类</p>
<ul>
<li>边界 Boundary / Border edge</li>
<li>折痕 Crease</li>
<li>材质边缘 Material edge</li>
<li>有多个面共享的外轮廓线 Silhouette edge</li>
</ul></li>
<li><p>Silhouette edge 描边绘制</p>
<ul>
<li><p>Silhouette edge处观察方向与法线方向几乎垂直</p>
<ul>
<li>设定观察方向与发现夹角的阈值，超过的像素设黑</li>
<li>问题：描边粗细不一样</li>
</ul></li>
<li><p>背面的三角形/模型扩大一小圈渲染为黑</p></li>
<li><p>图像后处理：Edge Detect</p>
<ul>
<li><p>Sobel Detector 纵向/横向，色块处两侧抵消，分界线两侧不抵消 <span
class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; -1\\
2 &amp; 0 &amp; -2\\
1 &amp; 0 &amp; -1
\end{bmatrix}\quad
\begin{bmatrix}
-1 &amp; -2 &amp; -1\\
0 &amp; 0 &amp; 0\\
1 &amp; 2 &amp; 1
\end{bmatrix}
\]</span></p>
<center>
<p><img src="/images/games202/NPR2.jpg" alt="NPR2" style="zoom:50%;" /><img src="/images/games202/NPR3.jpg" alt="NPR3" style="zoom:50%;" /></p>
<center/></li>
<li><p>利用G-Buffer信息，深度、法线等</p></li>
</ul></li>
</ul></li>
<li><p>色块</p>
<ul>
<li>先得到正常的shading结果，再做一个阈值化（多值化 Quantization）</li>
<li>在不同的部分（Diffuse、Specular…）应用不同的阈值化方法</li>
</ul></li>
<li><p>素描效果</p>
<ul>
<li>阴影部分打横竖线格，格子密度与阴影明暗相关</li>
<li>提前设计不同密度的格状纹理查询（结果邻近像素查询纹理邻近像素，保证笔触连续）</li>
<li>对每种纹理做MIPMAP时，保证每一级MIPMAP的密度一致（类似裁切而非等比缩小）</li>
</ul>
<p><img src="/images/games202/NPR4.jpg" alt="NPR4" style="zoom: 33%;" /></p></li>
</ul>
<p><strong>真实感模型是非真实感渲染的基础。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-11-数值分析-Day14-RungeKutta方法-线性多步方法</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 11 Mar 2021 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/</guid>
      <description>7.5 - 7.7 Runge-Kutta方法 单步高阶方法构造思路 设 \(y(x)\) 是一阶常微分方程初值问题的精确解，Taylor展开得： \[ \begin{aligned} \displaystyle y(x_{n+1})&amp;amp;=y(x_n)+y&amp;#39;(x_n)h+\frac{y&amp;#39;&amp;#39;(x_n)}{2!}h^2+\dots+\frac{y^{(p)}(x_n)}{p!}h^p+\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\ &amp;amp;=y(x_n)+hf(x_n,y(x_n))+\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\end{aligned} \] 因此可建立节点处近似值 \(y_n\) 满足的差分公式： \[ \left\{\begin{array}{l}\displaystyle y_{n+1}=y_n+hf(x_n,y_n)+\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\y_0=\alpha,\quad n=0,1,\dots,N-1\end{array}\right. \] 称之为 \(\mathbf p\) 阶Taylor展开方法。 其中： \(\begin{array}{l}\displaystyle f^{(1)}(x,y)=\frac{\partial f(x,y)}{\partial x}+\frac{\partial f(x,y)}{\partial y}f(x,y)\\\displaystyle f^{(2)}(x,y)=\frac{\partial^2f}{\partial x^2}+2\frac{\partial^2f}{\partial x\partial y}f+\frac{\partial^2 f}{\partial y^2}f^2+\frac{\partial f}{\partial x}\frac{\partial f}{\partial y}+\left(\frac{\partial f}{\partial y}\right)^2f\\\dots\end{array}\)
计算过于复杂，很少直接使用
减少Taylor展开次数得： \[ y(x_{n+1})=y(x_n)+hy&amp;#39;(\xi)=y(x_n)+hf(\xi,y(\xi)),\quad x_n\le\xi\le x_{n+1} \] 构造差分方法即利用适当的函数值来近似计算 \(f(\xi,y(\xi))\) 。
Euler方法用 \(K_1\) 作为其近似，其 \(y_{n+1}\) 表达式与精确解的Taylor展式前 \(2\) 项一致。为 \(1\) 阶方法。 改进Euler方法用 \(K_1,K_2\) 的线性组合作为其近似，其 \(y_{n+1}\) 表达式与精确解的Taylor展式前 \(3\) 项一致。为 \(2\) 阶方法。 能否增加计算 \(f(x,y)\) 的次数来提高方法阶数？ Runge-Kutta方法 \[ \left\{\begin{array}{l} y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2+\dots+\lambda_pK_p)\\ K_1=f(x_n,y_n)\\ K_2=f(x_n+\alpha_2h,y_n+h\beta_{21}K_1)\\ \dots\\ K_p=f(x_n+\alpha_ph,y_n+h\sum\limits_{i=1}^{p-1}\beta_{pi}K_i) \end{array}\right.</description>
      <content:encoded><![CDATA[<h3 id="runge-kutta方法">7.5 - 7.7 Runge-Kutta方法</h3>
<h4 id="单步高阶方法构造思路">单步高阶方法构造思路</h4>
<p>设 <span class="math inline">\(y(x)\)</span>
是一阶常微分方程初值问题的精确解，Taylor展开得： <span
class="math display">\[
\begin{aligned}
\displaystyle
y(x_{n+1})&amp;=y(x_n)+y&#39;(x_n)h+\frac{y&#39;&#39;(x_n)}{2!}h^2+\dots+\frac{y^{(p)}(x_n)}{p!}h^p+\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\
&amp;=y(x_n)+hf(x_n,y(x_n))+\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\end{aligned}
\]</span> 因此可建立节点处近似值 <span
class="math inline">\(y_n\)</span> 满足的差分公式： <span
class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_n+hf(x_n,y_n)+\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\dots+\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\y_0=\alpha,\quad
n=0,1,\dots,N-1\end{array}\right.
\]</span> 称之为 <span class="math inline">\(\mathbf p\)</span>
<strong>阶Taylor展开方法</strong>。 其中： <span
class="math inline">\(\begin{array}{l}\displaystyle
f^{(1)}(x,y)=\frac{\partial f(x,y)}{\partial x}+\frac{\partial
f(x,y)}{\partial y}f(x,y)\\\displaystyle
f^{(2)}(x,y)=\frac{\partial^2f}{\partial
x^2}+2\frac{\partial^2f}{\partial x\partial y}f+\frac{\partial^2
f}{\partial y^2}f^2+\frac{\partial f}{\partial x}\frac{\partial
f}{\partial y}+\left(\frac{\partial f}{\partial
y}\right)^2f\\\dots\end{array}\)</span></p>
<blockquote>
<p>计算过于复杂，很少直接使用</p>
</blockquote>
<p>减少Taylor展开次数得： <span class="math display">\[
y(x_{n+1})=y(x_n)+hy&#39;(\xi)=y(x_n)+hf(\xi,y(\xi)),\quad x_n\le\xi\le
x_{n+1}
\]</span> 构造差分方法即利用适当的函数值来近似计算 <span
class="math inline">\(f(\xi,y(\xi))\)</span> 。</p>
<ul>
<li>Euler方法用 <span class="math inline">\(K_1\)</span> 作为其近似，其
<span class="math inline">\(y_{n+1}\)</span>
表达式与精确解的Taylor展式前 <span class="math inline">\(2\)</span>
项一致。为 <span class="math inline">\(1\)</span> 阶方法。</li>
<li>改进Euler方法用 <span class="math inline">\(K_1,K_2\)</span>
的线性组合作为其近似，其 <span class="math inline">\(y_{n+1}\)</span>
表达式与精确解的Taylor展式前 <span class="math inline">\(3\)</span>
项一致。为 <span class="math inline">\(2\)</span> 阶方法。</li>
<li>能否增加计算 <span class="math inline">\(f(x,y)\)</span>
的次数来提高方法阶数？</li>
</ul>
<h4 id="runge-kutta方法-1">Runge-Kutta方法</h4>
<p><span class="math display">\[
\left\{\begin{array}{l}
y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2+\dots+\lambda_pK_p)\\
K_1=f(x_n,y_n)\\
K_2=f(x_n+\alpha_2h,y_n+h\beta_{21}K_1)\\
\dots\\
K_p=f(x_n+\alpha_ph,y_n+h\sum\limits_{i=1}^{p-1}\beta_{pi}K_i)
\end{array}\right.
\]</span> 其中 <span
class="math inline">\(\{\lambda_i,\alpha_i,\beta_{ij}\}\)</span>
为待定系数，此公式称为 <span class="math inline">\(\mathbf p\)</span>
<strong>级Runge-Kutta方法</strong>。 若该公式局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> ，则称其为 <span
class="math inline">\(\mathbf p\)</span>
<strong>阶Runge-Kutta方法</strong>。</p>
<ul>
<li><span class="math inline">\(\mathbf{p=2}\)</span> 时，二级R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  y_{n+1}=y_n+h(\lambda_1K_1+\lambda_2K_2)\\
  K_1=f(x_n,y_n)\\
  K_2=f(x_n+\alpha h,y_n+h\beta K_1)\\
  \end{array}\right.
  \]</span> Taylor展开分析易得，只要令 <span
class="math inline">\(\lambda_1+\lambda_2=1,\ \alpha\lambda_2=1/2,\
\beta\lambda_2=1/2\)</span> 即可使局部截断误差达到 <span
class="math inline">\(O(h^3)\)</span>
，为二阶R-K公式。该条件有多组解：</li>
<li><span class="math inline">\(\alpha=1,\ \lambda_1=\lambda_2=1/2,\
\beta=1\)</span> 时即为改进Euler公式。</li>
<li><span class="math inline">\(\lambda_1=0,\ \lambda_2=1,\
\alpha=\beta=1/2\)</span> 时为<strong>中点公式</strong>。</li>
<li><span class="math inline">\(\mathbf{p=3}\)</span> 时，三阶R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  \displaystyle y_{n+1}=y_n+\frac{h}{6}(K_1+4K_2+K_3)\\
  \displaystyle K_1=f(x_n,y_n)\\
  \displaystyle K_2=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_1)\\
  \displaystyle K_3=f(x_n+h,y_n-hK_1+2hK_2)
  \end{array}\right.
  \]</span></li>
<li><span class="math inline">\(\mathbf{p=4}\)</span> 时，四阶R-K公式：
<span class="math display">\[
  \left\{\begin{array}{l}
  \displaystyle y_{n+1}=y_n+\frac{h}{6}(K_1+2K_2+2K_3+K_4)\\
  \displaystyle K_1=f(x_n,y_n)\\
  \displaystyle K_2=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_1)\\
  \displaystyle K_3=f(x_n+\frac{1}{2}h,y_n+\frac{1}{2}hK_2)\\
  \displaystyle K_4=f(x_n+h,y_n+hK_3)
  \end{array}\right.
  \]</span></li>
</ul>
<h5 id="隐式runge-kutta方法">隐式Runge-Kutta方法</h5>
<p>一般形式： <span class="math display">\[
\left\{\begin{array}{l}
\displaystyle y_{n+1}=y_n+h\sum_{r=1}^p\lambda_rK_r\\
\displaystyle
K_r=f(x_n+\alpha_rh,y_n+h\sum_{i=1}^r\lambda_{ri}K_i),\quad
r=1,2,\dots,p
\end{array}\right.
\]</span> 称为 <span class="math inline">\(\mathbf p\)</span>
<strong>级隐式Runge-Kutta方法</strong>。（如梯形公式就是二级隐式R-K方法。）</p>
<p>缺点是计算量较大，优点是数值稳定性好。</p>
<h5 id="变步长runge-kutta方法">变步长Runge-Kutta方法</h5>
<p>设从 <span class="math inline">\(x_n\)</span> 以步长 <span
class="math inline">\(h\)</span> 计算 <span
class="math inline">\(y(x_{n+1})\)</span> 的近似值为 <span
class="math inline">\(y_{n+1}^{(h)}\)</span> ，设有局部截断误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}^{(h)}=Ch^{p+1}\)</span> 。</p>
<p>设从 <span class="math inline">\(x_n\)</span> 以步长 <span
class="math inline">\(\frac{h}{2}\)</span> 计算 <span
class="math inline">\(y(x_{n+1})\)</span> 的近似值为 <span
class="math inline">\(y_{n+1}^{(\frac{h}{2})}\)</span>
，则有局部截断误差 <span class="math inline">\(\displaystyle
y(x_{n+1})-y_{n+1}^{(\frac{h}{2})}\approx \frac{1}{2^p}Ch^{p+1}\)</span>
。</p>
<p>两式相除得 <span
class="math inline">\(\displaystyle\frac{y(x_{n+1})-y_{n+1}^{(\frac{h}{2})}}{y(x_{n+1})-y_{n+1}^{(h)}}\approx\frac{1}{2^p}\)</span>
，从而得事后误差估计 <span class="math inline">\(\displaystyle
y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)}\approx\frac{1}{2^p-1}(y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)})\)</span>
。</p>
<p>因此当 <span
class="math inline">\(\displaystyle\left|y_{n+1}^{(\frac{h}{2})}-y_{n+1}^{(h)}\right|\le\varepsilon\)</span>
时，可取 <span class="math inline">\(\displaystyle
y_{n+1}^{(\frac{h}{2})}\approx y_{n+1}^{(h)}\)</span>
，否则将步长减半计算，直至满足精度要求。</p>
<h3 id="单步方法的性质">7.7 - 7.11 单步方法的性质</h3>
<h4 id="收敛性">收敛性</h4>
<p>求解初值问题的单步显式方法可统一写为如下形式： <span
class="math display">\[
y_{n+1}=y_n+h\Phi(x_n,y_n,h)
\]</span> 其中 <span class="math inline">\(\Phi(x,y,h)\)</span>
称为<strong>增量函数</strong>。不同方法对应着不同的增量函数。</p>
<p><strong>定义</strong>：设 <span class="math inline">\(y(x)\)</span>
是一阶常微分方程初值问题的精确解， <span
class="math inline">\(y_n\)</span>
是某单步方法产生的近似解，如任一固定点 <span
class="math inline">\(x_n\)</span> ，均有： <span
class="math display">\[
\displaystyle\lim_{h\to0}y_n=y(x_n)
\]</span> 则称此单步方法<strong>收敛</strong>。因为此时 <span
class="math inline">\(y(x_n)-y_n\)</span> 不仅与 <span
class="math inline">\(y_{n+1}\)</span> 一步计算有关，而与前面的 <span
class="math inline">\(n\)</span>
步计算均有关，故称之为<strong>整体截断误差</strong>。（该定义也适用于单步隐式方法和多步方法。）</p>
<p><strong>定理</strong>：若某单步显式方法满足： + 是 <span
class="math inline">\(p\)</span> 阶方法，也即局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> ； + 增量函数 <span
class="math inline">\(\Phi(x,y,h)\)</span> 在区域 <span
class="math inline">\(\{a\le x\le b,-\infty&lt;y&lt;+\infty,0\le h\le
h_0\}\)</span> 上连续，且关于 <span class="math inline">\(y\)</span>
满足Lipschitz条件，即存在常数 <span
class="math inline">\(L&gt;0\)</span> 使 <span
class="math inline">\(|\Phi(x,y,h)-\Phi(x,\bar{y},h)|\le
L|y-\bar{y}|\)</span> ； + 初始近似 <span
class="math inline">\(y_0=y(\alpha)=\alpha\)</span> 。
则此单步方法收敛，且存在与 <span class="math inline">\(h\)</span>
无关的常数 <span class="math inline">\(C\)</span> ，使得 <span
class="math inline">\(|y(x_n)-y_n|\le Ch^p\)</span> 。</p>
<p>易证，Euler方法、改进Euler方法均是收敛的。</p>
<p>（注意，此处差分方法的收敛性与前面构造改进Euler方法时所用到的“校正步骤的收敛性不同。）</p>
<h4 id="稳定性">稳定性</h4>
<blockquote>
<p>收敛性反映截断误差，稳定性反映舍入误差。</p>
</blockquote>
<p>下面用 <span class="math inline">\(y(x_n)\)</span> 表示精确值， <span
class="math inline">\(y_n\)</span> 表示理论计算值（只考虑截断误差），
<span class="math inline">\(\bar{y}_n\)</span>
表示实际计算值（还考虑舍入误差）。</p>
<p>讨论数值方法稳定性通常仅限于典型试验方程： <span
class="math inline">\(\displaystyle\frac{dy}{dx}=\lambda y\)</span>
，其中 <span class="math inline">\(\lambda\)</span> 为复数且 <span
class="math inline">\(Re(\lambda)&lt;0\)</span> 。</p>
<p><strong>定义1</strong>：对于某给定初值问题（试验方程），假设只在一个节点值
<span class="math inline">\(y_n\)</span> 上产生计算误差 <span
class="math inline">\(\delta\)</span>
，若该误差引起之后各节点的计算值变化均不超过 <span
class="math inline">\(\delta\)</span>
，则称此差分方法<strong>绝对稳定</strong>。（对一般差分方法。）</p>
<p><strong>定义2</strong>：将单步方法应用于解试验方程，假设得 <span
class="math inline">\(y_{n+1}=E(\lambda h)y_n\)</span> ，若满足条件
<span class="math inline">\(|E(\lambda h)|&lt;1\)</span>
，则称此单步方法<strong>绝对稳定</strong>。在复平面上，变量 <span
class="math inline">\(\lambda h\)</span> 满足 <span
class="math inline">\(|E(\lambda h)|&lt;1\)</span>
的区域称为该方法的<strong>绝对稳定域</strong>，其与实轴的交集称为<strong>绝对稳定区间</strong>。（
<span class="math inline">\(|E(\lambda h)|=1\)</span>
时也可认为误差没有增长，方法稳定。）（对单步方法。）</p>
<ul>
<li>Euler方法：绝对稳定域 <span class="math inline">\(|1+\lambda
h|&lt;1\)</span> ，绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>梯形公式：绝对稳定域 <span class="math inline">\(Re(\lambda
h)&lt;0\)</span> ，绝对稳定区间 <span
class="math inline">\((-\infty,0)\)</span> 。</li>
<li>改进Euler方法：绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>二阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2,0)\)</span> 。</li>
<li>三阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2.51,0)\)</span> 。</li>
<li>四阶R-K方法：绝对稳定区间 <span
class="math inline">\((-2.78,0)\)</span> 。</li>
</ul>
<p>综上，单步显式方法的稳定性与步长密切相关。步长过小时又会导致计算量过大。</p>
<h3 id="线性多步方法">7.12 - 7.13 线性多步方法</h3>
<blockquote>
<p>单步方法计算简便，但精度较低。精度较高的单步方法（如四阶R-K方法），计算量较大。</p>
</blockquote>
<h4 id="待定参数法构造线性多步方法">待定参数法构造线性多步方法</h4>
<p><span class="math display">\[
\displaystyle
y_{n+1}=\sum_{i=0}^r\alpha_iy_{n-i}+h\sum_{i=-1}^r\beta_if_{n-1}
\]</span></p>
<p>若 <span class="math inline">\(\beta_{-1}\neq0\)</span>
公式为隐式，反之为显式。</p>
<p>参数 <span class="math inline">\(\{\alpha_i,\beta_i\}\)</span>
的选择原则是使方法局部截断误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}=O(h^{r+2})\)</span> 。（指在
<span class="math inline">\(y(x_{n-i})=y_{n-i}\)</span>
前提下的截断误差。）</p>
<h4 id="数值积分构造线性多步方法">数值积分构造线性多步方法</h4>
<p>由 <span class="math display">\[
\displaystyle y(x_{n+1})=y(x_n)+\int_{x_n}^{x_{n+1}}f(x,y(x))dx
\]</span> 设 <span class="math inline">\(p_r(x)\)</span> 为函数 <span
class="math inline">\(f(x,y(x))\)</span> 的某个 <span
class="math inline">\(r\)</span> 次插值多项式，则有 <span
class="math display">\[
\displaystyle y(x_{n+1})=y(x_n)+\int_{x_n}^{x_{n+1}}p_r(x)dx+R_n
\]</span> 其中 <span
class="math inline">\(R_n=\int_{x_n}^{x_{n+1}}(f(x,y(x))-p_r(x))dx\)</span>
。由此可建立差分公式： <span class="math display">\[
\displaystyle y_{n+1}=y_n+\int_{x_n}^{x_{n+1}}p_r(x)dx
\]</span></p>
<h5 id="adams显式公式">Adams显式公式</h5>
<p>设精确解 <span class="math inline">\(y(x)\)</span> 在步长为 <span
class="math inline">\(h\)</span> 的等距节点 <span
class="math inline">\(x_{n-r},\dots,x_n\)</span> 上的近似值 <span
class="math inline">\(y_{n-r},\dots,y_n\)</span> 。 记 <span
class="math inline">\(f_k=f(x_k,y_k)\)</span> ，利用 <span
class="math inline">\(r+1\)</span> 个数据 <span
class="math inline">\((x_{n-r},f_{n-r}),\dots,(x_n,f_n)\)</span> 构造
<span class="math inline">\(r\)</span> 次Lagrange插值多项式： <span
class="math display">\[
\displaystyle p_r(x)=\sum_{j=0}^rl_{n-j}(x)f_{n-j}
\]</span> 其中: <span class="math display">\[
\displaystyle l_{n-j}(x)=\prod_{k=0,k\neq
j}^r\frac{x-x_{n-k}}{x_{n-j}-x_{n-k}},\quad j=0,1,\dots,r
\]</span> 由此建立差分公式： <span class="math display">\[
\displaystyle
y_{n+1}=y_n+\sum_{j=0}^r\left(\int_{x_n}^{x_{n+1}}l_{n-j}(x)dx\right)f_{n-j}
\]</span></p>
<p>由此整理得差分公式的具体形式： <span class="math display">\[
\begin{array}{c}\displaystyle
y_{n+1}=y_n+h\sum_{j=0}^r\beta_{rj}f_{n-j}\\
令x=x_n+th,\displaystyle\quad\beta_{rj}=\frac{(-1)^j}{j!(r-j)!}\int_0^1\prod_{k=0,k\neq
j}^r(t+k)dt,\quad j=0,1,\dots,r\end{array}
\]</span> 称之为 <span class="math inline">\(\mathbf{r+1}\)</span>
<strong>步Adams显式公式</strong>。</p>
<ul>
<li><span class="math inline">\(r=0,\quad\displaystyle
y_{n+1}=y_n+hf_n+\frac{1}{2}h^2y&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=1,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{2}(3f_n-f_{n-1})+\frac{5}{12}h^3y&#39;&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=2,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{12}(23f_n-16f_{n-1}+5f_{n-2})+\frac{3}{8}h^4y^{(4)}(x_n)\)</span></li>
<li><span class="math inline">\(r=3,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{24}(55f_n-59f_{n-1}+37f_{n-2}-9f_{n-3})+\frac{251}{720}h^5y^{(5)}(x_n)\)</span></li>
</ul>
<h5 id="adams隐式公式">Adams隐式公式</h5>
<p>利用 <span class="math inline">\(r+1\)</span> 个数据 <span
class="math inline">\((x_{n-r+1},f_{n-r+1}),\dots,(x_{n+1},f_{n+1})\)</span>
，则可到处数值稳定性较好的隐式公式，其一般形式为： <span
class="math display">\[
\begin{array}{c}\displaystyle
y_{n+1}=y_n+h\sum_{j=0}^r\beta_{rj}^*f_{n-j+1}\\
令x=x_n+th,\displaystyle\quad\beta_{rj}^*=\frac{(-1)^j}{j!(r-j)!}\int_{-1}^0\prod_{k=0,k\neq
j}^r(t+k)dt,\quad j=0,1,\dots,r\end{array}
\]</span></p>
<ul>
<li><span class="math inline">\(r=0,\quad\displaystyle
y_{n+1}=y_n+hf_{n+1}+\frac{1}{2}h^2y&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=1,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{2}(f_{n+1}+f_n)-\frac{1}{12}h^3y&#39;&#39;&#39;(x_n)\)</span></li>
<li><span class="math inline">\(r=2,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{12}(5f_{n+1}-8f_n-f_{n-1})-\frac{1}{24}h^4y^{(4)}(x_n)\)</span></li>
<li><span class="math inline">\(r=3,\quad\displaystyle
y_{n+1}=y_n+\frac{h}{24}(9f_{n+1}+19f_n-5f_{n-1}+f_{n-2})-\frac{19}{720}h^5y^{(5)}(x_n)\)</span></li>
</ul>
<h5 id="adams预估-校正公式">Adams预估-校正公式</h5>
<p>由显式公式提供一个预估值，再用隐式公式校正一次得到数值解，称为预估-校正方法。
一般预估公式和校正公式都采用同阶公式（ <span
class="math inline">\(r\)</span> 相等）。</p>
<p>如使用四阶Adams显式公式和隐式公式则： <span class="math display">\[
\bar{f}_{n+1}=f(x_{n+1},\bar{y}_{n+1}),\ n=3,4,\dots
\]</span>
称为<strong>四阶Adams预估校正公式</strong>，实际计算中通常用四阶单步方法（如四阶R-K公式）为其提供起始值
<span class="math inline">\(y_1,y_2,y_3\)</span> 。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-03-11-GAMES202高质量实时渲染-Lecture8-9-GI in Screen Space</title>
      <link>https://elderlyaugustus.github.io/posts/2022-03-11-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture8-9-giinss/</link>
      <pubDate>Thu, 11 Mar 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-03-11-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture8-9-giinss/</guid>
      <description>Lecture 8-9 Real-time Global Illumination （Screen Space） Screen Space : 利用相机视角渲染出来的屏幕中的所有信息 可以认为是对渲染结果的Post Processing
Screen Space Ambient Occlusion (SSAO) AO 环境光遮蔽 : 通过Contact Shadow使物体间相对位置明显SSAO : 对全局光照的近似的屏幕空间方法
Key idea :
不知道间接光照 假定间接光照值是常数（对所有着色点、从所有方向） like Blinn-Phong 考虑不同着色点对各方向的Visibility（不同于Blinn-Phong的地方） 离线渲染中的AO——“天光”：等同于一个完全均匀的光照
Theory :
Rendering Equation \[ L_o(\mathrm p,\omega_0)=\int_{\Omega_\mathrm{patch}}L_i(\mathrm p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)V(\mathrm p,\omega_i)\cos\theta_i\,\mathrm d\omega_i \]
考虑对Rendering Equation的近似（“The RTR Approximation / Equation”） \[ \int_\Omega f(x)g(x)\,\mathrm d x\approx\dfrac{\int_{\Omega_G} f(x)\,\mathrm d x}{\int_{\Omega_G} \,\mathrm d x}\cdot\int_\Omega g(x)\,\mathrm d x \] 将Visibility项拆出，得： \[ \begin{aligned} L_o^{\rm indir}(\mathrm p,\omega_0)\approx&amp;amp;\dfrac{\int_{\Omega_+} V(\mathrm p,\omega_i)\cos\theta_i\,\mathrm d\omega_i}{\int_{\Omega_+}\cos\theta_i\,\mathrm d\omega_i}\cdot\\ \approx&amp;amp;\int_{\Omega_+}L_i^{\rm indir}(\mathrm p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)\cos\theta_i\,\mathrm d\omega_i\\ =&amp;amp;k_A\cdot \underbrace{L_i^{\rm indir}(p)\rho}_{\rm constant\ for\ AO} \end{aligned} \]</description>
      <content:encoded><![CDATA[<h3 id="lecture-8-9-real-time-global-illumination-screen-space">Lecture
8-9 Real-time Global Illumination （Screen Space）</h3>
<p><strong>Screen Space</strong> :
利用相机视角渲染出来的屏幕中的所有信息 可以认为是对渲染结果的Post
Processing</p>
<h4 id="screen-space-ambient-occlusion-ssao">Screen Space Ambient
Occlusion (SSAO)</h4>
<p><strong>AO 环境光遮蔽</strong> : 通过Contact
Shadow使物体间相对位置明显<strong>SSAO</strong> :
对全局光照的近似的屏幕空间方法</p>
<p><strong>Key idea</strong> :</p>
<ul>
<li>不知道间接光照</li>
<li>假定间接光照值是常数（对所有着色点、从所有方向）
<ul>
<li>like Blinn-Phong</li>
</ul></li>
<li>考虑不同着色点对各方向的Visibility（不同于Blinn-Phong的地方）</li>
</ul>
<blockquote>
<p>离线渲染中的AO——“天光”：等同于一个完全均匀的光照</p>
</blockquote>
<p><img src="/images/games202/AO.png" alt="AO" style="zoom:50%;" /></p>
<p><strong>Theory</strong> :</p>
<ul>
<li><p>Rendering Equation <span class="math display">\[
L_o(\mathrm p,\omega_0)=\int_{\Omega_\mathrm{patch}}L_i(\mathrm
p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)V(\mathrm
p,\omega_i)\cos\theta_i\,\mathrm d\omega_i
\]</span></p></li>
<li><p>考虑对Rendering Equation的近似（“The RTR Approximation /
Equation”） <span class="math display">\[
\int_\Omega f(x)g(x)\,\mathrm d x\approx\dfrac{\int_{\Omega_G}
f(x)\,\mathrm d x}{\int_{\Omega_G} \,\mathrm d x}\cdot\int_\Omega
g(x)\,\mathrm d x
\]</span> 将Visibility项拆出，得： <span class="math display">\[
\begin{aligned}
L_o^{\rm indir}(\mathrm p,\omega_0)\approx&amp;\dfrac{\int_{\Omega_+}
V(\mathrm p,\omega_i)\cos\theta_i\,\mathrm
d\omega_i}{\int_{\Omega_+}\cos\theta_i\,\mathrm d\omega_i}\cdot\\
\approx&amp;\int_{\Omega_+}L_i^{\rm indir}(\mathrm
p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)\cos\theta_i\,\mathrm
d\omega_i\\
=&amp;k_A\cdot \underbrace{L_i^{\rm indir}(p)\rho}_{\rm constant\ for\
AO}
\end{aligned}
\]</span></p></li>
<li><p>A deeper understanding 1 <span class="math display">\[
\begin{aligned}
\int_\Omega f(x)g(x)\,\mathrm d x&amp;\approx\dfrac{\int_{\Omega_G}
f(x)\,\mathrm d x}{\int_{\Omega_G} \,\mathrm d x}\cdot\int_\Omega
g(x)\,\mathrm d x\\
&amp;=\overline{f(x)}\cdot\int_\Omega g(x)\,\mathrm d x
\end{aligned}
\]</span> 由于 <span class="math inline">\(g(x)\)</span>
值小且平滑时该近似较准确，此处 <span class="math inline">\(g(x)\)</span>
为常数，为准确拆分。</p></li>
<li><p>A deeper understanding 2 前面积分中， <span
class="math inline">\(\,\mathrm d x\)</span> 总是跟着 <span
class="math inline">\(\cos\theta_i\)</span> =&gt; 半球上的立体角投影
<span class="math inline">\(\,\mathrm d x_\perp=\cos\theta_i\,\mathrm d
\omega_i\)</span> ，将球面积分转换为圆盘积分（积分值为圆盘面积 <span
class="math inline">\(\pi\)</span> ）
<img src="/images/games202/SSAO1.jpg" alt="SSAO1" style="zoom:50%;" /></p></li>
<li><p><strong>回到SSAO的简单情况</strong>：</p>
<ul>
<li><p>均匀间接光照 <span class="math inline">\(L_i\)</span>
[常数]</p></li>
<li><p>Diffuse材质BRDF <span
class="math inline">\(f_r=\dfrac{\rho}{\pi}\)</span> [常数]</p></li>
<li><p>Rendering Equation拆成： <span class="math display">\[
\begin{aligned}
L_o(\mathrm p,\omega_0)&amp;=\int_{\Omega_+}L_i(\mathrm
p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)V(\mathrm
p,\omega_i)\cos\theta_i\,\mathrm d\omega_i\\
&amp;=\dfrac{\rho}{\pi}\cdot L_i(p)\cdot\int_{\Omega_+}V(\mathrm
p,\omega_i)\cos\theta_i\mathrm d\omega_i
\end{aligned}
\]</span> 则即需求 <span class="math inline">\(k_A\)</span></p></li>
</ul></li>
</ul>
<p><strong>How to compute</strong> : + In object space + Raycasting
against geometry + Slow, require simplifications and / or spatial data
structures + Depends of scene complexity + In screen space + Done in a
post-rendering pass + No pre-processing required + Doesn’t depend on
scene comple + Simple + Not physically accurate</p>
<p><strong>SSAO</strong></p>
<ul>
<li>考虑特定半径<strong>半球</strong>范围内的遮挡关系（忽略远处的间接光照）</li>
<li>在半径范围内随机撒点，通过点在物体内/外判断对光源可见性
判断方法：通过Z-Buffer记录的物体深度直接判断（可能出现中图红线处的判断失误，忽略该失误）<img
src="/images/games202/SSAO2.png" alt="SSAO2" /></li>
<li>理论上应在法线方向半球范围内考虑，但渲染过程不一定有Normal-Buffer。
则考虑，仅当随机点中有超过一半在物体内时考虑AO问题。计算时 <span
class="math inline">\({\rm AO} =
\dfrac{物体外的点}{物体内的点-随机点总数/2}\)</span></li>
<li>随机点采样数不足时，易出现噪点，可以后期直接降噪应用，对画面影响较小</li>
<li>问题：在两个完全不接触的物体边界可能出现AO效果</li>
</ul>
<p><strong>HBAO</strong> , Horizon based Ambient Occlusion :
在有Normal-Buffer情况下，在半球范围内撒点采样，对不同方向加权（根据方向与法线的差值）。（更加精确，也改善了不接触的物体边界的问题。）</p>
<h4 id="screen-space-directional-occlusion-ssdo">Screen Space
Directional Occlusion (SSDO)</h4>
<p>在SSAO基础上的提升，考虑更加精确的间接光照</p>
<p><strong>Key idea</strong> :</p>
<ul>
<li>不再假设间接光照都是均匀的</li>
<li>有一些间接光照的信息已经知道——参考RSM中，直接光照的接收者</li>
</ul>
<p><strong>效果</strong> : 遮蔽不再简单变暗，而是带有Color
Blending效果</p>
<p><strong>思路</strong> :</p>
<ul>
<li>很像Path Tracing</li>
<li>在着色点P处随机发射一根光线</li>
<li>若未hit物体，则判为直接光照</li>
<li>若hit物体，则判为间接光照</li>
</ul>
<blockquote>
<p>Comparison with SSAO :</p>
<ul>
<li>AO : 未被挡住的有间接光照、被挡住的没有</li>
<li>DO : 未被挡住的无间接光照、被挡住的有</li>
</ul>
<p>原因：AO假设间接光照来自远处、DO假设间接光照来自近处。理论正确方法=AO+DO。</p>
<p><img src="/images/games202/SSDO1.png" alt="SSDO1" style="zoom: 25%;" /></p>
</blockquote>
<p><strong>Theory</strong> : <span class="math display">\[
L_o^{\rm dir}(\mathrm p,\omega_0)=\int_{\Omega_+,\,V=1}L_i^{\rm
dir}(\mathrm p,\omega_i)f_r(\mathrm
p,\omega_i,\omega_0)\cos\theta_i\,\mathrm d\omega_i\\
L_o^{\rm indir}(\mathrm p,\omega_0)=\int_{\Omega_+,\,V=0}L_i^{\rm
indir}(\mathrm p,\omega_i)f_r(\mathrm
p,\omega_i,\omega_0)\cos\theta_i\,\mathrm d\omega_i
\]</span> 则关注下式，求 <span class="math inline">\(V=0\)</span>
时得到的间接光照，来自一个patch/pixel的间接光照求法在前课中已介绍</p>
<p><strong>具体做法</strong></p>
<ul>
<li><p>对着色点P法线方向的半球内，随机取几个点（eg. 下图ABCD）</p></li>
<li><p>同SSAO，用相机对采样点的可见性替代P点对采样点的可见性，得到满足要求的不可见点</p></li>
<li><p>将满足要求的不可见点作为间接光源计算P点处间接光照</p>
<p><img src="/images/games202/SSDO3.jpg" alt="SSDO3" style="zoom:25%;" /></p></li>
<li><p>BUG：如下图出现前后非接触物体时，用相机对采样点的可见性替代P点对采样点的可见性会错误
<img src="/images/games202/SSDO4.jpg" alt="SSDO4" style="zoom:25%;" /></p></li>
</ul>
<p><strong>问题</strong> :</p>
<ul>
<li><p>只能实现小范围的全局光照（半球范围内）</p></li>
<li><p>可见性问题（参考具体做法.BUG）</p></li>
<li><p><strong>丢失不可见面信息</strong>（所有SS方法都有的问题） eg.
下图中图3/4旋转后，丢失了方块深度面上的DO
<img src="/images/games202/SSDO5.jpg" alt="SSDO5" style="zoom:50%;" /></p></li>
</ul>
<h4 id="screen-space-reflection-ssr">Screen Space Reflection (SSR)</h4>
<p><strong><em>// “Screen Space Ray Tracing”</em></strong></p>
<p>SSR : 在屏幕空间作光线追踪</p>
<ul>
<li>Intersection : 任意光线与屏幕空间的场景求交</li>
<li>Shading : 交点处像素对着色点的“贡献”</li>
</ul>
<p>PS.反射信息绝大部分都是屏幕空间中已有的内容</p>
<p>可以做</p>
<ul>
<li>Specular 从着色点处trace镜面方向光线</li>
<li>Glossy 从着色点处，trace多根光线（根据BRDF）</li>
<li>Medium smoothness + normals 不光滑平面，根据法线和BRDF…</li>
<li>Variable smoothness</li>
</ul>
<p><strong>做法</strong></p>
<ul>
<li><p>Intersection</p>
<ul>
<li><p>逐渐往前走一小步</p></li>
<li><p>每步与Z-Buffer对比深度，若在深度内则判定相交
<img src="/images/games202/SSR1.png" alt="SSR1" style="zoom:33%;" /></p></li>
<li><p>步长过大不精准、过小效率低——动态自适应步长</p>
<ul>
<li><p>作深度的Mipmap（每一层的像素是下一层对应四个像素中的最小值，“最小池化”）
<img src="/images/games202/DepthMipmap1.png" alt="DepthMipmap" style="zoom: 20%;" /></p></li>
<li><p>类似BVH、KD-Tree的加速结构</p></li>
<li><p>在与上层（低分辨率）的深度图相交的情况下，下层（高分辨率）的深度图才可能相交
<img src="/images/games202/DepthMipmap2.png" alt="DepthMipmap2" style="zoom: 25%;" /></p></li>
<li><p>先以低步长前进、与高精度Mipmap判断，若无相交则增大步长、降低Mipmap精度，若无相交则继续增大步长、降低Mipmap精度，直到产生相交则减小步长，提高Mipmap精度，直至最高精度</p>
<pre class="pseudocode"><code>mip = 0;
while (level &gt; -1)
  step through current cell;
  if (above Z plane) ++level;
  if (below Z plane) --level;</code></pre>
<p><img src="/images/games202/DepthMipmap3.gif" alt="DepthMipmap2" style="zoom: 25%;" /></p></li>
</ul></li>
</ul></li>
</ul>
<p><strong>问题</strong> : Screen Space
被遮挡的物体、范围外的物体均不参与反射，通常在反射边界做虚化</p>
<p><strong>Theory</strong> : 与Path
Tracing无异——仅假设被反射物（非反射材质）和次级光源为diffuse。（没有距离衰减、没有次级光源与着色点之间的可见性问题。）</p>
<p><strong>类似Path Tracing带来的效果</strong></p>
<ul>
<li>通过不同BRDF（不同数量光线）实现镜面、Glossy等多种反射</li>
<li>Contact hardening 离反射面越近越Sharp的现象</li>
<li>Specular elongation 各向同性问题（雨天灯光拉长）</li>
<li>逐像素的Roughness和Normal</li>
</ul>
<p><strong>Improvements</strong></p>
<ul>
<li>BRDF的重要性采样</li>
<li>邻近pixel的hit复用，增加了采样数</li>
<li>屏幕空间先做模糊，再做单次查询（filter较难做）</li>
</ul>
<p><strong>Summary</strong></p>
<ul>
<li>Pros
<ul>
<li>快速的Specular/Gloss反射</li>
<li>高质量</li>
<li>没有Spike和遮挡问题</li>
</ul></li>
<li>Cons
<ul>
<li>效率较Diffuse情况低</li>
<li>丢失屏幕空间以外的信息</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-10-数值分析-Day13-差分公式</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-10-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day13-%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Wed, 10 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-10-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day13-%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F/</guid>
      <description>7.1 - 7.4 差分公式 一阶常微分方程初值问题 一阶常微分方程初值问题的一般形式为：
\[ \left\{\begin{array}{l}\displaystyle\frac{dy}{dx}=f(x,y),\quad a\le x\le b\\y(a)=\alpha\end{array}\right. \] 其中 \(f(x,y)\) 为已知函数， \(\alpha\) 为给定的值。
在许多数学模型中，上述方程通常以 \(x\) 描述时间，而定解条件 \(y(a)=\alpha\) 则给出了函数 \(y(x)\) 在初始时刻的取值。因此称为初值问题。
问题： + 上述方程何时存在唯一解 + 如何计算 \(y(x)\)
Lipschitz条件： 若函数 \(f(x,y)\) 在区域 \(\{a\le x\le b,\ m&amp;lt;y&amp;lt;M\}\) 上连续，满足 \[ \forall y,\bar{y},\ |f(x,y)-f(x,\bar{y})|\le L|y-\bar{y}| \] 其中 \(L&amp;gt;0\) 为Lipschitz常数（此处Lipschitz常数可以 \(\ge1\) ），则初值问题在初始时刻 \(a\) 的某个邻域上存在唯一解。 （不满足Lipschitz条件时，不一定存在唯一解。）
构造一阶常微分方程初值问题数值解法 假设初值问题的解 \(y=y(x)\) 唯一存在且足够光滑。对求解区域 \([a,b]\) 做等距剖分 \(a=x_0&amp;lt;x_1&amp;lt;x_2&amp;lt;\dots&amp;lt;x_n&amp;lt;\dots&amp;lt;x_N=b\) 。称 \(h=(b-a)/N\) 为剖分步长， \(x_n=a+nh,\ n=0,1,\dots,N\) 为剖分节点。数值解法即求精确解 \(y(x)\) 在剖分节点 \(x_n\) 上的值 \(y(x_n)\) 的近似值 \(y_n\) 。</description>
      <content:encoded><![CDATA[<h3 id="差分公式">7.1 - 7.4 差分公式</h3>
<blockquote>
<h4 id="一阶常微分方程初值问题">一阶常微分方程初值问题</h4>
<p>一阶常微分方程初值问题的一般形式为：<br />
<span class="math display">\[
\left\{\begin{array}{l}\displaystyle\frac{dy}{dx}=f(x,y),\quad a\le x\le
b\\y(a)=\alpha\end{array}\right.
\]</span> 其中 <span class="math inline">\(f(x,y)\)</span> 为已知函数，
<span class="math inline">\(\alpha\)</span> 为给定的值。</p>
<p>在许多数学模型中，上述方程通常以 <span
class="math inline">\(x\)</span> 描述时间，而定解条件 <span
class="math inline">\(y(a)=\alpha\)</span> 则给出了函数 <span
class="math inline">\(y(x)\)</span>
在初始时刻的取值。因此称为<strong>初值问题</strong>。</p>
<p><strong>问题</strong>： + 上述方程何时存在唯一解 + 如何计算 <span
class="math inline">\(y(x)\)</span></p>
<p><strong>Lipschitz条件</strong>： 若函数 <span
class="math inline">\(f(x,y)\)</span> 在区域 <span
class="math inline">\(\{a\le x\le b,\ m&lt;y&lt;M\}\)</span>
上连续，满足 <span class="math display">\[
\forall y,\bar{y},\ |f(x,y)-f(x,\bar{y})|\le L|y-\bar{y}|
\]</span> 其中 <span class="math inline">\(L&gt;0\)</span>
为Lipschitz常数（此处Lipschitz常数可以 <span
class="math inline">\(\ge1\)</span> ），则初值问题在初始时刻 <span
class="math inline">\(a\)</span> 的某个邻域上存在唯一解。
（不满足Lipschitz条件时，不一定存在唯一解。）</p>
</blockquote>
<h4
id="构造一阶常微分方程初值问题数值解法">构造一阶常微分方程初值问题数值解法</h4>
<p>假设初值问题的解 <span class="math inline">\(y=y(x)\)</span>
唯一存在且足够光滑。对求解区域 <span
class="math inline">\([a,b]\)</span> 做等距剖分 <span
class="math inline">\(a=x_0&lt;x_1&lt;x_2&lt;\dots&lt;x_n&lt;\dots&lt;x_N=b\)</span>
。称 <span class="math inline">\(h=(b-a)/N\)</span>
为<strong>剖分步长</strong>， <span class="math inline">\(x_n=a+nh,\
n=0,1,\dots,N\)</span> 为<strong>剖分节点</strong>。数值解法即求精确解
<span class="math inline">\(y(x)\)</span> 在剖分节点 <span
class="math inline">\(x_n\)</span> 上的值 <span
class="math inline">\(y(x_n)\)</span> 的近似值 <span
class="math inline">\(y_n\)</span> 。</p>
<p><strong>差分公式</strong>：在区间 <span
class="math inline">\([x_n,x_{n+1}]\)</span>
上对微分方程两端同时积分有： <span class="math display">\[
\displaystyle y(x_{n+1})-y(x_n)=\int_{x_n}^{x_{n+1}}f(x,y(x))dx
\]</span>
对该式右边积分部分应用不同的数值积分公式（参考前一章）做逼近，就得到相应不同的差分公式。</p>
<ul>
<li><strong>Euler公式</strong>：对右边积分应用左矩形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx(b-a)f(a)\)</span>
，得到Euler差分公式： <span class="math display">\[
\left\{\begin{array}{l}y_{n+1}=y_n+hf(x_n,y_n)\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span></li>
<li><strong>梯形公式</strong>：对右边积分应用梯形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{(b-a)}{2}[f(a)+f(b)]\)</span>
，得到梯形差分公式： <span class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_n+\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span></li>
<li><strong>Euler中点公式</strong>：将积分范围扩大为 <span
class="math inline">\([x_{n-1},x_{n+1}]\)</span> ，有 <span
class="math display">\[
\displaystyle y(x_{n+1})-y(x_{n-1})=\int_{x_{n-1}}^{x_{n+1}}f(x,y(x))dx
\]</span> 对右边积分应用中矩形公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx(b-a)[f(\frac{a+b}{2})]\)</span>
，得到Euler中点公式（或称<strong>双步Euler公式</strong>）： <span
class="math display">\[
\left\{\begin{array}{l}\displaystyle
y_{n+1}=y_{n-1}+2hf(x_n,y_n)\\y_0=\alpha\\n=0,1,\dots,N-1\end{array}\right.
\]</span> 该公式属于多步方法，需要更多初值信息。</li>
</ul>
<p>其中，Euler公式和Euler中点公式为<strong>显式方法</strong>，梯形公式为<strong>隐式方法</strong>。</p>
<h4 id="改进euler方法">改进Euler方法</h4>
<blockquote>
<p>梯形公式计算精度好，但属于隐式公式，不便计算。</p>
</blockquote>
<p>根据非线性方程迭代法的思想，进行如下近似计算： <span
class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;y_{n+1}^{[0]}=y_n+hf(x_n)\\
\displaystyle&amp;y_{n+1}^{[k+1]}=y_n+\frac{h}{2}[f(x_n,y_n),f(x_{n+1},y_{n+1}^{[k]})]\\
&amp;&amp;k=0,1,\dots\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span> 即首先应用Euler公式提供 <span
class="math inline">\(y_{n+1}\)</span>
的初始值（<strong>预估</strong>），然后采用梯形公式框架进行关于 <span
class="math inline">\(y_{n+1}\)</span>
值的迭代计算（<strong>校正</strong>）。</p>
<blockquote>
<p>校正过程中迭代计算是否一定收敛？</p>
</blockquote>
<p>考察迭代格式，迭代函数为 <span class="math display">\[
\displaystyle\varphi(x)=y_n+\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y)]
\]</span></p>
<blockquote>
<p><strong>压缩映射原理</strong>：设函数 <span
class="math inline">\(f\)</span> 定义域和值域均为 <span
class="math inline">\([a,b]\)</span> ，并存在一个常数 <span
class="math inline">\(L\)</span> ，满足 <span
class="math inline">\(0&lt;L&lt;1\)</span> ，使得对 <span
class="math inline">\(\forall x,y\in[a,b]\)</span> ，都有 <span
class="math inline">\(|f(x)-f(y)|\le L|x-y|\)</span> ，则称 <span
class="math inline">\(f\)</span> 是 <span
class="math inline">\([a,b]\)</span> 上的一个压缩映射，称常数 <span
class="math inline">\(L\)</span>
为<strong>Lipschitz常数</strong>（压缩常数）。</p>
</blockquote>
<p>假设 <span class="math inline">\(\displaystyle\frac{\partial
f}{\partial y}\)</span> 存在，则当 <span
class="math inline">\(|\varphi&#39;(y)|\le L&lt;1\)</span> 也即 <span
class="math inline">\(\displaystyle\frac{h}{2}\left|\frac{\partial
f}{\partial y}\right|\le L&lt;1\)</span>
时，迭代必然收敛。理论上只需令剖分步长 <span
class="math inline">\(h\)</span> 足够小即可满足条件。 计算中，当 <span
class="math inline">\(\left|y_{n+1}^{[k+1]}-y_{n+1}^{[k]}\right|&lt;\varepsilon\)</span>
，取 <span class="math inline">\(y_{n+1}=y_{n+1}^{[k+1]}\)</span></p>
<p>若仅迭代一步则有： <span class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;\bar{y}_{n+1}=y_n+hf(x_n)\\
\displaystyle&amp;y_{n+1}=y_n+\frac{h}{2}[f(x_n,y_n),f(x_{n+1},\bar{y}_{n+1})]\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span>
称之为<strong>改进Euler方法</strong>，属于单步显式方法。也可写作： <span
class="math display">\[
\left\{\begin{aligned}
\displaystyle&amp;y_{n+1}=y_n+h(K_1+K_2)\\
&amp;K_1=f(x_n,y_n)\\
&amp;K_2=f(x_n+h,y_n+hK_1)\\
&amp;y_0=\alpha,\ n=0,1,\dots,N-1
\end{aligned}\right.
\]</span></p>
<h4 id="误差分析">误差分析</h4>
<p>在节点 <span class="math inline">\(x_{n+1}\)</span> 处的误差 <span
class="math inline">\(y(x_{n+1})-y_{n+1}\)</span> ，不仅与 <span
class="math inline">\(y_{n+1}\)</span> 这一步计算，而且与前 <span
class="math inline">\(n\)</span>
步均有关。为简化误差分析，着重研究一步计算时产生的截断误差，假设 <span
class="math inline">\(y_n=y(x_n)\)</span> ，称 <span
class="math inline">\(y(x_{n+1})-y_{n+1}\)</span>
为<strong>局部截断误差</strong>。</p>
<p>若单步差分公式的局部截断误差为 <span
class="math inline">\(O(h^{p+1})\)</span> （同阶无穷小），则称该公式为
<span class="math inline">\(p\)</span> 阶方法。 <span
class="math inline">\(p\)</span> 为非负整数，阶数越高精度越好。</p>
<blockquote>
<p>由一元Taylor公式： <span class="math display">\[
\displaystyle
y(x_{n+1})=y(x_n+h)=y(x_n)+y&#39;(x_n)h+\frac{y&#39;&#39;(x_n)}{2!}h^2+\frac{y&#39;&#39;&#39;(x_n)}{3!}h^3+O(h^4)
\]</span> 由二元Taylor公式： <span class="math display">\[
\displaystyle\begin{aligned}f(x_n+h,y_n+k)=&amp;f(x_n,y_n)+\frac{\partial
f(x_n,y_n)}{\partial x}h+\frac{\partial f(x_n,y_n)}{\partial y}k\\
&amp;+\frac{1}{2!}\left[\frac{\partial^2f(x_n,y_n)}{\partial
x^2}h^2+2\frac{\partial^2 f(x_n,y_n)}{\partial x \partial
y}hk+\frac{\partial^2f(x_n,y_n)}{\partial y^2} k^2\right]\\
&amp;+\dots+\frac{1}{k!}\left[h\frac{\partial}{\partial
x}+k\frac{\partial}{\partial y}\right]^kf(x_n,y_n)+\dots
\end{aligned}
\]</span></p>
</blockquote>
<p><strong>常见差分公式的局部截断误差</strong> + Euler公式： <span
class="math display">\[
  \displaystyle
y(x_{n+1})-y_{n+1}=\frac{y&#39;&#39;(x_n)}{2!}h^2+O(h^3)=O(h^2)
  \]</span> 因此Euler公式为 <span class="math inline">\(1\)</span>
阶方法。 + 改进Euler公式： <span class="math display">\[
  y(x_{n+1})-y_{n+1}=O(h^3)
  \]</span> 因此Euler公式为 <span class="math inline">\(2\)</span>
阶方法。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-09-数值分析-Day12-续数值积分-数值微分</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-09-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day12-%E7%BB%AD%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/</link>
      <pubDate>Tue, 09 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-09-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day12-%E7%BB%AD%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/</guid>
      <description>续：6.1 - 6.11 数值积分 复化求积公式 Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数 \(\ge8\) 时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即复化求积公式的基本思想。
在区间 \([a,b]\) 上，取等距节点 \(x_k=a+kh,\ k=0,1,\dots,n\) ，
由定积分的区间可加性得 \(\displaystyle\int_a^bf(x)dx=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}f(x)dx\) 。
若在每个小区间 \(x_{k-1},x_k\) 用梯形公式，则有复化梯形公式 \(T_n\) ：
\[ \displaystyle I=\int_a^bf(x)dx\approx T_n=\frac{h}{2}\sum_{k=1}^n\left[f(x_{k-1})+f(x_k)\right]=\frac{h}{2}\left[2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right] \]
复化梯形公式的的误差为：
\[ \begin{array}{l}\displaystyle I-T_n=-\frac{h^3}{12}[f&amp;#39;&amp;#39;(\xi_1)+\dots+f&amp;#39;&amp;#39;(\xi_n)]=-\frac{h^2(b-a)}{12}f&amp;#39;&amp;#39;(\eta),\quad\eta\in(a,b)\\\displaystyle \left|I-T_n\right|\le\frac{(b-a)^3}{12n^2}\max_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|\end{array} \]
可知复化梯形公式收敛，且要使得误差 \(\le\varepsilon\) ，只要 \(\left|I-T_n\right|\le\varepsilon\) 或 \(\displaystyle n&amp;gt;\sqrt{\frac{(b-a)^3\max_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|}{12\varepsilon}}\) 。 同理，复化Simpson公式 \(S_n\) ：
\[ \displaystyle I=\int_a^bf(x)dx\approx S_n=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right] \]
复化Simpson公式的误差为：
\[ \begin{array}{l}\displaystyle I-S_n=-\frac{h^4(b-a)}{2880}f^{4}(\eta),\quad\eta\in(a,b)\\\displaystyle \left|I-S_n\right|\le\frac{(b-a)^5}{2880n^4}\max_{a\le x\le b}|f^{(4)}(x)|\end{array} \]
可知收敛，且要使得误差 \(\le\varepsilon\) ，只要 \(\left|I-S_n\right|\le\varepsilon\) 或 \(\displaystyle n&amp;gt;\sqrt[4]{\frac{(b-a)^5\max_{a\le x\le b}|f^{(4)}(x)|}{2880\varepsilon}}\) 。 同理，复化Cotes公式 \(C_n\) ：</description>
      <content:encoded><![CDATA[<h3 id="续6.1---6.11-数值积分">续：6.1 - 6.11 数值积分</h3>
<h4 id="复化求积公式">复化求积公式</h4>
<blockquote>
<p>Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数
<span class="math inline">\(\ge8\)</span>
时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即<strong>复化求积公式</strong>的基本思想。</p>
</blockquote>
<p>在区间 <span class="math inline">\([a,b]\)</span> 上，取等距节点
<span class="math inline">\(x_k=a+kh,\ k=0,1,\dots,n\)</span> ，<br />
由定积分的区间可加性得 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\sum_{k=1}^n\int_{x_{k-1}}^{x_k}f(x)dx\)</span>
。</p>
<ul>
<li>若在每个小区间 <span class="math inline">\(x_{k-1},x_k\)</span>
用梯形公式，则有<strong>复化梯形公式</strong> <span
class="math inline">\(T_n\)</span> ：<br />
<span class="math display">\[
\displaystyle I=\int_a^bf(x)dx\approx
T_n=\frac{h}{2}\sum_{k=1}^n\left[f(x_{k-1})+f(x_k)\right]=\frac{h}{2}\left[2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]
\]</span><br />
复化梯形公式的的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-T_n=-\frac{h^3}{12}[f&#39;&#39;(\xi_1)+\dots+f&#39;&#39;(\xi_n)]=-\frac{h^2(b-a)}{12}f&#39;&#39;(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-T_n\right|\le\frac{(b-a)^3}{12n^2}\max_{a\le x\le
b}|f&#39;&#39;(x)|\end{array}
\]</span><br />
可知复化梯形公式收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-T_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle n&gt;\sqrt{\frac{(b-a)^3\max_{a\le
x\le b}|f&#39;&#39;(x)|}{12\varepsilon}}\)</span> 。</li>
<li>同理，<strong>复化Simpson公式</strong> <span
class="math inline">\(S_n\)</span> ：<br />
<span class="math display">\[
\displaystyle I=\int_a^bf(x)dx\approx
S_n=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]
\]</span><br />
复化Simpson公式的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-S_n=-\frac{h^4(b-a)}{2880}f^{4}(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-S_n\right|\le\frac{(b-a)^5}{2880n^4}\max_{a\le x\le
b}|f^{(4)}(x)|\end{array}
\]</span><br />
可知收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-S_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle
n&gt;\sqrt[4]{\frac{(b-a)^5\max_{a\le x\le
b}|f^{(4)}(x)|}{2880\varepsilon}}\)</span> 。</li>
<li>同理，<strong>复化Cotes公式</strong> <span
class="math inline">\(C_n\)</span> ：<br />
<span class="math display">\[
\begin{aligned}\displaystyle I&amp;=\int_a^bf(x)dx\approx
C_n\\&amp;=\frac{h}{90}\left\{32\sum_{k=1}^n\left[f(x_{k-\frac{3}{4}})+f(x_{k-\frac{1}{4}})\right]+12\sum_{k=1}^nf(x_{k-\frac{1}{2}})+14\sum_{k=1}^{n-1}f(x_k)+7f(a)+7f(b)\right\}\end{aligned}
\]</span><br />
复化Cotes公式的误差为：<br />
<span class="math display">\[
\begin{array}{l}\displaystyle
I-S_n=-\frac{h^6(b-a)}{1935360}f^{6}(\eta),\quad\eta\in(a,b)\\\displaystyle
\left|I-S_n\right|\le\frac{(b-a)^7}{1935360n^6}\max_{a\le x\le
b}|f^{(6)}(x)|\end{array}
\]</span><br />
可知收敛，且要使得误差 <span
class="math inline">\(\le\varepsilon\)</span> ，只要 <span
class="math inline">\(\left|I-S_n\right|\le\varepsilon\)</span> 或 <span
class="math inline">\(\displaystyle
n&gt;\sqrt[6]{\frac{(b-a)^7\max_{a\le x\le
b}|f^{(6)}(x)|}{1935360\varepsilon}}\)</span> 。</li>
</ul>
<h4 id="romberg求积公式">Romberg求积公式</h4>
<blockquote>
<p>复化求积公式对步长有较高要求。</p>
</blockquote>
<p><strong>由复化梯形公式推导</strong> 由梯形公式 <span
class="math inline">\(\begin{array}{l}\displaystyle
I-T_n=-\frac{(b-a)^3}{12n^2}f&#39;&#39;(\eta)\quad\eta\in(a,b)\\\displaystyle
I-T_{2n}=-\frac{(b-a)^3}{36n^2}f&#39;&#39;(\tilde{\eta})\quad\tilde{\eta}\in(a,b)\end{array}\)</span>
，视 <span class="math inline">\(f&#39;&#39;(\eta)\approx
f&#39;&#39;(\tilde{\eta})\)</span> ，<br />
得 <span class="math inline">\(\displaystyle
I\approx\frac{4T_{2n}-T_n}{3}\)</span> 或 <span
class="math inline">\(\displaystyle
I-T_{2n}\approx\frac{T_{2n}-T_n}{3}\)</span> 。</p>
<p>该二式表述精度更高，代入有 <span
class="math inline">\(\displaystyle\frac{4T_{2n}-T_n}{3}=\frac{h}{6}\left[4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\right]=S_n\)</span>
，即为Simpson公式。且 <span class="math inline">\(\displaystyle
T_{2n}=\frac{T_n}{2}+\frac{h}{2}\sum_{k=1}^nf(x_{k-\frac{1}{2}})\)</span>
。</p>
<ul>
<li>由此得逐次分半的复化梯形公式的递推公式： <span
class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots
\end{array}\right.
\]</span> 且要使得 <span
class="math inline">\(|I-T_{2^k}|&lt;\varepsilon\)</span> ，只要 <span
class="math inline">\(|T_{2^k}-T_{2^{k-1}}|&lt;3\varepsilon\)</span>
。</li>
<li>同理得逐次分半的复化Simpson公式的递推公式： <span
class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots\\
\displaystyle S_{2^{k-1}}=\frac{4T_{2^k}-T_{2^{k-1}}}{3},\quad
k=1,2,\dots
\end{array}\right.
\]</span></li>
</ul>
<p><strong>由复化Simpson公式推导</strong> 类似的推法得到 <span
class="math inline">\(\displaystyle
I\approx\frac{16S_{2n}-S_n}{15}\)</span> 或 <span
class="math inline">\(\displaystyle
I-S_{2n}\approx\frac{S_{2n}-S_n}{15}\)</span> 。且有 <span
class="math inline">\(\displaystyle\frac{16S_{2n}-S_n}{15}=C_n\)</span>
。</p>
<p><strong>由复化Cotes公式推导</strong></p>
<p>同理得 <span class="math inline">\(\displaystyle
I\approx\frac{64C_{2n}-C_n}{63}\)</span> 或 <span
class="math inline">\(\displaystyle
I-C_{2n}\approx\frac{C_{2n}-C_n}{63}\)</span> 。记 <span
class="math inline">\(\displaystyle R_n=\frac{64C_{2n}-C_n}{63}\)</span>
，即为<strong>Romberg求积公式</strong>。</p>
<h5 id="一般化推论">一般化推论</h5>
<p>令 <span class="math inline">\(T_{2^k}^{(1)}=T_{2^k},\
T_{2^k}^{(1)}=S_{2^k},\ T_{2^k}^{(2)}=C_{2^k},\
T_{2^k}^{(3)}=R_{2^k}\)</span> ，则有： <span class="math display">\[
\left\{\begin{array}{l}
\displaystyle T_{2^0}=T_1=\frac{b-a}{2}[f(a)+f(b)]\\
\displaystyle
T_{2^k}^{(0)}=\frac{T_{2^{k-1}}}{2}+\frac{b-a}{2^k}\sum_{i=1}^{2^{k-1}}f(a+\frac{(2i-1)(b-a)}{2^k}),\quad
k=1,2,\dots\\
\displaystyle
T_{2^k}^{(m)}=\frac{4^mT_{2^{k+1}}^{(m-1)}-T_{2^k}^{(m-1)}}{4^m-1},\quad
k=1,2,\dots,\ m=1,2,\dots
\end{array}\right.
\]</span> 且要使得 <span
class="math inline">\(|I-T_{2^k}^{(m)}|&lt;\varepsilon\)</span> ，只要
<span
class="math inline">\(|T_{2^k}^{(m)}-T_{2^{k-1}}^{(m)}|&lt;(4^{m+1}-1)\varepsilon,\
m=0,1,\dots\)</span> 。</p>
<blockquote>
<h4 id="正交多项式">正交多项式</h4>
<p><strong>函数内积</strong>：若 <span
class="math inline">\(f(x),g(x)\in C[a,b]\)</span> ，则称 <span
class="math inline">\(\displaystyle\int_a^bf(x)g(x)dx\)</span> 为 <span
class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(g(x)\)</span> 的内积，记为： <span
class="math inline">\((f,g)\)</span> ，其满足： + <span
class="math inline">\((f,g)=(g,f)\)</span> + <span
class="math inline">\((cf,g)=c(f,g)\)</span> + <span
class="math inline">\((f_1+f_2,g)=(f_1,g)+(f_2,g)\)</span> 若 <span
class="math inline">\((f,g)=0\)</span> ，则称 <span
class="math inline">\(f(x)\)</span> 与 <span
class="math inline">\(g(x)\)</span> <strong>正交</strong>，记为 <span
class="math inline">\(f\perp g\)</span> 。</p>
<p>利用内积可定义函数的<strong>平方模</strong> <span
class="math inline">\(\displaystyle\|f\|_2=\sqrt{(f,f)}=\sqrt{\int_a^bf^2(x)dx}\)</span>
，其满足： + <span class="math inline">\(\|f\|_2\ge0,\
\|f\|_2=0\Leftrightarrow f(x)=0\)</span> + <span
class="math inline">\(\|cf\|_2=|c|\|f\|_2\)</span> + <span
class="math inline">\(\|f,g\|_2\le\|f\|_2+\|g\|_2\)</span> + <span
class="math inline">\(\|(f,g)\|_2\le\|f\|_2\|g\|_2\)</span></p>
<p>常引进加权形式定义： <span
class="math inline">\(\displaystyle(f,g)=\int_a^b\rho(x)f(x)g(x)dx\)</span>
，则 <span
class="math inline">\(\displaystyle\|f\|_2=\sqrt{\int_a^b\rho(x)f^2(x)dx}\)</span>
。</p>
<p><strong>定理1</strong>：若 <span
class="math inline">\(f_0(x),f_1(x),\dots,f_n(x)\)</span> 为 <span
class="math inline">\(C[a,b]\)</span> 上的一组线性无关函数，则由 <span
class="math inline">\(f_k(x)\)</span> 线性组合可得到 <span
class="math inline">\(C[a,b]\)</span> 上的一组两两正交的函数组 <span
class="math inline">\(g_0(x),g_1(x),\dots,g_n(x)\)</span>
，单位化（平方模变为 <span class="math inline">\(1\)</span>
）为<strong>规范正交组</strong> <span
class="math inline">\(e_0(x),r_1(x),\dots,r_n(x)\)</span>
。（Schemite正交化）</p>
<p>将 <span class="math inline">\(P_n\)</span> 上由线性无关函数 <span
class="math inline">\(1,x,x^2,\dots,x^n\)</span>
经过Schemite正交化得到的多项式 <span
class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 称为 <span
class="math inline">\([a,b]\)</span>
上的<strong>正交多项式</strong>。</p>
<p>若 <span class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 为
<span class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式，则满足： + <span
class="math inline">\(p_k(x)\)</span> 时首项系数不为零的 <span
class="math inline">\(k\)</span> 次多项式 + <span
class="math inline">\(p_0(x),p_1(x),\dots,p_n(x)\)</span> 构成 <span
class="math inline">\(P_n\)</span> 上的一组正交基 + <span
class="math inline">\(p_n(x)\)</span> 与不高于 <span
class="math inline">\(n-1\)</span> 次的多项式正交, <span
class="math inline">\(p_n(x)\perp P_{n-1}\)</span> + 方程 <span
class="math inline">\(p_n(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上有 <span
class="math inline">\(n\)</span> 个单根 + 方程 <span
class="math inline">\(p_{n-1}(x)=0\)</span> 的根与方程 <span
class="math inline">\(p_n(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上交错分布</p>
<p><strong>常用正交多项式系</strong></p>
<ol type="1">
<li><strong>Legendre多项式</strong> <span
class="math inline">\(\displaystyle
L_n(x)=\frac{1}{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n\quad x\in[-1,1],\
n=0,1,\dots\)</span> ，权函数 <span
class="math inline">\(\displaystyle\rho(x)=1\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;\frac{2}{2n+1}&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
(n+1)L_{n+1}(x)=(2n+1)xL_n(x)-nL_{n-1}(x),\quad n\ge1\\L_0(x)=1,\
L_1(x)=x\end{array}\right.\)</span></li>
</ul></li>
<li><strong>Chebyshev多项式</strong> <span
class="math inline">\(T_n(x)=\cos(n\arccos x)\quad x\in[-1,1],\
n=0,1,\dots\)</span> ，权函数 <span
class="math inline">\(\displaystyle\rho(x)=\frac{1}{\sqrt{1-x^2}}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(T_m,T_n)=\left\{\begin{array}{l}0\quad\quad m\neq n\\\pi\quad\quad
m=n=0\\\pi/2\quad m=n\neq0\end{array}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
T_{n+1}(x)=2xT_n(x)-nT_{n-1}(x),\quad n=1,2,\dots\\T_0(x)=1,\
T_1(x)=x\end{array}\right.\)</span></li>
<li><span class="math inline">\(T_n(x)\)</span> 在 <span
class="math inline">\([-1,1]\)</span> 上的 <span
class="math inline">\(n\)</span> 个零点为 <span
class="math inline">\(\displaystyle
x_k^{(n)}=\cos\frac{2k-1}{2n}\pi,\quad k=1,2,\dots,n\)</span></li>
</ul></li>
<li><strong>Laguere多项式</strong> <span
class="math inline">\(\displaystyle
L_n(x)=e^x\frac{d^n}{dx^n}(x^ne^{-x}),\quad0&lt;x&lt;+\infty,\quad
n=0,1,2,\dots\)</span> ，权函数 <span
class="math inline">\(\rho(x)=e^{-x}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;(n!)^2&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
L_{n+1}(x)=(2n+1-x)L_n(x)-n^2L_{n-1}(x),\quad n=1,2,\dots\\L_0(x)=1,\
L_1(x)=1-x\end{array}\right.\)</span></li>
</ul></li>
<li><strong>Hermite多项式</strong> <span
class="math inline">\(\displaystyle
H_n(x)=(-1)^ne^{x^2}\frac{d^n}{dx^n}(e^{-x^2}),\quad-\infty&lt;x&lt;+\infty,\quad
n=0,1,2,\dots\)</span> ，权函数 <span
class="math inline">\(\rho(x)=e^{-x^2}\)</span>
<ul>
<li><span class="math inline">\(\displaystyle
(L_m,L_n)=\left\{\begin{aligned}&amp;0&amp;m\neq
n\\&amp;2^nn!\pi&amp;m=n\end{aligned}\right.\)</span></li>
<li>有三项递推关系 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
H_{n+1}(x)=2xH_n(x)-nH_{n-1}(x),\quad n\ge1\\H_0(x)=1,\
H_1(x)=2x\end{array}\right.\)</span></li>
</ul></li>
</ol>
</blockquote>
<h4 id="gauss型求积公式">Gauss型求积公式</h4>
<blockquote>
<p>对一个求积公式而言，若不固定节点位置，节点数不变的情况下，代数精度如何提高。</p>
</blockquote>
<p><strong>定理1</strong>：区间 <span
class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的具有 <span
class="math inline">\(n\)</span> 个节点的数值积分公式代数精度不超过
<span class="math inline">\(2n-1\)</span> 次。</p>
<p><strong>Gauss型求积公式</strong>：使求积公式具有 <span
class="math inline">\(2n-1\)</span> 次代数精度的节点 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span>
称为<strong>Gauss点</strong>，此时的插值型求积公式称为<strong>Gauss型求积公式</strong>：
<span
class="math inline">\(I\approx\displaystyle\sum_{i=1}^nA_if(x_i)\)</span>
。</p>
<p><strong>定理2</strong>：取区间 <span
class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式 <span
class="math inline">\(p_n(x)\)</span> 的 <span
class="math inline">\(n\)</span> 个零点 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span> 恰为Gauss点。</p>
<p>因此构造Gauss型求积公式的方法为：</p>
<ul>
<li>求出区间 <span class="math inline">\([a,b]\)</span> 上权函数为 <span
class="math inline">\(\rho(x)\)</span> 的正交多项式 <span
class="math inline">\(p_n(x)\)</span> ；</li>
<li>求出 <span class="math inline">\(p_n(x)\)</span> 的 <span
class="math inline">\(n\)</span> 个零点；</li>
<li>计算积分系数 <span
class="math inline">\(A_i=\displaystyle\int_a^bl_i(x)\rho(x)dx\)</span>
。</li>
</ul>
<p><strong>定理3</strong>：设 <span class="math inline">\(f(x)\in
C^{2n}[a,b]\)</span> ，则Gauss公式的误差为： <span
class="math inline">\(\displaystyle
R[f]=\int_a^bf(x)\rho(x)dx-\sum_{i=1}^nA_if(x_i)=\frac{f^{(2n)}(\eta)}{(2n)!}\int_a^b\rho(x)\omega^2(x)dx,\quad
\eta\in(a,b)\)</span></p>
<p><strong>常见Gauss型求积公式</strong></p>
<ul>
<li><p><strong>Gauss-Legendre求积公式</strong>：区间 <span
class="math inline">\([-1,1]\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_{-1}^1f(x)dx\approx\displaystyle\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Legendre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{2^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\eta),\quad\eta\in(-1,1)\)</span>
。</p>
<p>利用积分变换 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\frac{b-a}{2}\int_{-1}^1(\frac{a+b}{2}+\frac{b-a}{2}t)dt,\quad(x=\frac{(a+b)+(b-a)t}{2})\)</span><br />
可用Gauss-Legendre求积公式求任意区间的数值积分，其在 <span
class="math inline">\([a,b]\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span> 的求积公式为 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{2}\sum_{i=1}^{n}A_if(\frac{a+b}{2}+\frac{b-a}{2}x_i)\)</span>
。余项为 <span class="math inline">\(\displaystyle
R[f]=\frac{(b-a)^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\eta),\quad\eta\in(a,b)\)</span>
。</p></li>
<li><p><strong>Gauss-Laguerre求积公式</strong>：区间 <span
class="math inline">\([0,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=e^{-x}\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_0^\infty
e^{-x}f(x)dx\approx\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Laguerre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{(n!)^2}{(2n)!}f^{(2n)}(\eta),\quad\eta\in(0,+\infty)\)</span>
。</p>
<p>对 <span class="math inline">\([0,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=1\)</span>
的积分，也可构造Gauss-Laguerre求积公式（再乘一个 <span
class="math inline">\(e^x\)</span> ）： <span
class="math inline">\(\displaystyle\int_0^\infty
f(x)dx\approx\sum_{i=1}^nA_ie^{x_i}f(x_i)\)</span> 。</p></li>
<li><p><strong>Gauss-Hermite求积公式</strong>：区间 <span
class="math inline">\((-\infty,+\infty)\)</span> 上权函数 <span
class="math inline">\(\rho(x)=e^{-x^2}\)</span> 的Guass型求积公式 <span
class="math inline">\(\displaystyle\int_{-\infty}^\infty
e^{-x^2}f(x)dx\approx\sum_{i=1}^nA_if(x_i)\)</span>
，其Gauss点为Herimite多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为
<span class="math inline">\(\displaystyle
R[f]=\frac{n!\sqrt\pi}{2^n(2n)!}f^{(2n)}(\eta),\quad\eta\in(-\infty,+\infty)\)</span>
。</p>
<p>同理，对 <span class="math inline">\((-\infty,+\infty)\)</span>
上权函数 <span class="math inline">\(\rho(x)=1\)</span>
的积分，也可构造Gauss-Hermite求积公式（再乘一个 <span
class="math inline">\(e^{x^2}\)</span> ）： <span
class="math inline">\(\displaystyle\int_{-\infty}^\infty
f(x)dx\approx\sum_{i=1}^nA_ie^{x_i^2}f(x_i)\)</span> 。</p></li>
</ul>
<h3 id="数值微分">6.12 - 6.13 数值微分</h3>
<p><strong>数值微分</strong>是指用函数值的线性组合近似函数在某点的导数值。</p>
<h4 id="差商型数值微分">差商型数值微分</h4>
<ul>
<li><p><strong>向前差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0+h)-f(x_0)}{h}\)</span></p>
<p>Taylor展开得 <span class="math inline">\(\displaystyle
f(x_0+h)=f(x_0)+f&#39;(x_0)h+\frac{h^2}{2}f&#39;&#39;(x_0+\theta
h)\quad0\le\theta\le1\)</span><br />
可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-f(x_0)}{h}=-\frac{h}{2}f&#39;&#39;(x_0+\theta
h)\quad0\le\theta\le1\)</span></p></li>
<li><p><strong>向后差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0)-f(x_0-h)}{h}\)</span></p>
<p>Taylor展开得 <span class="math inline">\(\displaystyle
f(x_0-h)=f(x_0)-f&#39;(x_0)h+\frac{h^2}{2}f&#39;&#39;(x_0-\theta
h)\quad0\le\theta\le1\)</span><br />
可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0)-f(x_0-h)}{h}=\frac{h}{2}f&#39;&#39;(x_0-\theta
h)\quad0\le\theta\le1\)</span></p></li>
<li><p><strong>中心差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;(x_0)\approx\frac{f(x_0+h)-f(x_0-h)}{2h}\)</span></p>
<p>可得误差 <span class="math inline">\(\begin{aligned}\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-f(x_0-h)}{2h}&amp;=-\frac{h^2}{12}[f&#39;&#39;&#39;(x_0+\theta_1
h)+f&#39;&#39;&#39;(x_0-\theta_2
h)]\\&amp;=-\frac{h^2}{6}f&#39;&#39;&#39;(x_0+\theta
h)\quad\quad-1\le\theta\le1\end{aligned}\)</span></p></li>
<li><p><strong>二阶中心差商数值微分公式</strong>： <span
class="math inline">\(\displaystyle
f&#39;&#39;(x_0)\approx\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}\)</span></p>
<p>Taylor展开得 <span
class="math inline">\(\begin{array}{l}\displaystyle
f(x_0+h)=f(x_0)+hf&#39;(x_0)+\frac{h^2}{2}f&#39;&#39;(x_0)+\frac{h^3}{6}f&#39;&#39;&#39;(x_0)+\frac{h^4}{24}f^{(4)}(x_0+\theta_1
h)\\\displaystyle
f(x_0-h)=f(x_0)-hf&#39;(x_0)+\frac{h^2}{2}f&#39;&#39;(x_0)-\frac{h^3}{6}f&#39;&#39;&#39;(x_0)+\frac{h^4}{24}f^{(4)}(x_0-\theta_2
h)\end{array}\)</span><br />
两式相加可得误差 <span class="math inline">\(\displaystyle
f&#39;(x_0)-\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}=-\frac{h^2}{12}f^{(4)}(x_0+\theta
h)\quad\theta\in(-1,1)\)</span></p></li>
</ul>
<p>从截断误差的角度看，步长 <span class="math inline">\(h\)</span>
越小，计算越精确；但是 <span class="math inline">\(h\)</span>
过小时，计算过程中有相近的数相减，会严重损失数值精度。实际应用中，可采用步长逐次减半的方法确定最终补偿。记
<span class="math inline">\(G(h),\ G(h/2)\)</span>
分别为对应步长取值时的差商公式，对给定精度 <span
class="math inline">\(\varepsilon&gt;0\)</span> ，若 <span
class="math inline">\(|G(h)-G(h/2)|&lt;\varepsilon\)</span> 就取步长为
<span class="math inline">\(h/2\)</span> ，反之取 <span
class="math inline">\(h\)</span> 。</p>
<h4 id="插值型数值微分">插值型数值微分</h4>
<p>建立插值多项式 <span class="math inline">\(L_n(x)\)</span> ，取 <span
class="math inline">\(L_n&#39;(x)\)</span> 作为 <span
class="math inline">\(f&#39;(x)\)</span> 的近似。误差余项 <span
class="math inline">\(\displaystyle
f&#39;(x_k)-L_n&#39;(x_k)=\frac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x_k)\)</span>
（ <span class="math inline">\(x\neq x_k\)</span> 时难以分析）</p>
<p>仅考察节点处的导数值，假定所给节点等距。</p>
<ul>
<li><p><strong>两点公式</strong>：线性插值函数 <span
class="math inline">\(\displaystyle
L_1(x)=\frac{x-x_1}{x_0-x_1}f(x_0)+\frac{x-x_0}{x_1-x_0}f(x_1)\)</span>
，对公式两端求导，记 <span class="math inline">\(x_1-x_0=h\)</span>
，有：<br />
<span class="math inline">\(\displaystyle
L_1&#39;(x)=\frac{1}{h}[f(x_1)-f(x_0)]\)</span> ，<br />
得到两个两点公式： <span class="math inline">\(\displaystyle
L_1&#39;(x_0)=L_1&#39;(x_1)=\frac{1}{h}[f(x_1)-f(x_0)]\)</span></p></li>
<li><p><strong>三点公式</strong>：二次插值函数 <span
class="math inline">\(L_2(x)\)</span> ，对其求导，记 <span
class="math inline">\(x=x_0+th\)</span> ，有：<br />
<span class="math inline">\(\displaystyle
L_2&#39;(x)=\frac{1}{2h}[(2t-3)f(x_0)-(4t-4)f(x_1)+(2t-1)f(x_2)]\)</span><br />
得到三个三点公式： <span
class="math inline">\(\begin{array}{l}\displaystyle
L_2&#39;(x_0)=\frac{1}{2h}[-3f(x_0)+4f(x_1)-f(x_2)]\\L_2&#39;(x_1)=\frac{1}{2h}[-f(x_0)+f(x_2)]\\L_2&#39;(x_2)=\frac{1}{2h}[f(x_0)-4f(x_1)+3f(x_2)]\end{array}\)</span></p>
<p>再次求导，可以得到更高阶的数值微分公式 <span
class="math inline">\(\displaystyle
L_2&#39;&#39;(x)=\frac{1}{h^2}[f(x_0)-2f(x_1)+f(x_2)]\)</span></p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-08-数值分析-Day11-插值型数值积分</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-08-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day11-%E6%8F%92%E5%80%BC%E5%9E%8B%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</link>
      <pubDate>Mon, 08 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-08-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day11-%E6%8F%92%E5%80%BC%E5%9E%8B%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/</guid>
      <description>6.1 - 6.11 数值积分 牛顿-莱布尼茨公式： \(\displaystyle\int_a^bf(x)dx=F(b)-F(a)\)
问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。
【例】弧长积分： \(L=\displaystyle\int_a^b\sqrt{1+(f&amp;#39;(x))^2}dx\)
由定积分的定义 \(\displaystyle I=\int_a^bf(x)dx=F(b)-F(a)=\lim_{\Delta x\to0}\sum_{i=0}^nf(x_i)\Delta x_i\) ，可以想到利用被积函数在区间 \([a,b]\) 上一些离散节点 \(x_k\) 处的函数值 \(f(x_k)\) 的线性组合来得到近似积分值： \(\displaystyle I=\sum_{k=0}^nA_kf(x_k)\) 。则得求积公式的一般形式： \(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\) ，其中 \(\{x_k\}\) 为求积点， \(A_k\) 为求积系数。或表示为 \(\displaystyle\int_a^bf(x)dx=\sum_{k=0}^nA_kf(x_k)+R[f]\) ，其中 \(R[f]\) 为求积公式的误差或余项。
积分中值定理：在 \([a,b]\) 内存在一点 \(\xi\) ，有 \(\displaystyle\int_a^bf(x)dx=(b-a)f(\xi)\) 。
问题： \(\xi\) 未知
取特殊点为 \(\xi\) 求近似解：
左矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(a)(b-a),\quad R[f]=\frac{(b-a)^2}{2}f&amp;#39;(\xi)\ (\xi\in(a,b))\)
右矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(b)(b-a),\quad R[f]=-\frac{(b-a)^2}{2}f&amp;#39;(\eta)\ (\eta\in(a,b))\)
中矩形求积公式： \(\displaystyle\int_a^bf(x)dx\approx f(\frac{a+b}{2})(b-a),\quad R[f]=-\frac{(b-a)^3}{24}f&amp;#39;&amp;#39;(\eta)\ (\eta\in(a,b))\)
代数精度 若求积公式 \(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\) 对 \(f(x)=x^j\ (j=0,1,\dots,m)\) 都精确成立，但对 \(f(x)=x^{m+1}\) 不精确成立。即： \(\left\{\begin{array}{l}\displaystyle\int_a^bx^jdx=\sum_{k=0}^nA_kx_k^j\quad j=0,1,\dots,m\\\displaystyle\int_a^bx^{m+1}dx\approx\sum_{k=0}^nA_kx_k^{m+1}\end{array}\right.</description>
      <content:encoded><![CDATA[<h3 id="数值积分">6.1 - 6.11 数值积分</h3>
<blockquote>
<p>牛顿-莱布尼茨公式： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=F(b)-F(a)\)</span></p>
<p>问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。</p>
<p>【例】弧长积分： <span
class="math inline">\(L=\displaystyle\int_a^b\sqrt{1+(f&#39;(x))^2}dx\)</span></p>
</blockquote>
<p>由定积分的定义 <span class="math inline">\(\displaystyle
I=\int_a^bf(x)dx=F(b)-F(a)=\lim_{\Delta x\to0}\sum_{i=0}^nf(x_i)\Delta
x_i\)</span> ，可以想到利用被积函数在区间 <span
class="math inline">\([a,b]\)</span> 上一些离散节点 <span
class="math inline">\(x_k\)</span> 处的函数值 <span
class="math inline">\(f(x_k)\)</span> 的线性组合来得到近似积分值： <span
class="math inline">\(\displaystyle I=\sum_{k=0}^nA_kf(x_k)\)</span>
。则得<strong>求积公式</strong>的一般形式： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
，其中 <span class="math inline">\(\{x_k\}\)</span>
为<strong>求积点</strong>， <span class="math inline">\(A_k\)</span>
为<strong>求积系数</strong>。或表示为 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=\sum_{k=0}^nA_kf(x_k)+R[f]\)</span>
，其中 <span class="math inline">\(R[f]\)</span>
为求积公式的<strong>误差</strong>或<strong>余项</strong>。</p>
<blockquote>
<p>积分中值定理：在 <span class="math inline">\([a,b]\)</span>
内存在一点 <span class="math inline">\(\xi\)</span> ，有 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx=(b-a)f(\xi)\)</span>
。</p>
<p>问题： <span class="math inline">\(\xi\)</span> 未知</p>
</blockquote>
<p>取特殊点为 <span class="math inline">\(\xi\)</span> 求近似解：</p>
<ul>
<li><p><strong>左矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx f(a)(b-a),\quad
R[f]=\frac{(b-a)^2}{2}f&#39;(\xi)\ (\xi\in(a,b))\)</span></p></li>
<li><p><strong>右矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx f(b)(b-a),\quad
R[f]=-\frac{(b-a)^2}{2}f&#39;(\eta)\ (\eta\in(a,b))\)</span></p></li>
<li><p><strong>中矩形求积公式</strong>： <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx
f(\frac{a+b}{2})(b-a),\quad R[f]=-\frac{(b-a)^3}{24}f&#39;&#39;(\eta)\
(\eta\in(a,b))\)</span></p></li>
</ul>
<h4 id="代数精度">代数精度</h4>
<p>若求积公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
对 <span class="math inline">\(f(x)=x^j\ (j=0,1,\dots,m)\)</span>
都精确成立，但对 <span class="math inline">\(f(x)=x^{m+1}\)</span>
不精确成立。即： <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle\int_a^bx^jdx=\sum_{k=0}^nA_kx_k^j\quad
j=0,1,\dots,m\\\displaystyle\int_a^bx^{m+1}dx\approx\sum_{k=0}^nA_kx_k^{m+1}\end{array}\right.\)</span>
，则称此公式具有 <span class="math inline">\(\mathbf m\)</span>
<strong>次代数精度</strong>。</p>
<p>可见，具有 <span class="math inline">\(m\)</span>
次代数精度的求积公式对最高次 <span class="math inline">\(\le m\)</span>
的多项式函数均是精确成立的。由由于，所有函数均可由多项式函数逼近，因此代数精度越高，求积公式的精度就越高。</p>
<p><strong>利用代数精度求求积公式</strong>：若求积公式 <span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)\)</span>
具有 <span class="math inline">\(n\)</span> 次代数精度，则： <span
class="math display">\[
\begin{array}{c}\left\{\begin{array}{l}A_0+A_1+\dots+A_n=b-a\\
\displaystyle x_0A_0+x_1A_1+\dots+x_nA_n=\frac{b^2-a^2}{2}\\
\dots\\\displaystyle
x_0^n+x_1^n+\dots+x_n^nA_n=\frac{b^{n+1}-a^{n+1}}{n+1}
\end{array}\right.\\
即\begin{pmatrix}
1  &amp;1  &amp;\cdots  &amp;1 \\
x_0  &amp;x_1  &amp;\cdots  &amp;x_n \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
x_0^n  &amp;x_1^n  &amp;\cdots  &amp;x_n^n
\end{pmatrix}
\begin{pmatrix}
A_0 \\
A_1 \\
\vdots \\
A_n
\end{pmatrix}=
\begin{pmatrix}
b-a \\
(b^2-a^2)/2 \\
\vdots \\
(b^{n+1}-a^{n+1})/(n+1)
\end{pmatrix}\\
D=\begin{vmatrix}
1  &amp;1  &amp;\cdots  &amp;1 \\
x_0  &amp;x_1  &amp;\cdots  &amp;x_n \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
x_0^n  &amp;x_1^n  &amp;\cdots  &amp;x_n^n
\end{vmatrix}=\displaystyle\prod_{0\le i&lt;j\le n}(x_j-x_i)\neq0
\end{array}
\]</span> 因此该方程组有唯一解。</p>
<h4 id="插值型数值求积公式">插值型数值求积公式</h4>
<p><strong>定义</strong>：已知定积分 <span
class="math inline">\(I=\displaystyle \int_a^bf(x)dx\)</span> 的被积函数
<span class="math inline">\(f(x)\)</span> 在节点 <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span>
上的函数值 <span class="math inline">\(y_k=f(x_k),\
k=0,1,\dots,n\)</span> 。则可构造 <span class="math inline">\(n\)</span>
次Lagrange插值多项式 <span
class="math inline">\(L_n(x)=\displaystyle\sum_{k=0}^nf(x_k)l_k(x)\)</span>
，其中 <span class="math inline">\(l_k(x)\)</span>
为Lagrange插值的基函数。因此<br />
<span class="math inline">\(\displaystyle
I_n=\int_a^bf(x)dx\approx\int_a^bL_n(x)dx=\int_a^b\left[\sum_{k=0}^nf(x_k)l_k(x)\right]dx=\sum_{k=0}^n\left[\int_a^bl_k(x)dx\right]f(x_k)\)</span>
。<br />
记 <span
class="math inline">\(A_k=\displaystyle\int_a^bl_k(x)dx\)</span>
，称之为<strong>求积系数</strong>，则有 <span
class="math inline">\(\int_a^bL_n(x)dx=\sum_{k=0}^nA_kf(x_k)\)</span>
，称之为<strong>插值型求积公式</strong>。</p>
<p><strong>误差</strong>：若 <span class="math inline">\(f(x)\)</span>
在 <span class="math inline">\([a,b]\)</span> 有 <span
class="math inline">\(n+1\)</span>
阶连续导数，则Lagrange插值余项为：<br />
<span class="math inline">\(\displaystyle
f(x)-L_n(x)=\frac{f^{(n+1)}(\xi_x)}{(n+1)!}\omega_{n+1}(x),\
\xi_x\in(a,b)\)</span><br />
从而得到插值型求积公式的误差如下 <span
class="math inline">\(\displaystyle
R[f]=\int_a^b[f(x)-L_n(x)]dx=\frac{1}{(n+1)!}\int_a^bf^{n+1}(\xi_x)\omega_{n+1}(x)dx,\
\xi_x\in(a,b)\)</span></p>
<p>加入权函数项非负连续函数 <span class="math inline">\(\rho(x)\)</span>
（物理意义为密度函数），则求积系数 <span
class="math inline">\(\displaystyle A_k=\int_a^b\rho(x)l_k(x)dx\)</span>
，误差表达式 <span class="math inline">\(\displaystyle
R[f]=\frac{1}{(n+1)!}\int_a^b\rho(x)f^{n+1}(\xi_x)\omega_{n+1}(x)dx,\
\xi_x\in(a,b)\)</span> 。</p>
<h4 id="newton-cotes公式">Newton-Cotes公式</h4>
<p><strong>定义</strong>：为简化计算，取等距节点 <span
class="math inline">\(x_k=a+kh\ (k=0,1,\dots,n,\ h=(b-a)/n)\)</span>
，则： <span class="math display">\[
\begin{array}{c}
\displaystyle A_k=\int_a^bl_k(x)dx=\int_a^b\left[\prod_{i=0,i\neq
k}^n\right]dx\xlongequal{令x=a+th}\frac{(-1)^{n-k}h}{k!(n-k)!}\int_0^n\left[\prod_{i=0,i\neq
k}^n(t-i)\right]dt\\
令\
C_k^{(n)}=\displaystyle\frac{1}{b-a}A_k=\frac{(-1)^{n-k}}{nk!(n-k)!}\int_0^n\left[\prod_{i=0,i\neq
k}^n(t-i)\right]dt,\quad k=0,1,\dots,n\\
则有\ \displaystyle\int_a^bf(x)dx\approx(b-a)\sum_{k=0}^nC_k^{(n)}f(x_k)
\end{array}
\]</span> 称最后一行式为<strong>Newton-Cotes公式</strong>， <span
class="math inline">\(C_k^{(n)}\)</span>
为<strong>Cotes系数</strong>。</p>
<ul>
<li>设 <span class="math inline">\(f(x)\in C^2[a,b]\)</span> ，则 <span
class="math inline">\(n=1\)</span> 时，Newton-Cotes公式为：<br />
<span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{2}[f(a)+f(b)]\)</span>
，<br />
误差为 <span
class="math inline">\(R[f]=\displaystyle-\frac{(b-a)^3}{12}f&#39;&#39;(\eta)\le\frac{\max\limits_{a\le
x\le b}|f&#39;&#39;(x)|}{12}(b-a)^3,\ \eta\in(a,b)\)</span> 。<br />
由于图像为梯形，称为<strong>梯形公式</strong>，记为 <span
class="math inline">\(\mathbf T\)</span> 。</li>
<li>设 <span class="math inline">\(f(x)\in C^4[a,b]\)</span> ，则 <span
class="math inline">\(n=2\)</span> 时，Newton-Cotes公式为：<br />
<span
class="math inline">\(\displaystyle\int_a^bf(x)dx\approx\frac{b-a}{6}\left[f(a)+4f\left(\frac{a+b}{2}\right)+f(b)\right]\)</span>
，<br />
误差为 <span
class="math inline">\(R[f]=\displaystyle-\frac{(b-a)^5}{2880}f^{(4)}(\eta)\le\frac{\max\limits_{a\le
x\le b}|f^{(4)}(x)|}{2880}(b-a)^5,\ \eta\in(a,b)\)</span> 。<br />
由于图像为抛物线，称为<strong>抛物线公式</strong>或<strong>Simpson公式</strong>，记为
<span class="math inline">\(\mathbf S\)</span> 。其代数精度为 <span
class="math inline">\(3\)</span> 。</li>
<li>依次，Cotes系数可查<strong>【Cotes系数表】</strong>。当Cotes系数出现相反数时，公式数值不稳定，因此高次Newton-Cotes公式没有实用价值。</li>
</ul>
<p>Newton-Cotes公式的截断误差为： <span
class="math inline">\(\begin{array}{r}R[f]=\left\{\begin{array}{l}\displaystyle\frac{f^{(n+1)}(\eta)}{(n+1)!}\int_a^b\omega_{n+1}(x)dx\quad
n为奇数\\\displaystyle\frac{f^{(n+2)}(\eta)}{(n+2)!}\int_a^b\omega_{n+1}(x)dx\quad
n为偶数\end{array}\right.\\\eta\in(a,b)\end{array}\)</span> 。</p>
<p><span class="math inline">\(n+1\)</span>
个节点的插值型求积公式至少具有 <span class="math inline">\(n\)</span>
次代数精度， <span class="math inline">\(n\)</span>
是偶数时Newton-Cotes公式具有 <span class="math inline">\(n+1\)</span>
次代数精度。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-07-数值分析-Day10-三次样条插值-最小二乘拟合</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-07-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day10-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/</link>
      <pubDate>Sun, 07 Mar 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-07-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day10-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/</guid>
      <description>续：5.8 - 5.10 三次样条插值 三转角方法 考虑第一种一般边界条件： \(S&amp;#39;(x_0)=f_0&amp;#39;,\ S&amp;#39;(x_n)=f_n&amp;#39;\) ，即已知两端点一阶导数值。
令 \(m_i=S&amp;#39;(x_i),\ i=0,1,\dots,n\) ，利用三次Hermite插值，得到 \(S(x)=\displaystyle \sum_{j=0}^n[y_j\alpha_j(x)+m_j\beta_j(x)]\) ，其中 \(\alpha_j(x),\ \beta_j(x)\) 为分段三次Hermite插值的基函数。再由边界条件得 \(S&amp;#39;(x_0)=f_0&amp;#39;,\ S&amp;#39;(x_n)=f_n&amp;#39;\) 即可解出 \(m_i\) 在各插值点的取值。记
\(\displaystyle \lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}},\ \mu_i=1-\lambda_i=\frac{h_i}{h_i+h_{i+1}},\ g_i=3(\lambda_if[x_{i-1},x_i]+\mu_if[x_i,x_{i+1}])\) ，
最终解得： \[ \begin{array}{c}\lambda_im_{i-1}+2m_i+\mu_im_{i+1}=g_i\\ \begin{pmatrix} 2 &amp;amp;\mu_1 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ \lambda_2 &amp;amp;2 &amp;amp;\mu_2 &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp;\ddots &amp;amp;\ddots &amp;amp;\ddots &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp;\ddots &amp;amp;\ddots &amp;amp;\ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp;\lambda_{n-2} &amp;amp;2 &amp;amp;\mu_{n-2} \\ &amp;amp; &amp;amp; &amp;amp; &amp;amp;\lambda_{n-1} &amp;amp;2 \end{pmatrix} \begin{pmatrix} m_1 \\ m_2 \\ \vdots \\ \vdots \\ m_{n-2} \\ m_{n-1} \end{pmatrix}= \begin{pmatrix} g_1-\lambda_iy_0&amp;#39; \\ g_2 \\ \vdots \\ \vdots \\ g_{n-2} \\ g_{n-1}-\mu_{n-1}y_n&amp;#39; \end{pmatrix} \end{array} \] 利用大型稀疏矩阵线性方程数值解法，解出 \(m_i\) ，即解得 \(x\in[x_{i-1},x_i]\) 时，有：</description>
      <content:encoded><![CDATA[<h3 id="续5.8---5.10-三次样条插值">续：5.8 - 5.10 三次样条插值</h3>
<h4 id="三转角方法">三转角方法</h4>
<p>考虑第一种一般边界条件： <span
class="math inline">\(S&#39;(x_0)=f_0&#39;,\
S&#39;(x_n)=f_n&#39;\)</span> ，即已知两端点一阶导数值。</p>
<p>令 <span class="math inline">\(m_i=S&#39;(x_i),\
i=0,1,\dots,n\)</span> ，利用三次Hermite插值，得到 <span
class="math inline">\(S(x)=\displaystyle
\sum_{j=0}^n[y_j\alpha_j(x)+m_j\beta_j(x)]\)</span> ，其中 <span
class="math inline">\(\alpha_j(x),\ \beta_j(x)\)</span>
为分段三次Hermite插值的基函数。再由边界条件得 <span
class="math inline">\(S&#39;(x_0)=f_0&#39;,\
S&#39;(x_n)=f_n&#39;\)</span> 即可解出 <span
class="math inline">\(m_i\)</span> 在各插值点的取值。记<br />
<span class="math inline">\(\displaystyle
\lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}},\
\mu_i=1-\lambda_i=\frac{h_i}{h_i+h_{i+1}},\
g_i=3(\lambda_if[x_{i-1},x_i]+\mu_if[x_i,x_{i+1}])\)</span> ，<br />
最终解得： <span class="math display">\[
\begin{array}{c}\lambda_im_{i-1}+2m_i+\mu_im_{i+1}=g_i\\
\begin{pmatrix}
2  &amp;\mu_1  &amp;  &amp;  &amp;  &amp; \\
\lambda_2  &amp;2  &amp;\mu_2  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\lambda_{n-2}  &amp;2  &amp;\mu_{n-2} \\
  &amp;  &amp;  &amp;  &amp;\lambda_{n-1}  &amp;2
\end{pmatrix}
\begin{pmatrix}
m_1 \\
m_2 \\
\vdots \\
\vdots \\
m_{n-2} \\
m_{n-1}
\end{pmatrix}=
\begin{pmatrix}
g_1-\lambda_iy_0&#39; \\
g_2 \\
\vdots \\
\vdots \\
g_{n-2} \\
g_{n-1}-\mu_{n-1}y_n&#39;
\end{pmatrix}
\end{array}
\]</span> 利用大型稀疏矩阵线性方程数值解法，解出 <span
class="math inline">\(m_i\)</span> ，即解得 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> 时，有：<br />
<span class="math inline">\(\begin{aligned}\displaystyle
S(x)&amp;=\frac{
(2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i
}{h_i^3}\\ &amp;+\frac{
(x-x_{i-1})(x-x_i)[(x-x_i)m_{i-1}+(x-x_{i-1})m_i] }{h_i^2}
\end{aligned}\)</span></p>
<p>其他边界条件也可用类似方法解得，计算方法较复杂。</p>
<h4 id="三弯矩方法">三弯矩方法</h4>
<blockquote>
<p>二阶导数 <span class="math inline">\(S&#39;&#39;(x)=M_j\
(j=0,1,\dots,n)\)</span> 在力学上解释为细梁在 <span
class="math inline">\(x_j\)</span> 截面处的<strong>弯矩</strong>。</p>
</blockquote>
<p>令 <span class="math inline">\(M_i=S&#39;&#39;(x_i),\
i=0,1,\dots,n\)</span> ，则对 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> ，有：<br />
<span class="math inline">\(\displaystyle
S&#39;&#39;(x)=\frac{x-x_i}{x_{i-1}-x_i}M_{i-1}+\frac{x-x_{i-1}}{x_i-x_{i-1}}M_i\)</span>
，对此连续积分两次，记 <span class="math inline">\(S(x_i)=y_i\)</span>
，得：<br />
<span class="math inline">\(\begin{aligned}\displaystyle
S(x)&amp;=\frac{1}{6h_i}\left[(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i\right]\\&amp;+\left(\frac{y_{i-1}}{h_i}-\frac{h_iM_{i-1}}{6}\right)(x_i-x)+\left(\frac{y_i}{h_i}-\frac{h_iM_i}{6}\right)(x-x_{i-1})\\&amp;=\frac{(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i+(6y_{i-1}-h_i^2M_{i-1})(x_i-x)+(6y_i-h_i^2M_i)(x-x_{i-1})}{6h_i}\end{aligned}\)</span><br />
利用 <span class="math inline">\(S&#39;(x_i-0)=S&#39;(x_i+0)\)</span>
求出 <span class="math inline">\(M_i\)</span> ，记<br />
<span class="math inline">\(\displaystyle
\lambda_i=\frac{h_{i+1}}{h_i+h_{i+1}}=,\ \mu_i=\frac{h_i}{h_i+h_{i+1}},\
d_i=6f[x_{i-1},x_i,x_{i+1}]\)</span> ，<br />
则有： <span
class="math inline">\(\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\)</span><br />
结合边界条件 <span
class="math inline">\(M_0=S&#39;&#39;(x_0)=y&#39;&#39;_0,\
M_n=S&#39;&#39;(x_n)=y&#39;&#39;_n\)</span> ，可得： <span
class="math display">\[
\begin{array}{c}\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\\
\begin{pmatrix}
2  &amp;\mu_1  &amp;  &amp;  &amp;  &amp; \\
\mu_2  &amp;2  &amp;\lambda_2  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\mu_{n-2}  &amp;2  &amp;\lambda_{n-2} \\
  &amp;  &amp;  &amp;  &amp;\mu_{n-1}  &amp;2
\end{pmatrix}
\begin{pmatrix}
M_1 \\
M_2 \\
\vdots \\
\vdots \\
M_{n-2} \\
M_{n-1}
\end{pmatrix}=
\begin{pmatrix}
d_1-\mu_iy_0&#39; \\
d_2 \\
\vdots \\
\vdots \\
d_{n-2} \\
d_{n-1}-\lambda_{n-1}y_n&#39;&#39;
\end{pmatrix}
\end{array}
\]</span> 或结合边界条件 <span
class="math inline">\(S&#39;(x_0)=y_0&#39;,\
S&#39;(x_n)=y_n&#39;\)</span> ，得： <span class="math display">\[
\begin{array}{c}\mu_iM_{i-1}+2M_i+\lambda_iM_{i+1}=d_i\\2M_0+M_1=d+0\\M_{n-1}+2M_n=d_n\\
\begin{pmatrix}
2  &amp;_1  &amp;  &amp;  &amp;  &amp; \\
\mu_1  &amp;2  &amp;\lambda_1  &amp;  &amp;  &amp; \\
  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp;  &amp; \\
  &amp;  &amp;\ddots  &amp;\ddots  &amp;\ddots  &amp; \\
  &amp;  &amp;  &amp;\mu_{n-1}  &amp;2  &amp;\lambda_{n-1} \\
  &amp;  &amp;  &amp;  &amp;1  &amp;2
\end{pmatrix}
\begin{pmatrix}
M_1 \\
M_2 \\
\vdots \\
\vdots \\
M_{n-2} \\
M_{n-1}
\end{pmatrix}=
\begin{pmatrix}
d_0 \\
d_1 \\
\vdots \\
\vdots \\
d_{n-1} \\
d_n
\end{pmatrix}
\end{array}
\]</span> 或结合周期边界条件 <span
class="math inline">\(S&#39;(x_0)=S&#39;(x_n),\
S&#39;&#39;(x_0)=S&#39;&#39;(x_n)\)</span> ，同样得到稀疏矩阵线性方程。
采用稀疏矩阵线性方程解法即可。</p>
<p><strong>综上</strong>，当边界条件为第一类（已知一阶导数值）时，适合采用三转角方法；当边界条件为第二类（已知二阶导数值）时适合采用三弯矩方法；对周期边界条件，两种方法计算量一致。</p>
<h3 id="最小二乘法">最小二乘法</h3>
<h4 id="数据拟合问题">数据拟合问题</h4>
<p>经由观察或测试得到 <span class="math inline">\(y(x)\)</span>
的一组离散数据，在给定的函数类 <span class="math inline">\(\Phi\)</span>
上根据这组离散数据做出逼近曲线，要求逼近曲线在 <span
class="math inline">\(x_i\)</span> 处与离散数据尽可能接近。</p>
<p>对函数 <span class="math inline">\(\varphi(x)\in\Phi\)</span>
，要求以 <span class="math inline">\(\varphi(x)\)</span> 在离散点的误差
<span class="math inline">\(\delta_i=\phi(x_i)-y_i,\
i=0,1,\dots,m\)</span> 为分量的误差向量 <span
class="math inline">\(\delta=(\delta_0,\delta_1,\dots,\delta_m)^T\)</span>
，使某一向量范数 <span class="math inline">\(\|\delta\|\)</span>
达到最小。对不同的范数，可以构造出不同意义下的拟合函数。</p>
<p>函数类 <span class="math inline">\(\Phi\)</span> 通常取为 <span
class="math inline">\(\Phi=Span\{\varphi_0(x),\varphi_1(x),\dots,\varphi_n(x)\}\)</span>
，其中函数系 <span
class="math inline">\(\varphi_0(x),\varphi_1(x),\dots,\varphi_n(x)\)</span>
在包含节点 <span class="math inline">\(\{x_i\}\)</span> 的区间 <span
class="math inline">\([a,b]\)</span> 上线性无关， <span
class="math inline">\(\Phi\)</span> 中任一函数 <span
class="math inline">\(\varphi(x)\)</span> 可表示为： <span
class="math inline">\(\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+\dots+a_n\varphi_n(x)\)</span>
。</p>
<p>常用函数系包括幂函数系 <span class="math inline">\(\{x^j\}\)</span>
，三角函数系 <span class="math inline">\(\{\sin jx\}\ \{\cos
jx\}\)</span> ，指数函数系 <span
class="math inline">\(\{e^{\lambda_jx}\}\)</span> ，正交函数系等。</p>
<p>在求误差向量 <span class="math inline">\(\delta\)</span>
的范数时，常用 <span class="math inline">\(2\)</span>
-范数，对应的曲线拟合方法就称为<strong>最小二乘法</strong>。</p>
<p><strong>推导</strong>：在函数类 <span
class="math inline">\(\Phi\)</span> 中找到函数 <span
class="math inline">\(y=\varphi^*(x)\)</span> ，使误差向量 <span
class="math inline">\(\delta\)</span> 的 <span
class="math inline">\(2\)</span>
-范数达到最小值。（通常取误差向量的加权形式 <span
class="math inline">\(\rho(x)\varphi(x)\)</span> 求 <span
class="math inline">\(2\)</span> -范数的平方 <span
class="math inline">\(\|\delta\|_2^2\)</span> ）。该范数为关于 <span
class="math inline">\((a_0,a_1,\dots,a_n)\)</span> 的函数，记其为 <span
class="math inline">\(G(a_0,a_1,\dots,a_n)\)</span>
，则问题转换为求该函数最小值问题。<br />
记 <span
class="math inline">\(\left\{\begin{array}{l}\varphi_j=(\varphi_j(x_0),\varphi_j(x_1),\dots,\varphi_j(x_m))^T,\
j=0,1,2,\dots,n\\f=(y_0,y_1,\dots,y_m)^T\\(\varphi_j,\varphi_k)=\displaystyle\sum_{i=0}^m\rho(x_i)\varphi_j(x_i)\varphi_k(x_i)\\(f,\varphi_k)=\displaystyle\sum_{i=0}^m\rho(x_i)y_i\varphi_k(x_i)\end{array}\\\right.\)</span><br />
得到关于系数向量 <span
class="math inline">\((a_0,a_1,\dots,a_n)^T\)</span> 的线性方程组：
<span class="math display">\[
\begin{array}{c}\displaystyle\sum_{j=0}^n(\varphi_j,\varphi_k)a_j=(f,\varphi_k)\quad
k=0,1,\dots,n\\
\begin{pmatrix}
(\varphi_0,\varphi_0)  &amp;(\varphi_0,\varphi_1)  &amp;\cdots  &amp;(\varphi_j,\varphi_k)
\\
(\varphi_1,\varphi_0)  &amp;(\varphi_1,\varphi_1)  &amp;\cdots  &amp;(\varphi_1,\varphi_n)
\\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
(\varphi_n,\varphi_0)  &amp;(\varphi_n,\varphi_1)  &amp;\cdots  &amp;(\varphi_n,\varphi_n)
\end{pmatrix}
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{pmatrix}
=\begin{pmatrix}
(f,\varphi_0) \\
(f,\varphi_1) \\
\vdots \\
(f,\varphi_n)
\end{pmatrix}\end{array}
\]</span>
称之为<strong>正则方程组</strong>或<strong>法方程组</strong>。<br />
正则方程组的系数矩阵为对称矩阵。若向量组 <span
class="math inline">\(\varphi_0,\varphi_1,\dots,\varphi_n\)</span>
线性无关，则其为对称正定矩阵，可以通过迭代法求得唯一解 <span
class="math inline">\(a_j^*\)</span> ，从而得到拟合函数 <span
class="math inline">\(\varphi^*(x)\)</span> 。</p>
<h4 id="取函数类">取函数类</h4>
<p>取函数类为幂函数系，则正则方程组为：<br />
<span class="math display">\[
\begin{pmatrix}
\sum\rho_i  &amp;\sum\rho_i x_i  &amp;\cdots  &amp;\sum\rho_i x_i^n \\
\sum\rho_i x_i  &amp;\sum\rho_i x_i^2  &amp;\cdots  &amp;\sum\rho_i
x_i^{n+1} \\
\vdots  &amp;\vdots  &amp;\ddots  &amp;\vdots \\
\sum\rho_i x_i^n  &amp;\sum\rho_i
x_i^{n+1}  &amp;\cdots  &amp;\sum\rho_i x_i^{2n}
\end{pmatrix}
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{pmatrix}
=\begin{pmatrix}
\sum\rho_iy_i \\
\sum\rho_ix_iy_i \\
\vdots \\
\sum\rho_ix_i^ny_i
\end{pmatrix}
\]</span> 其中 <span class="math inline">\(\rho_i=\rho(x_i),\
\sum=\sum\limits_{i=0}^m\)</span> 。此时拟合曲线 <span
class="math inline">\(\varphi^*(x)=p_n^*(x)=a_0^*+a_1^*x+\dots+a_n^*x^n\)</span>
，称之为<strong>多项式拟合曲线</strong>。</p>
<p>取函数类为正交函数系，则 <span
class="math inline">\((\varphi_i,\varphi_j)=0,\ (i\neq j)\)</span>
，正则方程组的系数矩阵为对角矩阵， <span
class="math inline">\(a_k^*=(f,\varphi_k)/(\varphi_k,\varphi_k),\
k=0,1,\dots,n\)</span> 。</p>
<h3
id="代码本节计算主要过程为解线性方程组列出对应元计算式调用对应函数即可线性方程组解法在之前章节已给出不再重复">代码：本节计算主要过程为解线性方程组，列出对应元计算式，调用对应函数即可。线性方程组解法在之前章节已给出，不再重复。</h3>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-06-数值分析-Day09-分段插值-三次样条函数</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-06-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day09-%E5%88%86%E6%AE%B5%E6%8F%92%E5%80%BC-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 06 Mar 2021 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-06-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day09-%E5%88%86%E6%AE%B5%E6%8F%92%E5%80%BC-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/</guid>
      <description>5.6 - 5.7 分段插值 Runge现象：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。
分段Lagrange插值 分段线性插值 通过相邻两个插值点作线性插值。已知节点 \(a=x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n=b\) ，记 \(h_k=x_{k+1}-x_k,\ h=\max\limits_{0\le k\le n-1}h_k\) ，记分段插值函数为 \(I_h(x)\) ，为 \(n-1\) 段折线。
余项估计有 \(|f(x)-I_h(x)|\le \displaystyle\frac{\max\limits_{a\le x\le b}|f&amp;#39;&amp;#39;(x)|}{8}h^2\) ，说明分段线性插值函数具有一致收敛性。
分段二次插值 相邻三个插值点作二次插值。
课程中以线性插值中两邻点中间值，作为补充条件，即取 \(x_{i-0.5}=(x_i+x_{i-1})/2\) 作为每组中的第三个插值点，使得两点间距为 \(h_k/2\) 。按照这种方式得到余项估计 \(|f(x)-I_h(x)|\le \displaystyle\frac{\max\limits_{a\le x\le b}|f&amp;#39;&amp;#39;&amp;#39;(x)|}{72\sqrt{3}}h^3\) 。
PS：个人认为应直接取连续三个插值点，即 \(\{x_0,x_1,x_2\}\ \{x_2,x_3,x_4\}\ \{x_4,x_5,x_6\}\ \dots\) 作为插值点进行二次插值。
分段Lagrange插值的问题：区间内出现不可导点 分段Hermite插值 设节点 \(a\le x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n\le b,\ h_i=x_i-x_{i-1}\ (i=1,2,\dots,n)\) ，给出插值条件： \(y_k=f(x_k),\ y&amp;#39;_k=f&amp;#39;(x_k),\ (k=0,1,\dots,n)\) 。则每区间 \([x_{i-1},x_i]\) 具有四个插值条件。构造三次多项式 \(H_3^{(i)}(x)\) ： \[ \begin{array}{c}H_3^{(i)}(x)=\varphi_{i-1}(x)y_{i-1}+\varphi_i(x)y_i+\psi_{i-1}(x)y&amp;#39;_{i-1}+\psi_i(x)y&amp;#39;_i\\ \left\{\begin{aligned} &amp;amp;\varphi_{i-1}(x_{i-1})=1 &amp;amp;&amp;amp;\varphi_{i-1}(x_i)=0 &amp;amp;&amp;amp;\varphi&amp;#39;_{i-1}(x_{i-1})=0 &amp;amp;&amp;amp;\varphi&amp;#39;_{i-1}(x_i)=0\\ &amp;amp;\varphi_i(x_{i-1})=0 &amp;amp;&amp;amp;\varphi_i(x_i)=1 &amp;amp;&amp;amp;\varphi&amp;#39;_i(x_{i-1})=0 &amp;amp;&amp;amp;\varphi&amp;#39;_i(x_i)=0\\ &amp;amp;\psi_{i-1}(x_{i-1})=0 &amp;amp;&amp;amp;\psi_{i-1}(x_i)=0 &amp;amp;&amp;amp;\psi&amp;#39;_{i-1}(x_{i-1})=1 &amp;amp;&amp;amp;\psi&amp;#39;_{i-1}(x_i)=0\\ &amp;amp;\psi_i(x_{i-1})=0 &amp;amp;&amp;amp;\psi_i(x_i)=0 &amp;amp;&amp;amp;\psi&amp;#39;_i(x_{i-1})=0 &amp;amp;&amp;amp;\psi&amp;#39;_i(x_i)=1\\ \end{aligned}\right.</description>
      <content:encoded><![CDATA[<h3 id="分段插值">5.6 - 5.7 分段插值</h3>
<p><strong>Runge现象</strong>：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。</p>
<h4 id="分段lagrange插值">分段Lagrange插值</h4>
<h5 id="分段线性插值">分段线性插值</h5>
<p>通过相邻两个插值点作线性插值。已知节点 <span
class="math inline">\(a=x_0&lt;x_1&lt;\dots&lt;x_n=b\)</span> ，记 <span
class="math inline">\(h_k=x_{k+1}-x_k,\ h=\max\limits_{0\le k\le
n-1}h_k\)</span> ，记分段插值函数为 <span
class="math inline">\(I_h(x)\)</span> ，为 <span
class="math inline">\(n-1\)</span> 段折线。</p>
<p>余项估计有 <span class="math inline">\(|f(x)-I_h(x)|\le
\displaystyle\frac{\max\limits_{a\le x\le
b}|f&#39;&#39;(x)|}{8}h^2\)</span>
，说明分段线性插值函数具有一致收敛性。</p>
<h5 id="分段二次插值">分段二次插值</h5>
<p>相邻三个插值点作二次插值。</p>
<p>课程中以线性插值中两邻点中间值，作为补充条件，即取 <span
class="math inline">\(x_{i-0.5}=(x_i+x_{i-1})/2\)</span>
作为每组中的第三个插值点，使得两点间距为 <span
class="math inline">\(h_k/2\)</span> 。按照这种方式得到余项估计 <span
class="math inline">\(|f(x)-I_h(x)|\le
\displaystyle\frac{\max\limits_{a\le x\le
b}|f&#39;&#39;&#39;(x)|}{72\sqrt{3}}h^3\)</span> 。</p>
<p>PS：个人认为应直接取连续三个插值点，即 <span
class="math inline">\(\{x_0,x_1,x_2\}\ \{x_2,x_3,x_4\}\ \{x_4,x_5,x_6\}\
\dots\)</span> 作为插值点进行二次插值。</p>
<h5
id="分段lagrange插值的问题区间内出现不可导点">分段Lagrange插值的问题：区间内出现不可导点</h5>
<h4 id="分段hermite插值">分段Hermite插值</h4>
<p>设节点 <span class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le
b,\ h_i=x_i-x_{i-1}\ (i=1,2,\dots,n)\)</span> ，给出插值条件： <span
class="math inline">\(y_k=f(x_k),\ y&#39;_k=f&#39;(x_k),\
(k=0,1,\dots,n)\)</span> 。则每区间 <span
class="math inline">\([x_{i-1},x_i]\)</span>
具有四个插值条件。构造三次多项式 <span
class="math inline">\(H_3^{(i)}(x)\)</span> ： <span
class="math display">\[
\begin{array}{c}H_3^{(i)}(x)=\varphi_{i-1}(x)y_{i-1}+\varphi_i(x)y_i+\psi_{i-1}(x)y&#39;_{i-1}+\psi_i(x)y&#39;_i\\
\left\{\begin{aligned}
&amp;\varphi_{i-1}(x_{i-1})=1 &amp;&amp;\varphi_{i-1}(x_i)=0
&amp;&amp;\varphi&#39;_{i-1}(x_{i-1})=0
&amp;&amp;\varphi&#39;_{i-1}(x_i)=0\\
&amp;\varphi_i(x_{i-1})=0 &amp;&amp;\varphi_i(x_i)=1
&amp;&amp;\varphi&#39;_i(x_{i-1})=0 &amp;&amp;\varphi&#39;_i(x_i)=0\\
&amp;\psi_{i-1}(x_{i-1})=0 &amp;&amp;\psi_{i-1}(x_i)=0
&amp;&amp;\psi&#39;_{i-1}(x_{i-1})=1 &amp;&amp;\psi&#39;_{i-1}(x_i)=0\\
&amp;\psi_i(x_{i-1})=0 &amp;&amp;\psi_i(x_i)=0
&amp;&amp;\psi&#39;_i(x_{i-1})=0 &amp;&amp;\psi&#39;_i(x_i)=1\\
\end{aligned}\right.\\\Longrightarrow\quad\left\{\begin{aligned}
&amp;H_3^{(i)}(x_{i-1})=y_{i-1}&amp;&amp;H_3^{(i)}(x_i)=y_i\\
&amp;H_3&#39;^{(i)}(x_{i-1})=y&#39;_{i-1}&amp;&amp;H_3&#39;^{(i)}(x_i)=y&#39;_i
\end{aligned}\right.\end{array}
\]</span> 其中，称 <span class="math inline">\(\varphi_{i-1}(x),\
\varphi_i(x),\ \psi_{i-1}(x),\ \psi_i(x)\)</span>
为<strong>三次Hermite插值基函数</strong>。<br />
求得： <span class="math display">\[
\begin{array}{c}\left\{\begin{aligned}\displaystyle
&amp;\varphi_{i-1}(x_{i-1})=\frac{1}{h_i^3}(2x-3x_{i-1}+x_i)(x-x_i)^2\\
&amp;\varphi_i(x_{i-1})=\frac{1}{h_i^3}(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2\\
&amp;\psi_{i-1}(x_{i-1})=\frac{1}{h_i^2}(x-x_{i-1})(x-x_i)^2\\
&amp;\psi_i(x_{i-1})=\frac{1}{h_i^2}(x-x_{i-1})^2(x-x_i)
\end{aligned}\right.\\
\begin{aligned}\displaystyle H_3^{(i)}(x)&amp;=\frac{
(2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i
}{h_i^3}\\
&amp;+\frac{
(x-x_{i-1})(x-x_i)[(x-x_i)y&#39;_{i-1}+(x-x_{i-1})y&#39;_i]
}{h_i^2}
\end{aligned}\end{array}
\]</span></p>
<p><strong>余项分析</strong>：若 <span class="math inline">\(f(x)\in
C^4[a,b]\)</span> （四阶连续可微），则当 <span
class="math inline">\(x\in[x_{i-1},x_i]\)</span> 时，有： <span
class="math display">\[
\begin{array}{c}\displaystyle
f(x)-H_3^{(i)}(x)=\frac{f^{(4)}(\xi_i)}{4!}(x-x_{i-1})^2(x-x_i)^2,\quad\xi\in[x_{i-1},x_i]\\
\displaystyle |f(x)-H_3(x)|\le\frac{\max\limits_{a\le x\le
b}|f^{(4)}(x)|\times h^4}{4!\times16}=\frac{\max\limits_{a\le x\le
b}|f^{(4)}(x)|\times h^4}{384}\end{array}
\]</span> 可知 <span class="math inline">\(H_3(x)\)</span>
是收敛的，且在 <span class="math inline">\([a,b]\)</span>
内具有一阶连续导数。</p>
<h3 id="三次样条插值">5.8 - 5.10 三次样条插值</h3>
<p>Hermite分段插值只能保证一阶连续可导，引入三次样条插值保证二阶连续可导。</p>
<p><strong>三次样条函数</strong>：若函数 <span
class="math inline">\(S(x)\in C^2[a,b]\)</span> ，且在每个小区间 <span
class="math inline">\([x_j,x_{j+1}]\)</span> 上是三次多项式，其中 <span
class="math inline">\(a=x_0&lt;x_1&lt;\dots&lt;x_n=b\)</span>
是给定节点，则称 <span class="math inline">\(S(x)\)</span> 是节点 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span>
上的<strong>三次样条函数</strong>。</p>
<p><strong>分段三次多项式</strong>： <span
class="math inline">\(S(x)=a_jx^3+b_jx^2+c_jx+d_j,\
j=0,1,2,\dots,n-1\)</span> ，其中 <span class="math inline">\(a_j\ b_j\
c_j\ d_j\)</span> 为待定系数，因此函数共有 <span
class="math inline">\(4n\)</span> 个待定参数。函数满足关系： <span
class="math inline">\(\left\{\begin{array}{l}S(x_j-0)=S(x_j+0)\\S&#39;(x_j-0)=S&#39;(x_j+0)\\S&#39;&#39;(x_j-0)=S&#39;&#39;(x_j+0)\end{array}\right.\)</span>
，共 <span class="math inline">\(3n-3\)</span> 个条件，加上插值条件
<span class="math inline">\(S(x_j)=f_j,\ j=0,1,\dots,n\)</span> 共 <span
class="math inline">\(4n-2\)</span>
个条件。在此基础上在区间端点处添加一对<strong>边界条件</strong>即可满足唯一确定
<span class="math inline">\(4n\)</span> 个待定参数的 <span
class="math inline">\(4n\)</span> 个条件。</p>
<p><strong>边界条件</strong>：一般来说有两种边界条件，即两端点的一阶导数值或二阶导数值。</p>
<p><strong>周期边界条件</strong>：当 <span
class="math inline">\(f(x)\)</span> 是以 <span
class="math inline">\(x_n-x_0\)</span> 为周期的周期函数时，要求 <span
class="math inline">\(S(x)\)</span> 也是周期函数，此时边界条件满足：
<span
class="math inline">\(\left\{\begin{array}{l}S(x_0+0)=S(x_n-0)\\S&#39;(x_0+0)=S&#39;(x_n-0)\\S&#39;&#39;(x_0+0)=S&#39;&#39;(x_n-0)\end{array}\right.\)</span>
，且端点二阶导数值均为 <span class="math inline">\(0\)</span>
。称这样的样条函数为<strong>周期样条函数</strong>。</p>
<h3 id="代码hermite插值">代码：Hermite插值</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-06.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_im1<span class="op">;</span> <span class="dt">double</span> x_i<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y_im1<span class="op">;</span> <span class="dt">double</span> y_i<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y_1_im1<span class="op">;</span> <span class="dt">double</span> y_1_i<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">// x, y, y_1</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> array<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> H<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> <span class="va">array_</span> <span class="op">{{</span><span class="dv">100</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">20</span><span class="op">},</span> <span class="op">{</span><span class="dv">121</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">22</span><span class="op">},</span> <span class="op">{</span><span class="dv">144</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">24</span><span class="op">},</span> <span class="op">{</span><span class="dv">169</span><span class="op">,</span> <span class="dv">13</span><span class="op">,</span> <span class="dv">1</span><span class="op">/</span><span class="dv">26</span><span class="op">}};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    array<span class="op">.</span>assign<span class="op">(</span><span class="va">array_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">array_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> H<span class="op">(</span><span class="dv">125</span><span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> H<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>array<span class="op">.</span>begin<span class="op">(),</span> array<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">});</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span> x <span class="op">&lt;</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            x_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span> x_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            y_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span> y_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            y_1_im1 <span class="op">=</span> array<span class="op">[</span>i<span class="op">][</span><span class="dv">2</span><span class="op">];</span> y_1_i <span class="op">=</span> array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h_i <span class="op">=</span> x_i <span class="op">-</span> x_im1<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h <span class="op">=</span> <span class="op">(</span> <span class="op">(</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x_im1 <span class="op">+</span> x_i<span class="op">)</span> <span class="op">*</span> pow<span class="op">((</span>x <span class="op">-</span> x_i<span class="op">),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> y_im1</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                 <span class="op">+</span> <span class="op">(-</span> <span class="dv">2</span> <span class="op">*</span> x <span class="op">-</span> x_im1 <span class="op">+</span> <span class="dv">3</span> <span class="op">*</span> x_i<span class="op">)</span> <span class="op">*</span> pow<span class="op">((</span>x <span class="op">-</span> x_im1<span class="op">),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">*</span> y_i <span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>             <span class="op">+</span> h_i <span class="op">*</span> <span class="op">(</span>x <span class="op">-</span> x_im1<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>x <span class="op">-</span> x_i<span class="op">)</span> <span class="op">*</span> <span class="op">((</span>x <span class="op">-</span> x_i<span class="op">)</span> <span class="op">*</span> y_1_im1 <span class="op">+</span> <span class="op">(</span>x <span class="op">-</span> x_im1<span class="op">)</span> <span class="op">*</span> y_1_i <span class="op">)</span> <span class="op">)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>             <span class="op">/</span> pow<span class="op">(</span>h_i<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-05-数值分析-Day08-Lagrange插值-Newton插值</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-05-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day08-lagrange%E6%8F%92%E5%80%BC-newton%E6%8F%92%E5%80%BC/</link>
      <pubDate>Fri, 05 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-05-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day08-lagrange%E6%8F%92%E5%80%BC-newton%E6%8F%92%E5%80%BC/</guid>
      <description>5.1 - 5.3 插值的引入与Lagrange插值 插值的定义 设函数 \(y=f(x)\) 在区间 \([a,b]\) 上连续，给定 \(n+1\) 个点： \(a\le x_0&amp;lt;x_1&amp;lt;\dots&amp;lt;x_n\le b\) 。
已知 \(f(x_k)=y_k(k=0,1,\dots,n)\) ，在函数类 \(P\) 中寻找一函数 \(\varphi(x)\) 作为 \(f(x)\) 的近似表达式，使满足：
$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 \(y=f(x)\) 为被插值函数，称 \(\varphi(x)\) 为插值函数。称 \(x_0,x_1,\dots,x_n\) 为插值节点； \(\varphi(x_k)=f(x_k)=y_k,\ k=0,1,2,\dots,n\) 为插值条件，寻求插值函数的方法称为插值方法。
在构造插值函数时，函数类 \(P\) 的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即多项式插值。若用 \(P_n\) 表示所有次数不超过 \(n\) 的多项式函数类，则若 \(p_n(x)\in P_n\) ，则 有\(p_n(x)=a_0+a_1x+\dots+a_nx^n\) ，由 \(n+1\) 个系数唯一确定。若 \(p_n(x)\) 满足插值条件，即 \(\left\{\begin{array}{l}a_0+a_1x_1+\dots+a_nx_1^n\\a_0+a_1x_2+\dots+a_nx_2^n\\\dots\\a_0+a_1x_n+\dots+a_nx_n^n\end{array}\right.\) 。令 \(\{a_0,a_1,\dots,a_n\}\) 为元，则该方程系数行列式为 \(\begin{vmatrix}1&amp;amp;x_0&amp;amp;\cdots&amp;amp;x_0^n\\1&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_1^n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;x_n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}\) ，由范德蒙行列式得: \(\begin{vmatrix}1&amp;amp;x_0&amp;amp;\cdots&amp;amp;x_0^n\\1&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_1^n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;x_n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}=\begin{vmatrix}1&amp;amp;1&amp;amp;\cdots&amp;amp;1\\x_0&amp;amp;x_1&amp;amp;\cdots&amp;amp;x_n\\\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\x_0^n&amp;amp;x_2^n&amp;amp;\cdots&amp;amp;x_n^n\end{vmatrix}=\prod\limits_{0\le&amp;lt;j\le n}(x_j-x_i)\neq0\) ，因此该方程有解。
由此得定理：满足上述条件的插值问题， \(p_n(x)\) 存在且唯一。
Lagrange插值 线性插值 最简单的插值问题：已知两点 \((x_0,y_0)\ (x_1,y_1)\) 。通过此两点的插值多项式是一条直线，即两点式： \(\displaystyle L_1(x)=\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1\) 。称 \(L_1(x)\) 为线性插值函数。</description>
      <content:encoded><![CDATA[<h3 id="插值的引入与lagrange插值">5.1 - 5.3
插值的引入与Lagrange插值</h3>
<h4 id="插值的定义">插值的定义</h4>
<p>设函数 <span class="math inline">\(y=f(x)\)</span> 在区间 <span
class="math inline">\([a,b]\)</span> 上连续，给定 <span
class="math inline">\(n+1\)</span> 个点： <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span>
。<br />
已知 <span class="math inline">\(f(x_k)=y_k(k=0,1,\dots,n)\)</span>
，在函数类 <span class="math inline">\(P\)</span> 中寻找一函数 <span
class="math inline">\(\varphi(x)\)</span> 作为 <span
class="math inline">\(f(x)\)</span> 的近似表达式，使满足：<br />
$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 <span
class="math inline">\(y=f(x)\)</span> 为<strong>被插值函数</strong>，称
<span class="math inline">\(\varphi(x)\)</span>
为<strong>插值函数</strong>。称 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span>
为<strong>插值节点</strong>； <span
class="math inline">\(\varphi(x_k)=f(x_k)=y_k,\ k=0,1,2,\dots,n\)</span>
为<strong>插值条件</strong>，寻求插值函数的方法称为<strong>插值方法</strong>。</p>
<p>在构造插值函数时，函数类 <span class="math inline">\(P\)</span>
的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即<strong>多项式插值</strong>。若用
<span class="math inline">\(P_n\)</span> 表示所有次数不超过 <span
class="math inline">\(n\)</span> 的多项式函数类，则若 <span
class="math inline">\(p_n(x)\in P_n\)</span> ，则 有<span
class="math inline">\(p_n(x)=a_0+a_1x+\dots+a_nx^n\)</span> ，由 <span
class="math inline">\(n+1\)</span> 个系数唯一确定。若 <span
class="math inline">\(p_n(x)\)</span> 满足插值条件，即 <span
class="math inline">\(\left\{\begin{array}{l}a_0+a_1x_1+\dots+a_nx_1^n\\a_0+a_1x_2+\dots+a_nx_2^n\\\dots\\a_0+a_1x_n+\dots+a_nx_n^n\end{array}\right.\)</span>
。令 <span class="math inline">\(\{a_0,a_1,\dots,a_n\}\)</span>
为元，则该方程系数行列式为 <span
class="math inline">\(\begin{vmatrix}1&amp;x_0&amp;\cdots&amp;x_0^n\\1&amp;x_1&amp;\cdots&amp;x_1^n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;x_n&amp;\cdots&amp;x_n^n\end{vmatrix}\)</span>
，由范德蒙行列式得: <span
class="math inline">\(\begin{vmatrix}1&amp;x_0&amp;\cdots&amp;x_0^n\\1&amp;x_1&amp;\cdots&amp;x_1^n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;x_n&amp;\cdots&amp;x_n^n\end{vmatrix}=\begin{vmatrix}1&amp;1&amp;\cdots&amp;1\\x_0&amp;x_1&amp;\cdots&amp;x_n\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\x_0^n&amp;x_2^n&amp;\cdots&amp;x_n^n\end{vmatrix}=\prod\limits_{0\le&lt;j\le
n}(x_j-x_i)\neq0\)</span> ，因此该方程有解。<br />
由此得定理：满足上述条件的插值问题， <span
class="math inline">\(p_n(x)\)</span> 存在且唯一。</p>
<h4 id="lagrange插值">Lagrange插值</h4>
<h5 id="线性插值">线性插值</h5>
<p>最简单的插值问题：已知两点 <span class="math inline">\((x_0,y_0)\
(x_1,y_1)\)</span> 。通过此两点的插值多项式是一条直线，即两点式： <span
class="math inline">\(\displaystyle
L_1(x)=\frac{x-x_1}{x_0-x_1}y_0+\frac{x-x_0}{x_1-x_0}y_1\)</span> 。称
<span class="math inline">\(L_1(x)\)</span>
为<strong>线性插值函数</strong>。<br />
令 <span class="math inline">\(\left\{\begin{array}{l}\displaystyle
l_0(x)=\frac{x-x_1}{x_0-x_1}\\\displaystyle
l_1(x)=\frac{x-x_0}{x_1-x_0}\end{array}\right.\)</span> ，则有 <span
class="math inline">\(\left\{\begin{array}{l}L_1(x)=y_0l_0(x)+y_1l_1(x)\\l_0(x_0)=1\quad
l_0(x_1)=0\\l_1(x_0)=0\quad l_1(x_1)=1\end{array}\right.\)</span> ，称
<span class="math inline">\(l_0(x),\ l_1(x)\)</span> 为关于 <span
class="math inline">\(x_0,\ x_1\)</span>
的<strong>线性插值基函数</strong>。</p>
<h5 id="抛物插值">抛物插值</h5>
<p>已知三点 <span class="math inline">\((x_0,y_0)\ (x_1,y_1)\
(x_2,y_2)\)</span> 。构造插值函数 <span
class="math inline">\(L_2(x)\)</span> 。称 <span
class="math inline">\(L_2(x)\)</span>
为<strong>抛物插值函数</strong>。<br />
设 <span
class="math inline">\(L_2(x)=y_0l_0(x)+y_1l_1(x)+y_2l_2(x)\)</span>
，则由插值条件可知 <span
class="math inline">\(\left\{\begin{array}{l}l_0(x_0)=1\quad
l_0(x_1)=0\quad l_2(x_2)=0\\l_0(x_0)=0\quad l_0(x_1)=1\quad
l_2(x_2)=0\\l_0(x_0)=0\quad l_0(x_1)=0\quad
l_2(x_2)=1\end{array}\right.\)</span> ，可解得 <span
class="math inline">\(\left\{\begin{array}{l}\displaystyle
l_0(x)=\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}\\\displaystyle
l_1(x)=\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}\\\displaystyle
l_2(x)=\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\end{array}\right.\)</span>
，称为<strong>二次插值基函数</strong>。<br />
得到 <span class="math inline">\(\displaystyle
L_2(x)=y_0\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}+y_1\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}+y_2\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\)</span>
。</p>
<h5 id="mathbf-n-次插值"><span class="math inline">\(\mathbf n\)</span>
次插值</h5>
<p>推广到一般形式：考虑已知 <span class="math inline">\(n+1\)</span>
个点 <span class="math inline">\((x_i,y_i)(i=0,1,2,\dots,n)\)</span>
，构造插值多项式 <span class="math inline">\(L_n(x)\)</span> 。<br />
设 <span class="math inline">\(\displaystyle
L_n(x)=\sum_{i=0}^{n}y_il_i(x)\)</span> ，则 <span
class="math inline">\(l_i(x_j)=\left\{\begin{array}{l}1,\ j=i\\0,\ j\neq
i\end{array}\right.\ i,j=0,1,\dots,n\)</span> ，解得 <span
class="math inline">\(\displaystyle l_i(x)=\prod_{j=0,j\neq
i}^{n}\frac{x-x_j}{x_i-x_j}\)</span> 。 &gt; 引入记号： <span
class="math inline">\(\displaystyle
\omega_{n+1}(x)=\prod_{i=0}^{n}(x-x_i)\)</span> 则有： <span
class="math display">\[
\begin{aligned}L_n&amp;=\displaystyle\sum_{i=0}^n\left(\prod_{j=0,j\neq
i}^n\frac{x-x_j}{x_i-x_j}\right)y_i\\
&amp;=\displaystyle\sum_{i=0}^n\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}y_i\end{aligned}
\]</span> 称这两式为 <span class="math inline">\(\mathbf n\)</span>
<strong>次插值多项式</strong>，也称为<strong>Lagrange插值多项式</strong>。</p>
<h5 id="lagrange插值余项">Lagrange插值余项</h5>
<p>若在 <span class="math inline">\([a,b]\)</span> 上用 <span
class="math inline">\(L_n(x)\)</span> 近似 <span
class="math inline">\(f(x)\)</span> ，则其<strong>截断误差</strong>为
<span class="math inline">\(R_n(x)=f(x)-L_n(x)\)</span>
，也称其为插值多项式的<strong>余项</strong>。</p>
<p>设 <span class="math inline">\(f^{(n)}(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上连续， <span
class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span
class="math inline">\((a,b)\)</span> 内存在，节点 <span
class="math inline">\(a\le x_0&lt;x_1&lt;\dots&lt;x_n\le b\)</span> ，
<span class="math inline">\(L_n(x)\)</span> 是插值多项式，则 <span
class="math inline">\(\forall x\in [a,b],\
R_n=\displaystyle\frac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)\)</span>
，其中 <span class="math inline">\(a&lt;\xi&lt;b\)</span> 且依赖于 <span
class="math inline">\(x\)</span> 。</p>
<p>插值多项式 <span class="math inline">\(L_n(x)\)</span> 逼近 <span
class="math inline">\(f(x)\)</span> 的截断误差限为 <span
class="math inline">\(\left|R_n(x)\right|\le\displaystyle\frac{\max_{a&lt;x&lt;b}\left|f^{(n+1)}(x)\right|}{(n+1)!\left|\omega_{n+1}(x)\right|}\)</span>
。</p>
<p>当被插值函数未知时，无法用上述插值余项估计误差。</p>
<h5 id="事后误差估计">事后误差估计</h5>
<p>求 <span class="math inline">\(L_n(x)\)</span> 为 <span
class="math inline">\(f(x)\)</span> 以 <span
class="math inline">\(x_0,x_1,\dots,x_n\)</span> 为节点的 <span
class="math inline">\(n\)</span> 次插值多项式；<br />
求 <span class="math inline">\(L_n^{(1)}(x)\)</span> 为 <span
class="math inline">\(f(x)\)</span> 以 <span
class="math inline">\(x_1,x_2,\dots,x_n,x_{n+1}\)</span> 为节点的 <span
class="math inline">\(n\)</span> 次插值多项式；<br />
认为两者较 <span class="math inline">\(f(x)\)</span> 误差相近，则有：
<span class="math display">\[
\begin{array}{c}
\displaystyle\frac{f(x)-L_n(x)}{f(x)-L_n^{(1)}}\approx\frac{x-x_0}{x-x_{n+1}}\\
\displaystyle
f(x)\approx\frac{x-x_{n+1}}{x_0-x_{n+1}}L_n(x)+\frac{x-x_0}{x_{n+1}-x_0}L_n^{(1)}(x)\\
\displaystyle
f(x)-L_n(x)\approx\frac{x-x_0}{x_0-x_{n+1}}(L_n(x)-L_n^{(1)}(x))
\end{array}
\]</span></p>
<p>则第三式可用于事后误差估计，第二式可用于较精确的插值多项式。</p>
<h3 id="差商与newton插值">5.4 - 5.5 差商与Newton插值</h3>
<blockquote>
<h4 id="差商或称均差">差商（或称均差）</h4>
<p><strong>定义</strong>：</p>
<ul>
<li>称 <span
class="math inline">\(f[x_0,x_k]=\displaystyle\frac{f(x_k)-f(x_0)}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的一阶差商；</li>
<li>称 <span
class="math inline">\(f[x_0,x_1,x_k]=\displaystyle\frac{f[x_1,x_k]-f[x_0,x_1]}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的二阶差商；</li>
<li>称 <span
class="math inline">\(f[x_0,x_1,\dots,x_k]=\displaystyle\frac{f[x_1,\dots,x_{k-1},x_{k}]-f[x_0,x_1,\dots,x_{k-1}]}{x_k-x_0}\)</span>
为函数 <span class="math inline">\(f(x)\)</span> 关于点 <span
class="math inline">\(x_0,\ x_k\)</span> 的 <span
class="math inline">\(k\)</span> 阶差商。</li>
</ul>
<p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(\displaystyle
f[x_0,\dots,x_k]=\sum_{j=0}^k\frac{f(x_j)}{(x_j-x_0)\cdots(x_j-x_{j-1})(x_j-x_{j+1})\cdots(x_j-x_k)}=\sum_{j=0}^k\frac{f(x_j)}{\omega_{k+1}(x_j)}\)</span></li>
<li>差商与节点的排列次序无关；</li>
<li>若 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上存在 <span
class="math inline">\(n\)</span>
阶导数，且差商节点位于区间内，则：<br />
<span
class="math inline">\(f[x_0,\dots,x_n]=\displaystyle\frac{f^{(n)}(\xi)}{n!},\quad\xi\in[a,b]\)</span>
。</li>
</ul>
</blockquote>
<h4 id="newton插值">Newton插值</h4>
<ul>
<li><p>由直线方程点斜式得到线性插值函数： <span class="math display">\[
L_1(x)=y_0+a_1(x-x_0),\quad a_1=\frac{y_1-y_0}{x_1-x_0}
\]</span></p></li>
<li><p>推广至三点情况得到二次插值函数： <span class="math display">\[
\begin{array}{c}
L_2(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)\\
\left\{\begin{array}{l}
a_0=y_0\\
a_1=\displaystyle\frac{y_1-y_0}{x_1-x_0}\\
a_2=\displaystyle\frac{\displaystyle\frac{y_2-y_0}{x_2-x_0}-\frac{y_1-y_0}{x_1-x_0}}{x_2-x_1}
\end{array}\right.
\end{array}
\]</span></p></li>
<li><p>推广至 <span class="math inline">\(n+1\)</span> 点情况得到 <span
class="math inline">\(n+1\)</span> 次插值函数： <span
class="math display">\[
\begin{aligned}
L_n(x)&amp;=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+\dots+a_n(x-x_0)\dots(x-x_{n-1})\\
&amp;=\displaystyle\sum_{i=0}^{n}\left[a_i\left(\prod_{j=0}^{i-1}(x-x_j)\right)\right]\end{aligned}
\]</span> 由前面的推导和差商的定义可知 <span
class="math inline">\(a_i=f[x_0,x_1,\dots,x_i]\)</span>
；或进行如下推导： <span class="math display">\[
\begin{aligned}
&amp;\quad\left\{\begin{array}{l}
f(x)=f(x_0)+f[x,x_0](x-x_0)\\
f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1])(x-x_1)\\
f[x,x_0,\dots,x_{n-1}]=f[x_0,x_1,\dots,x_n]+f[x,x_0,\dots,x_n]\end{array}\right.\\
&amp;\begin{aligned}\Rightarrow\
f(x)&amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\
&amp;+\dots+f[x_0,x_1,\dots,x_n](x-x_0)\cdots(x-x_{n-1})+f[x,x_0,\dots,x_n]\omega_{n+1}(x)\\
&amp;\equiv N_n(x) + R_n(x)\\\end{aligned}\\
&amp;\begin{aligned}
N_n(x)&amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\
&amp;+\dots+f[x_0,x_1,\dots,x_n](x-x_0)\cdots(x-x_{n-1})\\
R_n(x)&amp;=f[x,x_0,\dots,x_n]\omega_{n+1}(x)
\end{aligned}\end{aligned}
\]</span> 其中 <span class="math inline">\(N_n(x)\)</span>
就称作<strong>Newton插值多项式</strong>，其与Lagrange插值多项式是等价的。
<span class="math inline">\(R_n(x)\)</span>
为Newton插值多项式的余项，它比Lagrange插值多项式的余项更具有一般性，对于离散函数
<span class="math inline">\(f\)</span> 或 <span
class="math inline">\(f\)</span> 导数不存在时均适用。</p>
<blockquote>
<p>Lagrange插值多项式的缺陷：当节点发生改变时，所有计算需要重新计算。</p>
</blockquote></li>
</ul>
<h3 id="代码lagrange插值">代码：Lagrange插值</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-05.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> L<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> sqrt_xy <span class="op">{{</span><span class="dv">100</span><span class="op">,</span> <span class="dv">10</span><span class="op">},</span> <span class="op">{</span><span class="dv">121</span><span class="op">,</span> <span class="dv">11</span><span class="op">},</span> <span class="op">{</span><span class="dv">144</span><span class="op">,</span> <span class="dv">12</span><span class="op">}};</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> L<span class="op">(</span>sqrt_xy<span class="op">,</span> <span class="dv">120</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> L<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> prod <span class="op">*=</span> <span class="op">(</span>x<span class="op">-</span>xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="op">/</span> <span class="op">(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> prod  <span class="op">*</span> xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="代码newton插值含生成差商表">代码：Newton插值（含生成差商表）</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-05.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> DD<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshDD<span class="op">();</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printDD<span class="op">();</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> N<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> xy_array<span class="op">,</span> <span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> sqrt_xy <span class="op">{{-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">},</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">17</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">21</span><span class="op">}};</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> N<span class="op">(</span>sqrt_xy<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">//获取Divided Difference 差商表</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshDD<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> tmp<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> DD<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">)</span> tmp<span class="op">.</span>push_back<span class="op">((</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> tmp<span class="op">.</span>push_back<span class="op">((</span>DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>tmp<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">-</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            DD<span class="op">.</span>push_back<span class="op">(</span>tmp<span class="op">);</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            tmp<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;=</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> DD<span class="op">.</span>size<span class="op">()+</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i <span class="op">=</span> xy_array<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">)</span> tmp<span class="op">.</span>push_back<span class="op">((</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                tmp<span class="op">.</span>push_back<span class="op">((</span>DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>tmp<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])/(</span>xy_array<span class="op">[</span>i<span class="op">-</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]-</span>xy_array<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        DD<span class="op">.</span>push_back<span class="op">(</span>tmp<span class="op">);</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        tmp<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    printDD<span class="op">();</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printDD<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&lt;</span> DD<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&lt;</span> DD<span class="op">.</span>back<span class="op">().</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;)&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> DD<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> DD<span class="op">[</span>i<span class="op">].</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> DD<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> N<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> <span class="va">xy_array_</span><span class="op">,</span> <span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    xy_array<span class="op">.</span>assign<span class="op">(</span><span class="va">xy_array_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">xy_array_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    refreshDD<span class="op">();</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sum <span class="op">=</span> xy_array<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">1</span><span class="op">];</span> <span class="dt">double</span> prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> xy_array<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> prod <span class="op">*=</span> x <span class="op">-</span> xy_array<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> DD<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">].</span>back<span class="op">()</span> <span class="op">*</span> prod<span class="op">;</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        prod <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-04-数值分析-Day07-Newton迭代法</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-04-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day07-newton%E8%BF%AD%E4%BB%A3%E6%B3%95/</link>
      <pubDate>Thu, 04 Mar 2021 19:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-04-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day07-newton%E8%BF%AD%E4%BB%A3%E6%B3%95/</guid>
      <description>4.11 - 15 牛顿迭代法 Newton迭代法 泰勒级数： \(\displaystyle f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(a)}{n!}(x-a)^n\)
泰勒展开公式： \(\displaystyle f(x)=\sum_{n=0}^n\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\)
皮亚诺型余项： \(R_n(x)=o[(x-a)^n]\) ，即当 \(x\to a\) 时，余项为 \((x-a)^n\) 的高阶无穷小 拉格朗日型余项： \(R_n(x)=\displaystyle\frac{f^{(n+1)}(\theta)}{(n+1)!}(x-a)^{(n+1)},\ \theta\in(a,x)\)
积分型余项： \(R_{n}(x)=\displaystyle\int_{a}^{x}{\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\,dt\) 原理：将非线性方程线性化——Taylor展开
取 \(x_0\) 作为初始近似值，将 \(f(x)\) 在 \(x_0\) 处做一阶Taylor展开： \[ \begin{array}{c}f(x)=f(x_0)+f&amp;#39;(x_0)(x-x_0)+\displaystyle{f&amp;#39;&amp;#39;(\xi)}{2!}(x-x_0)^2,\quad \xi\in(x_0,x)\\ 0=f(x^*)\approx f(x_0)+f&amp;#39;(x_0)(x-x_0)\quad\Rightarrow\quad x^*\approx x_0-\displaystyle\frac{f(x_0)}{f&amp;#39;(x_0)}\\ \left\{\begin{array}{l}x_1=x_0-\displaystyle\frac{f(x_0)}{f&amp;#39;(x_0)}\\ x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f&amp;#39;(x_k)}\quad\leftarrow\ \textbf{Newton迭代公式}\end{array}\right.\end{array} \]
Newton迭代法的收敛性 定理：设 \(f\in C^2[a,b]\) （二阶连续可微），若 \(x^*\) 为 \(f(x)=0\) 在 \([a,b]\) 上的根，且 \(f&amp;#39;(x^*)\neq0\) ，则Newton迭代法是二阶收敛的，且有 \(\displaystyle\lim_{k\to\infty}\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\frac{f&amp;#39;&amp;#39;(x^*)}{2f&amp;#39;(x^*)}\) 。
初值的选取：令 \(c=\displaystyle\frac{\max|f&amp;#39;&amp;#39;(x)|}{2\min|f&amp;#39;(x)|}\) ，则有： \[ c|x_{k+1}-x^*|\le(c|x_{k}-x^*|)^2\le(c|x_{k-1}-x^*|)^4\le\dots\le\le(c|x_{k+1}-x^*|)^{2^{k+1}} \] 因此， \(c|x_0-x^*|=1\ \Rightarrow\ |x_0-x^*|\le\displaystyle\frac{2\min|f&amp;#39;(x)|}{\max|f&amp;#39;&amp;#39;(x)|}\) 时，Newton迭代法收敛。
Newton下山法 调整 \(x_0\) 的选取来使得Newton迭代法满足收敛条件。</description>
      <content:encoded><![CDATA[<h3 id="牛顿迭代法">4.11 - 15 牛顿迭代法</h3>
<h4 id="newton迭代法">Newton迭代法</h4>
<blockquote>
<p>泰勒级数： <span class="math inline">\(\displaystyle
f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span></p>
<p>泰勒展开公式： <span class="math inline">\(\displaystyle
f(x)=\sum_{n=0}^n\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\)</span></p>
<ul>
<li>皮亚诺型余项： <span
class="math inline">\(R_n(x)=o[(x-a)^n]\)</span> ，即当 <span
class="math inline">\(x\to a\)</span> 时，余项为 <span
class="math inline">\((x-a)^n\)</span> 的高阶无穷小</li>
<li>拉格朗日型余项： <span
class="math inline">\(R_n(x)=\displaystyle\frac{f^{(n+1)}(\theta)}{(n+1)!}(x-a)^{(n+1)},\
\theta\in(a,x)\)</span><br />
</li>
<li>积分型余项： <span
class="math inline">\(R_{n}(x)=\displaystyle\int_{a}^{x}{\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\,dt\)</span></li>
</ul>
</blockquote>
<p><strong>原理</strong>：将非线性方程线性化——Taylor展开</p>
<p>取 <span class="math inline">\(x_0\)</span> 作为初始近似值，将 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0\)</span> 处做一阶Taylor展开： <span
class="math display">\[
\begin{array}{c}f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\displaystyle{f&#39;&#39;(\xi)}{2!}(x-x_0)^2,\quad
\xi\in(x_0,x)\\
0=f(x^*)\approx f(x_0)+f&#39;(x_0)(x-x_0)\quad\Rightarrow\quad
x^*\approx x_0-\displaystyle\frac{f(x_0)}{f&#39;(x_0)}\\
\left\{\begin{array}{l}x_1=x_0-\displaystyle\frac{f(x_0)}{f&#39;(x_0)}\\
x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f&#39;(x_k)}\quad\leftarrow\
\textbf{Newton迭代公式}\end{array}\right.\end{array}
\]</span></p>
<h4 id="newton迭代法的收敛性">Newton迭代法的收敛性</h4>
<p><strong>定理</strong>：设 <span class="math inline">\(f\in
C^2[a,b]\)</span> （二阶连续可微），若 <span
class="math inline">\(x^*\)</span> 为 <span
class="math inline">\(f(x)=0\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上的根，且 <span
class="math inline">\(f&#39;(x^*)\neq0\)</span>
，则Newton迭代法是二阶收敛的，且有 <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\frac{f&#39;&#39;(x^*)}{2f&#39;(x^*)}\)</span>
。</p>
<p><strong>初值的选取</strong>：令 <span
class="math inline">\(c=\displaystyle\frac{\max|f&#39;&#39;(x)|}{2\min|f&#39;(x)|}\)</span>
，则有： <span class="math display">\[
c|x_{k+1}-x^*|\le(c|x_{k}-x^*|)^2\le(c|x_{k-1}-x^*|)^4\le\dots\le\le(c|x_{k+1}-x^*|)^{2^{k+1}}
\]</span> 因此， <span class="math inline">\(c|x_0-x^*|=1\ \Rightarrow\
|x_0-x^*|\le\displaystyle\frac{2\min|f&#39;(x)|}{\max|f&#39;&#39;(x)|}\)</span>
时，Newton迭代法收敛。</p>
<h4 id="newton下山法">Newton下山法</h4>
<p>调整 <span class="math inline">\(x_0\)</span>
的选取来使得Newton迭代法满足收敛条件。</p>
<p><strong>定义</strong>：对Newton迭代过程附加单调性要求： <span
class="math inline">\(|f(x_{k+1})|&lt;|x_k|\)</span>
，满足该条件的Newton迭代法称为<strong>Newton下山法</strong>。</p>
<p><strong>实现</strong>：若由 <span class="math inline">\(x_k\)</span>
得到的 <span class="math inline">\(x_{k+1}\)</span> 不能使得 <span
class="math inline">\(|f|\)</span> 减小，则在 <span
class="math inline">\(x_k\)</span> 和 <span
class="math inline">\(x_{k+1}\)</span> 之间找点 <span
class="math inline">\(\overline{x_{k+1}}\)</span> ，使得 <span
class="math inline">\(|f(\overline{x_{k+1}})|&lt;|f(x_k)|\)</span> ，
<span class="math display">\[
\begin{aligned}\overline{x_{k+1}}&amp;=\lambda x_{k+1}+(1-\lambda)x_k\\
&amp;=\lambda[x_k-\frac{f(x_k)}{f&#39;(x_k)}]+(1-\lambda)x_k\\
&amp;=x_k-\lambda\frac{f(x_k)}{f&#39;(x_k)}\end{aligned}
\]</span> 其中， <span class="math inline">\(\lambda=1\)</span>
时即Newton迭代法，当 <span class="math inline">\(\lambda=1\)</span>
效果不好时，将 <span class="math inline">\(\lambda\)</span>
减半计算。</p>
<h4 id="newton迭代法的变形">Newton迭代法的变形</h4>
<p>Newton下山法中计算每次迭代都需要计算一阶导数，试图简化计算。</p>
<h5 id="简化newton迭代法">简化Newton迭代法</h5>
<p>采用迭代格式： <span
class="math inline">\(x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{M},\
k=0,1,2,\dots\)</span> ，即用常数来代替一阶导，通常取 <span
class="math inline">\(M=f&#39;(x_0)\)</span>
。一般，简化Newton迭代法只具有线性收敛。</p>
<h5 id="割线法">割线法</h5>
<p>采用迭代格式： <span
class="math inline">\(x_{k+1}=x_k-\displaystyle\frac{f(x_k)}{f(x_k)-f(x_{k-1})}\
k=0,1,2,3,\dots\)</span> ，需要取两个初值 <span
class="math inline">\(x_0,x_1\)</span> 。收敛阶 <span
class="math inline">\(p\approx1.618\)</span> 。</p>
<h4 id="求重根的newton迭代法">求重根的Newton迭代法</h4>
<blockquote>
<p><strong>重根</strong>：称 <span class="math inline">\(x^*\)</span>
为方程 <span class="math inline">\(f(x)=0\)</span> 的 <span
class="math inline">\(m\)</span> 重根时，是指 <span
class="math inline">\(f(x)=(x-x^*)^mh(x)\)</span> ，其中 <span
class="math inline">\(h(x)\)</span> 在 <span
class="math inline">\(x=x^*\)</span> 处连续且 <span
class="math inline">\(h(x^*)\neq0\)</span> ，若 <span
class="math inline">\(h(x)\)</span> 在 <span
class="math inline">\(x^*\)</span> 处充分可微，则 <span
class="math inline">\(f(x^*)=f&#39;(x^*)=\dots=f^{(m-1)}(x^*)=0,\
f^{(m)}(x^*)\neq0\)</span> 。</p>
</blockquote>
<p>由于 <span
class="math inline">\([f(x)]^{\frac{1}{m}}=(x-x^*)[h(x)]^{\frac{1}{m}}\)</span>
，知 <span class="math inline">\(x^*\)</span> 恰是方程 <span
class="math inline">\([f(x)]^{\frac{1}{m}}\)</span>
的单根。应用Newton迭代法对该方程求解，得到： <span
class="math display">\[
\begin{aligned}x_{k+1}&amp;=x_k-\frac{[f(x_k)]^{\frac{1}{m}}}{\frac{1}{m}[f(x_k)]^{\frac{1}{m}-1}f&#39;(x_k)}\\
&amp;=x_k-m\frac{f(x_k)}{f&#39;(x_k)},\quad k=0,1,2,\dots\end{aligned}
\]</span> 也称之为<strong>带参数的Newton迭代法</strong>，求方程 <span
class="math inline">\(f(x)=0\)</span> 的 <span
class="math inline">\(m\)</span> 重根时具有平方收敛。</p>
<p>当 <span class="math inline">\(m\)</span> 未知时：</p>
<p>根据函数 <span class="math inline">\(\displaystyle
u(x)=\frac{f(x)}{f&#39;(x)}=\frac{(x-x^*)h(x)}{mh(x)+(x-x^*)h&#39;(x)}\)</span>
，可见 <span class="math inline">\(x^*\)</span> 恰是方程 <span
class="math inline">\(u(x)\)</span> 的单根。对之应用Newton迭代法有：
<span class="math display">\[
x_{k+1}=x_k-\frac{u(x_k)}{u&#39;(x_k)}=x_k-\frac{f(x_k)f&#39;(x_k)}{[f&#39;(x_k)]^2-f(x_k)f&#39;&#39;(x_k)},\quad
k=0,1,2,\dots
\]</span> 在该迭代过程中，不需要知道根的重数，具有平方收敛。</p>
<h3 id="代码newton迭代法三种">代码：Newton迭代法（三种）</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-04.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">//已知一阶导函数求单根</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">//已知二阶导函数求重根（重数任意）</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_2<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">//未知导函数，有二初值，利用割线法求单根</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">,</span> <span class="dt">double</span> x_1<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pow<span class="op">(</span>x<span class="op">,</span><span class="dv">4</span><span class="op">)</span> <span class="op">-</span> <span class="fl">8.6</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">-</span> <span class="fl">35.51</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="fl">464.4</span><span class="op">*</span>x <span class="op">-</span> <span class="fl">998.46</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f_1 <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">4</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">3</span><span class="op">)</span> <span class="op">-</span> <span class="dv">3</span><span class="op">*</span><span class="fl">8.6</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="fl">35.51</span><span class="op">*</span>x <span class="op">+</span> <span class="fl">464.4</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f_2 <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">double</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span><span class="op">*</span><span class="dv">4</span><span class="op">*</span>pow<span class="op">(</span>x<span class="op">,</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="fl">8.6</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="fl">35.51</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> f_1<span class="op">,</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> f_1<span class="op">,</span> f_2<span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>f<span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> next_x<span class="op">;</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x <span class="op">/</span> f_1_x<span class="op">;</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_1<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f_2<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span> <span class="dt">double</span> f_2_x <span class="op">=</span> f_2<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> next_x<span class="op">;</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> f_1_x <span class="op">=</span> f_1<span class="op">(</span>x<span class="op">);</span> f_2_x<span class="op">=</span>f_2<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x<span class="op">*</span>f_1_x<span class="op">/(</span>f_1_x<span class="op">*</span>f_1_x<span class="op">-</span>f_x<span class="op">*</span>f_2_x<span class="op">);</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;OK&quot;</span><span class="op">;</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">double</span> <span class="op">(</span><span class="dt">double</span><span class="op">)&gt;</span> <span class="at">const</span><span class="op">&amp;</span> f<span class="op">,</span> <span class="dt">double</span> x_0<span class="op">,</span> <span class="dt">double</span> x_1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> pre_x <span class="op">=</span> x_0<span class="op">;</span> <span class="dt">double</span> f_pre_x <span class="op">=</span> f<span class="op">(</span>pre_x<span class="op">);</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> x_1<span class="op">;</span> <span class="dt">double</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">g_x</span> <span class="op">=</span> f_x <span class="op">-</span> f_pre_x<span class="op">;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x <span class="op">-</span> x<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1e-6</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>count<span class="op">;</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        pre_x <span class="op">=</span> x<span class="op">;</span> x <span class="op">=</span> next_x<span class="op">;</span> f_pre_x <span class="op">=</span> f<span class="op">(</span>pre_x<span class="op">);</span> f_x <span class="op">=</span> f<span class="op">(</span>x<span class="op">);</span> <span class="va">g_x</span> <span class="op">=</span> f_x <span class="op">-</span> f_pre_x<span class="op">;</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;第&quot;</span> <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="st">&quot;次：&quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        lambda <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        next_x <span class="op">=</span> x <span class="op">-</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>f<span class="op">(</span>next_x<span class="op">))</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>f_x<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            lambda <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            next_x <span class="op">=</span> x <span class="op">-</span> lambda <span class="op">*</span> f_x <span class="op">/</span> <span class="va">g_x</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-03-数值分析-Day06-非线性方程的迭代解法及收敛性</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-03-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day06-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95%E5%8F%8A%E6%94%B6%E6%95%9B%E6%80%A7/</link>
      <pubDate>Wed, 03 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-03-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day06-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95%E5%8F%8A%E6%94%B6%E6%95%9B%E6%80%A7/</guid>
      <description>4.1-3 非线性方程简介及二分法：略 4.4 - 10 简单迭代法的构造与收敛性 构造简单迭代法 \[ \begin{array}{c}\begin{aligned} f(x)=0\quad&amp;amp;\Leftrightarrow\quad x=\varphi(x)\\ f(x)的根\quad&amp;amp;\Leftrightarrow\quad\varphi(x)的不动点 \end{aligned}\end{array} \]
其中 \(x_{k+1}=\varphi(x_k),\quad (k=0,1,2,\dots)\) 称为迭代格式， \(\varphi(x)\) 称为迭代函数。
简单迭代法的收敛条件 几何解释：求方程 \(x=\varphi(x)\) 的根，就是求直线 \(y=x\) 和曲线 \(y=\varphi(x)\) 的交点的横坐标。（图略。）
如果 \(x_{k+1}=\varphi(x_k)\) 收敛，则迭代函数 \(y=\varphi(x)\) 的曲线走势平坦，即 \(\left|\varphi&amp;#39;(x)\right|&amp;lt;1\) ；
如果 \(x_{k+1}=\varphi(x_k)\) 发散，则迭代函数 \(y=\varphi(x)\) 的曲线走势陡峭，即 \(\left|\varphi&amp;#39;(x)\right|\ge1\) ；
迭代法收敛的判定定理：设函数 \(\varphi(x)\) 满足条件： \[ \begin{array}{l}(1)\quad \forall x\in[a,b],\ a\le\varphi(x)\le b;\\ (2)\quad \exists0\le L&amp;lt;1,\ \begin{array}{l}\forall x,y\in[a,b],\ |\varphi(x)-\varphi(y)|\le L|x-y|\\或\ |\varphi&amp;#39;(x)\le L&amp;lt;1|\end{array}\end{array} \]
则 \(\forall x_0\in[a,b]\) ，由 \(x_{k+1}=\varphi(x_K)\) 得到的序列 \(\{x_k\}_{k=0}^\infty\) 收敛于 \(\varphi(x)\) 在 \([a,b]\) 上的唯一不动点。并且由误差估计式： \(\begin{array}{l}\displaystyle\left|x^*-x_k\right|\le\frac{1}{1-L}\left|x_k-x_{k-1}\right|\\\displaystyle\left|x^*-x_k\right|\le\frac{L^k}{1-L}\left|x_1-x_0\right|\end{array}\) 。由第一式分析误差；由第二式得到结论 \(L\) 越小，收敛越快 。</description>
      <content:encoded><![CDATA[<h3 id="非线性方程简介及二分法略">4.1-3 非线性方程简介及二分法：略</h3>
<h3 id="简单迭代法的构造与收敛性">4.4 - 10 简单迭代法的构造与收敛性</h3>
<h4 id="构造简单迭代法">构造简单迭代法</h4>
<p><span class="math display">\[
\begin{array}{c}\begin{aligned}
f(x)=0\quad&amp;\Leftrightarrow\quad x=\varphi(x)\\
f(x)的根\quad&amp;\Leftrightarrow\quad\varphi(x)的不动点
\end{aligned}\end{array}
\]</span></p>
<p>其中 <span class="math inline">\(x_{k+1}=\varphi(x_k),\quad
(k=0,1,2,\dots)\)</span> 称为<strong>迭代格式</strong>， <span
class="math inline">\(\varphi(x)\)</span>
称为<strong>迭代函数</strong>。</p>
<h4 id="简单迭代法的收敛条件">简单迭代法的收敛条件</h4>
<p><strong>几何解释</strong>：求方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的根，就是求直线 <span
class="math inline">\(y=x\)</span> 和曲线 <span
class="math inline">\(y=\varphi(x)\)</span>
的交点的横坐标。（图略。）</p>
<p>如果 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
收敛，则迭代函数 <span class="math inline">\(y=\varphi(x)\)</span>
的曲线走势平坦，即 <span
class="math inline">\(\left|\varphi&#39;(x)\right|&lt;1\)</span>
；<br />
如果 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
发散，则迭代函数 <span class="math inline">\(y=\varphi(x)\)</span>
的曲线走势陡峭，即 <span
class="math inline">\(\left|\varphi&#39;(x)\right|\ge1\)</span> ；</p>
<p><strong>迭代法收敛的判定定理</strong>：设函数 <span
class="math inline">\(\varphi(x)\)</span> 满足条件： <span
class="math display">\[
\begin{array}{l}(1)\quad \forall x\in[a,b],\ a\le\varphi(x)\le b;\\
(2)\quad \exists0\le L&lt;1,\ \begin{array}{l}\forall x,y\in[a,b],\
|\varphi(x)-\varphi(y)|\le L|x-y|\\或\ |\varphi&#39;(x)\le
L&lt;1|\end{array}\end{array}
\]</span></p>
<p>则 <span class="math inline">\(\forall x_0\in[a,b]\)</span> ，由
<span class="math inline">\(x_{k+1}=\varphi(x_K)\)</span> 得到的序列
<span class="math inline">\(\{x_k\}_{k=0}^\infty\)</span> 收敛于 <span
class="math inline">\(\varphi(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上的唯一不动点。并且由误差估计式：
<span
class="math inline">\(\begin{array}{l}\displaystyle\left|x^*-x_k\right|\le\frac{1}{1-L}\left|x_k-x_{k-1}\right|\\\displaystyle\left|x^*-x_k\right|\le\frac{L^k}{1-L}\left|x_1-x_0\right|\end{array}\)</span>
。由第一式分析误差；由第二式得到结论 <span
class="math inline">\(L\)</span> 越小，收敛越快 。</p>
<h4 id="局部收敛性">局部收敛性</h4>
<p><strong>定义</strong>：若存在 <span
class="math inline">\(x^*\)</span> 的某个邻域 <span
class="math inline">\(S=\{|x-x^*|\le\delta\}\subset[a,b]\)</span>
，使迭代过程 <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
对于任一初值 <span class="math inline">\(x_0\in S\)</span>
均收敛则称迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在根 <span
class="math inline">\(x^*\)</span>
邻近具有<strong>局部收敛性</strong>。</p>
<p><strong>判定定理</strong>： <span
class="math inline">\(\varphi(x)\)</span> 在方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的精确根 <span
class="math inline">\(x^*\)</span> 的邻域连续，且 <span
class="math inline">\(|\varphi&#39;(x^*)|&lt;1\)</span> ，则迭代过程
<span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在根 <span
class="math inline">\(x^*\)</span> 的邻域具有局部收敛性。</p>
<p>不严格的准则：只要在一个不大的有根区间上， <span
class="math inline">\(|\varphi&#39;(x)|&lt;1\)</span>
明显成立，则从该区间内一点 <span class="math inline">\(x_0\)</span>
出发， <span class="math inline">\(x_{k+1}=\varphi(x_k)\)</span>
产生的迭代序列 <span class="math inline">\(\{x_k\}\)</span>
一般是收敛的。</p>
<h4 id="收敛阶描述收敛速度">收敛阶（描述收敛速度）</h4>
<p>观察得到， <span class="math inline">\(|\varphi&#39;(x)|\)</span>
越小，收敛速度越快，越大越慢。</p>
<p><strong>定义</strong>：记迭代误差 <span
class="math inline">\(e_k=x^*-x_k\)</span> ，对收敛于方程 <span
class="math inline">\(x=\varphi(x)\)</span> 的根 <span
class="math inline">\(x^*\)</span> 的迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> ，若存在常数 <span
class="math inline">\(p\ge1\)</span> 和非零常数 <span
class="math inline">\(C\)</span> ，使得 <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{|e_{k+1}|}{|e_k|^p}=C\)</span>
，则称迭代过程是 <span class="math inline">\(\mathbf{p}\)</span>
<strong>阶收敛</strong>的， <span class="math inline">\(C\)</span>
是<strong>渐进误差常数</strong>。<br />
其中， <span class="math inline">\(p=1\)</span>
时称<strong>线性收敛</strong>， <span
class="math inline">\(p&gt;1\)</span> 时称<strong>超线性收敛</strong>，
<span class="math inline">\(p=2\)</span> 时称<strong>平方收敛</strong>。
<span class="math inline">\(p\)</span> 越大，收敛速度越快。</p>
<p><strong>定理</strong>：若 <span
class="math inline">\(\varphi&#39;(x)\)</span> 在 <span
class="math inline">\(\varphi(x)\)</span> 的不动点 <span
class="math inline">\(x^*\)</span> 邻域连续，且 <span
class="math inline">\(\varphi&#39;(x)\neq0\)</span> ，则迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在 <span
class="math inline">\(x^*\)</span> 的邻域是线性收敛的。</p>
<h4 id="mathbfp-阶收敛的迭代法"><span
class="math inline">\(\mathbf{p}\)</span> 阶收敛的迭代法</h4>
<p><strong>定理</strong>：若 <span class="math inline">\(x^*\)</span> 是
<span class="math inline">\(\varphi(x)\)</span> 的不动点，对于整数 <span
class="math inline">\(p&gt;1\)</span> ，迭代函数 <span
class="math inline">\(\varphi(x)\)</span> 及其 <span
class="math inline">\(p\)</span> 阶导数在 <span
class="math inline">\(x^*\)</span> 的邻域上连续，且满足： <span
class="math inline">\(\varphi&#39;(x^*)=\varphi&#39;&#39;(x^*)=\dots=\varphi^{(p-1)}(x^*)=0,\quad
\varphi^{(p)}(x^*)\neq0\)</span> ，则迭代过程 <span
class="math inline">\(x_{k+1}=\varphi(x_k)\)</span> 在 <span
class="math inline">\(x^*\)</span> 的邻域是 <span
class="math inline">\(p\)</span> 阶收敛的。且有： <span
class="math inline">\(\displaystyle\lim_{k\to\infty}\frac{e_{k+1}}{e_k^p}=\frac{\varphi^{(p)}(x^*)}{p!}\)</span>
。</p>
<p>因此， <span class="math inline">\(\varphi&#39;(x^*)\neq0\)</span>
时，迭代过程只可能是线性的，因此绝大部分迭代方法只能是线性收敛的。</p>
<h4 id="aitken加速算法">Aitken加速算法</h4>
<p>由于 <span
class="math inline">\(\begin{array}{l}x_{k+1}-x^*=\varphi&#39;(\xi_1)(x_k-x^*)\\x_{k+2}-x^*=\varphi&#39;(\xi_2)(x_{k+1}-x^*)\end{array}\)</span>
，当 <span class="math inline">\(k\)</span> 较大时，假设 <span
class="math inline">\(\varphi&#39;(\xi_1)\approx\varphi&#39;(\xi_2)\)</span>
，则有： <span
class="math inline">\(\displaystyle\frac{x_{k+1}-x^*}{x_{k+2}-x^*}\approx\frac{x_k-x^*}{x_{k+1}-x^*}\)</span>
。然后解得 <span class="math inline">\(x^*\approx \hat
x_k=x_k-\displaystyle\frac{(x_{k+1}-x_k)^2}{x_{k+2}-2x_{k+1}+x_k}\)</span>
。</p>
<p>则序列 <span class="math inline">\(\{\hat x_k\}\)</span> 比序列 <span
class="math inline">\(\{x_k\}\)</span> 更快地收敛于 <span
class="math inline">\(x^*\)</span>
，可构造如下<strong>Aitken加速算法</strong>： <span
class="math display">\[
\left\{\begin{array}{l}
y_k=\varphi(x_k)\\
z_k=\varphi(y_k)\\
x_{k+1}=x_k-\displaystyle\frac{(y_k-x_k)^2}{z_k-2y_k+x_k},
\quad k=0,1,2,\dots
\end{array}\right.
\]</span> 若第 <span class="math inline">\(k\)</span> 步发生 <span
class="math inline">\(z_k-2y_k+x_k=0\)</span> ，则中止计算，取 <span
class="math inline">\(x^*\approx x_k\)</span> 。</p>
<h3 id="代码二分法">代码：二分法</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-03.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> f<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> solve<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="dt">double</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">&amp;</span>b<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> solve<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;The solve in [1, 2] is : x = &quot;</span> <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> f<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> x <span class="op">-</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> solve<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>f<span class="op">(</span>a<span class="op">)</span> <span class="op">*</span> f<span class="op">(</span>b<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;WRONG INTERVAL&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> epsilon <span class="op">=</span> <span class="fl">1e-5</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>a<span class="op">-</span>b<span class="op">)</span> <span class="op">&gt;=</span> epsilon<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        iterate<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span><span class="dt">double</span> <span class="op">&amp;</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_a <span class="op">=</span> f<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_b <span class="op">=</span> f<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> f_c <span class="op">=</span> f<span class="op">((</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>f_c <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>f_a <span class="op">*</span> f_c <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> b <span class="op">=</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>f_b <span class="op">*</span> f_c <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> a <span class="op">=</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="代码简单迭代法与aitken加速算法比较">代码：简单迭代法与Aitken加速算法比较</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-03.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> phi<span class="op">(</span><span class="dt">double</span> x<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_simple<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> next_x_simple<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_simple<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> simple<span class="op">();</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x_aitken<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> next_x_aitken<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> count_aitken<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> aitken<span class="op">();</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    simple<span class="op">();</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    aitken<span class="op">();</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> phi<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.6</span> <span class="op">+</span> <span class="fl">0.99</span> <span class="op">*</span> cos<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> simple<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    x_simple <span class="op">=</span> <span class="fl">1.57</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x_simple <span class="op">=</span> next_x_simple<span class="op">,</span> <span class="op">++</span>count_simple<span class="op">,</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x_simple <span class="op">&lt;&lt;</span> <span class="st">&quot;; &quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        next_x_simple <span class="op">=</span> phi<span class="op">(</span>x_simple<span class="op">);</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x_simple <span class="op">-</span> x_simple<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1e-5</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op"> &lt;&lt;</span> <span class="st">&quot;The count is &quot;</span> <span class="op">&lt;&lt;</span> count_simple <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> aitken<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    x_aitken <span class="op">=</span> <span class="fl">1.57</span><span class="op">;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x_aitken <span class="op">=</span> next_x_aitken<span class="op">,</span> <span class="op">++</span>count_aitken<span class="op">,</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x_aitken <span class="op">&lt;&lt;</span> <span class="st">&quot;; &quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> y <span class="op">=</span> phi<span class="op">(</span>x_aitken<span class="op">);</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> z <span class="op">=</span> phi<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        next_x_aitken <span class="op">=</span> x_aitken</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>                <span class="op">-</span> <span class="op">(</span>pow<span class="op">(</span>y <span class="op">-</span> x_aitken<span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>                <span class="op">/</span> <span class="op">(</span>z <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> y <span class="op">+</span> x_aitken<span class="op">)</span> <span class="op">);</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>next_x_aitken <span class="op">-</span> x_aitken<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1e-5</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op"> &lt;&lt;</span> <span class="st">&quot;The count is &quot;</span> <span class="op">&lt;&lt;</span> count_aitken <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-02-数值分析-Day05-SOR-迭代法收敛性</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-02-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day05-sor-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%94%B6%E6%95%9B%E6%80%A7/</link>
      <pubDate>Tue, 02 Mar 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-02-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day05-sor-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%94%B6%E6%95%9B%E6%80%A7/</guid>
      <description>续：3.1 - 6 迭代法 逐次超松弛迭代法（SOR迭代法） 选取分裂矩阵 \(M\) 为带参数的下三角阵： \(M=\displaystyle\frac{1}{\omega}(D-\omega L),\ B=I-M^{-1}A,\ f=M^{-1}b\) ，其中 \(w&amp;gt;0\) 为可选择的松弛因子。
构造迭代法，迭代矩阵为： \(L_\omega=I-\omega(D-\omega L)^{-1}A=(D-\omega L)^{-1}((1-\omega)D+\omega U)\) 。
则解 \(Ax=b\) 的SOR方法即为： \(\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=L_\omega x^{(k)}+f\quad(k=0,1,\dots)\end{array}\right.\\其中\begin{array}{l}L_\omega=(D-\omega L)^{-1}((1-\omega)D+\omega U),\\f=\omega(D-\omega L)^{-1}b\end{array}\end{array}\) 。
推导得： \(\begin{array}{l}(D-\omega L)x^{(k+1)}=((1-\omega)D+\omega U)x^{(k)}+\omega b\\或Dx^{(k+1)}=Dx^{(k+1)}+\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\end{array}\) 。
分量计算公式为： \(\displaystyle x_i^{(k+1)}=x_1^{(k)}+\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\) 。
可令 \(\Delta x_i=\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\) ，则 \(x_i^{(k+1)}=x_i^{(k)}+\Delta x_i\) 。
Gauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 \(\omega=1\) ）。
当 \(\omega&amp;lt;1\) 时，称为超松弛法；当 \(\omega&amp;gt;1\) 时，称为低松弛法。
计算机中，常用 \(\max\limits_{1\le i\le n}|\Delta x_i|=\max\limits_{1\le i\le n}\left|x_i^{(k+1)}-x_i^{(k)}\right|&amp;lt;\varepsilon\) 或者 \(\left\|r^{(k)}\right\|=\left\|b-Ax^{(k)}\right\|\) 作为迭代终止条件。
迭代法的收敛性 设 \(Ax=b\) ，其中 \(A\in R^{n\times n}\) 为非奇异矩阵，记 \(x^*\) 为原方程组精确解，且设有等价的方程组： \(Ax=b\Leftrightarrow x=Bx+f\) ，则 \(x^*=Bx^*+f\) 。设有一阶定常迭代法 \(x^{(k+1)}=Bx^{(k)}\) 。引进误差向量 \(\varepsilon^{(k)}=x^{(k)}\) ，得到误差向量递推公式 \(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\ \Rightarrow\ \varepsilon^{(k)}=B^k\varepsilon^{(0)}\) 。则研究问题从 \(\varepsilon^{(k)}\to0\) 转换为 \(B^k\to0\) 。</description>
      <content:encoded><![CDATA[<h3 id="续3.1---6-迭代法">续：3.1 - 6 迭代法</h3>
<h4 id="逐次超松弛迭代法sor迭代法">逐次超松弛迭代法（SOR迭代法）</h4>
<p>选取分裂矩阵 <span class="math inline">\(M\)</span>
为带参数的下三角阵： <span
class="math inline">\(M=\displaystyle\frac{1}{\omega}(D-\omega L),\
B=I-M^{-1}A,\ f=M^{-1}b\)</span> ，其中 <span
class="math inline">\(w&gt;0\)</span>
为可选择的<strong>松弛因子</strong>。</p>
<p>构造迭代法，迭代矩阵为： <span
class="math inline">\(L_\omega=I-\omega(D-\omega L)^{-1}A=(D-\omega
L)^{-1}((1-\omega)D+\omega U)\)</span> 。</p>
<p>则解 <span class="math inline">\(Ax=b\)</span> 的SOR方法即为： <span
class="math inline">\(\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=L_\omega
x^{(k)}+f\quad(k=0,1,\dots)\end{array}\right.\\其中\begin{array}{l}L_\omega=(D-\omega
L)^{-1}((1-\omega)D+\omega U),\\f=\omega(D-\omega
L)^{-1}b\end{array}\end{array}\)</span> 。</p>
<p>推导得： <span class="math inline">\(\begin{array}{l}(D-\omega
L)x^{(k+1)}=((1-\omega)D+\omega U)x^{(k)}+\omega
b\\或Dx^{(k+1)}=Dx^{(k+1)}+\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\end{array}\)</span>
。</p>
<p>分量计算公式为： <span class="math inline">\(\displaystyle
x_i^{(k+1)}=x_1^{(k)}+\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\)</span>
。</p>
<p>可令 <span class="math inline">\(\Delta
x_i=\omega(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\)</span>
，则 <span class="math inline">\(x_i^{(k+1)}=x_i^{(k)}+\Delta
x_i\)</span> 。</p>
<p><strong>Gauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 <span
class="math inline">\(\omega=1\)</span> ）。</strong></p>
<p>当 <span class="math inline">\(\omega&lt;1\)</span>
时，称为<strong>超松弛法</strong>；当 <span
class="math inline">\(\omega&gt;1\)</span>
时，称为<strong>低松弛法</strong>。</p>
<p>计算机中，常用 <span class="math inline">\(\max\limits_{1\le i\le
n}|\Delta x_i|=\max\limits_{1\le i\le
n}\left|x_i^{(k+1)}-x_i^{(k)}\right|&lt;\varepsilon\)</span> 或者 <span
class="math inline">\(\left\|r^{(k)}\right\|=\left\|b-Ax^{(k)}\right\|\)</span>
作为迭代终止条件。</p>
<h4 id="迭代法的收敛性">迭代法的收敛性</h4>
<p>设 <span class="math inline">\(Ax=b\)</span> ，其中 <span
class="math inline">\(A\in R^{n\times n}\)</span> 为非奇异矩阵，记 <span
class="math inline">\(x^*\)</span>
为原方程组精确解，且设有等价的方程组： <span
class="math inline">\(Ax=b\Leftrightarrow x=Bx+f\)</span> ，则 <span
class="math inline">\(x^*=Bx^*+f\)</span> 。设有一阶定常迭代法 <span
class="math inline">\(x^{(k+1)}=Bx^{(k)}\)</span> 。引进误差向量 <span
class="math inline">\(\varepsilon^{(k)}=x^{(k)}\)</span>
，得到误差向量递推公式 <span
class="math inline">\(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\
\Rightarrow\ \varepsilon^{(k)}=B^k\varepsilon^{(0)}\)</span>
。则研究问题从 <span
class="math inline">\(\varepsilon^{(k)}\to0\)</span> 转换为 <span
class="math inline">\(B^k\to0\)</span> 。</p>
<p><strong>定理1</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=A\Leftrightarrow\lim\limits_{x\to\infty}\left\|A_k-A\right\|,\
\|\|为任一种算子范数\)</span></p>
<p><strong>定理2</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=A\Leftrightarrow\lim\limits_{x\to\infty}A_kx=Ax,\
x\in R^n\)</span></p>
<p><strong>定理3</strong>： <span
class="math inline">\(\lim\limits_{x\to\infty}A_k=0\Leftrightarrow\rho(A)&lt;1,\
\rho\ 谱半径\)</span></p>
<p><strong>迭代法收敛基本定理</strong>：对方程组 <span
class="math inline">\(x=Bx+f\)</span> ，及对应一阶定常迭代法 <span
class="math inline">\(x^{(k+1)}=Bx^{(k)}+f\)</span>
，迭代法收敛的充要条件为矩阵 <span class="math inline">\(B\)</span>
的谱半径 <span class="math inline">\(\rho(B)&lt;1\)</span> 。</p>
<p>由于 <span class="math inline">\(\rho(B)\le\|B\|\)</span> ，因此矩阵
<span class="math inline">\(B\)</span>
的范数也可用于判别迭代法的收敛性：<br />
<strong>迭代法收敛充分条件</strong>： <span
class="math inline">\(\exists \|B\|=q&lt;1\)</span> ，迭代法收敛，且有
<span
class="math inline">\(\begin{array}{l}\left\|x^*-x^{(k)}\right\|\le
q^k\left\|x^*-x^{(0)}\right\|\\\left\|x^*-x^{(k)}\right\|\le\displaystyle\frac{q}{1-q}\left\|x^k-x^{(k-1)}\right\|\\\left\|x^*-x^{(k)}\right\|\le\displaystyle\frac{q}{1-q^k}\left\|x^1-x^0\right\|\end{array}\)</span>
。根据第二式也可得到迭代法的一种终止条件参考量： <span
class="math inline">\(\left\|x^k-x^{(k-1)}\right\|\)</span> 。</p>
<h4 id="几种特殊迭代法的收敛性">几种特殊迭代法的收敛性</h4>
<blockquote>
<p>如果矩阵 <span class="math inline">\(A\)</span> 的元素满足： <span
class="math inline">\(|a_{ii}|&gt;\displaystyle\sum_{j=1,j\neq
i}^n|a_{ij}|,\ (i=1,2,\dots,n)\)</span> ，则称 <span
class="math inline">\(A\)</span> 为<strong>严格对角占优阵</strong>。</p>
<p>若 <span
class="math inline">\(|a_{ii}|\ge\displaystyle\sum_{j=1,j\neq
i}^n|a_{ij}|,\ (i=1,2,\dots,n)\)</span>
，且至少有一个不等式严格成立，则称 <span
class="math inline">\(A\)</span> 为<strong>弱对角占优阵</strong>。</p>
<p><strong>对角占优定理</strong>：若矩阵 <span
class="math inline">\(A\)</span> 为严格对角占优矩阵，则 <span
class="math inline">\(A\)</span> 为非奇异矩阵。</p>
</blockquote>
<p><strong>Jacobi和Gauss迭代法收敛的充分条件</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span>
为严格对角占优阵，则解该方程的Jacobi迭代法和Gauss-Seidel迭代法均收敛。</p>
<p><strong>SOR迭代法收敛的必要条件</strong>： <span
class="math inline">\(0&lt;\omega&lt;2\)</span> 。</p>
<p><strong>SOR迭代法收敛的充分条件1</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span> 为对称正定矩阵， <span
class="math inline">\(0&lt;\omega&lt;2\)</span>
，则解该方程的SOR迭代法收敛。</p>
<p><strong>SOR迭代法收敛的充分条件2</strong>：对方程 <span
class="math inline">\(Ax=b\)</span> ，如果 <span
class="math inline">\(A\)</span>
为严格对角占优矩阵（或弱对角占优不可约矩阵）， <span
class="math inline">\(0&lt;\omega\le1\)</span>
，则解该方程的SOR迭代法收敛。</p>
<h3 id="代码sor迭代与两种终止条件">代码：SOR迭代与两种终止条件</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">4</span><span class="op">},</span> <span class="op">{-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">17</span><span class="op">,</span> <span class="dv">10</span><span class="op">},</span> <span class="op">{-</span><span class="dv">4</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">}};</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="op">-</span><span class="dv">7</span><span class="op">};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">,</span> <span class="fl">1.46</span><span class="op">);</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span>iterate<span class="op">(</span>A_<span class="op">,</span><span class="va">b_</span><span class="op">,</span><span class="dv">1</span><span class="op">);}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>omega <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> omega <span class="op">&gt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;SOR does not converge !&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="cf">return</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> omega <span class="op">*</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>            r <span class="op">+=</span> tmp <span class="op">*</span> tmp<span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r <span class="op">&lt;</span> <span class="fl">1e-10</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">,</span> <span class="dt">double</span> omega<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> omega <span class="op">*</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> maxDelta <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>next_x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>next_x<span class="op">)))</span> <span class="op">-</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                                   <span class="op">*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>x<span class="op">))));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> maxDelta <span class="op">&lt;&lt;</span> <span class="st">&quot; | &quot;</span><span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>maxDelta <span class="op">&lt;</span> <span class="fl">1e-3</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-03-02-GAMES202高质量实时渲染-Lecture7-8-3DGI</title>
      <link>https://elderlyaugustus.github.io/posts/2022-03-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture7-8-3dgi/</link>
      <pubDate>Tue, 02 Mar 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-03-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture7-8-3dgi/</guid>
      <description>Lecture 7-8 Real-time Global Illumination （3D GI） Introduction GI is complex
Ray tracing … Hack方法：Blinn-Phong——统一大小的Ambient项 in RTR：直接光照 + 一次间接光照
一次间接光照：Q点接收到直接光照后，作为次级光源照射P点的结果 核心问题：
要计算间接光照需要知道
被直接光照照亮的表面有哪些？ / 哪些是次级光源？ 借助Shadow Map 每一个次级光源的“贡献”是多少？ 求和 每一个次级光源作为一个Area Light Reflective Shadow Maps (RSM) 获得光源的Shadow Map，存储光源“可见”的深度/世界坐标/法线/Flux等（即Reflective Shadow Maps），视作多个多个点次级光源，eg. Reflective Shadow Maps为512*512，则有512*512个点光源。 次级光源的反射方向未知——假定次级光源物体材质均为Diffuse。（不假设接收物为Diffuse） Recall 一个Patch（Reflective Shadow Maps的一个像素）的“贡献
\[ \begin{array}{l}\begin{aligned}L_o(\mathrm p,\omega_0)&amp;amp;=\int_{\Omega_\mathrm{patch}}L_i(\mathrm p,\omega_i)V(\mathrm p,\omega_i)f_r(\mathrm p,\omega_i,\omega_0)\cos\theta_i\,\mathrm d \omega_i\\ &amp;amp;=\int_{A_\mathrm{patch}}L_i(\mathrm q\rightarrow \mathrm p)V(\mathrm p,\omega_i)f_r(\mathrm p,\mathrm q\rightarrow \mathrm p,\omega_0)\dfrac{\cos\theta_p\cos\theta_q}{\|q-p\|^2}\,\mathrm d A \end{aligned}\\\\ f_r=\dfrac{\rho}{\pi}\\ L_i=f_r\cdot\dfrac{\Phi}{\mathrm d A}\quad(\Phi\ \text{is the incident flux / energy}) \end{array} \] 故对每个Reflective Shadow Maps的像素只需存储其 \(\Phi\) ， \(\mathrm d A\) 在积分中被约掉； 由于计算复杂、忽略次级光源的Visibility项。 则有：（原论文中为 \(P\rightarrow Q\) ，故论文中原式为下式中 \(q\) 换成 \(p\) ） \[ E_q(x,n)=\Phi_q\dfrac{\max\{0,\langle n_q|x-x_q\rangle \}\max\{0,\langle n|x_q-x\rangle \}}{\|x-x_q\|^4} \]</description>
      <content:encoded><![CDATA[<h3 id="lecture-7-8-real-time-global-illumination-3d-gi">Lecture 7-8
Real-time Global Illumination （3D GI）</h3>
<h4 id="introduction">Introduction</h4>
<ul>
<li><p>GI is complex</p>
<ul>
<li>Ray tracing …</li>
<li>Hack方法：Blinn-Phong——统一大小的Ambient项</li>
</ul></li>
<li><p>in RTR：直接光照 + 一次间接光照</p></li>
<li><p>一次间接光照：Q点接收到直接光照后，作为次级光源照射P点的结果
<img src="/images/games202/GIIntro1.png" alt="GIIntro1" style="zoom:40%;" /></p></li>
</ul>
<p><strong>核心问题：</strong></p>
<p>要计算间接光照需要知道</p>
<ul>
<li>被直接光照照亮的表面有哪些？ / 哪些是次级光源？
<ul>
<li>借助Shadow Map</li>
</ul></li>
<li>每一个次级光源的“贡献”是多少？
<ul>
<li>求和</li>
<li>每一个次级光源作为一个Area Light</li>
</ul></li>
</ul>
<h4 id="reflective-shadow-maps-rsm">Reflective Shadow Maps (RSM)</h4>
<ul>
<li>获得光源的Shadow
Map，存储光源“可见”的<strong>深度/世界坐标/法线/Flux</strong>等（即Reflective
Shadow Maps），视作多个多个点次级光源，eg. Reflective Shadow
Maps为512*512，则有512*512个点光源。</li>
<li>次级光源的反射方向未知——假定次级光源物体材质均为Diffuse。（不假设接收物为Diffuse）</li>
</ul>
<blockquote>
<p>Recall
<img src="/images/games202/LightMeasurementofInterest.png" alt="LightMeasurementofInterest" style="zoom:30%;" /></p>
</blockquote>
<ul>
<li><p>一个Patch（Reflective Shadow Maps的一个像素）的“贡献</p>
<p><img src="/images/games202/RSM1.png" alt="RSM1" style="zoom:60%;" />
<span class="math display">\[
\begin{array}{l}\begin{aligned}L_o(\mathrm
p,\omega_0)&amp;=\int_{\Omega_\mathrm{patch}}L_i(\mathrm
p,\omega_i)V(\mathrm p,\omega_i)f_r(\mathrm
p,\omega_i,\omega_0)\cos\theta_i\,\mathrm d \omega_i\\
&amp;=\int_{A_\mathrm{patch}}L_i(\mathrm q\rightarrow \mathrm
p)V(\mathrm p,\omega_i)f_r(\mathrm p,\mathrm q\rightarrow \mathrm
p,\omega_0)\dfrac{\cos\theta_p\cos\theta_q}{\|q-p\|^2}\,\mathrm d A
\end{aligned}\\\\
f_r=\dfrac{\rho}{\pi}\\
L_i=f_r\cdot\dfrac{\Phi}{\mathrm d A}\quad(\Phi\ \text{is the incident
flux / energy})
\end{array}
\]</span> 故对每个Reflective Shadow Maps的像素只需存储其 <span
class="math inline">\(\Phi\)</span> ， <span
class="math inline">\(\mathrm d A\)</span> 在积分中被约掉；
由于计算复杂、忽略次级光源的Visibility项。 则有：（原论文中为 <span
class="math inline">\(P\rightarrow Q\)</span> ，故论文中原式为下式中
<span class="math inline">\(q\)</span> 换成 <span
class="math inline">\(p\)</span> ） <span class="math display">\[
E_q(x,n)=\Phi_q\dfrac{\max\{0,\langle n_q|x-x_q\rangle \}\max\{0,\langle
n|x_q-x\rangle \}}{\|x-x_q\|^4}
\]</span></p></li>
<li><p>Reflective Shadow
Maps中不是每一个像素都可以作为次级光源有“贡献”：</p>
<ul>
<li>Visibility 遮挡，但该项计算复杂，影响不大，故忽略</li>
<li>Orientation 方向，例如下图 <span
class="math inline">\(x_{-1}\)</span> 对 <span
class="math inline">\(x\)</span> 无光照
<img src="/images/games202/RSM2.jpg" alt="RSM1" style="zoom: 100%;" /></li>
<li>Distance 距离 -&gt; 减少计算量的方法 ↓</li>
</ul></li>
<li><p>假设：以Reflective Shadow Maps上的距离近似世界坐标的距离
<img src="/images/games202/RSM3.jpg" alt="RSM3" style="zoom: 60%;" /></p>
<ul>
<li>参考PCSS，降低Shadow Map作为次级光源的采样</li>
<li>对一个Shadow Map，约400个采样</li>
</ul></li>
<li><p>优势：易于实现 问题：性能开销与直接光源数量成正比 /
间接光照不考虑可见性（不真实） / 大量假设 / 采样率和质量的权衡</p></li>
<li><p>非常类似离线渲染中的VPL(Virtual Point Light)方法</p></li>
</ul>
<h4 id="light-propagation-volumes-lpv">Light Propagation Volumes
(LPV)</h4>
<p><strong>关键问题</strong>：着色点收到所有方向的间接光照
<strong>关键想法</strong>：Radiance沿直线传播，且在空间中传播时不会变化
<strong>解决思路</strong>：用体素传播Radiance</p>
<p><strong>步骤</strong>：</p>
<ul>
<li><p>获取次级光源</p>
<ul>
<li>利用RSM，采样以减少数量</li>
</ul></li>
<li><p>将次级光源的Radiance“注入”到空间网格/体素中</p>
<ul>
<li>预分割三维网格（eg. 3D texture）</li>
<li>对每个网格，找到接近的次级光源</li>
<li>求次级光源接收的直接光照Radiance分布和（空间分布）</li>
<li>用二阶SH函数（4个数值）压缩Radiance空间分布（近似）
<img src="/images/games202/LPV1.png" alt="LPV1" style="zoom: 40%;" /></li>
</ul></li>
<li><p>在网格中传播Radiance</p>
<ul>
<li>空间上向周围6个面传播，周边网格也用二阶SH表示
<img src="/images/games202/LPV2.jpg" alt="LPV2" style="zoom: 40%;" /></li>
<li>迭代4-5次基本达到稳定</li>
</ul></li>
<li><p>在着色点处读取对应体素的Radiance参与渲染</p></li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>由于粒度不够小（至少比画面分辨率小一个数量级），会传播到物体背面/侧面
-&gt; Light Leaking
<img src="/images/games202/LPV3.jpg" alt="LPV3" style="zoom:50%;" /></li>
<li>同样不考虑Visibility</li>
</ul>
<blockquote>
<p>Cascaded / Multiscale / LoD: 用自适应粒度的网格</p>
</blockquote>
<h4 id="voxel-global-illumination-vxgi">Voxel Global Illumination
(VXGI)</h4>
<ul>
<li><p><strong>2 Pass Algorithm</strong> Differences with RSM:</p>
<ul>
<li>直接光照对象 / 次级光源 pixel -&gt; (hierarchical) voxels
（层级结构的体素，大小层级，建立树结构存储）</li>
<li>RSM中的采样 -&gt; 对每个Shading
Point作圆锥形trace，计算trace到的voxels</li>
</ul></li>
<li><p>Voxelize the scene &amp; Build a hierachy</p>
<p><img src="/images/games202/VXGI1.jpg" alt="VXGI1" style="zoom:30%;" /><img src="/images/games202/VXGI2.jpg" alt="VXGI2" style="zoom:60%;" /></p></li>
<li><p>Pass 1 : Light Pass</p>
<ul>
<li>存储光源的入射分布、法线分布，再在trace时计算出射分布（比LPV中视作Diffuse使用SH压缩存储准确，可以支持Glossy材质）
<img src="/images/games202/VXGI3.png" alt="VXGI3" style="zoom:30%;" /></li>
<li>在hiearchy中更新</li>
</ul></li>
<li><p>Pass 2 : Camera Pass</p>
<ul>
<li><p>对Glossy材质，向反射方向作cone trace</p></li>
<li><p>基于cone的大小遍历hierarchy，找到相近大小的块再求和
<img src="/images/games202/VXGI4.jpg" alt="VXGI4" style="zoom:40%;" /><img src="/images/games202/VXGI5.jpg" alt="VXGI5" style="zoom:40%;" /></p></li>
<li><p><strong>PS</strong>：对Diffuse材质，求能覆盖表面的多个cone
trace（eg.8个，空隙可忽略）
<img src="/images/games202/VXGI6.jpg" alt="VXGI6" style="zoom: 30%;" /></p></li>
</ul></li>
<li><p>问题：计算量较大、实时体素化开销较大</p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-03-01-数值分析-Day04-Jacobi-GaussSeidel</title>
      <link>https://elderlyaugustus.github.io/posts/2021-03-01-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day04-jacobi-gaussseidel/</link>
      <pubDate>Mon, 01 Mar 2021 20:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-03-01-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day04-jacobi-gaussseidel/</guid>
      <description>3.1 - 6 迭代法 基本思想 对线性方程组 \(Ax=b\) ，当 \(A\) 为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。
工程应用中 \(A\) 常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。
通法：
将 \(Ax=b\) 改写为 \(x=B_0x+f\) 任取初始值，如 \(x^{(0)}=(0,0,0)^T\) ，将其带入得到方程组解 \(x^{(1)}=B_0x^{(0)}+f\) 依次得： \(x^{(2)}=B_0x^{(1)}+f,\ x^{(2)}=B_0x^{(1)}+f,\ \dots,\ x^{(k)}=B_0x^{(k-1)}+f,\ \dots\) 即得向量序列 \(x^{(0)},x^{(1)},\dots,x^{(k)}\) ，迭代公式 \(x^{(k)}=B_0x^{(k-1)}+f\) 迭代次数较高时，向量序列 \(x^{(k)}\) 有可能收敛至逼近精确解的值（不一定）。 根据 \(x=Bx+f\) 变形方式的不同，存在多种迭代算法。
定义1：
对于给定方程组 \(x=Bx+f\) ，用公式 \(x^{k+1}=Bx^{(k)}+f,\ (k=0,1,2,3,\dots)\) 逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 \(B\) 与 \(k\) 无关）。
如果 \(\lim\limits_{k\to\infty}x^{(k)}=x^*\) ，即向量序列收敛至精确解序列，则称此迭代法收敛，否则称发散。
由于需要研究 \(\{x^{(k)}\}\) 的收敛性，引进误差向量 \(\varepsilon^{(k+1)}=x^{(k+1)}-x^*\) 。易得到： \(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\) ，递推得： \(\varepsilon^{(k)}=B\varepsilon^{(k-1)}=\dots=B^k\varepsilon^{(0)}\) 。
Jacobi迭代 通法细节：
将 \(A\) 分裂成 \(A=M-N\) ，其中 \(M\) 为可选择的非奇异矩阵，使 \(Mx=d\) 易解，一般选择为 \(A\) 的某种近似，称 \(M\) 为分裂矩阵。</description>
      <content:encoded><![CDATA[<h3 id="迭代法">3.1 - 6 迭代法</h3>
<h4 id="基本思想">基本思想</h4>
<p>对线性方程组 <span class="math inline">\(Ax=b\)</span> ，当 <span
class="math inline">\(A\)</span>
为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。<br />
工程应用中 <span class="math inline">\(A\)</span>
常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。</p>
<p><strong>通法</strong>：</p>
<ul>
<li>将 <span class="math inline">\(Ax=b\)</span> 改写为 <span
class="math inline">\(x=B_0x+f\)</span></li>
<li>任取初始值，如 <span
class="math inline">\(x^{(0)}=(0,0,0)^T\)</span> ，将其带入得到方程组解
<span class="math inline">\(x^{(1)}=B_0x^{(0)}+f\)</span></li>
<li>依次得： <span class="math inline">\(x^{(2)}=B_0x^{(1)}+f,\
x^{(2)}=B_0x^{(1)}+f,\ \dots,\ x^{(k)}=B_0x^{(k-1)}+f,\
\dots\)</span></li>
<li>即得向量序列 <span
class="math inline">\(x^{(0)},x^{(1)},\dots,x^{(k)}\)</span> ，迭代公式
<span class="math inline">\(x^{(k)}=B_0x^{(k-1)}+f\)</span></li>
<li>迭代次数较高时，向量序列 <span
class="math inline">\(x^{(k)}\)</span>
<strong>有可能</strong>收敛至逼近精确解的值（不一定）。</li>
</ul>
<p>根据 <span class="math inline">\(x=Bx+f\)</span>
变形方式的不同，存在多种迭代算法。</p>
<p><strong>定义1</strong>：<br />
对于给定方程组 <span class="math inline">\(x=Bx+f\)</span> ，用公式
<span class="math inline">\(x^{k+1}=Bx^{(k)}+f,\
(k=0,1,2,3,\dots)\)</span>
逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 <span
class="math inline">\(B\)</span> 与 <span
class="math inline">\(k\)</span> 无关）。<br />
如果 <span
class="math inline">\(\lim\limits_{k\to\infty}x^{(k)}=x^*\)</span>
，即向量序列<strong>收敛</strong>至精确解序列，则称此迭代法<strong>收敛</strong>，否则称<strong>发散</strong>。<br />
由于需要研究 <span class="math inline">\(\{x^{(k)}\}\)</span>
的收敛性，引进误差向量 <span
class="math inline">\(\varepsilon^{(k+1)}=x^{(k+1)}-x^*\)</span>
。易得到： <span
class="math inline">\(\varepsilon^{(k+1)}=B\varepsilon^{(k)}\)</span>
，递推得： <span
class="math inline">\(\varepsilon^{(k)}=B\varepsilon^{(k-1)}=\dots=B^k\varepsilon^{(0)}\)</span>
。</p>
<h4 id="jacobi迭代">Jacobi迭代</h4>
<p><strong>通法细节</strong>：<br />
将 <span class="math inline">\(A\)</span> 分裂成 <span
class="math inline">\(A=M-N\)</span> ，其中 <span
class="math inline">\(M\)</span> 为可选择的非奇异矩阵，使 <span
class="math inline">\(Mx=d\)</span> 易解，一般选择为 <span
class="math inline">\(A\)</span> 的某种近似，称 <span
class="math inline">\(M\)</span> 为<strong>分裂矩阵</strong>。<br />
则原方程 <span class="math inline">\(Ax=b\)</span> 转化为 <span
class="math inline">\(Mx=Nx+b\)</span> ，即求解： <span
class="math inline">\(x=M^{-1}Nx+M^{-1}b\)</span> 。<br />
可构造一阶定常迭代法： <span class="math display">\[
\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=Bx^{(k)}+f\
(k=0,1,\dots)\end{array}\right.\\
B=M^{-1}N=M^{-1}(M-A)=I-M^{-1}A,\quad f=M^{-1}b
\]</span> 称 <span class="math inline">\(B=I-M^{-1}A\)</span>
为迭代法的迭代矩阵，选取 <span class="math inline">\(M\)</span> 阵就得到
<span class="math inline">\(Ax=b\)</span> 的各种迭代法。</p>
<p><strong>Jacobbi迭代</strong>：<br />
设 <span class="math inline">\(a_{ii}\neq0(i=1,2,\dots,n)\)</span>
，并将 <span class="math inline">\(A\)</span> 写成三部分： <span
class="math display">\[
\begin{aligned}A&amp;=\begin{pmatrix}
a_{11}\\
&amp;a_{22}\\
&amp;&amp;\ddots\\
&amp;&amp;&amp;a_{nn}
\end{pmatrix}\\
&amp;-\begin{pmatrix}
0\\
-a_{21}&amp;0\\
\vdots&amp;\vdots&amp;\ddots\\
-a_{n-1,1}&amp;-a_{n-1,2}&amp;\cdots&amp;0\\
-a_{n,1}&amp;-a_{n,2}&amp;\cdots&amp;-a_{n,n-1}&amp;0
\end{pmatrix}\\
&amp;-\begin{pmatrix}
0&amp;-a_{12}&amp;\cdots&amp;-a_{1,n-1}&amp;-a_{1,n}\\
&amp;0&amp;\cdots&amp;-a_{2,n-1}&amp;-a_{2,n}\\
&amp;&amp;\ddots&amp;\vdots&amp;\vdots\\
&amp;&amp;&amp;0&amp;-a_{n-1,n}\\
&amp;&amp;&amp;&amp;0
\end{pmatrix}\\
&amp;\equiv D-L-U
\end{aligned}
\]</span> 由此，当 <span
class="math inline">\(a_{ii}\neq0(i=1,2,\dots,n)\)</span> 时，选取 <span
class="math inline">\(M\)</span> 为 <span
class="math inline">\(A\)</span> 的对角元素部分，即选取 <span
class="math inline">\(M=D\)</span> ，<span
class="math inline">\(A=D-N\)</span> ，即得到 <span
class="math inline">\(Ax=b\)</span> 的<strong>Jacobi迭代法</strong>。
<span class="math display">\[
\begin{aligned}&amp;\left\{\begin{array}{l}x^{(0)}\\x^{(k+1)}=Bx^{(k)}+f\
(k=0,1,\dots)\end{array}\right.\\
&amp;其中\ \begin{aligned}&amp;B=D^{-1}(L+U)\equiv J\\
&amp;f=D^{-1}b\end{aligned}\end{aligned}
\]</span> 称 <span class="math inline">\(J\)</span>
为Jacobi迭代法的<strong>迭代矩阵</strong>。</p>
<p><strong>Jacobi迭代法的分量计算公式</strong>： 记 <span
class="math inline">\(x^{(k)}=(x_1^{(k)},x_2^{(k)},\dots,x_n^{(k)})\)</span>
，则有： <span class="math display">\[
\begin{array}{l}
\begin{aligned}Dx^{k+1}&amp;=(L+U)x^{(k)}+b
a_{ii}x_i^{k+1}\\&amp;=-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}+b_i\quad(i=1,2,\dots,n)\end{aligned}\\
B=I-M^{-1}A,\ f=M^{-1}b
\end{array}
\]</span> 因此，解 <span class="math inline">\(Ax=b\)</span>
的Jacobi迭代法的计算公式为： <span class="math display">\[
\left\{\begin{array}{l}
x^{(0)}=(x_1^{(0)},\dots,x_i^{(0)},\dots,x_n^{(0)})^T\\
x_i^{(k+1)}=(b_i-\sum\limits_{j=1,j\neq i}^na_{ij}x_j^{(k)})/a_{ii}\\
i=1,2,\dots,n\\
k=0,1,\dots\ 表示迭代次数
\end{array}\right.
\]</span> 矩阵表示为： <span class="math display">\[
\begin{array}{l}
Ax=b\Leftrightarrow(D-L-U)x=b\Leftrightarrow Dx=(L+U)x+b\\
\begin{aligned}Dx&amp;=\begin{pmatrix}
a_{11}\\
&amp;a_{22}\\
&amp;&amp;\ddots\\
&amp;&amp;&amp;a_{nn}
\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}\\
&amp;=\begin{pmatrix}
0&amp;-a_{12}&amp;\cdots&amp;-a_{1,n-1}&amp;-a_{1,n}\\
-a_{21}&amp;0&amp;\cdots&amp;-a_{2,n-1}&amp;-a_{2,n}\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\
-a_{n-1,1}&amp;-a_{n-1,2}&amp;\cdots&amp;0&amp;-a_{n-1,n}\\
-a_{n,1}&amp;-a_{n,2}&amp;\cdots&amp;-a_{n,n-1}&amp;0
\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix}+b\\
&amp;=(L+U)x+b
\end{aligned}\end{array}
\]</span></p>
<h4 id="gauss-seidel迭代法">Gauss-Seidel迭代法</h4>
<p><strong>改进Jacobi迭代法</strong>：选取分裂矩阵 <span
class="math inline">\(M\)</span> 为 <span
class="math inline">\(A\)</span> 的下三角部分，即 <span
class="math inline">\(M=D-L\)</span> ， <span
class="math inline">\(A=M-U\)</span> ，得到： <span
class="math display">\[
\begin{array}{l}\left\{\begin{array}{l}x^{(0)}\quad初始向量\\x^{(k+1)}=Bx^{(k)}+f\quad
(k=0,1,\dots)\end{array}\right.\\
B=I-(D-L^{-1})A=(D-L)^{-1}U\equiv G,\quad f=(D-L)^{-1}b\end{array}
\]</span> 称 <span class="math inline">\(G\)</span>
为Gauss-Seidel迭代法的迭代矩阵。</p>
<p><strong>分量计算公式</strong>： <span class="math display">\[
\begin{array}{l}Dx^{(k+1)}=Dx^{(k)}-(Lx^{(k+1)}+Ux^{k}-Dx^{(k)}+b)\\\\
\left\{\begin{array}{l}
x_1^{(k+1)}=\displaystyle-\frac{a_{12}}{a_{11}}x_2^{(k)}-\frac{a_{13}}{a_{11}}x_3^{(k)}-\dots-\frac{a_{1n}}{a_{11}}x_n^{(k)}+\frac{b_2}{a_{22}}\\
x_2^{(k+1)}=\displaystyle-\frac{a_{21}}{a_{22}}x_2^{(k+1)}-\frac{a_{23}}{a_{22}}x_3^{(k)}-\dots-\frac{a_{2n}}{a_{22}}x_n^{(k)}+\frac{b_2}{a_{22}}\\
x_3^{(k+1)}=\displaystyle-\frac{a_{31}}{a_{33}}x_2^{(k+1)}-\frac{a_{32}}{a_{33}}x_3^{(k+1)}-\dots-\frac{a_{3n}}{a_{33}}x_n^{(k)}+\frac{b_3}{a_{33}}\\
\dots\\
x_n^{(k+1)}=\displaystyle-\frac{a_{n1}}{a_{nn}}x_2^{(k+1)}-\frac{a_{n2}}{a_{nn}}x_3^{(k+1)}-\dots-\frac{a_{n,n-1}}{a_{nn}}x_n^{(k+1)}+\frac{b_n}{a_{nn}}\\
\end{array}\right.\\
即\
\displaystyle{x_i^{k+1}=\frac{b_n-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}}{a_{ii}}}\end{array}
\]</span></p>
<h3 id="代码jacobi迭代">代码：Jacobi迭代</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">}};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">14</span><span class="op">,</span> <span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">14</span><span class="op">};</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="代码gauss-seidel迭代">代码：Gauss-Seidel迭代</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">/***区别***/</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Jacobi</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">!=</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">//Gauss-Seidel</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-03-01.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">10</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">}};</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="dv">14</span><span class="op">,</span> <span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">14</span><span class="op">};</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> next_x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> tmp <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> next_x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> i<span class="op">)</span> tmp <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>            next_x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> next_x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot; 第&quot;</span><span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot;次&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-28-数值分析-Day03-范数-迭代改善算法</title>
      <link>https://elderlyaugustus.github.io/posts/2021-02-28-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day03-%E8%8C%83%E6%95%B0-%E8%BF%AD%E4%BB%A3%E6%94%B9%E5%96%84%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 28 Feb 2021 20:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-02-28-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day03-%E8%8C%83%E6%95%B0-%E8%BF%AD%E4%BB%A3%E6%94%B9%E5%96%84%E7%AE%97%E6%B3%95/</guid>
      <description>2.9-11 范数 为研究线性方程组近似解的误差估计和迭代法的收敛性，对 \(R……n\) （ \(n\) 维向量空间）中的向量（ \(R^{n\times n}\) 中的矩阵）的“大小”引进度量——向量（或矩阵）的范数。
向量的范数 定义1：设 \(x=(x_1,x_2,\dots,x_n)^T,y=(y_1,y_2,\dots,y_n)^T\in R^n (or\ C^n)\)
将实数 \((x,y)=y^Tx=\sum_{i=1}^{n}x_i\overline{y_i}\)（或复数 \((x,y)=y^Hx=\sum_{i=1}^{n}x_iy_i\) ）称为向量x,y的数量积（内积）。
将非负实数 \(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}\) 或 \(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}|x_i|^2)^{1\over2}\) 称为向量 \(x\) 的欧式范数。
引理：向量的内积运算支持交换律、分配律、与实数乘时的结合律。
Cauchy-Schwarz不等式 \(|(x,y)|\le \|x\|_2\cdot\|y\|_2\) 当且仅当 \(x\) 与 \(y\) 线性相关时取等。
三角不等式 \(\|x+y\|_2\le\|x\|_2+\|y\|_2\)
定义2-向量的范数：若向量 \(x\in R^n\) （或 \(C^n\) ）的某个实值函数 \(N(x)=\|x\|\) ，满足条件： \[ \begin{aligned} &amp;amp; (1)\ \|x\|\ge 0\ (\|x\|=0当且仅当x=0)\quad\textbf{正定条件}\\ &amp;amp; (2)\ \|\alpha x\|=|\alpha|\|x\|,\ \forall\alpha\in R(或\alpha\in C)\quad\textbf{齐次性}\\ &amp;amp; (3)\ \|x+y\|_2\le\|x\|_2+\|y\|_2\quad\textbf{三角不等式}\\ &amp;amp; (3\to 4)\ \|x-y\|_2\ge\|x\|_2-\|y\|_2 \end{aligned} \] 则称 \(N(x)\) 是 \(R^n\) （或 \(C^n\) ）上的一个向量范数（或模）</description>
      <content:encoded><![CDATA[<h3 id="范数">2.9-11 范数</h3>
<p>为研究线性方程组近似解的误差估计和迭代法的收敛性，对 <span
class="math inline">\(R……n\)</span> （ <span
class="math inline">\(n\)</span> 维向量空间）中的向量（ <span
class="math inline">\(R^{n\times n}\)</span>
中的矩阵）的“大小”引进度量——向量（或矩阵）的<strong>范数</strong>。</p>
<h4 id="向量的范数">向量的范数</h4>
<p><strong>定义1</strong>：设 <span
class="math inline">\(x=(x_1,x_2,\dots,x_n)^T,y=(y_1,y_2,\dots,y_n)^T\in
R^n (or\ C^n)\)</span><br />
将实数 <span
class="math inline">\((x,y)=y^Tx=\sum_{i=1}^{n}x_i\overline{y_i}\)</span>（或复数
<span class="math inline">\((x,y)=y^Hx=\sum_{i=1}^{n}x_iy_i\)</span>
）称为向量x,y的数量积（内积）。<br />
将非负实数 <span
class="math inline">\(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}\)</span>
或 <span
class="math inline">\(\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}|x_i|^2)^{1\over2}\)</span>
称为向量 <span class="math inline">\(x\)</span> 的欧式范数。</p>
<p><strong>引理</strong>：向量的内积运算支持交换律、分配律、与实数乘时的结合律。<br />
Cauchy-Schwarz不等式 <span class="math inline">\(|(x,y)|\le
\|x\|_2\cdot\|y\|_2\)</span> 当且仅当 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 线性相关时取等。<br />
三角不等式 <span
class="math inline">\(\|x+y\|_2\le\|x\|_2+\|y\|_2\)</span></p>
<p><strong>定义2-向量的范数</strong>：若向量 <span
class="math inline">\(x\in R^n\)</span> （或 <span
class="math inline">\(C^n\)</span> ）的某个实值函数 <span
class="math inline">\(N(x)=\|x\|\)</span> ，满足条件： <span
class="math display">\[
\begin{aligned}
&amp; (1)\ \|x\|\ge 0\ (\|x\|=0当且仅当x=0)\quad\textbf{正定条件}\\
&amp; (2)\ \|\alpha x\|=|\alpha|\|x\|,\ \forall\alpha\in R(或\alpha\in
C)\quad\textbf{齐次性}\\
&amp; (3)\ \|x+y\|_2\le\|x\|_2+\|y\|_2\quad\textbf{三角不等式}\\
&amp; (3\to 4)\ \|x-y\|_2\ge\|x\|_2-\|y\|_2
\end{aligned}
\]</span> 则称 <span class="math inline">\(N(x)\)</span> 是 <span
class="math inline">\(R^n\)</span> （或 <span
class="math inline">\(C^n\)</span>
）上的一个<strong>向量范数</strong>（或<strong>模</strong>）</p>
<p><strong>几种常用的向量范数</strong>：</p>
<ul>
<li>向量的 <span class="math inline">\(\infty\)</span>
-范数（最大范数）： <span
class="math inline">\(\displaystyle{\|x\|_\infty=\max\limits_{1\le i\le
n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(1\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_1=\sum_{i=1}^{n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(2\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_2=(x,x)^{1\over2}=(\sum_{i=1}^{n}x_i^2)^{1\over2}}\)</span></li>
<li>向量的 <span class="math inline">\(p\)</span> -范数： <span
class="math inline">\(\displaystyle{\|x\|_p=(\sum_{i=1}^{n}|x_i|^p)^{1\over
p}}\)</span></li>
<li>向量的 <span class="math inline">\(\infty\)</span>
-范数（最大范数）： <span
class="math inline">\(\displaystyle{\|x\|_{-\infty}=\min\limits_{1\le
i\le n}|x_i|}\)</span></li>
<li>向量的 <span class="math inline">\(0\)</span>
-范数：向量的非零元素个数</li>
</ul>
<p><strong>向量的收敛性</strong>：设 <span
class="math inline">\(\{x^{(k)}\}\)</span> 为 <span
class="math inline">\(R^n\)</span> 中的一个向量序列， <span
class="math inline">\(x^*\in R^n\)</span> ，记 <span
class="math inline">\(x^{(k)}=(x_1^{(k)}=(x_1^{(k)},x_2^{(k)},\dots,x_n^{(k)})^T\,
x^*=(x_1^*,x_2^*,\dots,x_n^*)^T\)</span> 。 若 <span
class="math inline">\(\lim\limits_{k\to\infty}x_i^{(k)}=x_i^*(i=1,2,\dots,n)\)</span>
，则称 <span class="math inline">\(x^{(k)}\)</span> 收敛于 <span
class="math inline">\(x^*\)</span> ，记为 <span
class="math inline">\(\lim\limits_{k\to\infty}x_i^{(k)}=x^*\)</span>
。</p>
<p><strong>范数的连续性</strong>：设非负函数 <span
class="math inline">\(N(x)=\|x\|\)</span> 为 <span
class="math inline">\(R^n\)</span> 上任一向量范数，则 <span
class="math inline">\(N(x)\)</span> 是 <span
class="math inline">\(x\)</span> 的分量 <span
class="math inline">\(x_1,x_2,\dots,x_n\)</span> 的连续函数。 <span
class="math inline">\(x\)</span> 有很小变化时，同时 <span
class="math inline">\(N(x)\)</span> 亦变化不大。</p>
<p><strong>向量范数的等价性</strong>：设 <span
class="math inline">\(\|x\|_s,\|x\|_t\)</span> 为 <span
class="math inline">\(R^n\)</span> 上向量的任意两种范数，则存在常数
<span class="math inline">\(c_1,c_2&gt;0\)</span> ，使得对一切 <span
class="math inline">\(x\in R^n\)</span> 有 <span
class="math inline">\(c_1\|x\|_s\le\|x\|_t\le c_2\|x\|_s\)</span> 。</p>
<h4 id="矩阵的范数">矩阵的范数</h4>
<h5 id="方阵">方阵</h5>
<p><strong>定义1</strong>：若矩阵 <span class="math inline">\(A\in
R^{n\times n}\)</span> 的某个非负实值函数 <span
class="math inline">\(N(A)=\|A\|\)</span> 满足条件：<br />
<span class="math display">\[
\begin{aligned}
&amp; (1)\ \|A\|\ge 0\ (\|A\|=0\Leftrightarrow
A=0)\quad\textbf{正定条件}\\
&amp; (2)\ \|c A\|=|c|\|A\|,\ c为实数\quad\textbf{齐次性}\\
&amp; (3)\ \|A+B\|\le\|A\|+\|B\|\quad\textbf{三角不等式}\\
&amp; (4)\ \|AB\|\le\|A\|\|B\|
\end{aligned}
\]</span> 则称 <span class="math inline">\(N(A)\)</span> 是 <span
class="math inline">\(R^{n\times n}\)</span>
上的一个<strong>矩阵范数</strong>（或<strong>模</strong>）。</p>
<p><strong>定义2-矩阵的算子范数</strong>：设 <span
class="math inline">\(x\in R^n, A\in R^{n\times n}\)</span>
，给出一种向量范数 <span class="math inline">\(\|x\|_\nu,\
(如\nu=1,2,\infty,\dots)\)</span> ，相应地定义一个矩阵的非负函数： <span
class="math inline">\(\displaystyle{\|A\|_\nu=\max\limits_{x\neq0}\frac{\|Ax\|_\nu}{\|x\|_\nu}}\)</span>
，可验证该非负函数为矩阵 <span class="math inline">\(A\)</span>
的范数，称之为矩阵 <span class="math inline">\(A\)</span>
的<strong>算子范数</strong>。</p>
<p><strong>定理</strong>： <span
class="math inline">\(\|Ax\|_\nu\le\|A\|_\nu\|x\|_\nu\)</span></p>
<p><strong>几种常用的矩阵范数</strong>：</p>
<ul>
<li>Frobenius范数（F范数）： <span
class="math inline">\(\displaystyle{F(A)=\|A\|_F=\left(\sum\limits_{i,j=1}^{n}a_{i,j}^2\right)^{1\over2}}\)</span>
，由向量的 <span class="math inline">\(2\)</span> -范数推广而来</li>
<li>行范数（<span class="math inline">\(\infty\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_\infty=\max\limits_{1\le i\le
n}\sum\limits_{j=1}^{n}|a_{i,j}|}\)</span></li>
<li>列范数（ <span class="math inline">\(1\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_1=\max\limits_{1\le j\le
n}\sum\limits_{i=1}^{n}|a_{i,j}|}\)</span></li>
<li>谱范数（ <span class="math inline">\(2\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_2=\sqrt{\lambda_{\max}(A^TA)},\
(\lambda为特征值)}\)</span></li>
</ul>
<h5 id="非方阵">非方阵</h5>
<p>矩阵 <span class="math inline">\(A_{mn}\)</span></p>
<ul>
<li>Frobenius范数（F范数）： <span
class="math inline">\(\displaystyle{F(A)=\|A\|_F=\left(\sum\limits_{i=1}^{m}\sum\limits_{j=1}^{n}a_{i,j}^2\right)^{1\over2}}\)</span>
，由向量的 <span class="math inline">\(2\)</span> -范数推广而来</li>
<li>行范数（<span class="math inline">\(\infty\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_\infty=\max\limits_{1\le i\le
n}\sum\limits_{j=1}^{n}|a_{i,j}|}\)</span></li>
<li>列范数（ <span class="math inline">\(1\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_1=\max\limits_{1\le j\le
n}\sum\limits_{i=1}^{m}|a_{i,j}|}\)</span></li>
<li>谱范数（ <span class="math inline">\(2\)</span> -范数）： <span
class="math inline">\(\displaystyle{\|A\|_2=\sqrt{\lambda_{\max}(A^TA)},\
(\lambda为特征值)}\)</span></li>
</ul>
<h3 id="谱半径">2.12 谱半径</h3>
<blockquote>
<p><strong>特征值和特征向量</strong> <span
class="math inline">\(Ax=\lambda x\)</span> 常数 <span
class="math inline">\(\lambda\)</span> 为<strong>特征值</strong>，矩阵
<span class="math inline">\(A\)</span>
为<strong>特征向量</strong>，且为方阵。 计算方法： <span
class="math inline">\(\det(A-\lambda I)=0\)</span></p>
</blockquote>
<p><strong>定义</strong>：设 <span class="math inline">\(A\in R^{n\times
n}\)</span> 的特征值为 <span
class="math inline">\(\lambda_i(i=1,2,\dots,n)\)</span> ，称 <span
class="math inline">\(\rho(A)=\max\limits_{1\le i\le
n}|\lambda_i|\)</span> 为 <span class="math inline">\(A\)</span>
的谱半径。</p>
<p><strong>定理</strong>：</p>
<ul>
<li>设 <span class="math inline">\(A\in R^{n\times n}\)</span> ，则
<span class="math inline">\(\rho(A)\le\|A\|\)</span>
，即矩阵的谱半径不超过矩阵的任何一种算子范数（对F范数也成立）。</li>
<li>若 <span class="math inline">\(A\in R^{n\times n}\)</span>
为对称矩阵，则 <span class="math inline">\(\rho(A)=\|A\|_2\)</span>
。</li>
<li>若 <span class="math inline">\(\|B\|&lt;1\)</span> ，则 <span
class="math inline">\(I+B\)</span> 为非奇异矩阵，且 <span
class="math inline">\(\left\|(I\pm
B)^{-1}\right\|\le\displaystyle\frac{1}{1-\|B\|}\)</span> ，此处 <span
class="math inline">\(\|\ \|\)</span> 指算子范数。</li>
</ul>
<h3 id="方程组的条件数">2.13 - 14 方程组的条件数</h3>
<p><strong>定义</strong>：如果矩阵 <span
class="math inline">\(A\)</span> 或常数项 <span
class="math inline">\(b\)</span> 的微小变化，引起方程组 <span
class="math inline">\(Ax=b\)</span>
的解的巨大变化，则称该方程组为<strong>“病态”方程组</strong>，若矩阵
<span class="math inline">\(A\)</span>
为原因则称之为该方程组的<strong>“病态”矩阵</strong>。否则称<strong>“良态”</strong>。</p>
<ol type="1">
<li><p>设 <span class="math inline">\(A\)</span> 精确， <span
class="math inline">\(b\)</span> 有误差 <span
class="math inline">\(\delta b\)</span> ，解为 <span
class="math inline">\(x+\delta x\)</span> ，则： <span
class="math display">\[
A(x+\delta x)=b+\delta b\ \Rightarrow\ \delta x=A^{-1}\delta b\\
\|\delta x\|\le\|A^{-1}\|\|\delta b\|\\
\]</span> 由 <span class="math inline">\(Ax=b\)</span> 得： <span
class="math display">\[
\|b\|\le\|A\|\|x\|,\ \frac{1}{\|x\|}\le\frac{\|A\|}{\|b\|}\ (b\neq0)
\]</span> 两式相乘得到<strong>定理1</strong>：设 <span
class="math inline">\(A\)</span> 是非奇异矩阵， <span
class="math inline">\(Ax=b\neq0\)</span> ，且 <span
class="math inline">\(A(x+\delta x)=b+\delta b\)</span> ，则 <span
class="math inline">\(\displaystyle\frac{\|\delta
x\|}{\|x\|}\le\|A^{-1}\|\|A\|\frac{\|\delta b\|}{\|b\|}\)</span>
。该定理给出解的相对误差的上街，即常数项 <span
class="math inline">\(b\)</span> 的相对误差在解中至多放大 <span
class="math inline">\(\|A^{-1}\|\|A\|\)</span> 倍。</p></li>
<li><p>设 <span class="math inline">\(b\)</span> 精确， <span
class="math inline">\(A\)</span> 有微小误差（扰动） <span
class="math inline">\(\delta A\)</span> ，解为 <span
class="math inline">\(x+\delta x\)</span> ，则： <span
class="math display">\[
(A+\delta A)(x+\delta x)=b\ \Rightarrow\ (A+\delta A)\delta x=-(\delta
A)x\\
\]</span> 若 <span class="math inline">\(\delta A\)</span> 不受限制，
<span class="math inline">\(A+\delta A\)</span> 可能奇异，而： <span
class="math display">\[
(A+\delta A)=A(I+A^{-1}\delta A)
\]</span> 当 <span class="math inline">\(\|A^{-1}\delta
A\|&lt;1\)</span> 时， <span class="math inline">\((I+A^{-1}\delta
A)^{-1}\)</span> 存在。则可得： <span class="math display">\[
\delta x=-(I+A^{-1}\delta A)^{-1}A^{-1}(\delta A)x\\
\|\delta x\|\le\frac{\|A^{-1}\|\|\delta A\|\|x\|}{1-\|A^{-1}(\delta
A)\|}
\]</span> 设 <span class="math inline">\(1-\|A^{-1}(\delta
A)\|&lt;1\)</span> ，则有： <span class="math display">\[
\frac{\|\delta x\|}{\|x\|}\le\frac{\|A^{-1}\|\|A\|\frac{\|\delta
A\|}{\|A\|}}{1-\|A^{-1}\|\|A\|\frac{\|\delta A\|}{\|A\|}}
\]</span></p></li>
</ol>
<p>综上， <span class="math inline">\(\|A^{-1}\|\|A\|\)</span>
刻画了方程组的“病态”程度，称之为矩阵 <span
class="math inline">\(A\)</span> 的<strong>条件数</strong>： <span
class="math display">\[
cond(A)_\nu=\|A^{-1}\|_\nu\|A\|_\nu\ (\nu=1,2,\infty)
\]</span> <span class="math inline">\(cond(A)\)</span>
过大时，方程组“病态”。（相对于矩阵中的元比较大小。）</p>
<p><strong>通常使用的条件数</strong>： + 无穷条件数 <span
class="math inline">\(cond(A)_\infty=\|A^{-1}\|_\infty\|A\|_\infty\)</span>
+ 谱条件数 <span
class="math inline">\(cond(A)_2=\|A^{-1}\|_2\|A\|_2=\displaystyle\sqrt{\frac{\lambda_{\max}(A^TA)}{\lambda_{\min}(A^TA)}}\)</span>
当 <span class="math inline">\(A\)</span> 为对称矩阵时， <span
class="math inline">\(cond(A)_2=\displaystyle\frac{\lambda_1}{\lambda_2}\)</span>
，其中 <span class="math inline">\(\lambda_1,\lambda_2\)</span> 为 <span
class="math inline">\(A\)</span> 的绝对值最大和绝对值最小的特征值。</p>
<p><strong>条件数的性质</strong>： + <span
class="math inline">\(cond(A)_\nu=\|A^{-1}\|_\nu\|A\|_\nu\ge\|A^{-1}A\|=1\)</span>
+ <span class="math inline">\(cond(cA)_\nu=cond(A)_\nu, c为常数\)</span>
+ 若 <span class="math inline">\(A\)</span> 为正交矩阵（ <span
class="math inline">\(A^{-1}=A^T\)</span> ），则 <span
class="math inline">\(cond(A)_2=1\)</span> 若 <span
class="math inline">\(A\)</span> 为非奇异矩阵， <span
class="math inline">\(R\)</span> 为正交矩阵，则 <span
class="math inline">\(cond(RA)_2=cond(AR)_2=cond(A)_2\)</span></p>
<h3 id="事后误差估计与迭代改善算法">2.15 事后误差估计与迭代改善算法</h3>
<h4 id="事后误差估计">事后误差估计</h4>
<p>设 <span class="math inline">\(A\)</span> 为非奇异矩阵， <span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(Ax=b\neq0\)</span> 的精确解。再设 <span
class="math inline">\(\overline x\)</span> 是此方程组的近似解， <span
class="math inline">\(r=b-A\overline x\)</span> ，则： <span
class="math display">\[
\frac{\|x-\overline x\|}{\|x\|}\le cond(A)\cdot\frac{\|r\|}{\|b\|}
\]</span></p>
<h4 id="迭代改善算法">迭代改善算法</h4>
<p><strong>理论</strong>： 设 <span class="math inline">\(Ax=b\)</span>
，其中 <span class="math inline">\(A\in R^{n\times n}\)</span>
为非奇异矩阵，且为病态方程组（但不过分病态）。 +
用选主元三角分析法实现分解计算 <span
class="math inline">\(PA=LU\)</span> ，其中 <span
class="math inline">\(P\)</span> 为置换阵， <span
class="math inline">\(L\)</span> 为单位下三角阵， <span
class="math inline">\(U\)</span> 为上三角阵，求得方程组近似解 <span
class="math inline">\(x_1\)</span> 。 + 计算剩余向量： <span
class="math inline">\(r_1=b-Ax_1\)</span> + 求解 <span
class="math inline">\(Ad=r_1\)</span> ，得到解 <span
class="math inline">\(d_1\)</span> ，然后改善原解： <span
class="math inline">\(x_2=x_1+d_1\)</span> 。 + 递归推：<span
class="math inline">\(d_2,d_3,\dots,\ x_3,x_4,\dots\)</span></p>
<p><strong>实现</strong>： + 用选主元三角分解实行分解计算 <span
class="math inline">\(PA=LU\)</span> ，且求计算解 <span
class="math inline">\(x_1\)</span> 。 + 对于 <span
class="math inline">\(k=1,2,\dots,N_0\)</span> : + 计算 <span
class="math inline">\(r_k=b-Ax_k\)</span> + 求解 <span
class="math inline">\(LUd_k=Pr_k=PAd_k\)</span> ，<span
class="math inline">\(\left\{\begin{array}{}Ly=Pr_k\\Ud_k=y\end{array}\right.\)</span>
+ 若 <span
class="math inline">\(\displaystyle\frac{\|d_k\|_\infty}{\|x_k\|_\infty}\le10^{-t}\)</span>
则输出 + 改善 <span class="math inline">\(x_{k+1}=x_k+d_k\)</span></p>
<h4 id="补充选主元三角分解法">补充：选主元三角分解法</h4>
<p>LU分解过程中的问题：有解问题无法LU分解（主元为0）；主元过小时引入较大误差</p>
<p>解决方法：选主元</p>
<ul>
<li>第 <span class="math inline">\(k\)</span>
列主元及主元所在列下方元素挑选绝对值最大的数</li>
<li>通过初等变换使该元位于主对角线上，最终将 <span
class="math inline">\(A\)</span> 转换为 <span
class="math inline">\(PA\)</span></li>
<li>则 Doolittle分解转换为 <span
class="math inline">\(PA=LU\)</span></li>
</ul>
<h3 id="代码迭代改善算法">代码：迭代改善算法</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-28.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> C<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> r<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">();</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">();</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshR<span class="op">();</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printX<span class="op">();</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">{{</span><span class="fl">1.0303</span><span class="op">,</span> <span class="fl">0.99030</span><span class="op">},</span> <span class="op">{</span><span class="fl">0.99030</span><span class="op">,</span> <span class="fl">0.95285</span><span class="op">}};</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">{</span><span class="fl">2.4944</span><span class="op">,</span> <span class="fl">2.3988</span><span class="op">};</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    iterate<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> iterate<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    getPA<span class="op">();</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    C<span class="op">.</span>assign<span class="op">(</span>A<span class="op">.</span>begin<span class="op">(),</span> A<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>assign<span class="op">(</span>b<span class="op">.</span>begin<span class="op">(),</span> b<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    solve<span class="op">();</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    x<span class="op">.</span>assign<span class="op">(</span>r<span class="op">.</span>begin<span class="op">(),</span> r<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        refreshR<span class="op">();</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>r<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>r<span class="op">)))</span> <span class="op">/</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">*(</span><span class="bu">std::</span>max_element<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>x<span class="op">),</span> <span class="bu">std::</span>end<span class="op">(</span>x<span class="op">)))</span> <span class="op">&lt;=</span> <span class="fl">1e-5</span><span class="op">)</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>            x<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> r<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        printX<span class="op">();</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> d<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> r<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> r<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> C<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve d</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    d<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> C<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> r<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> C<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>assign<span class="op">(</span>d<span class="op">.</span>begin<span class="op">(),</span> d<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">&gt;</span> A<span class="op">[</span>max<span class="op">][</span>k<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>A<span class="op">[</span>k<span class="op">],</span> A<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>b<span class="op">[</span>k<span class="op">],</span>b<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>                    C<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> C<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> C<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> C<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>            C<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>C<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> C<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> refreshR<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        r<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            r<span class="op">[</span>i<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printX<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="代码选主元doolittle算法">代码：选主元Doolittle算法</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-28.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">();</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">();</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_ <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}};</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x <span class="op">=</span> solve<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    getPA<span class="op">();</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve x</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    x<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> A<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getPA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">&gt;</span> A<span class="op">[</span>max<span class="op">][</span>k<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>A<span class="op">[</span>k<span class="op">],</span> A<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>            swap<span class="op">(</span>b<span class="op">[</span>k<span class="op">],</span>b<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>                    A<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">&amp;</span> a<span class="op">,</span> T<span class="op">&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-27-数值分析-Day02-三角分解</title>
      <link>https://elderlyaugustus.github.io/posts/2021-02-27-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day02-%E4%B8%89%E8%A7%92%E5%88%86%E8%A7%A3/</link>
      <pubDate>Sat, 27 Feb 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-02-27-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day02-%E4%B8%89%E8%A7%92%E5%88%86%E8%A7%A3/</guid>
      <description>续 2.1 - 2.4 矩阵三角分解法 初等行变换 \(\Leftrightarrow\) 矩阵左乘初等矩阵 消元 \(\Leftrightarrow\) 矩阵左乘 \((n-1)\) 个初等矩阵
若 \(a_{11}^{(1)}\neq0\) ，令 \(l_{i1} = a_{i1}^{(1)}\div a_{11}^{11},\ i=2,3,\dots,n\) ，记： \(L_{1}=\begin{pmatrix} 1 \\ -l_{21} &amp;amp; 1 \\ -l_{31} &amp;amp;&amp;amp; 1 \\ \vdots &amp;amp;&amp;amp;&amp;amp; \ddots \\ -l_{31} &amp;amp;&amp;amp;&amp;amp;&amp;amp; 1 \end{pmatrix}\)
则有 \(A^{(2)}=L_{1}A^{(1)}=\begin{pmatrix} a_11^{(1)} &amp;amp; a_{12}^{(1)} &amp;amp; \cdots &amp;amp; a_{1n}^{(1)} \\ 0 &amp;amp; a_{22}^{(2)} &amp;amp; \cdots &amp;amp; a_{2n}^{(2)} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ 0 &amp;amp; a_{n2}^{(2)} &amp;amp; \cdots &amp;amp; a_{nn}^{(2)} \end{pmatrix}\)</description>
      <content:encoded><![CDATA[<h3 id="续-2.1---2.4">续 2.1 - 2.4</h3>
<h4 id="矩阵三角分解法">矩阵三角分解法</h4>
<p>初等行变换 <span class="math inline">\(\Leftrightarrow\)</span>
矩阵左乘初等矩阵 消元 <span
class="math inline">\(\Leftrightarrow\)</span> 矩阵左乘 <span
class="math inline">\((n-1)\)</span> 个初等矩阵</p>
<p>若 <span class="math inline">\(a_{11}^{(1)}\neq0\)</span> ，令 <span
class="math inline">\(l_{i1} = a_{i1}^{(1)}\div a_{11}^{11},\
i=2,3,\dots,n\)</span> ，记： <span
class="math inline">\(L_{1}=\begin{pmatrix} 1 \\ -l_{21} &amp; 1 \\
-l_{31} &amp;&amp; 1 \\ \vdots &amp;&amp;&amp; \ddots \\ -l_{31}
&amp;&amp;&amp;&amp; 1 \end{pmatrix}\)</span></p>
<p>则有 <span class="math inline">\(A^{(2)}=L_{1}A^{(1)}=\begin{pmatrix}
a_11^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ 0 &amp;
a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)} \\ \vdots &amp; \vdots
&amp; \ddots &amp; \vdots \\ 0 &amp; a_{n2}^{(2)} &amp; \cdots &amp;
a_{nn}^{(2)} \end{pmatrix}\)</span></p>
<p>同理进行第二步消元 <span class="math inline">\(A^{(3)}=L_{2}A^{(2)},\
\dots\)</span> 第 <span class="math inline">\((n-1)\)</span> 步得到：
<span class="math inline">\(A^{(n)}=L_{n-1}A^{(n-1)}=\begin{pmatrix}
a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ &amp;
a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)} \\ &amp;&amp; \ddots &amp;
\vdots \\ &amp;&amp;&amp; a_{nn}^{(n)} \end{pmatrix}\)</span></p>
<p>其中： <span
class="math inline">\(L_{n-1}=\begin{pmatrix}1\\&amp;1\\&amp;&amp;\ddots\\&amp;&amp;&amp;1\\&amp;&amp;&amp;-l_{n,n-1}&amp;1\end{pmatrix}\)</span></p>
<p>也就是： <span
class="math inline">\(A^{(n)}=L_{n-1}A^{(n-1)}=L_{n-1}L_{n-2}A^{(n-2)}=\dots=L_{n-1}L_{n-2}\dots
L_{2}L_{1}A^{(1)}\)</span></p>
<p>其中： <span
class="math inline">\(L_{k}=\begin{pmatrix}1\\&amp;\cdots\\&amp;&amp;1\\&amp;&amp;-l_{k+1k}&amp;1\\&amp;&amp;\vdots&amp;&amp;\ddots\\&amp;&amp;-l_{k+(n-1)k}&amp;&amp;&amp;1\end{pmatrix},\
k=1,2,\dots,n-1\)</span><br />
<span
class="math inline">\(L_{k}^{-1}=\begin{pmatrix}1\\&amp;\cdots\\&amp;&amp;1\\&amp;&amp;l_{k+1k}&amp;1\\&amp;&amp;\vdots&amp;&amp;\ddots\\&amp;&amp;l_{k+(n-1)k}&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>所以有： <span
class="math inline">\(A=A^{(1)}=L_{1}^{-1}L_{2}^{-1}\dots
L_{n-1}^{-1}A^{(n)}=LU\)</span> ，称为 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\(LU\)</span> 三角分解。</p>
<p>其中： <span class="math inline">\(L=L_{1}^{-1}L_{2}^{-1}\dots
L_{n-1}^{-1}, U=A^{(n)}\)</span> <span
class="math inline">\(L=\begin{pmatrix}1\\l_{21}&amp;1\\l_{31}&amp;l_{32}&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;l_{n3}&amp;\cdots&amp;1\end{pmatrix}\)</span>
即一个单位下三角矩阵</p>
<p><span class="math inline">\(U=\begin{pmatrix} a_{11}^{(1)} &amp;
a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} \\ &amp; a_{22}^{(2)} &amp;
\cdots &amp; a_{2n}^{(2)} \\ &amp;&amp; \ddots &amp; \vdots \\
&amp;&amp;&amp; a_{nn}^{(n)} \end{pmatrix}\)</span> 为一个上三角矩阵</p>
<h3 id="直接三角分解法">2.5 - 2.6 直接三角分解法</h3>
<p><strong>定理1</strong>：设 <span class="math inline">\(n\)</span>
阶方阵 <span class="math inline">\(A\)</span>
的各阶顺序主子式不为零，则存在<strong>唯一</strong>单位下三角矩阵 <span
class="math inline">\(L\)</span> 和上三角矩阵 <span
class="math inline">\(U\)</span> 使得 <span
class="math inline">\(A=LU\)</span>
。（条件与顺序Gauss消去法的执行条件一致。）</p>
<p>由此可得： <span class="math inline">\(Ax=b \
\Rightarrow\  LUx=b\)</span> ，令 <span
class="math inline">\(Ux=y\)</span> ，得 <span
class="math inline">\(\left\{\begin{aligned}Ly=b\\Ux=y\end{aligned}\right.\)</span>
从而将问题转换为两个三角型方程组的求解。</p>
<p>直接得到 <span class="math inline">\(L\ U\)</span>
两个矩阵——<strong>Doolittle分解法</strong> 设： <span
class="math display">\[
\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{pmatrix}
=
\begin{pmatrix}1\\l_{21}&amp;1\\l_{31}&amp;l_{32}&amp;1\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;l_{n3}&amp;\cdots&amp;1\end{pmatrix}
\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\]</span> 则得： <span class="math display">\[
\left\{\begin{array}{l}
u_{1j}=a_{1j}\quad j=1,2,\dots,n\\
l_{i1}=a_{i1}\div u_{11}\quad i=2,3,\dots,n\\\vdots\\
对k=2,3,\dots,n,计算\\
u_{kj}=a_{kj}-\sum_{m=1}^{k-1}{l_{km}u_{mj}}\quad j=k,k+1,\dots,n\\
l_{ik}=(a_{ik}-\sum_{m=1}^{k-1}{l_{im}u_{mk}})\div u_{kk}\quad
i=k+1,k+2,\dots,n
\end{array}\right.
\]</span> 应用中为节省存储空间，将矩阵 <span
class="math inline">\(U\)</span> 覆盖矩阵 <span
class="math inline">\(A\)</span> 的上三角进行存放，矩阵 <span
class="math inline">\(L\)</span> 覆盖矩阵 <span
class="math inline">\(A\)</span>
除对角线的下三角进行存放，即在原位形成矩阵： <span
class="math inline">\(\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\l_{21}&amp;u_{22}&amp;\cdots&amp;u_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\l_{n1}&amp;l_{n2}&amp;\cdots&amp;u_{nn}\end{pmatrix}\)</span></p>
<p>回代得到： <span class="math display">\[
\begin{array}{l}
\left\{\begin{array}{l}
\begin{pmatrix}1\\l_{21}&amp;1\\\vdots&amp;\vdots&amp;\ddots\\l_{n1}&amp;l_{n2}&amp;\cdots&amp;1\end{pmatrix}
\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix} =
\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix},\\
\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix} =
\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix}
\end{array}\right.\\
解得\left\{\begin{array}{l}
y_1=b_1\\
y_k=b_k-\sum_{i=1}^{k-1}{l_{ki}y_i},\quad k=2,3,\dots,n\\
x_n=y_n\div u_{nn}\\
x_i=(y_i-\sum_{j=i+1}^{n}{u_{ij}x_j})\div u_{ii},\quad i=n-1,n-2m\dots,1
\end{array}\right.
\end{array}
\]</span></p>
<h3 id="平方根法">2.7 平方根法</h3>
<p>针对系数矩阵 <span class="math inline">\(A\)</span>
为对称正定矩阵情况，有 <span
class="math inline">\(A=LU,u_{kk}&gt;0\)</span> ，而：</p>
<p><span
class="math inline">\(\begin{pmatrix}u_{11}&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;u_{22}&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
=
\begin{pmatrix}u_{11}\\&amp;u_{22}\\&amp;&amp;\ddots\\&amp;&amp;&amp;u_{nn}\end{pmatrix}
\begin{pmatrix}1&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;1&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>令 <span
class="math inline">\(D=\begin{pmatrix}u_{11}\\&amp;u_{22}\\&amp;&amp;\ddots\\&amp;&amp;&amp;u_{nn}\end{pmatrix},\
M=\begin{pmatrix}1&amp;u_{12}&amp;\cdots&amp;u_{1n}\\&amp;1&amp;\cdots&amp;u_{2n}\\&amp;&amp;\ddots&amp;\vdots\\&amp;&amp;&amp;1\end{pmatrix}\)</span></p>
<p>则有： <span class="math inline">\(A=LDM\)</span> ，又因为 <span
class="math inline">\((LDM)^T=M^TDL^T=LDM\)</span> ，所以： <span
class="math inline">\(M=L^T\)</span> ，则有： <span
class="math inline">\(A=LDM=LDL^T\)</span> 。</p>
<p>令 <span
class="math inline">\(D=\begin{pmatrix}\sqrt{u_{11}}\\&amp;\sqrt{u_{22}}\\&amp;&amp;\ddots\\&amp;&amp;&amp;\sqrt{u_{nn}}\end{pmatrix}^2=(D^{\frac{1}{2}})^2\)</span></p>
<p>则有： <span
class="math inline">\(A=LD^{\frac{1}{2}}D^{\frac{1}{2}}L^T=(LD^{\frac{1}{2}})(LD^{\frac{1}{2}})^T=GG^T,\quad
G=LD^{\frac{1}{2}}\)</span></p>
<p>分解 <span class="math inline">\(A=GG^T\)</span>
称为对称正定矩阵的<strong>Cholesky分解</strong>， <span
class="math inline">\(Ax=b\)</span> 则转换为 <span
class="math inline">\(\left\{\begin{aligned}Gy=b\\G^Tx=y\end{aligned}\right.\)</span>
，称为<strong>平方根法</strong>。</p>
<p>求解方法：</p>
<p>若记 <span class="math inline">\(G=(g_{ij})\)</span> ，则对 <span
class="math inline">\(k=1,2,\dots,n\)</span> 有： <span
class="math inline">\(\left\{\begin{array}{l}g_{kk}=(a_{kk}-\sum_{m=1}^{k-1}{g_{km}^2})^\frac{1}{2}\\g_{ik}=(a_{ik}-\sum_{m=1}^{k-1}{g_{im}g_{km}})\div
g_{kk},\ i=k+1,\dots,n\end{array}\right.\)</span></p>
<p>同样将 <span class="math inline">\(G\)</span> 存放在 <span
class="math inline">\(A\)</span> 的位置来节省存储。</p>
<p>解三角方程 <span
class="math inline">\(\left\{\begin{aligned}Gy=b\\G^Tx=y\end{aligned}\right.\)</span>
得： <span
class="math inline">\(\left\{\begin{array}{l}y_k=(b_k-\sum_{m=1}^{k-1}{g_{km}y_m})\div
g_{kk},\quad k=1,2,\dots,n\\x_k=(y_k-\sum_{m=k+1}^{n}g_{mk})\div
g_{kk},\quad k=n,n-1,\dots,1\end{array}\right.\)</span></p>
<h3 id="追赶法">2.8 追赶法</h3>
<p>追赶法是求三对角线性方程组的三角分解法： <span
class="math inline">\(\begin{pmatrix}a_1&amp;c_1\\d_2&amp;a_2&amp;c_2\\&amp;\ddots&amp;\ddots&amp;\ddots\\&amp;&amp;d_{n-1}&amp;a_{n-1}&amp;c_{n-1}\\&amp;&amp;&amp;d_n&amp;a_n\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\\vdots\\x_{n-1}\\x_n\end{pmatrix} =
\begin{pmatrix}b_1\\b_2\\\vdots\\b_{n-1}\\b_n\end{pmatrix}\)</span></p>
<p>三对角矩阵 <span class="math inline">\(A\)</span>
的各阶顺序主子式都不为零的一个充分条件是： <span
class="math inline">\(|a_1|&gt;|c_1|&gt;0;\ |a_n|&gt;|d_n|&gt;0;\
|a_i|\ge|c_i|+|d_i|, c_id_i\neq0, i=2,3,\dots,n-1\)</span> 在此条件下，
<span class="math inline">\(A=LDM=TM\)</span> ，称为矩阵 <span
class="math inline">\(A\)</span> 的<strong>Crout分解</strong>。</p>
<p>对三对角矩阵 <span class="math inline">\(A\)</span>
进行Crout分解，有：<span
class="math inline">\(A=\begin{pmatrix}\alpha_1\\\gamma_2&amp;\alpha_2\\&amp;\ddots&amp;\ddots\\&amp;&amp;\gamma_{n-1}&amp;\alpha_{n-1}\\&amp;&amp;&amp;\gamma_n&amp;\alpha_n\end{pmatrix}
\begin{pmatrix}1&amp;\beta_1\\&amp;1&amp;\beta_2\\&amp;&amp;\ddots&amp;\ddots\\&amp;&amp;&amp;1&amp;\beta_{n-1}\\&amp;&amp;&amp;&amp;1\end{pmatrix}\)</span><br />
<span class="math inline">\(\left\{\begin{array}{l}\alpha_1=a_1,\
\beta_1=c_1\div\alpha_1,\ \gamma_i=d_i,\ i=1,2,3,\dots,n\\
\alpha_i=a_i-d_i\beta_{i-1},\ i=2,3,\dots,n\\ \beta_i=c_i\div\alpha_i,\
i=2,3,\dots,n-1 \end{array}\right.\)</span></p>
<h3 id="代码lu分解法doolittle">代码：LU分解法（Doolittle）</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-27.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> b<span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">();</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">();</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_ <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}};</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x <span class="op">=</span> solve<span class="op">(</span>A_<span class="op">,</span> <span class="va">b_</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> A_<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="va">b_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    A<span class="op">.</span>assign<span class="op">(</span>A_<span class="op">.</span>begin<span class="op">(),</span> A_<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>assign<span class="op">(</span><span class="va">b_</span><span class="op">.</span>begin<span class="op">(),</span> <span class="va">b_</span><span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    getLU<span class="op">();</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve y</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    y<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            y<span class="op">[</span>k<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>i<span class="op">]</span> <span class="op">*</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// solve x</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    x<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> y<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">/</span> A<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> x<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        x<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>y<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getLU<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> k<span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>                    A<span class="op">[</span>k<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>k<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&lt;</span> size<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>            <span class="dt">double</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> m <span class="op">&lt;</span> k<span class="op">;</span> <span class="op">++</span>m<span class="op">)</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>                sum <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>m<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">-</span> sum<span class="op">)</span> <span class="op">/</span> A<span class="op">[</span>k<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    printA<span class="op">();</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printA<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>2021-02-26-数值分析-Day01-顺序Gauss消元</title>
      <link>https://elderlyaugustus.github.io/posts/2021-02-26-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day01-%E9%A1%BA%E5%BA%8Fgauss%E6%B6%88%E5%85%83/</link>
      <pubDate>Fri, 26 Feb 2021 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2021-02-26-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day01-%E9%A1%BA%E5%BA%8Fgauss%E6%B6%88%E5%85%83/</guid>
      <description>1.1 - 1.2 数值分析的算法要求 结构简单，易于计算机实现 理论上保证方法的收敛性和数值稳定性 计算效率高：速度快，内存开销小 经过数值实验验证 误差的来源和分类 模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免 观测误差：观测实验得到的参数带来的误差 截断误差：近似方法产生的误差 舍入误差：计算机有限位计算产生的误差 （后两者为本课程主要研究对象）
绝对误差和相对误差
设 \(x\) 是精确值 \(x^{*}\) 的一个近似值，则 \(e=x^{*}-x\) 为近似值 \(x\) 的绝对误差，简称误差。
若 \(\varepsilon\) 满足 \(|e|\le\varepsilon\) ，则称 \(\varepsilon\) 为 \(x\) 的绝对误差限，简称误差限，有量纲。则满足 \(x-\varepsilon \le x^{*} \le x+\varepsilon\) ，简写为 \(x^{*} = x\pm\varepsilon\) 。
\(e_{r} = \displaystyle\frac{e}{x^{*}} = \frac{x^{*}-x}{x^{*}}\) 称相对误差。
\(\varepsilon_{r} = \displaystyle\frac{\varepsilon}{|x|}\) 称相对误差限， \(|e_{r}| \le \varepsilon_{r}\) ，无量纲。
（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）
1.3 有效数字 定义1：设数 \(x\) 是数 \(x^{*}\) 的近似值，如果 \(x\) 的绝对误差限是它的某一数位的半个单位，并且从 \(x\) 左起第一个非零数到该数位共有 \(n\) 位，则称这 \(n\) 个数字为 \(x\) 的有效数字，也称用 \(x\) 近似 \(x*\) 时具有 \(n\) 位有效数字。</description>
      <content:encoded><![CDATA[<h3 id="section">1.1 - 1.2</h3>
<h4 id="数值分析的算法要求">数值分析的算法要求</h4>
<ul>
<li>结构简单，易于计算机实现</li>
<li>理论上保证方法的收敛性和数值稳定性</li>
<li>计算效率高：速度快，内存开销小</li>
<li>经过数值实验验证</li>
</ul>
<h4 id="误差的来源和分类">误差的来源和分类</h4>
<ul>
<li><ul>
<li>模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免</li>
<li>观测误差：观测实验得到的参数带来的误差</li>
<li><strong>截断误差</strong>：近似方法产生的误差</li>
<li><strong>舍入误差</strong>：计算机有限位计算产生的误差</li>
</ul>
<p>（后两者为本课程主要研究对象）</p></li>
<li><p>绝对误差和相对误差</p>
<p>设 <span class="math inline">\(x\)</span> 是精确值 <span
class="math inline">\(x^{*}\)</span> 的一个近似值，则 <span
class="math inline">\(e=x^{*}-x\)</span> 为近似值 <span
class="math inline">\(x\)</span>
的<strong>绝对误差</strong>，简称<strong>误差</strong>。</p>
<p>若 <span class="math inline">\(\varepsilon\)</span> 满足 <span
class="math inline">\(|e|\le\varepsilon\)</span> ，则称 <span
class="math inline">\(\varepsilon\)</span> 为 <span
class="math inline">\(x\)</span>
的<strong>绝对误差限</strong>，简称<strong>误差限</strong>，有量纲。则满足
<span class="math inline">\(x-\varepsilon \le x^{*} \le
x+\varepsilon\)</span> ，简写为 <span class="math inline">\(x^{*} =
x\pm\varepsilon\)</span> 。</p>
<p><span class="math inline">\(e_{r} = \displaystyle\frac{e}{x^{*}} =
\frac{x^{*}-x}{x^{*}}\)</span> 称<strong>相对误差</strong>。</p>
<p><span class="math inline">\(\varepsilon_{r} =
\displaystyle\frac{\varepsilon}{|x|}\)</span>
称<strong>相对误差限</strong>， <span class="math inline">\(|e_{r}| \le
\varepsilon_{r}\)</span> ，无量纲。</p>
<p>（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）</p></li>
</ul>
<h3 id="有效数字">1.3 有效数字</h3>
<p><strong>定义1</strong>：设数 <span class="math inline">\(x\)</span>
是数 <span class="math inline">\(x^{*}\)</span> 的近似值，如果 <span
class="math inline">\(x\)</span>
的绝对误差限是它的某一数位的半个单位，并且从 <span
class="math inline">\(x\)</span> 左起第一个非零数到该数位共有 <span
class="math inline">\(n\)</span> 位，则称这 <span
class="math inline">\(n\)</span> 个数字为 <span
class="math inline">\(x\)</span> 的有效数字，也称用 <span
class="math inline">\(x\)</span> 近似 <span
class="math inline">\(x*\)</span> 时具有 <span
class="math inline">\(n\)</span> 位有效数字。</p>
<p><strong>有效数字与绝对误差限的关系</strong>： <span
class="math inline">\(x\)</span> 作为 <span
class="math inline">\(x^{*}\)</span> 的近似值，具有 <span
class="math inline">\(n\)</span> 位（ <span class="math inline">\(n \le
k\)</span> ）有效数字当且仅当：</p>
<p><span class="math display">\[
\left|x^{*}-x\right| \le \frac{1}{2}\times10 ^{m-n}
\]</span></p>
<p>近似值的有效数字越多，其绝对误差越小。</p>
<p>（PS：精确值的有效数字可认为有无限多位。）</p>
<p><strong>有效数字与相对误差限的关系</strong>：若 <span
class="math inline">\(x\)</span> 有 <span
class="math inline">\(n\)</span> 位有效数字，则其相对误差限为： <span
class="math display">\[
\varepsilon_{r} \le \frac{1}{2 a_{1}}\times10^{-n+1}
\]</span> 反之，若 <span class="math inline">\(x\)</span> 的相对误差限：
<span class="math display">\[
\varepsilon_{r} \le \frac{1}{2(a_{1}+1)}\times10^{-n+1}
\]</span> 则 <span class="math inline">\(x\)</span> 至少有 <span
class="math inline">\(n\)</span> 位有效数字。</p>
<h3 id="数值计算中的若干原则">1.4 - 1.6 数值计算中的若干原则</h3>
<p>为减少舍入误差</p>
<ul>
<li><p>避免两个相近的数相减</p>
<p>利用对数计算法则将减法转换为除法、利用三角函数和差化积公式转换为乘除、倒用分母有理化将减法转换为分母上的乘法等方法。</p></li>
<li><p>防止大数“吃掉”小数</p>
<p>指参与计算的数数量级差很大时，则加减运算中，绝对值小的数往往被绝对值大的数“吃掉”（如被计算机存储位数限制舍去）。</p>
<p>改变计算顺序，在求和差过程中由小到大进行计算。</p></li>
<li><p>绝对值太小的数不宜作除数</p></li>
<li><p>注意简化计算程序，减少计算次数</p></li>
<li><p>选用数值稳定性好的算法</p>
<p>计算舍入误差积累是可控制的。</p></li>
</ul>
<h3 id="gauss消去法">2.1 - 2.4 Gauss消去法</h3>
<p>求解线性方程组 <span class="math display">\[
\left\{
\begin{aligned}
a_{11}x_{1} + a_{12}x_{2} + ... + a_{1n}x_{n} = b_{1}\\
a_{21}x_{1} + a_{22}x_{2} + ... + a_{2n}x_{n} = b_{2}\\
\dots\\
a_{n1}x_{1} + a_{n2}x_{2} + ... + a_{nn}x_{n} = b_{n}\\
\end{aligned}
\right.
(1)
\]</span> 矩阵形式 <span class="math inline">\(Ax = b\)</span> <span
class="math display">\[
A=  
\begin{pmatrix}  
  a_{11}&amp; a_{12}&amp; \cdots  &amp; a_{1n} \\  
  a_{21}&amp; a_{22}&amp; \cdots  &amp; a_{2n} \\  
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  
  a_{n1}&amp; a_{n2}&amp; \cdots  &amp; a_{nn}
\end{pmatrix},
x=
\begin{pmatrix}  
  x_{1} \\
  x_{2} \\
  \cdots \\
  x_{n} \\
\end{pmatrix},
b=
\begin{pmatrix}  
  b_{1} \\
  b_{2} \\
  \cdots \\
  b_{n} \\
\end{pmatrix} \\
矩阵A奇异，det(A)\neq0
\]</span></p>
<p>Cramer法则：直接方法，计算量过大，不适合实际应用</p>
<p><strong>Gauss消去法</strong>：直接方法，逐次消元，转换为上三角方程组。</p>
<h4 id="顺序gauss消去法">顺序Gauss消去法</h4>
<p>顺序Gauss消去法求解线性方程组 <span
class="math inline">\((1)\)</span>：</p>
<p>记 <span class="math inline">\(A^{(1)}=A, b^{(1)}=b,
a_{ij}^{(1)}=a_{ij}, b_{i}*{(1)}=b_{i}\)</span></p>
<p>则，线性方程组 <span class="math inline">\((1)\)</span>
的增广矩阵为： <span class="math display">\[
(A^{(1)},b^{(1)})=  
\begin{pmatrix}  
  a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
  a_{21}^{(1)}&amp; a_{22}^{(1)}&amp; a_{23}^{(1)}&amp; \dots  &amp;
a_{2n}^{(1)}&amp; b_{2}^{(1)} \\
  a_{31}^{(1)}&amp; a_{32}^{(1)}&amp; a_{33}^{(1)}&amp; \dots  &amp;
a_{3n}^{(1)}&amp; b_{3}^{(1)} \\
  \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
  a_{n1}^{(1)}&amp; a_{n2}^{(1)}&amp; a_{n3}^{(1)}&amp; \dots  &amp;
a_{nn}^{(1)}&amp; b_{n}^{(1)} \\
\end{pmatrix},
\]</span></p>
<ul>
<li><p>第 <span class="math inline">\(1\)</span> 步：设 <span
class="math inline">\(a_{11}^{(1)}\neq0\)</span> ，依次用 <span
class="math inline">\(-l_{i1}=-\displaystyle\frac{a_{i1}^{(1)}}{a_{11}^{(1)}},
(i=2,3,\dots,n)\)</span> 乘以矩阵的第 <span
class="math inline">\(1\)</span> 行加到第 <span
class="math inline">\(i\)</span> 行，得到矩阵： <span
class="math display">\[
\begin{array}{l}
(A^{(2)},b^{(2)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; a_{32}^{(2)}&amp; a_{33}^{(2)}&amp; \dots  &amp;
a_{3n}^{(2)}&amp; b_{3}^{(2)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; a_{n2}^{(2)}&amp; a_{n3}^{(2)}&amp; \dots  &amp;
a_{nn}^{(2)}&amp; b_{n}^{(2)} \\
\end{pmatrix},\\
其中：\begin{aligned}
a_{ij}^{(2)} = a_{ij}^{(1)} - l_{i1}a_{1j}^{(1)},\quad i,j=2,3,\dots,n
\\
b_{i}^{(2)} = b_{i}^{(1)} - l_{i1}b_{1}^{(1)},\qquad i=2,3,\dots,n
\end{aligned}
\end{array}
\]</span></p></li>
<li><p>第 <span class="math inline">\(2\)</span> 步：设 <span
class="math inline">\(a_{22}^{(2)}\neq0\)</span> ，依次用 <span
class="math inline">\(-l_{i2}=-\displaystyle\frac{a_{i2}^{(2)}}{a_{22}^{(2)}},
(i=3,4,\dots,n)\)</span> 乘以矩阵的第 <span
class="math inline">\(2\)</span> 行加到第 <span
class="math inline">\(i\)</span> 行，得到矩阵： <span
class="math display">\[
\begin{array}{l}
(A^{(2)},b^{(2)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; 0&amp; a_{33}^{(3)}&amp; \dots  &amp; a_{3n}^{(3)}&amp;
b_{3}^{(3)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; 0&amp; a_{n3}^{(3)}&amp; \dots  &amp; a_{nn}^{(3)}&amp;
b_{n}^{(3)} \\
\end{pmatrix},\\
其中：\begin{aligned}
a_{ij}^{(3)} = a_{ij}^{(2)} - l_{i2}a_{2j}^{(2)},\quad i,j=3,4,\dots,n
\\
b_{i}^{(3)} = b_{i}^{(2)} - l_{i2}b_{2}^{(2)},\qquad i=3,4,\dots,n
\end{aligned}
\end{array}
\]</span></p></li>
<li><p>第 <span class="math inline">\(3\)</span> 步，第 <span
class="math inline">\(4\)</span> 步， <span
class="math inline">\(\dots\)</span> ，第 <span
class="math inline">\((n-1)\)</span> 步后得到矩阵： <span
class="math display">\[
(A^{(n)},b^{(n)})=  
\begin{pmatrix}  
a_{11}^{(1)}&amp; a_{12}^{(1)}&amp; a_{13}^{(1)}&amp; \dots  &amp;
a_{1n}^{(1)}&amp; b_{1}^{(1)} \\
0&amp; a_{22}^{(2)}&amp; a_{23}^{(2)}&amp; \dots  &amp;
a_{2n}^{(2)}&amp; b_{2}^{(2)} \\
0&amp; 0&amp; a_{33}^{(3)}&amp; \dots  &amp; a_{3n}^{(3)}&amp;
b_{3}^{(3)} \\
\dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots&amp; \dots \\
0&amp; 0&amp; 0&amp; \dots  &amp; a_{nn}^{(n)}&amp; b_{n}^{(n)} \\
\end{pmatrix}
\]</span></p></li>
<li><p>对应的方程组则变成： <span class="math display">\[
\left\{
\begin{aligned}
a_{11}^{(1)}x_{1} + a_{12}^{(1)}x_{2} + ... + a_{1n}^{(1)}x_{n} =
b_{1}^{(1)}\\
a_{22}^{(2)}x_{2} + ... + a_{2n}^{(2)}x_{n} = b_{2}^{(2)}\\
\dots\\
a_{nn}^{(n)}x_{n} = b_{n}^{(n)}\\
\end{aligned}
\right.
\]</span></p></li>
<li><p>对此方程组进行回代，就可求出方程组的解</p></li>
</ul>
<p>顺序Gauss消去法的乘除计算量：<span
class="math inline">\(\displaystyle\sum_{k=1}^{n}(k^{2}-1)\ +\
\displaystyle\sum_{k=1}^{n}k\ =\
\displaystyle\frac{1}{3}(n^{3}+3n^{2}-n)\)</span></p>
<p><strong>顺序Gauss消去法</strong>也简称为<strong>Gauss消去法</strong>，其中
<span class="math inline">\(a_{kk}^{(k)}(k=1,2,\dots,n)\)</span>
也称为<strong>主元素</strong>，且主元素不为零（使用顺序Gauss消去法的充要条件）。</p>
<h4 id="列主元gauss消去法">列主元Gauss消去法</h4>
<p>顺序Gauss消去法的局限性：主元素过小时出现“大数吃小数”情况，舍入误差较大。常采用<strong>列主元Gauss消去法</strong>和<strong>全主元Gauss消去法</strong>解决。</p>
<p>线性方程组 <span class="math inline">\(Ax=b\)</span>，记 <span
class="math inline">\(A^{(1)}=A, b^{(1)}=b,\)</span>
列主元Gauss消去法过程如下： + 在增广矩阵 <span
class="math inline">\(B^{(1)}=(A^{(1)},b^{(1)})\)</span>
的第一列元素中，取： <span
class="math inline">\(\left|a_{k1}^{(1)}\right| = \max\limits_{1\le i\le
n}{\left|a_{i1}^{(1)}\right|}\)</span> 为主元素， <span
class="math inline">\(r_{k}\leftrightarrow r_{1}\)</span> 。 然后进行第
<span class="math inline">\(1\)</span> 步消元得到增广矩阵 <span
class="math inline">\(B^{2}=(A^{(2), b^{(2)}})\)</span> 。 + 再在矩阵
<span class="math inline">\(B^{(2)}=(A^{(2)},b^{(2)})\)</span>
的第二列元素中，取： <span
class="math inline">\(\left|a_{k2}^{(2)}\right| = \max\limits_{2\le i\le
n}{\left|a_{i2}^{(2)}\right|}\)</span> 为主元素， <span
class="math inline">\(r_{k}\leftrightarrow r_{2}\)</span> 。
然后进行第二步消元得到增广矩阵 <span
class="math inline">\(B^{3}=(A^{(3), b^{(3)}})\)</span> 。 +
依此类推，经过 <span class="math inline">\((n-1)\)</span>
步选主元和消元运算，得到增广矩阵 <span
class="math inline">\(B^{n}=(A^{(n), b^{(n)}})\)</span> 。则方程组 <span
class="math inline">\(A^{(n)}x=b^{(n)}\)</span>
是与原方程组等价的上三角方程组，回代求解。 + <strong>易证：只要 <span
class="math inline">\(|A|\neq 0\)</span>
列主元Gauss消去法就可顺利进行。</strong></p>
<h4 id="全主元gauss消去法">全主元Gauss消去法</h4>
<p>在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。</p>
<h3 id="代码顺序gauss消去法">代码：顺序Gauss消去法</h3>
<p>在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Created by xa on 2021-02-26.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> matrix<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> input<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upperTriangular<span class="op">();</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swapRow<span class="op">(</span><span class="dt">int</span> index<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss<span class="op">(</span><span class="dt">int</span> index<span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">*</span> a<span class="op">,</span> T<span class="op">*</span> b<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printMatrix<span class="op">();</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> test <span class="op">{{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">},</span> <span class="op">{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}};</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> ans <span class="op">=</span> solve<span class="op">(</span>test<span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ans<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> ans<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solve<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> input<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span>assign<span class="op">(</span>input<span class="op">.</span>begin<span class="op">(),</span> input<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    size <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> solution<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    upperTriangular<span class="op">();</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;No Solution.&quot;</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    solution<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">]/</span>matrix<span class="op">[</span>size<span class="op">-</span><span class="dv">1</span><span class="op">][</span>size<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> size<span class="op">-</span><span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> tmp <span class="op">=</span> matrix<span class="op">[</span>i<span class="op">][</span>size<span class="op">];</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            tmp <span class="op">-=</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">*</span> solution<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        solution<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> tmp<span class="op">/</span>matrix<span class="op">[</span>i<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solution<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upperTriangular<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        swapRow<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        gauss<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swapRow<span class="op">(</span><span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max <span class="op">=</span> index<span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> index<span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>index<span class="op">]</span> <span class="op">&gt;</span> matrix<span class="op">[</span>max<span class="op">][</span>index<span class="op">])</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>matrix<span class="op">[</span>index<span class="op">],</span> matrix<span class="op">[</span>max<span class="op">]);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;swap&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> gauss<span class="op">(</span><span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> index <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> l <span class="op">=</span> matrix<span class="op">[</span>i<span class="op">][</span>index<span class="op">]</span> <span class="op">/</span> matrix<span class="op">[</span>index<span class="op">][</span>index<span class="op">];</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>            matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> l <span class="op">*</span> matrix<span class="op">[</span>index<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;</span> <span class="fl">1e-16</span> <span class="op">&amp;&amp;</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;</span> <span class="op">-</span><span class="fl">1e-10</span><span class="op">)</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;gauss&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    printMatrix<span class="op">();</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span>T<span class="op">*</span> a<span class="op">,</span> T<span class="op">*</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> tmp <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> printMatrix<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> matrix<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">&#39; &#39;</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
