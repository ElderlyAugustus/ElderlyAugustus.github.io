[{"content":"虚拟制作（Virtual Production）中的景深问题思考 从发现这一问题就在思考如何从源头上的solution。之前和@houjue讨论得到过基本的思路和方法，但一直没有工程实践上的想法。今天旁观一场研讨会再次听到这一问题，突然有了想法，看了UE这部分的实现差不多确定是可以work的。但想安度最后的大学时光，便懒得做了，浅记在这里未来闲了再说吧。\n什么问题 简而言之就是LED墙内视锥的虚拟摄影机和真实摄影机的两次景深处理叠加，带来的背景景深错误。具体阐述可见大三时水的《基于LED背景墙的电影虚拟化制作实践探索与未来展望》这篇，不在博客里详述了。\n一个基于Unreal Engine的解决方案Idea UE中假定高斯模糊为景深效果的实现方式（实际略有差异），高斯模糊存在以下叠加关系 \\(\\sigma_1^2+\\sigma_2^2=\\sigma_3^2\\) 时， \\(\\sigma_1\\) 与 \\(\\sigma_2\\) 的两次高斯模糊叠加后效果与一次 \\(\\sigma_3\\) 的高斯模糊一致； 而UE景深后处理的 \\(\\sigma\\) 与 \\(CoC\\) （弥散圆）相关（线性关系），那同样认为真实摄影机的景深结果与 \\(CoC\\) 相关，则有 \\(R_{CoC_1}^2+R_{CoC_2}^2=R_{CoC_3}^2\\) ， \\(CoC_3\\) 带来的景深效果是最终目标， \\(CoC_2\\) 是真实摄影机到异形屏对应像素之间的距离计算得到，由此可以算出渲染应得的 \\(CoC_1\\) 。\n怎么获得真实摄影机到异形屏对应像素之间的距离：等效虚拟摄影机视线到虚拟LED Wall上交点的距离 —— 给CineCameraActor绑一个SceneCapture2D直接抓ZBuffer。\n预告一下今年的目标更新，在翻译最近两年关于光谱渲染的两篇Siggraph Course Notes：\nSpectral imaging in production | ACM SIGGRAPH 2021 Courses\nPractical aspects of spectral data in digital content production | ACM SIGGRAPH 2022 Courses\n目前一天翻不到半页的龟速，主线工作太多。等有一些进度了就放一部分上来。\n","permalink":"https://elderlyaugustus.github.io/posts/2023-02-25-%E8%99%9A%E6%8B%9F%E5%88%B6%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%99%AF%E6%B7%B1%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/","summary":"虚拟制作（Virtual Production）中的景深问题思考 从发现这一问题就在思考如何从源头上的solution。之前和@houjue讨论得到过基本的思路和方法，但一直没有工程实践上的想法。今天旁观一场研讨会再次听到这一问题，突然有了想法，看了UE这部分的实现差不多确定是可以work的。但想安度最后的大学时光，便懒得做了，浅记在这里未来闲了再说吧。\n什么问题 简而言之就是LED墙内视锥的虚拟摄影机和真实摄影机的两次景深处理叠加，带来的背景景深错误。具体阐述可见大三时水的《基于LED背景墙的电影虚拟化制作实践探索与未来展望》这篇，不在博客里详述了。\n一个基于Unreal Engine的解决方案Idea UE中假定高斯模糊为景深效果的实现方式（实际略有差异），高斯模糊存在以下叠加关系 \\(\\sigma_1^2+\\sigma_2^2=\\sigma_3^2\\) 时， \\(\\sigma_1\\) 与 \\(\\sigma_2\\) 的两次高斯模糊叠加后效果与一次 \\(\\sigma_3\\) 的高斯模糊一致； 而UE景深后处理的 \\(\\sigma\\) 与 \\(CoC\\) （弥散圆）相关（线性关系），那同样认为真实摄影机的景深结果与 \\(CoC\\) 相关，则有 \\(R_{CoC_1}^2+R_{CoC_2}^2=R_{CoC_3}^2\\) ， \\(CoC_3\\) 带来的景深效果是最终目标， \\(CoC_2\\) 是真实摄影机到异形屏对应像素之间的距离计算得到，由此可以算出渲染应得的 \\(CoC_1\\) 。\n怎么获得真实摄影机到异形屏对应像素之间的距离：等效虚拟摄影机视线到虚拟LED Wall上交点的距离 —— 给CineCameraActor绑一个SceneCapture2D直接抓ZBuffer。\n预告一下今年的目标更新，在翻译最近两年关于光谱渲染的两篇Siggraph Course Notes：\nSpectral imaging in production | ACM SIGGRAPH 2021 Courses\nPractical aspects of spectral data in digital content production | ACM SIGGRAPH 2022 Courses\n目前一天翻不到半页的龟速，主线工作太多。等有一些进度了就放一部分上来。","title":"虚拟制作（Virtual Production）中的景深问题思考"},{"content":"上一回写“年记”是My 2019了，今年发生的事太多，早就准备写一写，几次提笔，都没能写竟，想想算了还是留到年终来写这篇My 2022吧。\n今年元旦，我发了一条微博：\n21年两个主要的工作： 上半年一直搞着，但逐渐发现能搞得越来越少的Virtual Production； 下半年就着Presentation的课程，继续前一年没太搞明白的Simulation。\n一些杂七杂八的工作： 影院课及课程方案重编工作中，复习/新学了一些东西，Presentation部分新学了一点流媒体的知识； 科工委的技术展示片，早早开始筹备，制作却日常拖到了最后，明天要开始拍摄的部分； 零散地做了一些片子的后期/远程支持，以及极少量的现场工作，也算有一些二维影像的内容产出； 寒暑期照常补充了一些基础科学知识，后来也是不出所料派上了用场； 其他一些更零碎的就不提了。\n从19年进入实验室以来，持续了一年多的“精力‘Wireless’”，终于在一个暑假没回家之后，逐渐被大三上课内外的任务压得喘不过气来。\n今年只希望能得空做一些想做的工作罢，21年没学完的那些课等等。\n今年最想做的，是抛开实验室繁重的日常工作，真的有时间磨练磨练自己解决实际工程问题的能力。\n过完春节，三月，接到了这一学期又要从线上开始的通知，大家都没有两年前那样惊讶了，也预料到了开学的概率同样渺茫。在一边准备着本来这学期要拍的最后一次大作业的同时，我开始寻找学校外面的实践机会。\n跟着朋友们的步伐，我开始投出了我的第一批实习简历。仍然是抱着想要做电影的想法，先是盯上了几家有名视效、动画公司的RnD、TD岗，很快感受到了学校在业界的光环加成，聊家常一般的面试、快速的Offer沟通。然而，也很快地告诉了我影视行业这两年到底有多艰难的真相——我真的很难接受实习薪资甚至很难cover一个月北京房租和生活费的现实。留着最后一丝的希望，我只留下了一封没有定薪的、方向是刚做过的Simulation的动画公司RnD Offer，想着下半年如果能开学，住在学校宿舍兴许能去看看，虽然后面的计划很快被再一次打乱了。\n而三年里多少次念叨过的游戏行业，随后陆陆续续开始推进了流程。由于对游戏制作不算熟悉，尚不清楚自己到底适合什么样的岗位，投递策略是把自己技术栈能沾边的岗都投了个遍，从图程、引擎到技术美术、甚至技术策划等等，堪称“百花齐放”——几乎每家公司投递的都是不一样的岗位。不过很幸运的是，一面就收获了网易互娱的引擎预研课题岗，也最终几乎没有犹豫就选择了这一挑战最大的实习Offer。\n因为忐忑自己是否能够胜任实习的工作，4-5月我几乎把所有课余时间都投入到了进一步深入学习渲染、做更多的开发练习，并提前了解预研课题相关的知识上。也正在这期间上海封控，全国各地疫情散发，终于收到公司通知今年全体暑期实习生转为线上。在确认这一学期不会回学校，也取消了短片大作业后，我将自己的实习期提前了一个月，便开始了挣扎与快乐并存的实习两月。\n不得不承认，最初拿到没有文档、没有教学的开源引擎作为我的第一步算法验证工具的时候，我就害怕了。虽然从中学就开始写程序，但完全没有在这么大型的代码中穿梭工作的经验。第一天死读源码，头昏脑胀，我甚至和mentor提出了放弃，直接跳到第二步里我熟悉的Unreal去。mentor没有完全否定，只是鼓励我再试试，用过往经验告诉我，前两周一般都是这个状态。第二天，我重新从最基础的案例读起，在发现了各种函数与图形API之间的对应关系之后，我便豁然开朗了——很快，一天内就在案例的基础上搭建起验证的框架来。我建立起信心来，也开始沉迷上这种“初极狭，才通人。复行数十步，豁然开朗”的感觉，这在随后的两个月里不断地重演。\n犹记得和朋友聊到这种“真的在学习”的满足感，顿时会心。实习第三周，我第一次开始考虑要不要继续留下读书的问题，是不是工作会带给我更多的成长和满足呢？\n7月初的插曲是保研面试。因为只给保研本专业的限制，看着好朋友参与了十几个夏令营的眼睛只能干着眼发馋。在自己系的夏令营，没有新鲜、没有波折地完美作答，看起来顺理成章地取得第一，只等着那个似乎理所应当的三年绩点排名一。答着那些熟悉无比的题目，答着未来三年我会继续做什么，我意识到未来三年会做的这些事，跟前三年的实验室生活别无他样，也并不能做出我真正想做的东西。\n于是我跟着同事们一起卷入了秋招的大潮，看着今年的秋招大崩溃袭来，游戏行业的收缩，不仅呈现在“寒气”的蔓延上，也扎扎实实地呈现在每一家公司的Head Count上。好在我还算是幸运的，开始秋招时还可以抱着有学上的底气。这一次，我没有再犹豫自己应该选择什么岗位，因为实习的经历，我几乎没有犹豫地在每家游戏公司的秋招中投递了游戏引擎、图形渲染的岗位，并很顺利地通过了许多公司的筛选。\n实习结束后的那一个多月，几乎每一天，我三点醒来，在床上焦虑到九十点起床、一遍遍地翻邮箱，下午、晚上或是一场两场笔面试，或是杳无音信地焦虑一整天。仅有的慰藉是不像实习期间每天匆匆糊弄一两顿，可以有时间做点好吃的、买点好吃的。\n因为专业背景的关系，也因为自己真正深入引擎开发不过寥寥半年，不少厂和网易一样最后给我转岗到技术美术。其中也包括国内最喜欢的游戏内容的“梦厂”——米哈游。完成引擎开发笔试时，我又一次让我体会到初见图形学时的那般冲动与热情。等了两周阅卷、面试又表现不佳，泡了两周池子后转岗到技术美术，便面临保研结果确认的最后期限了。很感谢帮我反复催促的HR同学，整个秋招里我的流程从来没有如此迅速过：技术美术岗位的笔试流程较长，虽然尽量选择了开放性较低的题型，还是花了四天半的时间去完成，随后一天一面、两天一面，竟真的赶在两周内完成了所有的面试。\n这一次，我没有再错过机会。拿到意向书当晚，我做了最后的短暂思考，立刻联系了负责推免工作的老师。他告诉我，刚刚开完会，刚刚系内公示了我的名额。道歉、再次确认，在公示栏张贴之前，将最终的保研名额改为了我的室友。终于，像载着重石的气球脱开了束缚，我睡了个好觉。\n第二天，我向这三年里每一位指点过、照顾过我，对我抱有深远期望的老师——也几乎是北京电影学院影视技术系的全体教师了，一一抱歉、道别，一一接受了他们的祝福。我说，“要去迎接新的机遇与挑战了”。\n至于在网易互娱的实习，按mentor说往年应是轻松转正，今年却连续遭遇了：流程拖延、引擎招聘计划取消转岗至客户端、TA组邀请转岗至TA等等漫长的变化……跟着实习群里的大家一起焦虑了整整三个多月，直到一切尘埃落定之后的十二月初，才给到了两次转岗后转正的Offer Call。真的很感谢mentor和转岗的mentor的帮助，但真的晚了。\n做出决定的背后，是纠结了整个实习期和秋招期的折磨。最终在拿到意向书也是保研确认的前一周，我得到了答案——要从我的大学说起。\n高中上得像大学，大学上得像研究生。是一句玩笑，也算得是我这些年的至少半幅写照。\n刚来到电影学院的那个学，主旋律是和其他大多数同学一样，投入到剧组中、投入到活动中——有些，是新鲜的没体验过的、也有的则是高中的“大学生活”里已经驾轻就熟的，也是来到这里过得最像“本科生”的一个学期。但也正在这一学期，我发现了自己的积累对于实际的生产应用而言不过是冰山之一角，由于对各种技术的好奇，我频繁地抱怨时间不够用，这也要学那也要学。\n随后便是不幸却又幸运的半年——疫情使得大学的第二个学期不得不在家在线上度过。之所以说幸运，是我终于获得了大量的自主学习时间，互联网上也出现了大量高质量的分享课程。于是，我继续着前一学期学不完的那些东西，补着各种数理基础，也开始了早就说过想学的图形学的学习。\n这里要特别感谢GAMES，图形学与混合现实研讨会。在疫情的开始，我大学的第二学期开始陪伴至今，我从各门优质的课程中不断地探索图形学的魅力，也正是我早早参与科研、随后又在今年参与工作的重要力量之源。\n在这一学期对知识的贪婪汲取之后，我早早来到大二的校园，恰好赶上了系里实验室恢复运作却缺乏人手的时候，也发现了自己学的东西可以“派上用场”的机会。我很快融入了实验室，并又恰好赶上了实验室追逐热点的一个新科研项目——虚拟制作。作为前期参与预研的学生，我迅速成为了这个项目的三位早期核心成员之一，另两位都是与我同年入学的研究生。这正式开启了我大学的“研究生”生涯。\n于是，大学的第二年、第三年，我都过上了日常驻扎在实验室、摄影棚，与导师和研究生同学们一起工作，时而需要“溜出来”上本科生课的“Doctor”（绰号）。在实验室度过了一个又一个周末、假日，甚至那年的一整个暑假。\n在实验室待了快两年时，我已经是实验室还算比较重要的成员。在我主要参与的那个项目里，不像是项目早期三个人的野蛮探索，逐渐形成了快十人的团队，我也从所有方向都需要了解、负责变成了专注于渲染等细分方向，并且开始做论文、文档性的总结工作。而同时，系里的其他科研项目、创作项目也陆续开始缺乏人手，我开始并行参与多个项目。记得最深刻的一天，我一天内需要解决六个不同项目的不同需求，最终还是找帮手一起才能解决。在此之外，我还同步兼顾着大三繁重的课业……\n我几乎是经历了一个完整的研究生周期——积累理论基础、进入实验室开始科研项目、逐渐找到核心负责的方向、以文字形式呈现一定的成果。还围观并从旁“指指点点”了一年又一年的研究生开题、答辩……我也可以毫不谦虚地说，我在实验室两年的贡献，完全不比工作最辛苦的研究生少。\n也许就是阅历尚浅韧性不足吧，正如开头那篇微博所说的，我开始有些不像原先那样眼神里都充满了干劲，写论文、做内容都不再像之前面对未知的开发、探索那样有干劲，尤其是几乎每天都在写文字的那些日子，这让我逐渐厌倦。\n我开始回想这些年里不断说服自己留下读书的各种说法，几乎每一个，都被打破或是冲断了：\n我一直认为需要不断地换到更好的环境才可以给自己带来足够多的成长机会，当我意识到我这三年可以将西土城校区C楼和G楼地下二层的一切了如指掌的时候，我最初开始期待的研究生生涯是搬迁怀柔校区后从头建立“新一代影视制作中心”的三年。随后，便告诉我影视技术系的搬迁还遥遥无期，甚至就连现在的实验室，也被赶到了隔壁一个没有窗户的封闭仓库。 我又觉得我的科研项目还有许多可以攻克的难题，还有许多有意思的方向，值得我继续与其作战的三年。但就像我元旦的那条微博说的，越来越发觉我们这个行业里，几人的科研团队的力量难以解决这么庞大、复杂的工业问题，越来越发现我们真的只能等待工具的更新迭代，来测试来使用。 最后，我以为一段不需要在课业、科研任务上花费过多精力和时间的时间能带给自己足够多的自主探索时间。我可以在这三年里深入研究一个实时渲染引擎的内在，尝试一个又一个渲染、模拟上的Idea，实现一个个有趣的Feature，甚至，可以像一些优秀的前辈那样自己编写自己的引擎。这是我最后一次能够说服自己继续读三年的理由——就是今年的实习、工程练习告诉我，这条路的成长，有更快的实现方式。作为一个实习期间一下班就完全放松的懒人，在学校的孤军奋战理想显得可笑又荒唐。 既然所有的说法都没再能说服自己留下，接下来的一周我便用尽了全力去面试，获得了那个在现时的我看来闪闪发光的机会。\n人一旦完成了选择，就能找到无数的理由鼓励自己，选择是正确的——不再赘列一个个的理由，在最终做出选择的那一刻，我告诉自己：“这条路，又是充满坎坷曲折，但有着更多机会更多可能性的一条路”。\n这让我回想起在淋浴间冲着水决定选择南师附中的那个晚上、逃操查成绩并决定选择电影学院的那个课间，选择后的这些年来，我真的看到了各种新的可能，也真的走上了其中的几条有趣的新路线。\n因而，我又一次选择了继续相信。\n休息了一段时间，又去很近的苏州短游了两天后。我于十月份隔离两周回到学校，因为学校的“常态化防控”，因为他家期待已久的影片未能上映，我没有再去那家动画公司做Simulation的实习。我想趁着上班前，重新作为大学生度过最后的光阴。\n同样因为“常态化防控”，及经费问题，今年的实验室也不再有那么多的科研工作，这三个月过上了学累了玩、玩累了吃，随时到DI Room看电影的“温柔乡”生活。\n唯一的小工作是重新部署了个人网站，换到了这里。因此三年前的那篇My 2019和今天这篇，都重新发在这里了。\n在被“新十条”前最后的封控被赶出实验室后，和几个好朋友，去了环球影城，又去了汕头、广州旅行了十天。\n洗净了今年的劳累，全国封控也解除了，真的要重新出发了。\n不知如何收尾：2023，希望电影好起来，希望游戏好起来，希望世界好起来；希望能在进入行业后做出好的内容，变得更强大。\n","permalink":"https://elderlyaugustus.github.io/posts/2023-01-01-my2022/","summary":"上一回写“年记”是My 2019了，今年发生的事太多，早就准备写一写，几次提笔，都没能写竟，想想算了还是留到年终来写这篇My 2022吧。\n今年元旦，我发了一条微博：\n21年两个主要的工作： 上半年一直搞着，但逐渐发现能搞得越来越少的Virtual Production； 下半年就着Presentation的课程，继续前一年没太搞明白的Simulation。\n一些杂七杂八的工作： 影院课及课程方案重编工作中，复习/新学了一些东西，Presentation部分新学了一点流媒体的知识； 科工委的技术展示片，早早开始筹备，制作却日常拖到了最后，明天要开始拍摄的部分； 零散地做了一些片子的后期/远程支持，以及极少量的现场工作，也算有一些二维影像的内容产出； 寒暑期照常补充了一些基础科学知识，后来也是不出所料派上了用场； 其他一些更零碎的就不提了。\n从19年进入实验室以来，持续了一年多的“精力‘Wireless’”，终于在一个暑假没回家之后，逐渐被大三上课内外的任务压得喘不过气来。\n今年只希望能得空做一些想做的工作罢，21年没学完的那些课等等。\n今年最想做的，是抛开实验室繁重的日常工作，真的有时间磨练磨练自己解决实际工程问题的能力。\n过完春节，三月，接到了这一学期又要从线上开始的通知，大家都没有两年前那样惊讶了，也预料到了开学的概率同样渺茫。在一边准备着本来这学期要拍的最后一次大作业的同时，我开始寻找学校外面的实践机会。\n跟着朋友们的步伐，我开始投出了我的第一批实习简历。仍然是抱着想要做电影的想法，先是盯上了几家有名视效、动画公司的RnD、TD岗，很快感受到了学校在业界的光环加成，聊家常一般的面试、快速的Offer沟通。然而，也很快地告诉了我影视行业这两年到底有多艰难的真相——我真的很难接受实习薪资甚至很难cover一个月北京房租和生活费的现实。留着最后一丝的希望，我只留下了一封没有定薪的、方向是刚做过的Simulation的动画公司RnD Offer，想着下半年如果能开学，住在学校宿舍兴许能去看看，虽然后面的计划很快被再一次打乱了。\n而三年里多少次念叨过的游戏行业，随后陆陆续续开始推进了流程。由于对游戏制作不算熟悉，尚不清楚自己到底适合什么样的岗位，投递策略是把自己技术栈能沾边的岗都投了个遍，从图程、引擎到技术美术、甚至技术策划等等，堪称“百花齐放”——几乎每家公司投递的都是不一样的岗位。不过很幸运的是，一面就收获了网易互娱的引擎预研课题岗，也最终几乎没有犹豫就选择了这一挑战最大的实习Offer。\n因为忐忑自己是否能够胜任实习的工作，4-5月我几乎把所有课余时间都投入到了进一步深入学习渲染、做更多的开发练习，并提前了解预研课题相关的知识上。也正在这期间上海封控，全国各地疫情散发，终于收到公司通知今年全体暑期实习生转为线上。在确认这一学期不会回学校，也取消了短片大作业后，我将自己的实习期提前了一个月，便开始了挣扎与快乐并存的实习两月。\n不得不承认，最初拿到没有文档、没有教学的开源引擎作为我的第一步算法验证工具的时候，我就害怕了。虽然从中学就开始写程序，但完全没有在这么大型的代码中穿梭工作的经验。第一天死读源码，头昏脑胀，我甚至和mentor提出了放弃，直接跳到第二步里我熟悉的Unreal去。mentor没有完全否定，只是鼓励我再试试，用过往经验告诉我，前两周一般都是这个状态。第二天，我重新从最基础的案例读起，在发现了各种函数与图形API之间的对应关系之后，我便豁然开朗了——很快，一天内就在案例的基础上搭建起验证的框架来。我建立起信心来，也开始沉迷上这种“初极狭，才通人。复行数十步，豁然开朗”的感觉，这在随后的两个月里不断地重演。\n犹记得和朋友聊到这种“真的在学习”的满足感，顿时会心。实习第三周，我第一次开始考虑要不要继续留下读书的问题，是不是工作会带给我更多的成长和满足呢？\n7月初的插曲是保研面试。因为只给保研本专业的限制，看着好朋友参与了十几个夏令营的眼睛只能干着眼发馋。在自己系的夏令营，没有新鲜、没有波折地完美作答，看起来顺理成章地取得第一，只等着那个似乎理所应当的三年绩点排名一。答着那些熟悉无比的题目，答着未来三年我会继续做什么，我意识到未来三年会做的这些事，跟前三年的实验室生活别无他样，也并不能做出我真正想做的东西。\n于是我跟着同事们一起卷入了秋招的大潮，看着今年的秋招大崩溃袭来，游戏行业的收缩，不仅呈现在“寒气”的蔓延上，也扎扎实实地呈现在每一家公司的Head Count上。好在我还算是幸运的，开始秋招时还可以抱着有学上的底气。这一次，我没有再犹豫自己应该选择什么岗位，因为实习的经历，我几乎没有犹豫地在每家游戏公司的秋招中投递了游戏引擎、图形渲染的岗位，并很顺利地通过了许多公司的筛选。\n实习结束后的那一个多月，几乎每一天，我三点醒来，在床上焦虑到九十点起床、一遍遍地翻邮箱，下午、晚上或是一场两场笔面试，或是杳无音信地焦虑一整天。仅有的慰藉是不像实习期间每天匆匆糊弄一两顿，可以有时间做点好吃的、买点好吃的。\n因为专业背景的关系，也因为自己真正深入引擎开发不过寥寥半年，不少厂和网易一样最后给我转岗到技术美术。其中也包括国内最喜欢的游戏内容的“梦厂”——米哈游。完成引擎开发笔试时，我又一次让我体会到初见图形学时的那般冲动与热情。等了两周阅卷、面试又表现不佳，泡了两周池子后转岗到技术美术，便面临保研结果确认的最后期限了。很感谢帮我反复催促的HR同学，整个秋招里我的流程从来没有如此迅速过：技术美术岗位的笔试流程较长，虽然尽量选择了开放性较低的题型，还是花了四天半的时间去完成，随后一天一面、两天一面，竟真的赶在两周内完成了所有的面试。\n这一次，我没有再错过机会。拿到意向书当晚，我做了最后的短暂思考，立刻联系了负责推免工作的老师。他告诉我，刚刚开完会，刚刚系内公示了我的名额。道歉、再次确认，在公示栏张贴之前，将最终的保研名额改为了我的室友。终于，像载着重石的气球脱开了束缚，我睡了个好觉。\n第二天，我向这三年里每一位指点过、照顾过我，对我抱有深远期望的老师——也几乎是北京电影学院影视技术系的全体教师了，一一抱歉、道别，一一接受了他们的祝福。我说，“要去迎接新的机遇与挑战了”。\n至于在网易互娱的实习，按mentor说往年应是轻松转正，今年却连续遭遇了：流程拖延、引擎招聘计划取消转岗至客户端、TA组邀请转岗至TA等等漫长的变化……跟着实习群里的大家一起焦虑了整整三个多月，直到一切尘埃落定之后的十二月初，才给到了两次转岗后转正的Offer Call。真的很感谢mentor和转岗的mentor的帮助，但真的晚了。\n做出决定的背后，是纠结了整个实习期和秋招期的折磨。最终在拿到意向书也是保研确认的前一周，我得到了答案——要从我的大学说起。\n高中上得像大学，大学上得像研究生。是一句玩笑，也算得是我这些年的至少半幅写照。\n刚来到电影学院的那个学，主旋律是和其他大多数同学一样，投入到剧组中、投入到活动中——有些，是新鲜的没体验过的、也有的则是高中的“大学生活”里已经驾轻就熟的，也是来到这里过得最像“本科生”的一个学期。但也正在这一学期，我发现了自己的积累对于实际的生产应用而言不过是冰山之一角，由于对各种技术的好奇，我频繁地抱怨时间不够用，这也要学那也要学。\n随后便是不幸却又幸运的半年——疫情使得大学的第二个学期不得不在家在线上度过。之所以说幸运，是我终于获得了大量的自主学习时间，互联网上也出现了大量高质量的分享课程。于是，我继续着前一学期学不完的那些东西，补着各种数理基础，也开始了早就说过想学的图形学的学习。\n这里要特别感谢GAMES，图形学与混合现实研讨会。在疫情的开始，我大学的第二学期开始陪伴至今，我从各门优质的课程中不断地探索图形学的魅力，也正是我早早参与科研、随后又在今年参与工作的重要力量之源。\n在这一学期对知识的贪婪汲取之后，我早早来到大二的校园，恰好赶上了系里实验室恢复运作却缺乏人手的时候，也发现了自己学的东西可以“派上用场”的机会。我很快融入了实验室，并又恰好赶上了实验室追逐热点的一个新科研项目——虚拟制作。作为前期参与预研的学生，我迅速成为了这个项目的三位早期核心成员之一，另两位都是与我同年入学的研究生。这正式开启了我大学的“研究生”生涯。\n于是，大学的第二年、第三年，我都过上了日常驻扎在实验室、摄影棚，与导师和研究生同学们一起工作，时而需要“溜出来”上本科生课的“Doctor”（绰号）。在实验室度过了一个又一个周末、假日，甚至那年的一整个暑假。\n在实验室待了快两年时，我已经是实验室还算比较重要的成员。在我主要参与的那个项目里，不像是项目早期三个人的野蛮探索，逐渐形成了快十人的团队，我也从所有方向都需要了解、负责变成了专注于渲染等细分方向，并且开始做论文、文档性的总结工作。而同时，系里的其他科研项目、创作项目也陆续开始缺乏人手，我开始并行参与多个项目。记得最深刻的一天，我一天内需要解决六个不同项目的不同需求，最终还是找帮手一起才能解决。在此之外，我还同步兼顾着大三繁重的课业……\n我几乎是经历了一个完整的研究生周期——积累理论基础、进入实验室开始科研项目、逐渐找到核心负责的方向、以文字形式呈现一定的成果。还围观并从旁“指指点点”了一年又一年的研究生开题、答辩……我也可以毫不谦虚地说，我在实验室两年的贡献，完全不比工作最辛苦的研究生少。\n也许就是阅历尚浅韧性不足吧，正如开头那篇微博所说的，我开始有些不像原先那样眼神里都充满了干劲，写论文、做内容都不再像之前面对未知的开发、探索那样有干劲，尤其是几乎每天都在写文字的那些日子，这让我逐渐厌倦。\n我开始回想这些年里不断说服自己留下读书的各种说法，几乎每一个，都被打破或是冲断了：\n我一直认为需要不断地换到更好的环境才可以给自己带来足够多的成长机会，当我意识到我这三年可以将西土城校区C楼和G楼地下二层的一切了如指掌的时候，我最初开始期待的研究生生涯是搬迁怀柔校区后从头建立“新一代影视制作中心”的三年。随后，便告诉我影视技术系的搬迁还遥遥无期，甚至就连现在的实验室，也被赶到了隔壁一个没有窗户的封闭仓库。 我又觉得我的科研项目还有许多可以攻克的难题，还有许多有意思的方向，值得我继续与其作战的三年。但就像我元旦的那条微博说的，越来越发觉我们这个行业里，几人的科研团队的力量难以解决这么庞大、复杂的工业问题，越来越发现我们真的只能等待工具的更新迭代，来测试来使用。 最后，我以为一段不需要在课业、科研任务上花费过多精力和时间的时间能带给自己足够多的自主探索时间。我可以在这三年里深入研究一个实时渲染引擎的内在，尝试一个又一个渲染、模拟上的Idea，实现一个个有趣的Feature，甚至，可以像一些优秀的前辈那样自己编写自己的引擎。这是我最后一次能够说服自己继续读三年的理由——就是今年的实习、工程练习告诉我，这条路的成长，有更快的实现方式。作为一个实习期间一下班就完全放松的懒人，在学校的孤军奋战理想显得可笑又荒唐。 既然所有的说法都没再能说服自己留下，接下来的一周我便用尽了全力去面试，获得了那个在现时的我看来闪闪发光的机会。\n人一旦完成了选择，就能找到无数的理由鼓励自己，选择是正确的——不再赘列一个个的理由，在最终做出选择的那一刻，我告诉自己：“这条路，又是充满坎坷曲折，但有着更多机会更多可能性的一条路”。\n这让我回想起在淋浴间冲着水决定选择南师附中的那个晚上、逃操查成绩并决定选择电影学院的那个课间，选择后的这些年来，我真的看到了各种新的可能，也真的走上了其中的几条有趣的新路线。\n因而，我又一次选择了继续相信。\n休息了一段时间，又去很近的苏州短游了两天后。我于十月份隔离两周回到学校，因为学校的“常态化防控”，因为他家期待已久的影片未能上映，我没有再去那家动画公司做Simulation的实习。我想趁着上班前，重新作为大学生度过最后的光阴。\n同样因为“常态化防控”，及经费问题，今年的实验室也不再有那么多的科研工作，这三个月过上了学累了玩、玩累了吃，随时到DI Room看电影的“温柔乡”生活。\n唯一的小工作是重新部署了个人网站，换到了这里。因此三年前的那篇My 2019和今天这篇，都重新发在这里了。\n在被“新十条”前最后的封控被赶出实验室后，和几个好朋友，去了环球影城，又去了汕头、广州旅行了十天。\n洗净了今年的劳累，全国封控也解除了，真的要重新出发了。\n不知如何收尾：2023，希望电影好起来，希望游戏好起来，希望世界好起来；希望能在进入行业后做出好的内容，变得更强大。","title":"My 2022"},{"content":"2022年10月31日，从Hexo迁移至Hugo\n欢迎访问我的个人主页，主页内容主要为学习笔记，目前主要包含\n计算机图形学\n数理基础\n影视技术分享\n","permalink":"https://elderlyaugustus.github.io/posts/2022-10-31-%E8%BF%81%E7%A7%BB%E8%AF%B4%E6%98%8E/","summary":"2022年10月31日，从Hexo迁移至Hugo\n欢迎访问我的个人主页，主页内容主要为学习笔记，目前主要包含\n计算机图形学\n数理基础\n影视技术分享","title":"迁移说明"},{"content":"Lecture22 GPU Driven Geometry Pipeline - Nanite Research Background 传统渲染管线 CPU发起Draw Call，GPU准备State、进入漫长的Pipeline CPU、GPU不同步 存在大量的算力浪费 现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈 “曙光”: Compute Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算 Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh GPU Driven Render Pipeline 将场景完整load到显存中，完全由GPU处理：DrawPrimitive -\u0026gt; DrawScene @《刺客信条：大革命》\nMesh Cluster Rendering 将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算 不可见的Cluster不渲染；Culling流程： 尽可能裁剪掉不可见的三角形 将可见的三角形组成同一个Buffer GPU Driven Pipeline CPU端： 根据材质不同组合Instance 根据相机距离LoD 打包交给GPU做后续处理 GPU Instance Culling Instance Culling 将（64个）Cluster组成一个Chunk，再次Culling，以加速 GPU Cluster Culling Chunk -\u0026gt; Cluster -\u0026gt; Triangle 一步步裁剪，将视锥外、背面的全部裁剪 Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer 三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题 =\u0026gt; 硬件Multi-Indirect Draw Call或可解决此问题 对高精度的Mesh效率非常高 Codec Triangle Visibility in Cube : Backface Culling 每个Cluster存储每个三角形对两个方向的可见性 利用这一数据快速做Backface Culling Occlusion Culling for Camera and Shadow 利用前一帧Z-Buffer的方法： 取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer 将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处 保守估计Culling Instance -\u0026gt; Chunk -\u0026gt; Cluster -\u0026gt; Triangle 问题：高速移动物体存在一定Artifact Two-Phase Occlusion Culling 快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer 再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者 更加准确 Fast Occlusion for Shadow Shadow中生成深度时对几何细节量敏感 对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度 只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer Visibility Buffer Forward Rendering：所有互相遮挡、透明的物体需要做重复计算 Deferred Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算 G-Buffer的存储、IO开销大 复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over draw，多次绘制同一像素时开销大 Visibility Buffer： 第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID, PrimitiveID, MaterialID, …) 根据各种ID读取对应贴图，再做重心坐标插值着色 几乎没有Over Draw Cache Miss率低 Pipeline Visibility Buffer + Deferred Shading 一般来说，草丛等复杂细节情况可直接用Visibility Buffer渲染，主角等主要内容Gather到G-Buffer再渲染 注意点：MIPMAP采样时的插值平滑问题 Virtual Geometry - Nanite Overview Virtual Texture Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图 所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP 预烘焙这张“大贴图”，并做MIPMAP 根据View区域动态加载所需的部分 Idea of Nanite Virtual Geometry like Virtual Texture 挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point Cloud可以Filter） Voxel ? 数据量非常大 属性Leaking 非常不适合目前的美术工作流 Subdivision Surface ? 需要使用四边形面 Subdivision很难做Downsampling Maps-based Method ? 高度图、置换等 很难做非常细的几何细节 NVIDIA正在从硬件上做这方面的更多工作，或许还有发展的可能 Point Cloud ? 效果不好 Over Draw 材质如何绑定 Triangle ! 绘制三角形数量恰多于屏幕像素数量 1 more triangle per pixel Geometry Representation Cluster-based LoD Clusters, 128 Triangles per cluster View Dependent LoD 用远少于LoD0的Triangle数实现1 more triangle per pixel的精度 Naive Solution Cluster两两合并，减少一半三角形，得到简单的Cluster Hierarchy 根据View得到对Cluster的Cut Line，选择对应精度的Cluster Like Virtual Texturing，流式加载数据 问题：不同Cluster之间的Juction问题 锁住Cluster的边：边缘处的Triangle密度过高 面片简化利用率不高 密度不均匀，产生画面Artifact（缝合线感） Nanite Solution Cluster Group 将一定数量的Cluster组成一个Group 每个Group选择同样的LoD级别 在Group内做简化，锁住Group的边 简化后重新生成Cluster 每一级LoD，选择不同的Group边锁住 类似图片降采样时的Jiltering 构建DAG（有向无环图） 细节：QEM，保证Error计算的精确性，且Error单向向上传递 ##### Runtime LoD 直接在DAG中选择？但直接在DAG中遍历非常复杂 同属于一个Group的Cluster用同样的LoD等级 并行地做View Dependent Cut 规则： Parent View Error \u0026gt;= Child View Error LoD Cull 判定条件 Render : ParentErr \u0026gt; threshold \u0026amp;\u0026amp; ClusterErr \u0026lt;= threshold Cull : ParentErr \u0026lt;= threshold || Cluster \u0026gt; threshold 若Parent已经足够精确，则无需再Check Child ParentErr \u0026lt;= threshold 每一个Cluster Group的每一次LoD Selection是独立的，不会上一级没通过再看下一级 BVH Acceleration for LoD Selection 想法核心：把LoD0、LoD1、…每一层LoD独立组成一个BVH，最后再将所有BVH组成一个大的树 方便地取BVH的Bounding，做相机剔除后再Check，节省了非常多计算量 Hierarchical Culling 加速的Trick Rendering Software and Hardware Rasterization 硬件光栅化：光栅化单元是2*2的Quad（为了算ddx和ddy），用4*4的Tile遍历加速，剔除不参与渲染的Tile Triangle小到1个pixel的大小时 —— 上述优化均失效 软件光栅化： Compute Shader直接接管小三角形的光栅化 若三角形小于1pixel，则直接给pixel着色 直接通过三角形的UV算ddx、ddy，不用Tile计算 若三角形边长小于18pixel，则使用软件光栅化（Scanline），反之回到硬件光栅化 深度测试：存储64bit的atomic数据 —— 32bit Depth + 25bit Visible Cluster Index + 7bit Triangle Index （Visibility Buffer） 硬件光栅化 Imposter：对足够远、足够小的Instance，生成12*12个方向的的12*12大小的各种贴图（Aldobe、Normal、…） Overdraw： 没有逐像素剔除 没有硬件HiZ像素剔除 软件HZB来自上一帧 大Cluster、重叠Cluser、聚合、快速移动等带来的Overdraw … 期待硬件支持更完善，不要用软件Trick完成这些ideas Deferred Materials 早期： 将每个Material ID转换为一个Depth值，记录为一张Depth Buffer 扫描整张Buffer，判断Depth与Material ID相等时，用对应Material绘制 消耗较大 Tiled Based的思想 将全屏幕分为多个Tile，标记每个材质是否在Tile中出现 在逐材质扫描整张Buffer时，可以直接跳过没有该材质的Tile Shadow Shadow Casting的精度要求很高 Ray Trace？ Nanite几何表达无法兼容 Cascaded Shadow Map 具体略 本质：View-dependent Sampling Sample Distribution Shadow Maps 相当于将Cascaded Shadow Maps中重复的、视锥外的像素去除的Shadow Maps Shadow Map的本质：根据相机视空间的精度，采样光空间 Virtual Shadow Map - A Cached Shadow System 核心思想：将Shadow Map切成足够小的块，确保每一小块与视空间的采样率高度一直，且只更新产生光照变化的块 实际：给每个光源一张16k的VSM（点光源为6个方向的6张），仅可见像素会被Cache 相机运动、光照几何变化时，更新部分Tile即可 Streaming and Compression Streaming 流送的核心：只Load需要的数据到内存中 构建成逐个Page，动态加载 Compression 内存数据：Quantization 浮点变定点等 硬盘数据 LZ Compression 显存加载自动解压缩 ","permalink":"https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture22-nanite/","summary":"Lecture22 GPU Driven Geometry Pipeline - Nanite Research Background 传统渲染管线 CPU发起Draw Call，GPU准备State、进入漫长的Pipeline CPU、GPU不同步 存在大量的算力浪费 现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈 “曙光”: Compute Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算 Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh GPU Driven Render Pipeline 将场景完整load到显存中，完全由GPU处理：DrawPrimitive -\u0026gt; DrawScene @《刺客信条：大革命》\nMesh Cluster Rendering 将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算 不可见的Cluster不渲染；Culling流程： 尽可能裁剪掉不可见的三角形 将可见的三角形组成同一个Buffer GPU Driven Pipeline CPU端： 根据材质不同组合Instance 根据相机距离LoD 打包交给GPU做后续处理 GPU Instance Culling Instance Culling 将（64个）Cluster组成一个Chunk，再次Culling，以加速 GPU Cluster Culling Chunk -\u0026gt; Cluster -\u0026gt; Triangle 一步步裁剪，将视锥外、背面的全部裁剪 Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer 三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题 =\u0026gt; 硬件Multi-Indirect Draw Call或可解决此问题 对高精度的Mesh效率非常高 Codec Triangle Visibility in Cube : Backface Culling 每个Cluster存储每个三角形对两个方向的可见性 利用这一数据快速做Backface Culling Occlusion Culling for Camera and Shadow 利用前一帧Z-Buffer的方法： 取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer 将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处 保守估计Culling Instance -\u0026gt; Chunk -\u0026gt; Cluster -\u0026gt; Triangle 问题：高速移动物体存在一定Artifact Two-Phase Occlusion Culling 快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer 再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者 更加准确 Fast Occlusion for Shadow Shadow中生成深度时对几何细节量敏感 对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度 只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer Visibility Buffer Forward Rendering：所有互相遮挡、透明的物体需要做重复计算 Deferred Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算 G-Buffer的存储、IO开销大 复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over draw，多次绘制同一像素时开销大 Visibility Buffer： 第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID, PrimitiveID, MaterialID, …) 根据各种ID读取对应贴图，再做重心坐标插值着色 几乎没有Over Draw Cache Miss率低 Pipeline Visibility Buffer + Deferred Shading 一般来说，草丛等复杂细节情况可直接用Visibility Buffer渲染，主角等主要内容Gather到G-Buffer再渲染 注意点：MIPMAP采样时的插值平滑问题 Virtual Geometry - Nanite Overview Virtual Texture Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图 所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP 预烘焙这张“大贴图”，并做MIPMAP 根据View区域动态加载所需的部分 Idea of Nanite Virtual Geometry like Virtual Texture 挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point Cloud可以Filter） Voxel ?","title":"2022-10-23-GAMES104现代游戏引擎-Lecture22-GPU Driven Geometry Pipeline - Nanite"},{"content":"Lecture21 Dynamic Global Illumination and Lumen Part I Dynamic Global Illumination Global Illumination - 略 Reflective Shadow Maps, RSM - 略 低分辨率间接光照加速：\n计算低分辨率间接光照 对全分辨率图像的每个像素 获得周围四个低分辨率采样 通过法线和世界坐标位置判断，采样间差异过大时剔除 双线性插值 以全分辨率重新计算剔除的像素 Light Propagation Volumes, LPV - 略 Sparse Voxel Octree for Real-time Global Illumination, SVOGI 如何组织voxel的分布？\n硬件保守光栅化：对很小的三角形，保证其至少有一个voxel 八叉树存储 Shading with Cone Tracing in Voxel Tree 着色点根据BRDF发射Diffuse和Specular的Cone 根据Cone尺寸查询树结构获取光照 - 非常适合Hierarchy结构存储的光照数据 NVIDIA的工作，GPU表达非常复杂 Voxelization Based Global Illumination, VXGI 更关注相机视锥内的区域、更关注近处的区域 Clipmap，voxel版的Mipmap 利用Clipmaps存储voxel数据 重心区域使用更高分辨率voxel 更适合Cone Tracing 建构简单、读取简单、GPU Friendly… Voxel Update：空间网格位置固定，只需要更新相机周围的Voxel Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向 对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine Specular） 问题： 错误的遮挡关系，简单使用Opacity来表示 Light Leaking：遮挡物薄于Voxel时 Screen Space Global Illumination, SSGI Reuse screen space data \u0026lt;- Screen Space Reflection, SSR SSR：单根光线，构建反射 -\u0026gt; 多方向多根光线，构建GI 对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记 Reuse近邻像素 做Cone Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering 优势：快，质量高，没有遮挡问题 问题：缺少屏外信息，重用近邻像素带来的错误Visibility 独特优势： 易于处理非常近的接近阴影 准确的Hit点计算 对场景复杂度不敏感 可以处理动态物体 Part II Lumen Real-time Ray Tracing的问题：\n1/2 ray per pixel Sampling Idea：低分辨率的屏幕空间的Probe，采样简介光照\nPhase 1 : Fast Ray Trace in Any Hardware Signed Distance Function, SDF Per-Mesh SDF 对每个Mesh构建SDF，所有SDF组合成场景 对于薄于SDF分辨率的Mesh，将其加厚 Ray Tracing with SDF Cone Tracing with SDF (eg. SDF Soft Shadow) 对SDF稀疏化存储，但可能导致Raymarch迭代步长变长 对SDF做LoD SDF可导，导数为法线方向 可以根据相机远近方便地切换SDF分辨率 从Mesh SDF合成低分辨率的场景的Global SDF 场景Tracing非常快 精度相对低 在Lumen中结合对Global SDF的Tracing和对Mesh SDF的Tracing 4 Clipmaps Global SDF, 根据相机距离 Phase 2 : Radiance Injection and Caching Mesh Card 为场景中的Mesh“拍快照”，对六个面采样 对场景以AABB方式生成 对每个Card，存储其六个面的： Albedo Normal Depth Emissive … 根据物体大小、相机远近，对Card应用不同的分辨率 Surface Cache 从Mesh Card生成Surface Cache Pass 1 : Card capture Pass 2 : Copy cards to Surface Cache and compress “Freeze” lighting on Surface Cache Surface Cache上的像素是否在阴影中？ 如何处理多次Bounce？ Lighting Cache Pipeline 最终生成Surface Cache Final Lighting 计算当前帧的一次Bounce，利用前一帧的一次Bounce作为次级光源照亮场景，则相当于二次Bounce，依次累计，相当于同一场景下Bounce越积越多（Temporal思路） 1. Direct Lighting 直接累加多光源 对近处物体，直接取得精确的Instance，从Surface Cache上计算光照 对远处物体，因为Global SDF无法标记具体Instance，则对全场景光照做Voxelize表达，建构Clipmaps，对每个Voxel存储六个面的光照 2. World Space Voxel Lighting 由Final Lighting照亮计算得到的Voxel光照存储，用于下一帧的间接光照计算 与后面会提到的Light Probe区分：只存储Voxel六个面的亮度（被照亮的亮度） 3. Surface Cache Indirect Lighting Light Probe 用SH存储间接光照，方便做插值 Combine Lighting FinalLighting = (DirectLighting + InDirectLighting) * Diffuse_Lambert(Albedo) + Emissive 光照更新策略，保障性能开销稳定 固定的更新预算 桶排序更新优先级 Phase 3 : Build a lot of Probes with Different Kinds Screen Space Probe 只在Screen Space分布Probe，每16*16像素一个 Octahedron Mapping，使用8*8的Texture存储Probe 对于高频细节部分，进一步细化增加Probe，至8*8或4*4每个 判定是否需要增加Probe Probe之间很近、着色点之间实际距离较远时（深度差异过大） 取一些着色点，邻近四个Probe作着色点法平面投影，投影距离的权重超出阈值时，判定为无效采样，增加Probe Screen Probe Atlas 依次往下存储，因此不会造成过多额外开销 Importance Sampling 蒙特卡罗采样： \\[ \\lim_{N\\to\\infty}\\dfrac{1}{N}\\sum_{k=1}^{N}\\dfrac{L_i(l)f_s(l\\to v)\\cos(\\theta l)}{P_k} \\] 重要性采样即取 \\(P_k\\) 使其尽可能符合分子分布\n对光源：尽可能符合 \\(L_i\\) 分布 对BRDF：尽可能符合 \\(f_s\\) 分布 对光源做重要性采样，如何估计光源\n利用前一帧的光照数据 对前一帧邻近四个Probe的Radiance做插值 若邻近Probe被遮挡则fallback到世界空间Probe 得到插值后8*8的光照分布，作为Light PDF 对BRDF的法线分布做重要性采样\n法线分布不能用高频的着色点Normal指代 在32*32范围内取64点采样，保证深度权重的情况下，将每个Normal的SH累加得到法线分布，作为BRDF PDF Structured Importance Sampling\n每个Probe采样64根ray 将BRDF PDF与Lighting PDF卷积，得到重要的采样方向 对重要的方向做Supersampling，对不重要的方向忽略 Denoising and Spatial Probe Filtering 取Probe周围3*3，做filtering 但不同Probe的ray方向不同时，差异过大 -\u0026gt; 判断，若邻近Probe的ray着色点与当前Probe连线，与当前ray角度差大于阈值（10°）时则丢弃不用 邻近Probe的ray方向接近时，但Hit点差异过大 -\u0026gt; Clamp ray深度 World Space Radiance Cache Screen Space Probe采样较近的物体 World Space预先放置Probe，记录远处光照，Screen Space在采样远处时直接读取World Space Probe Clipmaps存储，分布分辨率48*48*48，每个Probe Atlas分辨率32*32 连接Screen Space Probe和World Space Probe的ray 取Screen Space Probe邻近8个World Space Probe，距离权重插值。 （Cube半径两倍范围内已采样，向更远处raycast时可以skip这段距离） 插值后产生与原方向的偏差，跳过遮挡物，产生漏光 球面parallax，如图修改光线，导致光线转弯，但Hack可接受 World Space Probe当且仅当有Screen Space Probe有采样需求时，才做Trace并更新光照 Phase 4 : Shading Full Pixels with Screen Space Probes 将Probe Radiance转换为三阶SH 相当于对Radiance做低通滤波，效果更柔和 SH积分更快速友好，质量也更高 最后利用SH着色 Overall, Performance and Result 核心思想：利用对不同数据结构、不同采样对象做Ray Tracing的硬件开销不一样 根据具体情况应用不同的方式 Fallback过程 ","permalink":"https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture21-lumen/","summary":"Lecture21 Dynamic Global Illumination and Lumen Part I Dynamic Global Illumination Global Illumination - 略 Reflective Shadow Maps, RSM - 略 低分辨率间接光照加速：\n计算低分辨率间接光照 对全分辨率图像的每个像素 获得周围四个低分辨率采样 通过法线和世界坐标位置判断，采样间差异过大时剔除 双线性插值 以全分辨率重新计算剔除的像素 Light Propagation Volumes, LPV - 略 Sparse Voxel Octree for Real-time Global Illumination, SVOGI 如何组织voxel的分布？\n硬件保守光栅化：对很小的三角形，保证其至少有一个voxel 八叉树存储 Shading with Cone Tracing in Voxel Tree 着色点根据BRDF发射Diffuse和Specular的Cone 根据Cone尺寸查询树结构获取光照 - 非常适合Hierarchy结构存储的光照数据 NVIDIA的工作，GPU表达非常复杂 Voxelization Based Global Illumination, VXGI 更关注相机视锥内的区域、更关注近处的区域 Clipmap，voxel版的Mipmap 利用Clipmaps存储voxel数据 重心区域使用更高分辨率voxel 更适合Cone Tracing 建构简单、读取简单、GPU Friendly… Voxel Update：空间网格位置固定，只需要更新相机周围的Voxel Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向 对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine Specular） 问题： 错误的遮挡关系，简单使用Opacity来表示 Light Leaking：遮挡物薄于Voxel时 Screen Space Global Illumination, SSGI Reuse screen space data \u0026lt;- Screen Space Reflection, SSR SSR：单根光线，构建反射 -\u0026gt; 多方向多根光线，构建GI 对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记 Reuse近邻像素 做Cone Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering 优势：快，质量高，没有遮挡问题 问题：缺少屏外信息，重用近邻像素带来的错误Visibility 独特优势： 易于处理非常近的接近阴影 准确的Hit点计算 对场景复杂度不敏感 可以处理动态物体 Part II Lumen Real-time Ray Tracing的问题：","title":"2022-10-23-GAMES104现代游戏引擎-Lecture21-Dynamic Global Illumination and Lumen"},{"content":" PS: Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记\nLecture16 Gameplay Systems - Basic Artificial Intelligence Navigation 三个步骤： Map Representation 地图表达 Walkable Area\n需要考虑：\nPhysical Collision Climbing Slope/Height Jumping Distance … 难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI Agents和Player的可行区域相同\nWaypoint Network\n路网，类似地铁线路图 寻找最近的路点 易于实现，快速寻路不够灵活，路网需要手工标注 Grid\nSquare / Triangle / Hexagon 其中Square相对易于存储 易于实现、均匀数据结构、动态可更新 精确性依赖分辨率 密集网格降低寻路性能 内存消耗大 难以处理3D地图（桥梁、隧道等） Navigation Mesh\n用简化的凸多边形表示场景 若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域 优势：\n支持3D可行区域 精确 快速寻路 灵活选择起始地、目的地 动态 缺陷：\n复杂的生成算法 不支持3D空间，例如空中飞行 Sparse Voxel Octree\n空间八叉树 存储量大 寻路复杂 Path Finding 寻找路径 所有表达，都可归为图结构\n即在图上找到一个路径，尽可能找到最优（短）路径\n深度优先搜索 / 广度优先搜索 消耗比较高，广度优先适合找到最短路径\nDijkstra Algorithm\nfor each vertex v: dist[v] = ∞ prev[v] = none dist[source] = 0 set all vertices to unexplored while destination not explored: v = least - valued unexplored vertex set v to explored for each edge(v, w): if dist[v] +len(v, w) \u0026lt; dist[w]: dist[w] = dist[v] + len(v, w) prev[w] = v A Star （A*） 一种启发式算法，不用精确的最短路径\n启发函数：预估当前点到终点的距离 \\(h(n)\\) 例如：欧拉距离 / 曼哈顿距离 \\(h(n)\\) 的精确性影响性能表现 则每一个当前点消耗为 \\(f(n)= g(n) + h(n)\\) 优先搜索 \\(f(n)\\) 最小的情况 走到终点就停止，不追求完全最短 Path Smoothing 路径平滑 Funnel Algorithm “走路时看前面” 当前点和所在三角形两端点组成一个扇形（漏斗，Funnel），下一个目标点是否在扇形中，来决定行走路线 寻找扇形两端点比较复杂 NavMesh Generation 先将整个场景体素化 Region Segmentation 寻找Edge Voxel，生成Distance Field，找到区块的中心区域（离Edge最远的） ”洪水“算法，类似Voroni算法，找到空间划分 处理Overlap问题 生成分割区域，凸多边形 可以为不同的凸多边形打上不同的标记 Polygon Flag AI寻路逻辑 AI移动速度 … Advanced Features 基于Tile的分区域NavMesh，易于更新 Off-Mesh Link建立不同Mesh之间的连接，手动，实现攀爬等动作 Steering 转向系统 寻路中，车辆无法严格执行路径（受到物理限制），需要转向系统\nSeek / Flee 追着目标点 Pursue 追踪 Path Following Wander Flow Field Following 方向场 Velocity Match 目标点速度，反向算每步加速度 Align 保证朝向一致 目标点角速度，反向算每步角加速度 Crowd Simulation 群集模拟 参考《基于物理的动画-粒子系统》\n“Boids” 三种力 Separation Cohesion Alignment 行人，沿着一定的Line运动 避障、避免碰撞 对每个个体做寻路消耗非常大 —— Distance Field Velocity-based Models 核心想法：个体相遇时，产生速度的障碍，调整速度 Reciprocal Velocity Obstacle 两个以上个体相遇时产生冲突，如何优化？ Optimal Reciprocal Collision Avoidance 结果最优，但开销大，根据需求自主选择（基于力的方式效果较差但开销小） Sensing or Perception AI所获得的信息 内部：位置、HP、子弹、Buff等 外部： 静态空间信息 Navigation Data Tactical Map 战术地图（更具有战术价值的位置） Smart Object eg.可打破的墙等 Cover Point 掩体点 … 动态空间信息 Influence Map 战场态势感知的热力图，避开危险系数高的区域 Navigation Data上更新的标记 Sight Area 视野区域 … Game Object Sensing Simulation 模仿人类的感知 考虑开销 共享Influence Map等方式 引擎侧提供充足的接口和自定义性 Classic Decision Making Algorithms Finite State Machine Behavior Tree Hierarchical Tasks Network Goal Oriented Action Planning Monte Carlo Tree Search Deep Learning Finite State Machine State Transition Condition 问题： 复杂情形下State过于多，网络过于复杂 解决方法：Hierarchical Finite State Machine 子状态之间切换变得复杂 Behavior Tree 状态机是对AI逻辑的抽象，并不符合人的知觉系统 将AI的行为Pattern从状态机的“飞线”转换为更符合人的决策树结构 Execution Node 执行节点（叶子节点）： Condition Node 条件节点 Action Node 动作节点 三种状态： Success Failure Running Control Node Sequence 依次执行 Selector 按优先级选择执行：A不行执行B，B不行执行C，有一个可执行就继续执行下去 Parallel 并行执行 Decorator 修饰器，例如增加延时等 如何Tick行为树？ 每一次从根节点开始Tick，防止动作保持在某一叶子节点 行为树同时在Running的节点不一定只有一个 Blackboard 记录环境变量，环境信息，与Gameplay交换信息的介质 缺点：Tick的消耗较大 Upcoming: AI Planning and Goals 上述提到的AI方法，均为条件-执行逻辑，AI是没有计划和目的的，期待下一课…\n","permalink":"https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture16-gameplaybasicartificialintelligence/","summary":"PS: Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记\nLecture16 Gameplay Systems - Basic Artificial Intelligence Navigation 三个步骤： Map Representation 地图表达 Walkable Area\n需要考虑：\nPhysical Collision Climbing Slope/Height Jumping Distance … 难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI Agents和Player的可行区域相同\nWaypoint Network\n路网，类似地铁线路图 寻找最近的路点 易于实现，快速寻路不够灵活，路网需要手工标注 Grid\nSquare / Triangle / Hexagon 其中Square相对易于存储 易于实现、均匀数据结构、动态可更新 精确性依赖分辨率 密集网格降低寻路性能 内存消耗大 难以处理3D地图（桥梁、隧道等） Navigation Mesh\n用简化的凸多边形表示场景 若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域 优势：\n支持3D可行区域 精确 快速寻路 灵活选择起始地、目的地 动态 缺陷：\n复杂的生成算法 不支持3D空间，例如空中飞行 Sparse Voxel Octree\n空间八叉树 存储量大 寻路复杂 Path Finding 寻找路径 所有表达，都可归为图结构\n即在图上找到一个路径，尽可能找到最优（短）路径\n深度优先搜索 / 广度优先搜索 消耗比较高，广度优先适合找到最短路径","title":"2022-10-22-GAMES104现代游戏引擎-Lecture16-Gameplay Systems - Basic Artificial Intelligence"},{"content":"Lecture15 Gameplay Complexity and Building Blocks Overview Gameplay的挑战 多个系统之间的合作 同一个游戏中Gameplay的多样性 快速迭代 Event Mechanism Hard Code写在函数中：无数的if/else、非常难以修改 Event/Message Mechanism：GO之间的“通讯协议” Publish-subscribe Pattern 发行-订阅设计模式 Event Definition 信息的定义 方法1：Event作为类设计 -\u0026gt; 不适合交给设计师修改 方法2：允许定义任意的Event 再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦 在引擎核心代码之外定义 dll注入 用脚本层语言实现 Callback Registration 响应注册 注册和调用不在同一处 –\u0026gt; 对象的生命周期和回调函数安全性问题 Strong Reference 强引用：引用关系绑定 Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多 Event Dispatching 信息分发 遍历每个GO，逐个分发调用函数 —— 效率过低 Immediate：发送消息立即调用函数 会打断前一任务，等待Callback执行后再继续 单次打断引发连锁Callback，易导致Callstack非常深，难以Debug 难以并行 Event Queue 把Event存储至队列，依次执行 Event Queue的序列化和反序列化 实现：利用反射，获取每个对象的描述结构 存储结构：Ring Buffer 不用重复申请新内存 Batching，将多个独立系统分开处理 问题： 无法保证多个系统间的执行顺序 =\u0026gt; 保留一定的Immediate处理能力 同时具备Pre、Post、Immediate处理方式 有系统延迟，削弱动作游戏打击感 =\u0026gt; 经常Hardcode绕过Delay Script System Game Logic 直接在游戏引擎代码内，使用编译语言编写 （C/C++） 每次修改Gameplay，需要重新编译游戏引擎 极难支持热更新 对设计师极不友好 脚本语言 Script System 支持快速迭代 易于学习、编写 支持热更新 沙盒运行，稳定、更少Crash 如何运行 基于虚拟机 Script Text -\u0026gt; [Compiler] -\u0026gt; Bytecode [Virtual Machine] 速度略慢 如何管理GO 强调效率：引擎内核管理，脚本触发引擎执行 编写难度大 执行过程非常复杂 直接交给脚本系统管理 脚本如何处理GO的生命周期：GC, Garbage Collection 优势：不需要手动管理对象生命周期，自动处理 问题：每次需要扫描内存，处理效率低 对于玩法相对简单的单机游戏，大多交给引擎管理； MMORPG等玩法非常复杂的游戏，大多脚本系统管理 架构 引擎调用脚本 eg. UE / Unity 脚本包引擎，引擎相当于一系列SDK库，目前应用相对少 热更新 直接修改对应位置的脚本 可能会导致Crash 需要保障鲁棒性 脚本语言的问题 弱类型语言难以编译优化 需要虚拟机运行 JIT，一边解释执行一边编译，可以优化 根据情况选择脚本语言 Lua 轻量，效率高，缺少拓展 Python 支持反射，面向对象，丰富的拓展库，虚拟机较重 C# Mono等库/.NET官方支持，将原生编译语言变成脚本语言 Visual Script eg. UE Blueprint, Unity Visual Script 对设计师和艺术家更友好 作为编程语言的要素： Variable 变量 Statement and Expression 声明和表达式 Control Flow 控制语句 Function 函数 Class 类（对于面向对象的语言） 可视化Debug 问题： 多人编辑的Merge问题 复杂度高后难以阅读 Visual Script和脚本本质同类 Script Graph -\u0026gt; Graph Compiler -\u0026gt; Bytecode -\u0026gt; Virtual Machine Character, Control and Camera Character Movement Idle, Start, Walk, Accelerate, Run, Brake, … 与环境交互 Hanging, Skating, Diving, … 与其它系统互动 基于物理的运动 Movement State Machine 状态机 Skills … Control 不同的输入设备，输入设备 -\u0026gt; 游戏逻辑 Zoom in and out Aim Assist 吸附操作等（尤其主机游戏） Feedback 力反馈、声音反馈、光效反馈、… Context Awareness 不同的游戏片段，输入响应不同 Chord \u0026amp; Key Sequences 按键触发、多个按键序列触发 Camera 基础：POV和FOV Point of View, Field of View 相机绑定 Spring Arm Camera Track Camera Effect Camera Manager 多相机管理，视角切换等 eg.枪械瞄准、赛车 Subjective Feelings 强调主观感受 引擎针对3C系统要公开足够多的接口到 Script / Visual Script 提供给设计师、艺术家\n","permalink":"https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture15-gameplaycomplexityandbuildingblocks/","summary":"Lecture15 Gameplay Complexity and Building Blocks Overview Gameplay的挑战 多个系统之间的合作 同一个游戏中Gameplay的多样性 快速迭代 Event Mechanism Hard Code写在函数中：无数的if/else、非常难以修改 Event/Message Mechanism：GO之间的“通讯协议” Publish-subscribe Pattern 发行-订阅设计模式 Event Definition 信息的定义 方法1：Event作为类设计 -\u0026gt; 不适合交给设计师修改 方法2：允许定义任意的Event 再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦 在引擎核心代码之外定义 dll注入 用脚本层语言实现 Callback Registration 响应注册 注册和调用不在同一处 –\u0026gt; 对象的生命周期和回调函数安全性问题 Strong Reference 强引用：引用关系绑定 Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多 Event Dispatching 信息分发 遍历每个GO，逐个分发调用函数 —— 效率过低 Immediate：发送消息立即调用函数 会打断前一任务，等待Callback执行后再继续 单次打断引发连锁Callback，易导致Callstack非常深，难以Debug 难以并行 Event Queue 把Event存储至队列，依次执行 Event Queue的序列化和反序列化 实现：利用反射，获取每个对象的描述结构 存储结构：Ring Buffer 不用重复申请新内存 Batching，将多个独立系统分开处理 问题： 无法保证多个系统间的执行顺序 =\u0026gt; 保留一定的Immediate处理能力 同时具备Pre、Post、Immediate处理方式 有系统延迟，削弱动作游戏打击感 =\u0026gt; 经常Hardcode绕过Delay Script System Game Logic 直接在游戏引擎代码内，使用编译语言编写 （C/C++） 每次修改Gameplay，需要重新编译游戏引擎 极难支持热更新 对设计师极不友好 脚本语言 Script System 支持快速迭代 易于学习、编写 支持热更新 沙盒运行，稳定、更少Crash 如何运行 基于虚拟机 Script Text -\u0026gt; [Compiler] -\u0026gt; Bytecode [Virtual Machine] 速度略慢 如何管理GO 强调效率：引擎内核管理，脚本触发引擎执行 编写难度大 执行过程非常复杂 直接交给脚本系统管理 脚本如何处理GO的生命周期：GC, Garbage Collection 优势：不需要手动管理对象生命周期，自动处理 问题：每次需要扫描内存，处理效率低 对于玩法相对简单的单机游戏，大多交给引擎管理； MMORPG等玩法非常复杂的游戏，大多脚本系统管理 架构 引擎调用脚本 eg.","title":"2022-10-22-GAMES104现代游戏引擎-Lecture15-Gameplay Complexity and Building Blocks"},{"content":"Lecture14 Tool Chains Applications \u0026amp; Advanced Topic Architecture of A World Editor A hub for everything to build the world\nEditor Viewport 运行一个完整游戏，“Editor Mode” 代码存在Editor Only -\u0026gt; 避免编译到最终游戏中 Everything is an Editable Object Objects Views Tree View Layer View Categories and groups 通过Schema系统编辑Object参数，参数编辑面板 Content Browser Editing Utilities in World Editor 鼠标选取\nRay casting 不需要缓存，支持同时选取多个物体 遍历性能差 RTT 在G-Buffer中存储Object ID 根据点击像素直接对应Object ID 其他Trick来选取无Mesh的Object Object Transform Editing\nTerrain\nHeightmap Texture 植被、水体等 Brush Height Brush 笔刷边缘的过渡、笔刷的可拓展性 Instance Brush eg.刷植被 Environment\nSky Light Roads Rivers … Rule System in Environment\neg. 路上不能有植被 保证局部修改而不是全部重新生成 Plugin Architecture 系统和对象的功能“矩阵” 插件既需要在横向上拓展对象，也需要在纵向上拓展系统 插件的Combination Covered：覆盖原有逻辑 eg.地形编辑系统 Distributed：分布式，最终混合输出 eg.大部分编辑系统 Pipeline：串联，前者输出作为后者输入 eg.资产预处理、物理几何体 Onion rings：洋葱圈，如图 eg.地形插件的道路编辑插件 版本控制 理想情况：版本更新 with 插件版本更新 插件使用SDK的方式不确定，保持SDK相同的输入输出并不一定代表稳定迭代更新 Design Narrative Tools 设计叙事工具 eg. Sequencer in UE Track Property Track Timeline Key Frame Sequence Reflection and Gameplay 反射 反射是Sequencer的基础，修改参数怎样应用到Runtime的对象上。Schema架构，反射系统执行 Visual Scripting System eg.UE蓝图 —— 核心解决问题：底层代码的可扩展性 eg. 底层增加一个新的Function，表层也需要跟着增加相应的调用，非常麻烦（可以通过继承减少一部分工作） 利用反射解决 反射：构建代码和工具之间的桥梁 使用反射生成代码元数据map，包括class_name、func_name 生成accessor（gettor、setter、invoker、…） C++如何实现反射 生成Schema GPL编译规范 从AST（Abstract Syntax Tree）可以很方便得到类型信息，生成Schema大量开源的编译器可以生成AST eg. gcc clang Piccolo clang生成AST，得到Schema数据结构 利用宏定义精确控制反射范围（不是所有变量、函数都需要被反射） clang可以定义__attribute__，控制编译器行为 生成Accessor get / set / invoke 代码渲染 自动化生成代码 节约人力 很难出错 数据和逻辑分离 Piccolo 利用Mustache生成代码 Collaborative Editing 协同编辑 核心问题：多人协作发生冲突 文件区分方式 分层方 按照资产分成多层，各自编辑单独层，最后Merge 分层难以完全分离，层之间经常存在相互关联 分块 将世界分成多块，各自单独编辑，最后Merge 难以解决块之间的连接 单独有Artist处理边界 OFPA, One File Per Actor @UE5 每个对象都有独立的文件 很好地解决冲突 但最终文件提交量非常大 cooking时打包小文件开销大 基于网络同时编辑，互相可见 问题 需要处理网络架构 操作之间相互同步，要将操作原子化 怎么解决Undo\u0026amp;Redo 方案 使用“锁定”机制固定部分资产不可修改 OT, Operation Transform CRDT, Conflict-free Replicated Data Type 现在大部分网络方案：客户端提交，由服务器决策分发 Client Crash： Nothing Server Crash： Boom ","permalink":"https://elderlyaugustus.github.io/posts/2022-07-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture14-applicationsadvancedtopic/","summary":"Lecture14 Tool Chains Applications \u0026amp; Advanced Topic Architecture of A World Editor A hub for everything to build the world\nEditor Viewport 运行一个完整游戏，“Editor Mode” 代码存在Editor Only -\u0026gt; 避免编译到最终游戏中 Everything is an Editable Object Objects Views Tree View Layer View Categories and groups 通过Schema系统编辑Object参数，参数编辑面板 Content Browser Editing Utilities in World Editor 鼠标选取\nRay casting 不需要缓存，支持同时选取多个物体 遍历性能差 RTT 在G-Buffer中存储Object ID 根据点击像素直接对应Object ID 其他Trick来选取无Mesh的Object Object Transform Editing\nTerrain\nHeightmap Texture 植被、水体等 Brush Height Brush 笔刷边缘的过渡、笔刷的可拓展性 Instance Brush eg.","title":"2022-07-03-GAMES104现代游戏引擎-Lecture14-Tool Chains Applications \u0026 Advanced Topic"},{"content":"Lecture13 Tool Chains 游戏引擎工具链的地位：\n用户和引擎Runtime层的桥梁 引擎和DCC软件的桥梁：Asset Conditioning Pipeline 调和不同思维方式的平台：策划 / 美术 / 程序 GUI Immediate Mode 逐帧直接绘制，由引擎逻辑绘制，简单轻量直接 扩展性有限，性能有限，将业务压力交给了引擎逻辑 eg. Unity UGUI / Omniverse GUI / Piccolo GUI Retained Mode 将需要绘制的图形内容存储成Buffer，再交由GUI绘制 将引擎逻辑和GUI工具隔离，扩展性强，性能表现好 对开发者来说相对复杂 eg. Unreal UMG / WPF GUI / QT GUI Design Pattern MVC MVP：在MVC基础上的变化，View进一步与Model分离 MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View 平台兼容性问题，eg. 在Windows下WPF表现较好 数据处理 Serialization and Deserialization 序列化与反序列化：文件、数据库、内存、网络之间的数据转换\n存储数据 - Serialization 文件格式 最简单的数据格式：文本文件 易读易处理，但缺乏安全性 纯文本信息 eg. txt/obj/… -\u0026gt; 结构化 eg. XML/… -\u0026gt; 更简单的结构 eg. json/… eg. Unity YAML / Piccolo json / Cryengine XML json 二进制文件 体积小，读取时无需语义处理，加载速度快 Asset Reference 大量重用的资产 -\u0026gt; 多个Instance引用同一个Asset Object Instance Variance：为Asset提供各种可变性，例如更换贴图 低效方法：copy一份直接修改 Data Inheritance，数据继承，override修改部分 加载数据 - Deserialization Parse Asset File 语义解析，生成 \u0026lt;field-value\u0026gt; tree 文本格式需要较为复杂的parse得到树 二进制文件则一般直接按树的顺序，field name + field data 存成表格 二进制文件需要考虑 Endianness，大端小端序 引擎本身保持同一字节序 根据不同平台判断提前处理 Asset Version Compatibility eg. 增删field 强制判断version number，将缺失field设为默认值 Protocol buffer：要求在增删field时标记UID，UID按新增顺序增加 如何增强工具链鲁棒性 Undo \u0026amp; Redo Command Pattern 原子化操作，存储用户command，Undo/Redo时重新加载command Command类设计 UID（及get/set） Data（及get/set） Invoke() Revoke() Serialize() Deserialize() 三类Command 增加对象 数据：通常使用runtime instance的拷贝 Invoke：根据数据创建runtime instance Revoke：删除runtime instance 删除对象 数据：通常使用runtime instance的拷贝 Invoke：删除runtime instance Revoke：根据数据创建runtime instance 更新对象 数据：通常使用对runtime instance的修改属性的属性名和新值旧值 Invoke：设置runtime instance的属性为新值 Revoke：设置runtime instance的属性为旧值 如何形成工具链 Building Blocks —— 从不同数据中找出共性，原子化 Schema —— 一种描述结构，描述Building Blocks的组合 用Schema构建各种高级数据 Schema需要支持继承 两种Schema的定义方式 用独立的Schema定义文件 解耦性好，易于理解 需要用parser创建代码，难以debug 在代码中直接定义 引擎数据的三种视角 Runtime内存：强调性能 硬盘：强调节约空间 用户视角/工具视角：强调易于理解 What you sees is what you get “所见即所得” 创作视图和运行时一致 Stand-alone Tools 工具层和runtime层分开，难以实现所见即所得 In Game Tools 工具层直接架在runtime层之上，直接使用runtime层运行创作窗口 Play in Editor, PIE 直接在Editor World内运行 简单 会污染runtime层模式 编译成游戏Release版本时可能会出bug 拷贝所有数据运行单独的PIE World 复杂度高，内存开销大 可以较好地保证编译结果一致 eg. Unreal Engine Plugin 提供大量的API 尽可能把各种功能API化，自己实现引擎工具链时也使用API实现 ","permalink":"https://elderlyaugustus.github.io/posts/2022-06-26-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture13-toolchain/","summary":"Lecture13 Tool Chains 游戏引擎工具链的地位：\n用户和引擎Runtime层的桥梁 引擎和DCC软件的桥梁：Asset Conditioning Pipeline 调和不同思维方式的平台：策划 / 美术 / 程序 GUI Immediate Mode 逐帧直接绘制，由引擎逻辑绘制，简单轻量直接 扩展性有限，性能有限，将业务压力交给了引擎逻辑 eg. Unity UGUI / Omniverse GUI / Piccolo GUI Retained Mode 将需要绘制的图形内容存储成Buffer，再交由GUI绘制 将引擎逻辑和GUI工具隔离，扩展性强，性能表现好 对开发者来说相对复杂 eg. Unreal UMG / WPF GUI / QT GUI Design Pattern MVC MVP：在MVC基础上的变化，View进一步与Model分离 MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View 平台兼容性问题，eg. 在Windows下WPF表现较好 数据处理 Serialization and Deserialization 序列化与反序列化：文件、数据库、内存、网络之间的数据转换\n存储数据 - Serialization 文件格式 最简单的数据格式：文本文件 易读易处理，但缺乏安全性 纯文本信息 eg. txt/obj/… -\u0026gt; 结构化 eg. XML/… -\u0026gt; 更简单的结构 eg. json/… eg.","title":"2022-06-26-GAMES104现代游戏引擎-Lecture13-Tool Chains"},{"content":"Lecture12 Effects Particle 一个粒子 @PBA 粒子形态 Billboard Particle 永远朝向相机的面片 Mesh Particle eg. 碎石 Ribbon Particle 光带 eg. 刀的尾迹 样条插值，一般用Catmull 粒子渲染 透明混合顺序 全局排序 精确但开销大 层级结构 系统 -\u0026gt; Emitter -\u0026gt; Within emitter 分辨率，性能开销爆炸 Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合 GPU粒子 定义Particle Pool\n管理Dead list和Alive list\n在Compute Shader上计算\nVisualization Culling，管理Alive list\nDepth Buffer\nSorting\nGPU并行Merge sort\n双指针合并排序，读写会跳来跳去 优化：单指针遍历待写位置，找该写入的数值写入 Depth Buffer Collision 利用Depth Buffer做碰撞\nAdvanced Particle Animated Particle Mesh 动画可以编码成Texture：Particle Animation Texture 状态机可以通过切换贴图实现 Navigation Texture 从SDF计算Direction Texture（RG通道贴图） 实现群集运动的运动方向 eg. Mesh变成粒子再编程Mesh Skeleton mesh emitter Dynamic procedural splines Reactions to other players … 群集模拟 游戏中的粒子系统工具 早期：设定emitter参数，增加各种效果 现代：节点式，更复杂的处理 eg. Niagara Sound System 声音基础知识（略） Panning Attenuation 衰减 Attenuation Shape 在区域内不衰减 溪流沿岸 圆柱体 空间内 长方体 喇叭 锥体 Obstruction and Occlusion Raycast Reverb 混响 分类 Direct (Dry) 干音 Early reflection (Echo) 回音 Late reverberations (Tail) 尾音 回音 + 尾音 == Wet 湿音 Absorption Pre-delay (seconds) HF ratio Dry level Wet level The Dopppler Effect 多普勒效应 Spatialization - Soundfield 引擎中间件 eg. Wwise 建模整个声音世界 ","permalink":"https://elderlyaugustus.github.io/posts/2022-06-18-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture12-effects/","summary":"Lecture12 Effects Particle 一个粒子 @PBA 粒子形态 Billboard Particle 永远朝向相机的面片 Mesh Particle eg. 碎石 Ribbon Particle 光带 eg. 刀的尾迹 样条插值，一般用Catmull 粒子渲染 透明混合顺序 全局排序 精确但开销大 层级结构 系统 -\u0026gt; Emitter -\u0026gt; Within emitter 分辨率，性能开销爆炸 Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合 GPU粒子 定义Particle Pool\n管理Dead list和Alive list\n在Compute Shader上计算\nVisualization Culling，管理Alive list\nDepth Buffer\nSorting\nGPU并行Merge sort\n双指针合并排序，读写会跳来跳去 优化：单指针遍历待写位置，找该写入的数值写入 Depth Buffer Collision 利用Depth Buffer做碰撞\nAdvanced Particle Animated Particle Mesh 动画可以编码成Texture：Particle Animation Texture 状态机可以通过切换贴图实现 Navigation Texture 从SDF计算Direction Texture（RG通道贴图） 实现群集运动的运动方向 eg.","title":"2022-06-18-GAMES104现代游戏引擎-Lecture12-Effects"},{"content":"Lecture11 Physics System - Applications Character Controller 一个反物理的系统：符合玩家感知 + 实现反物理运动 没有Character Controller时，大量Hack Kinematic Actor 不受物理规律控制 Push其他Actor Shape （人类角色时） Capsule 主要使用，一般设计两层 内层：碰撞 外层：防止角色与物体（墙面）太近 高速移动时容易卡进墙体 相机穿透导致看到墙后物体 Box Convex Collide with environment Sweep Test 判断 Sliding：撞到墙上时左右滑动 Auto Stepping：台阶 每帧尝试抬升高度前进 Slope 斜坡 坡度大于多少时，冲上去会滑下来 改变Controller形状/体积 eg.蹲下站起的变化 限制在环境大小不够时不可站起（eg.在隧道中） 更新前重叠测试，阻止形状更新 Push Objects (Dynamic Actors) Controller站在运动平台上时 不作处理就会平台动、Controller在原地 Ray Cast检测所站物体上，绑定，运动时也相对于平台 进一步精细：平台运动过快时的趔趄等 Ragdoll 不适用Ragdoll：播放死亡动画 =\u0026gt; 死亡环境并不一定与动画一致 eg. 在悬崖边，悬空挂在坡面上甚至插入地形 用Rigid Body将关键的Joint连结起来 考虑Constraints 将Ragdoll中较少Joints的运动映射到Skeleton Animation Retargeting 三种Joints Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据 Leaf Joints：一般不动，例如手掌脚掌 Intermediate Joints：Active Joints之间的Joints，利用邻近Active Joints插值 死亡动画到Ragdoll的过渡 一个问题：游戏中动画与物理的边界在哪里？ Powered Ragdoll - Physics-Animation Blending 纯Ragdoll：效果不像人类 纯动画：循环播放，有模式感 两种混合 Cloth 传统：Bake动画，随着运动方向更换动画，移动端常用\n动力学骨骼模拟：精度较低\nMesh-based Cloth Simulation ##### Mesh-based Cloth Simulation\nPhysical Mesh远低于Render Mesh，模拟完再用重心坐标插值到Render Mesh\nConstraints：\n划定布料每个顶点的运动范围 一般离人体越近，运动范围越小 eg.披风脖子处运动幅度小 解决衣料穿模问题 布料物理材质（丝绸/棉布等）\nCloth Solver - Mass Spring System 质点弹簧系统\nSpring force 胡克力 \\[ \\vec F^S=k_{\\rm spring}\\Delta\\vec x \\]\nSpring damping force （damping 衰减，空气阻力所致/提高迭代稳定性） \\[ \\vec F^d=-k_{\\rm damping}\\vec v \\]\n横向、纵向、斜向、跨越质点加弹簧，提高精度 受力\n重力 风力 空气阻力 周围弹簧弹力（胡克力 + damping） \\[ \\vec F_{\\rm net}^{\\rm vertex}=M\\vec g+\\vec F_{\\rm wind}(t)+\\vec F_{\\rm air\\ resistance}(t)+\\sum_{\\rm springs\\in v}(k_{\\rm spring}\\Delta \\vec x(t)-k_{\\rm damping}\\vec v(t))=M\\vec a(t) \\] Verlet数值积分 \\[ \\vec x(t+\\Delta t)=2\\vec x(t)-\\vec x(t-\\Delta t)+\\vec a(t)(\\Delta t)^2 \\]\n半隐式欧拉积分 \\[ \\vec v(t+\\Delta t)=\\vec v(t)+\\vec a(t)\\Delta t \\\\ \\vec x(t+\\Delta t)=\\vec x(t)+\\vec v(t+\\Delta t)\\Delta t \\] Observation \\[ \\left\\{\\begin{array}{l}\\vec v(t+\\Delta t)=\\vec v(t)+\\vec a(t)\\Delta t \\\\ \\vec x(t+\\Delta t)=\\vec x(t)+\\vec v(t+\\Delta t)\\Delta t\\\\ \\vec x(t)=\\vec x(t-\\Delta t)+\\vec v(t)\\Delta t \\end{array}\\right.\\ \\Rightarrow\\ \\left\\{\\begin{array}{l} \\vec x(t+\\Delta t)=\\vec x(t)+(\\vec v(t)+\\vec a(t)\\Delta t)\\Delta t\\\\ \\vec x(t)=\\vec x(t-\\Delta t)+\\vec v(t)\\Delta t \\end{array}\\right. \\] 得到 \\[ \\vec x(t+\\Delta t)=2\\vec x(t)-\\vec x(t-\\Delta t)+\\vec a(t)(\\Delta t)^2 \\] 与半隐式欧拉积分数学等价，但实现上因为排除了不稳定的速度因素，更加稳定 Cloth Solver - Position Based Dynamics 区别 传统Simulation：Constrains =\u0026gt; Force =\u0026gt; Velocity =\u0026gt; Position PBD：Constrains ==\u0026gt; Position 用约束描述物理属性 Solver更稳定 后面会再进一步解释 Self Collision 包括布料与布料、布料与刚体的碰撞，精度较低时极易发生\n暴力方法：加厚布料（渲染时），发生自穿插时不会渲染出来 提高迭代精度，减小迭代Step Maximal velocity 这样每次穿插不会过深，可以在下次迭代时弹回 增加一个负向力场，负向SDF实现 Destruction Chunk Hierarchy，组织未破碎物体的碎片\nConnectivity Graph，生成连接关系，每个Edge有Connectivity Value\nDamage Calculation，受力超过Connectivity Value则破坏连接\nImpact Point向外扩散 \\[ D_d=\\left\\{\\begin{aligned} \u0026amp;D \u0026amp;\u0026amp;d\\le R_\\min\\\\ \u0026amp;D\\cdot\\left(\\dfrac{R_\\max-d}{R_\\max-R_\\min}\\right)^K \u0026amp;\u0026amp;R_\\min\u0026lt;d\u0026lt;R_\\max\\\\ \u0026amp;0 \u0026amp;\u0026amp;d\\ge R_\\max\\quad \\end{aligned}\\right. \\] Pin住某些与世界的连接\nVoronoi生成Chunk\n@PBA 随机取点，等距垂平面 断面纹理生成 实时的3D Texture生成 离线生成，runtime切换 Chunk的分布 =\u0026gt; 取点的分布 Pipeline 增加其他真实感效果\n音效 粒子 Navigation更新 谨慎使用，增加了大量Mesh，对算力要求很高\nVehicle A rigidbody actor 驱动力 Traction Force 扭矩 Torque \\(T=T_{\\rm engine}X_gX_dn\\) 驱动力 Traction \\(\\vec F_{\\rm Traction}=\\dfrac{T}{R_w}\\vec u\\) 悬挂力 Suspension Force \\[ |\\vec F_{\\rm suspension}|=k(L_{\\rm rest}-(L_{ \\rm hit}-R_W)) \\] 轮胎力 Tire Forces\n径向力 Longitudinal force \\(F_{\\rm long}=F_{\\rm traction}+F_{\\rm drag}+F_{rr}\\) 切向力 Lateral force \\(F_{\\rm lateral}=C_c*a\\) 重心 Center of Mass \\[ M=M_1+M_2\\quad \\vec x_{cm}=\\dfrac{M_1\\vec x_1+M_2\\vec x_2}{M} \\] 重心太靠前在飞跃时容易栽，重心准确则稳定 重心靠前转向力不足，靠后转向力过大 变速时重心会有偏移 Weight Transfer 加速时车身后仰重心靠后，刹车时车身前倾重心靠前 转向角\n转向时，若内外侧轮转向角相同，则外侧轮打滑空转\n转向时，外侧轮转向角要大于内侧轮\n根据旋转中心计算 \\[ \\alpha_l=\\tan^{-1}\\dfrac{L_{wb}}{R_t+\\frac{L_r}{2}}\\\\ \\alpha_r=\\tan^{-1}\\dfrac{L_{wb}}{R_t-\\frac{L_r}{2}} \\] 轮胎接触 单方向垂直向下的 Single Raycast 效果不真实，易发生穿插 球面 Spherecast 实现真实的接触 Advanced Physics : PBD / XPBD 拉格朗日力学：用约束描述所有运动，把力学计算改变为求解约束问题 eg. 匀速圆周运动 位置约束 \\(C(\\mathbf x)=\\|\\mathbf x\\|-r=0\\) 速度约束 \\(\\dfrac{\\mathrm d}{\\mathrm dt}C(\\mathbf x)=\\dfrac{\\mathrm dC}{\\mathrm d\\mathbf x}\\cdot \\dfrac{d\\mathbf x}{\\mathrm dt}=\\mathbf J\\cdot\\mathbf v=0\\) \\(\\mathbf J\\) Jacobian \\(\\mathbf J^T\\) 与 \\(\\mathbf v\\) 垂直 \\(\\mathbf J^T\\cdot\\mathbf v=0\\) 把速度转换成速度约束 弹簧质点等系统也都可用约束表示 eg. 弹簧质点系统拉伸时：\\(C_{\\rm stretch}(\\mathbf x_1, \\mathbf x_2)=\\|\\mathbf x_1-\\mathbf x_2\\|-d\\) PBD, Position Based Dynamics 约束投影 求解约束的方法：迭代法 Jacobi矩阵指向正确的方向，反复迭代直到满足约束（接近） 收敛相对稳定 布料应用广泛 NVIDIA Flex XPBD, Extended Position Based Dynamics 在PBD基础上引入stiffness量，表示硬约束还是软约束\n硬约束：stiffness非常大，易爆炸\n软约束：stiffness较小，布料等软体\n\\[ U(\\mathbf x)=\\dfrac{1}{2}\\mathbf C(\\mathbf x)^T\\alpha^{-1}\\mathbf C(\\mathbf x)\\quad \\alpha:\\text{stiffness} \\]\n将约束转换为服从性矩阵 Compliance Matrix\nUnreal Engine Chaos\n","permalink":"https://elderlyaugustus.github.io/posts/2022-06-04-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture11-physicssystemapplications/","summary":"Lecture11 Physics System - Applications Character Controller 一个反物理的系统：符合玩家感知 + 实现反物理运动 没有Character Controller时，大量Hack Kinematic Actor 不受物理规律控制 Push其他Actor Shape （人类角色时） Capsule 主要使用，一般设计两层 内层：碰撞 外层：防止角色与物体（墙面）太近 高速移动时容易卡进墙体 相机穿透导致看到墙后物体 Box Convex Collide with environment Sweep Test 判断 Sliding：撞到墙上时左右滑动 Auto Stepping：台阶 每帧尝试抬升高度前进 Slope 斜坡 坡度大于多少时，冲上去会滑下来 改变Controller形状/体积 eg.蹲下站起的变化 限制在环境大小不够时不可站起（eg.在隧道中） 更新前重叠测试，阻止形状更新 Push Objects (Dynamic Actors) Controller站在运动平台上时 不作处理就会平台动、Controller在原地 Ray Cast检测所站物体上，绑定，运动时也相对于平台 进一步精细：平台运动过快时的趔趄等 Ragdoll 不适用Ragdoll：播放死亡动画 =\u0026gt; 死亡环境并不一定与动画一致 eg. 在悬崖边，悬空挂在坡面上甚至插入地形 用Rigid Body将关键的Joint连结起来 考虑Constraints 将Ragdoll中较少Joints的运动映射到Skeleton Animation Retargeting 三种Joints Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据 Leaf Joints：一般不动，例如手掌脚掌 Intermediate Joints：Active Joints之间的Joints，利用邻近Active Joints插值 死亡动画到Ragdoll的过渡 一个问题：游戏中动画与物理的边界在哪里？ Powered Ragdoll - Physics-Animation Blending 纯Ragdoll：效果不像人类 纯动画：循环播放，有模式感 两种混合 Cloth 传统：Bake动画，随着运动方向更换动画，移动端常用","title":"2022-06-04-GAMES104现代游戏引擎-Lecture11-Physics System - Applications"},{"content":"Lecture10 Physics System - Basic Concepts 物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 + 环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料\nPhysics Actors and Shapes Actor Static Actor 静态固定的，不受物理影响 Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动 Trigger 根据碰撞触发Message从而产生Event Kinematic 反物理的自发运动（游戏设计师设计的运动） \u0026gt; Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉” Shape : 复杂形状物理计算过于复杂 Sphere Capsule 胶囊体 Box Convex Mesh 凸多面体 Trangle Mesh （一般只用于静态） Height Field ！尽量使用简单的Shape（从前到后越来越复杂）\nShape Properties Mass / Density 质量 / 密度 Center of Mass 质心 Friction / Restitution 摩擦力 / 弹力 (and more …) Forces Force eg. Gravity / Drag / Friction / … Impulse 冲量 eg. simulating an explosion Movements （略，@GAMES201/103）\nRigid Body Dynamics （略，@GAMES103）\nCollision Detection Two phase Broad Phase 方法\nSpace partitioning：利用BVH查询，非常适合动态更新，但没有↓方法快 Sort and Sweep 对所有Actor的AABB按pmin或pmax的x轴、y轴排序，查询重叠 排序后动态更新，局部调整计算量也很低 Narrow Phase 方法\nBasic Shape Intersection Test\nSphere-Sphere 极易求 Sphere-Capsule 把Capsule拆成两端球和圆柱 Capsule-Capsule 同上 Minkowski Difference-based Methods\nA形状中无穷多点坐标 + B形状中无穷多点坐标 = Minkowski Sum \\[ A\\oplus B=\\{\\vec a+\\vec b:\\vec a\\in A,\\vec b\\in B\\} \\]\nA形状中无穷多点坐标 - B形状中无穷多点坐标 = Minkowski Difference （将B关于原点对称得到-B，再求Minkowski Sum） \\[ A\\ominus B=\\{\\vec a-\\vec b:\\vec a\\in A,\\vec b\\in B\\}\\\\ A\\ominus B=A \\oplus(-B) \\]\n观察：若AB有交点，则其Minkowski Difference一定过原点 GJK Algorithm\n分别取AB中Y轴方向最大最小的点，作差得到新的点C必为Minkowski Difference上一顶点，判断O是否在C上，若否则下一步 连接点C和原点O，以OC方向取AB中最大最小的点，作差得到点D，判断O是否在CD上，若否则下一步 再作O到CD的垂线，以垂线方向取AB中最大最小的点，作差得到点E，判断O是否在CDE内，若否则下一步 Next Next … Separating Axis Theorem, SAT\n定理：对两个分离的几何体，一定能找到分离轴将两者完全分开 =\u0026gt; 2D情况下，对凸多边形而言，其中一个几何体的一条边可作为分离轴 2D情形：分别遍历AB的每条边，判断另一图形是否相交。若有任一分离轴，则两者不相交；否则相交 3D情形：遍历AB的每个面，遍历AB的任两条边的叉积构成的平面 Collision Resolution Penalty Force （略，@PBA） Constraints （略，@PBA） Scene Query Raycast Multiple hits 返回所有交点 Closet hit 返回最近的交点 Any hit 返回交点，不需要排序 Sweep 用几何体扫描 Overlap 重叠 Collision Group\n对Actor分组 Pawn / Static / Dynamic / Trigger 作判断时忽略无关的Actor Efficiency, Accuracy, and Determinism Simulation Optimization Island 把一个个需要模拟的单元分离 Sleeping Island在不施加力的时候可以Sleep Continuous Collision Detection, CCD 部分Actor需开启CCD 移动速度过快时，下一时间步直接穿过碰撞物碰撞检测失效，Tunneling隧穿 Solution： 加厚碰撞物 CCD 一种方法：Time-of-Impact, TOI 评估两步之间的“安全时间” 以“安全时间步”迭代 重复直到距离在碰撞物厚度之内 Deterministic Simulation 确定性模拟 多人在线游戏中，各方须表现一致 same old states + same inputs = same new states 时间步、算法顺序、浮点数精度等等须保持一致 目前很难解决，大部分在线游戏中不用物理做游戏逻辑，而只做表现效果 ","permalink":"https://elderlyaugustus.github.io/posts/2022-05-25-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture10-physicssystemconcepts/","summary":"Lecture10 Physics System - Basic Concepts 物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 + 环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料\nPhysics Actors and Shapes Actor Static Actor 静态固定的，不受物理影响 Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动 Trigger 根据碰撞触发Message从而产生Event Kinematic 反物理的自发运动（游戏设计师设计的运动） \u0026gt; Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉” Shape : 复杂形状物理计算过于复杂 Sphere Capsule 胶囊体 Box Convex Mesh 凸多面体 Trangle Mesh （一般只用于静态） Height Field ！尽量使用简单的Shape（从前到后越来越复杂）\nShape Properties Mass / Density 质量 / 密度 Center of Mass 质心 Friction / Restitution 摩擦力 / 弹力 (and more …) Forces Force eg.","title":"2022-05-25-GAMES104现代游戏引擎-Lecture10-Physics System - Basic Concepts"},{"content":"Lecture09 Animation System - Advanced Animation Blending LERP LERP / NLERP / SLERP 两个动画clip之间的LERP 权重 eg. 走路与跑步动画，依据运动速度切换 \\[ {\\rm weight_1=\\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\\\ {\\rm weight_2=\\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\\\ \\]\n对齐时间线 eg.走路和跑步的步频不同，怎样对齐混合的帧 每一段动画为一步，对每一段动画时间线做归一化 Blend Space eg. 左右前后走/跑\n1D Blend Space： eg. 左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）\n2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置 双线性插值 Delaunay Triangulation 常用 根据设置的动画点，生成三角形划分 在空间内一点，由周围三角形插值 插值利用重心坐标 Skeleton Masked Blending 针对只应用于半身或身体局部的动画，实现多种动画的混合 eg.各种姿态下的鼓掌\n绘制一个Mask，只应用于部分Joints Additive Blending eg. 向着摄影机点头\n存储动画的变化量，在基础动画上叠加一层动画 需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果 Animation State Machine 状态机 两种核心元素 Node Clip Blend Space 脚本串接的单套动画系统 Translation 激活条件 Cross Fade Smooth transition 慢慢过渡，插值（各种插值曲线） Frozen transition 先停住动画A，再播放动画B 多层状态机 Animation Blend Tree 多层状态机在复杂动画中非常复杂 用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树 两种节点 Terminal Node 执行节点 (叶节点) Clip Blend Space ASM Non-terminal Node （非叶节点） LERP Blend Node Additive Blend Node Layered ASM to Blend Tree Blend Tree Control Parameters Variable 暴露变量，根据变量切换运动状态 eg. 速度、HP Event 外部传入激活状态的指令 eg. 持枪、开枪 Inverse Kinematics Forward Kinematics 前向传递动画 Inverse Kinematics 对末端Joint Key动画 eg. 崎岖地面走路，脚步顶点反向传递 Two Bones IK 2根Bone组成三角形的两边 大腿根部的Joint到地面接触点距离为第三边\n即可得到两根Bone的夹角 \\(\\cos\\theta=\\dfrac{a^2+c^2-b^2}{2ac}\\) 问题：在3D空间，解有无数个，构成一个圆 设定Reference Vector 朝着Reference Vector方向取解 更多复杂的IK\nLook At Hand Foot Full Body Multi-Joint IK Solving 更多种可能性 首先检查是否能到达目标（最长、最短的触及范围） 最长（拉直） 最短（最长的单根Bone减去其他Bone） 约束 Constraints 关节有运动的约束，不能超出约束范围（比如依据人体的骨骼结构） 解法 CCD, Cyclic Coordinate Decent 逐个Joint遍历，每个Joint朝下一个Joint与目标点连线方向旋转 上述过程反复迭代，不断接近结果 优化： 每次旋转时，使用Tolerance region进行缩小或限制 越靠近根节点的限制越大，运动幅度越小（处理约束同理） FABRIK, Forward And Backward Reaching Inverse Kinematics 逐个Joint遍历，每个Joint朝目标点或上一个Joint位移，再将Bone还原设定下一个Joint 从末端Joint出发、从Root出发反复迭代 同样需要Tolerance优化 处理约束：将约束区域投影到Target所在平面，取可运动到的点 IK with Multiple End-Effects eg. 爬墙、攀岩灯多个目标点的IK 利用Jacobi矩阵求解：\n其他解法\n基于物理的解法 PBD, Position Based Dynamics Fullbody IK in UE5 (XPBD, Extended PBD) IK的挑战 蒙皮后的自我穿插、交叠 对环境的感知 更自然的人类行为，例如平衡 基于数据的、AI的方法 Animation Pipeline with Blending and IK Facial Animation Facial Action Coding System 把表情分成46种，并进行编码 多种表情可以进行组合 Apple归纳了28个核心的表情，其中有23个是有对称性的，可以压缩 混合时如果线性叠加：合到一起后效果折半 -\u0026gt; 存储表情相对于“Neutral Face”的Offset，实现Additive Blending 即Morph Target Animation Morph Target Animation Facial Skeleton 骨骼非常复杂 UV Texture Facial Animation 简单用贴图实现\nMuscle Model Animation 前沿研究，如果运动脸部肌肉（影视行业开始使用） Animation Retargeting Skeleton Retargeting 把同一个骨骼动画应用到不同角色 Source Character + Target Character Source Animation + Target Animation 两幅骨骼比例、位置不同 -\u0026gt; 一一对应 保持Binding Pose的旋转，Retarget相对运动，而不是绝对运动 Translation和Scale动画：考虑Bone的长度之比，进行动画的放缩 问题：腿部不同长度时出现浮空 以Pelvis到地面的距离之比为放缩比例，对动画、移动速度做放缩 Foot IK 离线方法完成 对不同骨骼结构的Retargeting 以骨骼名字做对应 把有对应骨骼之间的部分做归一化 问题： 角色的自穿插 有语义动作偏移带来语义偏移，例如鼓掌动画，Retargeting后掌合不起来 Morph Animation Retargeting eg. 表情动画 + 直接存储的是相对于Neutral Face的相对位移，直接Apply到Target上 + 有语义动作 eg. 闭眼，眼睛大小不同时，直接Apply可能无法闭上 + 增加约束条件 eg. 闭眼动画限制眼睛必须闭上 + 手动调整，利用拉普拉斯算子计算，拉眼睑使相近脸部一起运动\n","permalink":"https://elderlyaugustus.github.io/posts/2022-05-19-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture9-advancedanimationsystem/","summary":"Lecture09 Animation System - Advanced Animation Blending LERP LERP / NLERP / SLERP 两个动画clip之间的LERP 权重 eg. 走路与跑步动画，依据运动速度切换 \\[ {\\rm weight_1=\\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\\\ {\\rm weight_2=\\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\\\ \\]\n对齐时间线 eg.走路和跑步的步频不同，怎样对齐混合的帧 每一段动画为一步，对每一段动画时间线做归一化 Blend Space eg. 左右前后走/跑\n1D Blend Space： eg. 左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）\n2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置 双线性插值 Delaunay Triangulation 常用 根据设置的动画点，生成三角形划分 在空间内一点，由周围三角形插值 插值利用重心坐标 Skeleton Masked Blending 针对只应用于半身或身体局部的动画，实现多种动画的混合 eg.各种姿态下的鼓掌\n绘制一个Mask，只应用于部分Joints Additive Blending eg. 向着摄影机点头\n存储动画的变化量，在基础动画上叠加一层动画 需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果 Animation State Machine 状态机 两种核心元素 Node Clip Blend Space 脚本串接的单套动画系统 Translation 激活条件 Cross Fade Smooth transition 慢慢过渡，插值（各种插值曲线） Frozen transition 先停住动画A，再播放动画B 多层状态机 Animation Blend Tree 多层状态机在复杂动画中非常复杂 用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树 两种节点 Terminal Node 执行节点 (叶节点) Clip Blend Space ASM Non-terminal Node （非叶节点） LERP Blend Node Additive Blend Node Layered ASM to Blend Tree Blend Tree Control Parameters Variable 暴露变量，根据变量切换运动状态 eg.","title":"2022-05-19-GAMES104现代游戏引擎-Lecture9-Animation System - Advanced"},{"content":"Lecture08 Animation System - Basics 挑战：\n不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互 实时，计算和存储开销 真实感（表情、Ragdoll、Motion Matching …） 2D Animation Sprite Animation 逐帧绘制，循环播放 Sprite-like animation technique in pseudo-3D game 《Doom》 绘制各个视角的sprite，做伪3D Sprite Animation in Modern Game Live2D 把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴 仿射变换 图元的前后遮挡由深度决定 每一个图元有控制网格 Key frame 2D Skinned Animation 2D蒙皮动画 3D Animation DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation Pan/Yaw Tilt/Pitch Roll Rigid Hierarchical Animation 基于刚体的层次结构动画 “皮影戏” 直接连接Mesh，会导致Mesh互相产生穿插 Per-vertex Animation 旗帜、布料、流体等（从物理烘焙而来的顶点动画实现） VAT, Virtual Animation Texture：用贴图存储顶点 Morph Target Animation 顶点动画的变种 顶点带有权重，邻近顶点相互影响 3D Skinned Animation 2D蒙皮动画 （见下章） Physics-based Animation Ragdoll 布料和流体 IK, Inverse kinematics 反向动力学 Animation 创作方式 Key frame 动作捕捉 Skinned Animation Implementation 怎样将Mesh运动起来 创建一个绑定姿态的Mesh 创建绑定骨骼Skeleton 刷定点权重（蒙皮） 骨骼动画 顶点按骨骼动画和蒙皮权重运动 Different Spaces\nLocal Space 每一个骨骼节点 Model Space World Space 骨骼 Humanoid 两足动物 Non-humanoid 四足动物 Joint 和 Bone 关节和骨段，存储/处理的是Joint 真实情况中的附加骨骼\n复杂的表情 披风、翅膀、武器等外饰 eg. 武器可能是单个Joint绑定在手上 Root节点 一般在地面 物体之间的骨骼Attach，骑马/开车等情况 绑定初始状态 T-Pose和A-Pose\nT-Pose肩部受到挤压，精度不够 目前大多采用A-Pose Pose：一个骨骼的状态\nJoint Pose (9DoF)\nPosition Orientation Scale \u0026gt; Math of 3D Rotation （略） Affine Matrix 仿射矩阵 \\[ M=R_{HM}T_{HM}S_{HM}=\\begin{bmatrix}SR \u0026amp; T\\\\0\u0026amp;1\\end{bmatrix} \\]\n从Local Space到Model Space \\[ M_J^{\\rm Model}=\\prod_{j=J}^0 M_{p(J)}^{\\rm Local} \\]\nInterpolation 左：Local Space 右：Model Space 故在Local Space进行插值，再转换至Model Space\nSkin - 蒙皮怎样运动 Skinning Matrix\n\\(V^{\\rm Local}(t)\\)：顶点 \\(V\\) 在Local Space，\\(t\\) 时间的位置： \\[ V^{\\rm Local}(t)\\equiv V_b^{\\rm Local}=(M_{b(j)}^{\\rm Model})^{-1}\\cdot V_b^{\\rm Model} \\] \\(M_J^{\\rm Model}(t)\\)：Joint \\(J\\) 在Model Space，\\(t\\) 时间的pose： \\[ M_J^{\\rm Model}(t)=\\prod_{j=J}^0 M_{p(j)}^{\\rm Local}(t) \\]\n\\(V^{\\rm Model}(t)\\)：顶点 \\(V\\) 在Model Space，\\(t\\) 时间的位置： \\[ V^{\\rm Model}(t)=M_J^{\\rm Model}(t)\\cdot V_J^{\\rm Local}=M_J^{\\rm Model}(t)\\cdot(M_{b(j)}^{\\rm Model})^{-1}\\cdot V_b^{\\rm Model} \\]\nSkinning Matrix \\[ K_J=M_J^{\\rm Model}(t)\\cdot(M_{b(j)}^{\\rm Model})^{-1} \\]\nSkinning Matrix Palette\n存储每个Joint的Skinning Matrix\nModel Space to World Space \\[ K_J\u0026#39;=M^{\\rm World}\\cdot M_J^{\\rm Model}(t)\\cdot(M_{b(j)}^{\\rm Model})^{-1} \\] 存储该Skinning Matrix’\nBind Pose Matrix的逆需提前计算存储，以提高效率 Weighted Skinning with Multi-joints\n加权平均（一般不超过4个），加权总和为1\nWeighted Skinned Blend\n顶点 \\(V\\) 关于Joint \\(J_i\\) 的Local Space to Model Space： \\[ V_{J_i}^M(t)=K_{J_i}(t)\\cdot V_{b_{J_i}}^M \\]\n顶点 \\(V\\) 在Model Space： \\[ V^M(t)=\\sum_{i=0}^{N-1}W_i\\cdot V_{J_i}^M(t) \\]\nClips 动画片段 Interpolation\nLERP - Translation / Scale \\[ f(x)=(1-\\alpha)f(x_1)+\\alpha f(x_2)\\\\ \\alpha=\\dfrac{x-x_1}{x_2-x_1},\\,x_1\u0026lt;x_2,\\,x\\in[x_1,x_2];\\quad f(x):T(t),S(t) \\]\nNLERP for Quaternion - Rotation Linear Interpolation \\[ q_t={\\rm Lerp}(q_{t_1},q_{t_2},t)=(1-\\alpha)q_{t_1}+\\alpha q_{t_2}\\\\ \\]\nNormalization \\[ q_t\u0026#39;={\\rm NLerp}(q_{t_1},q_{t_2},t)=\\dfrac{(1-\\alpha)q_{t_1}+\\alpha q_{t_2}}{\\|(1-\\alpha)q_{t_1}+\\alpha q_{t_2}\\|} \\]\n最短路径 SLERP for Quaternion - Rotation\nNLERP在弦上插值，故旋转不均匀；SLERP在球面上插值，但开销较大\n\\[ q_t={\\rm SLerp}(q_{t_1},q_{t_2},t)=\\dfrac{\\sin((1-t)\\theta)}{\\sin\\theta}\\cdot q_{t_1}+\\dfrac{\\sin(t\\theta)}{\\sin\\theta}\\cdot q_{t_2}\\\\ \\theta=\\arccos(q_{t_1}\\cdot q_{t_2}) \\] 一般设置阈值，插值角度小，则NLerp，插值角度非常大时使用SLerp\nSimple Animation Runtime Pipeline Animation Compression 大部分数据不变\n部分Joint整个固定 部分Joint的Translation/Rotation/Scale有部分保持不变（尤其是Translation和Scale） DoF Reduction 减少不变的自由度\nKeyframe 记录关键帧，其他帧插值\n使用插值方法测试\n若插值结果与真实结果差异小于阈值，则不记录为关键帧 若插值结果与真实结果差异较大，则以真实结果为关键帧 采用Catmull-Rom Spline插值 —— 比线性插值更平滑（开销大但这里不是Runtime） \\[ P(t)=\\begin{bmatrix}1\u0026amp;t\u0026amp;t^2\u0026amp;t^3\\end{bmatrix} \\begin{bmatrix}0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ -\\alpha\u0026amp;0\u0026amp;\\alpha\u0026amp;0\\\\ 2\\alpha\u0026amp;\\alpha-3\u0026amp;3-2\\alpha\u0026amp;-\\alpha\\\\ -\\alpha\u0026amp;2-\\alpha\u0026amp;\\alpha-2\u0026amp;\\alpha \\end{bmatrix} \\begin{bmatrix}P_0\\\\P_1\\\\P_2\\\\P_3\\end{bmatrix} \\] 减少了关键帧 Float Quantization\n32bit浮点存储量大 将关键帧中数据的最小值、最大值mapping到 \\([0, 1]\\) 所有数值mapping到16bit unsigned int来存储 四元数的特性： \\[ a^2+b^2+c^2+d^2=1,\\,|a|\\ge\\max(|b|,|c|,|d|)\\\\ \\Rightarrow b,c,d\\in[-\\frac{\\sqrt 2}{2}, \\frac{\\sqrt 2}{2}] \\] 因此，经验证四元数中除模最大的数 \\(a\\) 以外的三个数 \\(b,c,d\\) 可以用15bit精度表示，另有2bit表示哪个数最大；三个元共用48bit表示 经过压缩： 误差传播 结果会导致人物手部、手上武器等末端Joint发生抖动\n特殊情况需要高精度存储\n最简单的判定方法 —— 直接给误差设定阈值 Visual Error 视觉误差 为Joint在两个垂直方向设定两个Fake Vertex，计算运动后Fake Vertex的距离 误差补偿\n处理方法： 除Root外，每根bone上选一个点 计算每根压缩后的bone的旋转，使标记点在Model Space中接近实际位置 增加一个旋转来补偿误差 问题：末端骨骼的信息变成高频 更新的方法：FIK, Forward Inverse Kinematics Animation DCC Mesh 关节处Mesh更细分 Skeleton Binding 骨骼绑定 DCC的基础骨架 增加武器等Gameplay中特殊的Joint Skinning 蒙皮，刷权重 自动计算 —— 结果会像橡皮 手动部分校正权重 设计关键帧动画 Root要保持在Model Space中不变 FBX File ","permalink":"https://elderlyaugustus.github.io/posts/2022-05-13-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture8-basicanimationsystem/","summary":"Lecture08 Animation System - Basics 挑战：\n不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互 实时，计算和存储开销 真实感（表情、Ragdoll、Motion Matching …） 2D Animation Sprite Animation 逐帧绘制，循环播放 Sprite-like animation technique in pseudo-3D game 《Doom》 绘制各个视角的sprite，做伪3D Sprite Animation in Modern Game Live2D 把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴 仿射变换 图元的前后遮挡由深度决定 每一个图元有控制网格 Key frame 2D Skinned Animation 2D蒙皮动画 3D Animation DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation Pan/Yaw Tilt/Pitch Roll Rigid Hierarchical Animation 基于刚体的层次结构动画 “皮影戏” 直接连接Mesh，会导致Mesh互相产生穿插 Per-vertex Animation 旗帜、布料、流体等（从物理烘焙而来的顶点动画实现） VAT, Virtual Animation Texture：用贴图存储顶点 Morph Target Animation 顶点动画的变种 顶点带有权重，邻近顶点相互影响 3D Skinned Animation 2D蒙皮动画 （见下章） Physics-based Animation Ragdoll 布料和流体 IK, Inverse kinematics 反向动力学 Animation 创作方式 Key frame 动作捕捉 Skinned Animation Implementation 怎样将Mesh运动起来 创建一个绑定姿态的Mesh 创建绑定骨骼Skeleton 刷定点权重（蒙皮） 骨骼动画 顶点按骨骼动画和蒙皮权重运动 Different Spaces","title":"2022-05-13-GAMES104现代游戏引擎-Lecture8-Animation System - Basics"},{"content":"21年元旦，地下二号摄影棚油漆中毒。无较长记录。\n21年两个主要的工作： 上半年一直搞着，但逐渐发现能搞得越来越少的Virtual Production； 下半年就着Presentation的课程，继续前一年没太搞明白的Simulation。\n一些杂七杂八的工作： 影院课及课程方案重编工作中，复习/新学了一些东西，Presentation部分新学了一点流媒体的知识； 科工委的技术展示片，早早开始筹备，制作却日常拖到了最后，明天要开始拍摄的部分； 零散地做了一些片子的后期/远程支持，以及极少量的现场工作，也算有一些二维影像的内容产出； 寒暑期照常补充了一些基础科学知识，后来也是不出所料派上了用场； 其他一些更零碎的就不提了。\n从19年进入实验室以来，持续了一年多的“精力‘Wireless’”，终于在一个暑假没回家之后，逐渐被大三上课内外的任务压得喘不过气来。\n今年只希望能得空做一些想做的工作罢，21年没学完的那些课等等。\n","permalink":"https://elderlyaugustus.github.io/posts/2022-01-01-2021%E5%85%83%E6%97%A6%E4%B8%80%E5%88%99%E7%9F%AD%E5%BE%AE%E5%8D%9A/","summary":"21年元旦，地下二号摄影棚油漆中毒。无较长记录。\n21年两个主要的工作： 上半年一直搞着，但逐渐发现能搞得越来越少的Virtual Production； 下半年就着Presentation的课程，继续前一年没太搞明白的Simulation。\n一些杂七杂八的工作： 影院课及课程方案重编工作中，复习/新学了一些东西，Presentation部分新学了一点流媒体的知识； 科工委的技术展示片，早早开始筹备，制作却日常拖到了最后，明天要开始拍摄的部分； 零散地做了一些片子的后期/远程支持，以及极少量的现场工作，也算有一些二维影像的内容产出； 寒暑期照常补充了一些基础科学知识，后来也是不出所料派上了用场； 其他一些更零碎的就不提了。\n从19年进入实验室以来，持续了一年多的“精力‘Wireless’”，终于在一个暑假没回家之后，逐渐被大三上课内外的任务压得喘不过气来。\n今年只希望能得空做一些想做的工作罢，21年没学完的那些课等等。","title":"2022元旦一则短微博"},{"content":" 注：本篇由同组同学LLY编写，本人代完成格式化\n电影制作流程中的物理模拟 视效制作流程 在了解物理模拟在视效中的流程之前，我们需要先了解一下整个视效制作的大框架。\nFXPipeline 特效（FX）部门简述 动力学和模拟技术是数字特效的核心组成部分。从广义上讲，它们试图在数字领域复制真实世界的物理特征，这样就可以通过让软件计算适当的结果而不需要关键帧动画来实现真实的行为和交互。\n这可能是因为实际拍摄的话，成本过高（可能需要多个模型来允许重新拍摄），无法提供所需的可控性与可指导性，或者新一代监管人员对数字技术比传统的实际效果更满意。不管是什么原因，自20世纪90年代初以来，实际效果越来越被数字所取代，以至于模拟物体、流体和火的复杂相互作用现在已司空见惯。Dante的Peak（1997）使用简单的粒子系统对模型和微缩模型进行数字增强，同时使用真实拍摄，2012（2009）模拟了整个数字城市的大规模破坏。\n虽然模拟技术通常与毁灭和混乱联系在一起，包括破裂和变形物体、爆炸、火灾、烟雾和液体，但它们也被用来给角色穿衣服、造型和移动头发，以及移动皮肤下的肌肉。可以预期，通过模拟比通过关键帧更容易实现真实的复杂交互。\n3D动画中特效的种类 毛发模拟 Hair and Fur Simulation 模拟系统创建头发或毛发的模拟，不仅对环境因素作出反应，还对其附着角色头部或身体的运动作出反应。这是一个极其复杂的模拟，除了高预算项目以外，通常没有条件获取这样的资源。\n刚体\u0026amp;柔体模拟 Body Simulation 包括刚体模拟和柔体模拟。刚体用于模拟木材、石头、玻璃，或者其他形变不大的物体。刚体模拟处理的是物体间的相互作用、碰撞、破碎等效果。柔体模拟包括模拟刚性较低的材料，如布料、皮肤、土壤、身体组织等其他任何可能弯曲、扭曲活波动的材料。\n流体模拟 Fluid Simulation 流体模拟不仅包括水或液体，还包括气体、凝胶，或任何其他流体运动的物质。包括浓雾、明胶、燕麦等其他类似的物质。流体模拟器通常基于真实世界流体物理中涉及的方程进行计算。\n粒子模拟 Particle Simulation 粒子模拟器在空间中创建点，这些点具有分散的特征，如雨、烟、灰尘、群集、人群、前进的军队、飞溅的火花等等。艺术家将行为和视觉属性指定给粒子，使其外观和移动与艺术家想要的一样。与其他类型模拟相同，艺术家定义了基于物理的参数，如重力、风力等，粒子会做出相应的反应，创造出令人惊讶的逼真的效果，如暴风雪、迁徙的蜜蜂、攻击的鸟类，或者任何所需要的效果。\n我们今天主要从粒子、刚体、流体三个方面来讲，基本上从原理上涵盖了上述所有类型物体的模拟。\nFX部门流程与分工 RnD：Research and Development 研发部门。负责创新研发解决棘手问题的新方案，不断发展现有的能力。根据画面需求，对学术界现有的算法进行调研，寻找、整合可用于生产的解决方案。\nTD：Techinal Director 技术指导。TD是科学家与艺术家之间的桥梁，将研发部门开发的算法编写成艺术家能够上手使用的工具。他们使爆炸、浓烟、激流等效果更加容易使用。FX TD构建和测试工具，然后将其整合到VFX工作流程的制作pipeline当中。所有TD都是问题解决者。每个项目都有其复杂的地方，他们确保效果一致并且令人信服。\nFX Artist FX 艺术家。艺术家们使用TD创建出来的工具，通过自身的艺术造诣和导演的要求，为单个镜头创建效果。他们是视觉效果的生产者。\nFX 工作流程 因为今天演讲的主题是模拟相关，所以我们关注的FX部门的流程将不涉及到特效评估、数据统计、特效整理、测试、预演等细化工作。\nFX部门流程 首先，导演提出视效需求给视效总监，由视效总监判断现阶段视效能否实现。若不能实现，则交给RnD部门研发该效果，并准备可行备用方案。若可以实现，则将其交给视效制片规划制作方案。当RnD研发好算法后，将算法交给TD。TD询问艺术家的工作习惯、预期希望可以调整的方面等需求，编程、制作成实现容易，并为艺术家暴露出可修改的参数。在制作阶段，视效制片将相应的特效镜头派发给FX部门，相应的镜头将被派发给不同的FX艺术家。FX艺术家在制作时会收到来自其他部门的模型文件、跟踪数据、关键帧动画等信息，进行特效的制作。其中，每一个部门都有相应的组长，会对艺术家所制作的镜头进行评估和审核。全部制作完成的特效镜头，会经过各个监管的层层审核与反馈迭代，最后给到剪辑进行素材的回插。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C%E4%B8%AD%E7%9A%84fx%E6%B5%81%E7%A8%8B-bylly/","summary":"注：本篇由同组同学LLY编写，本人代完成格式化\n电影制作流程中的物理模拟 视效制作流程 在了解物理模拟在视效中的流程之前，我们需要先了解一下整个视效制作的大框架。\nFXPipeline 特效（FX）部门简述 动力学和模拟技术是数字特效的核心组成部分。从广义上讲，它们试图在数字领域复制真实世界的物理特征，这样就可以通过让软件计算适当的结果而不需要关键帧动画来实现真实的行为和交互。\n这可能是因为实际拍摄的话，成本过高（可能需要多个模型来允许重新拍摄），无法提供所需的可控性与可指导性，或者新一代监管人员对数字技术比传统的实际效果更满意。不管是什么原因，自20世纪90年代初以来，实际效果越来越被数字所取代，以至于模拟物体、流体和火的复杂相互作用现在已司空见惯。Dante的Peak（1997）使用简单的粒子系统对模型和微缩模型进行数字增强，同时使用真实拍摄，2012（2009）模拟了整个数字城市的大规模破坏。\n虽然模拟技术通常与毁灭和混乱联系在一起，包括破裂和变形物体、爆炸、火灾、烟雾和液体，但它们也被用来给角色穿衣服、造型和移动头发，以及移动皮肤下的肌肉。可以预期，通过模拟比通过关键帧更容易实现真实的复杂交互。\n3D动画中特效的种类 毛发模拟 Hair and Fur Simulation 模拟系统创建头发或毛发的模拟，不仅对环境因素作出反应，还对其附着角色头部或身体的运动作出反应。这是一个极其复杂的模拟，除了高预算项目以外，通常没有条件获取这样的资源。\n刚体\u0026amp;柔体模拟 Body Simulation 包括刚体模拟和柔体模拟。刚体用于模拟木材、石头、玻璃，或者其他形变不大的物体。刚体模拟处理的是物体间的相互作用、碰撞、破碎等效果。柔体模拟包括模拟刚性较低的材料，如布料、皮肤、土壤、身体组织等其他任何可能弯曲、扭曲活波动的材料。\n流体模拟 Fluid Simulation 流体模拟不仅包括水或液体，还包括气体、凝胶，或任何其他流体运动的物质。包括浓雾、明胶、燕麦等其他类似的物质。流体模拟器通常基于真实世界流体物理中涉及的方程进行计算。\n粒子模拟 Particle Simulation 粒子模拟器在空间中创建点，这些点具有分散的特征，如雨、烟、灰尘、群集、人群、前进的军队、飞溅的火花等等。艺术家将行为和视觉属性指定给粒子，使其外观和移动与艺术家想要的一样。与其他类型模拟相同，艺术家定义了基于物理的参数，如重力、风力等，粒子会做出相应的反应，创造出令人惊讶的逼真的效果，如暴风雪、迁徙的蜜蜂、攻击的鸟类，或者任何所需要的效果。\n我们今天主要从粒子、刚体、流体三个方面来讲，基本上从原理上涵盖了上述所有类型物体的模拟。\nFX部门流程与分工 RnD：Research and Development 研发部门。负责创新研发解决棘手问题的新方案，不断发展现有的能力。根据画面需求，对学术界现有的算法进行调研，寻找、整合可用于生产的解决方案。\nTD：Techinal Director 技术指导。TD是科学家与艺术家之间的桥梁，将研发部门开发的算法编写成艺术家能够上手使用的工具。他们使爆炸、浓烟、激流等效果更加容易使用。FX TD构建和测试工具，然后将其整合到VFX工作流程的制作pipeline当中。所有TD都是问题解决者。每个项目都有其复杂的地方，他们确保效果一致并且令人信服。\nFX Artist FX 艺术家。艺术家们使用TD创建出来的工具，通过自身的艺术造诣和导演的要求，为单个镜头创建效果。他们是视觉效果的生产者。\nFX 工作流程 因为今天演讲的主题是模拟相关，所以我们关注的FX部门的流程将不涉及到特效评估、数据统计、特效整理、测试、预演等细化工作。\nFX部门流程 首先，导演提出视效需求给视效总监，由视效总监判断现阶段视效能否实现。若不能实现，则交给RnD部门研发该效果，并准备可行备用方案。若可以实现，则将其交给视效制片规划制作方案。当RnD研发好算法后，将算法交给TD。TD询问艺术家的工作习惯、预期希望可以调整的方面等需求，编程、制作成实现容易，并为艺术家暴露出可修改的参数。在制作阶段，视效制片将相应的特效镜头派发给FX部门，相应的镜头将被派发给不同的FX艺术家。FX艺术家在制作时会收到来自其他部门的模型文件、跟踪数据、关键帧动画等信息，进行特效的制作。其中，每一个部门都有相应的组长，会对艺术家所制作的镜头进行评估和审核。全部制作完成的特效镜头，会经过各个监管的层层审核与反馈迭代，最后给到剪辑进行素材的回插。","title":"2021-12-25-影片技术分析Pre-基于物理的动画-影视制作中的FX流程-byLLY"},{"content":" 注：本篇由同组同学LLY编写，本人代完成格式化\n刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。\n刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \\(\\mathbf x\\) 和速度 \\(\\mathbf v\\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。\n质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \\(\\mathbf x\\) 和 方向 \\(R\\) 。局部坐标为 \\(\\mathbf p_0\\) 的点，世界坐标系下的坐标为：\\(\\mathbf p = \\mathbf x + R \\mathbf p_0\\)\n物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = + R + p_0 $\n因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $\n所以我们只需要求出每个时间的 \\(\\mathbf v\\) 和 $ $ 就可以描述刚体随时间的运动状态了。\n为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。\n角速度 我们知道 \\(R\\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \\[ \\displaystyle\\dot{R} = [\\dot{\\hat{u_x}}\\quad\\dot{\\hat{u_y}}\\quad\\dot{\\hat{u_z}} ] \\] 于是 \\(\\dot{R}\\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \\(\\mathbf x\\) ，旋转点位置是 \\(\\mathbf p\\) ，旋转中心到位置 \\(\\mathbf p\\) 的向量为 \\(r\\) 。我们的目的是测定 \\(r\\) 的变化率。由于 \\(\\mathbf p\\) 以角速度 \\(\\omega\\) 旋转，所以其瞬时速度与 \\(r\\) 和 \\(\\omega\\) 垂直。瞬时速度方向由 \\(\\omega\\times r\\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$\n半径的变化率 将结果应用到旋转矩阵中，我们能写出旋转矩阵按时间的导数： \\[ \\dot R=[\\omega\\times\\hat{\\mathbf u}_x,\\ \\omega\\times\\hat{\\mathbf u}_y,\\ \\omega\\times\\hat{\\mathbf u}_z] \\] 根据向量积表示法，我们可以化简得到： \\[ \\dot R=\\omega^*R\\quad其中a^*=\\begin{bmatrix}0\u0026amp;-a_z\u0026amp;a_y\\\\a_z\u0026amp;0\u0026amp;-a_x\\\\-a_y\u0026amp;a_x\u0026amp;0\\end{bmatrix} \\] 现在，我们只需要知道 \\(\\mathbf v\\) 和 \\(\\omega\\) 就能表示描述刚体的运动状态了。\n刚体运动 前面我们讲到，刚体有线性状态（ \\(\\mathbf v\\) ）和角度状态（ \\(\\omega\\) ）。在模拟刚体时，必须更新这两种状态。刚体的运动可以拆分称平移运动和旋转运动。\n平移运动 平移运动非常简单。根据牛顿第二定律 \\(F=ma\\) ，逐时间步地更新我们的加速度、速度和位置即可。我们用前面提到过的时间积分方法迭代计算即可。\n旋转运动 惯性张量 线性动量 \\(P=mv\\) ，在有角度的情况下，有一个接近的类比，其中角动量 \\(L\\) 被定义为惯性张量 \\(I\\) 和角速度 \\(\\omega\\) 的乘积： \\(L=I\\omega\\) 。惯性张量I描述质量如何在物体中分布，是一个 \\(3\\times 3\\) 的矩阵。 \\(I\\) 的矩阵形式描述了惯性因方向而变化。局部坐标系中惯性张量的公式如下： \\[ \\mathbf I_{ref}=\\sum m_i(\\mathbf R_i^T\\mathbf R_i\\mathbf 1-\\mathbf R_i\\mathbf R_i^T) \\] 刚体在局部坐标系中的惯性张量 \\(I_0\\) 不会改变，但在世界坐标系中，惯性张量却会随着物体当前的方向而发生变化。根据线性空间转换可得，在世界坐标系中，物体的惯性张量为： \\[ \\mathbf I=\\mathbf R\\mathbf I_0\\mathbf R^T \\] 线性运动与旋转运动中，有这样的对应关系：\n力矩 线性动量 \\(P=mv\\) ，对于 \\(F\\) ，有 $ F = ma = m = $ ，即 \\(F\\) 是线性动量的时间变化率。角动量变化有类似的过程，角动量的时间变化率是力矩 \\(\\tau\\)。\n力矩对应力的旋转 \\(\\tau = \\dot{L}\\)\n已知质心为 \\(\\mathbf x\\) ，假定在点 \\(\\mathbf p\\) 施加力 \\(F\\) 。任何不作用于刚体质心的力都将产生力矩。为测定力矩，首先计算力臂 \\(r\\) ，\\(\\tau = r \\times f\\) 。力矩是一个矢量，方向同时垂直于力臂及作用力。方向为物体因力矩旋转时围绕的轴的方向。\n力矩作用于整个刚体，可理解为力矩通过了质心。力矩的叠加满足矢量加法。\n于是，我们很容易就能得出 \\(\\displaystyle\\Delta \\omega = \\frac{\\Delta L}{I} = \\Delta t \\frac{\\tau}{I}\\)\n表示旋转的方法 我们到此为止一直在使用旋转矩阵来表示旋转。但其实旋转有很多种表示方式。\n旋转矩阵\n会有太多数据冗余：表示旋转矩阵需要九个元素，但是只表示了三个自由度。 表示方法不符合直觉。 定义它的时间导数很困难。 欧拉角\n优势：表示是符合直觉的。它用三个轴的旋转角度来表达一个旋转。 劣势：可能会导致万向锁问题，并且定义它的时间导数也很困难。 四元数： 一个四元数的第一位表示旋转角度，后三位表示旋转轴方向。 并且四元数可以和旋转矩阵互相转换： 于是我们用四元数来表示旋转的状态更新方程可以表示为： 总结一下，我们的刚体运动模拟过程由下图所示：线性运动和角度运动的物理量都有相互对应的关系。\n刚体的碰撞与接触 Rigid Collision Detection and Response by Impulse 之前我们在粒子系统中已经介绍了一个点与面的两种碰撞方式，在Mesh表达的刚体碰撞处理中，我们一般采用Impulse的碰撞响应方式。\n当物体有许多点构成时，我们可以检测每个点是否发生碰撞。\n每一个点由 $x_i $ 表示，计算点到表面的距离 $ (x) $ 是否小于0。若大于零，说明没有发生碰撞。若小于零，则发生碰撞。\n然后将线性速度与角速度合成为此时该点的速度，若速度方向远离刚体内部，则不需要改变力，碰撞结束。若方向继续深入刚体内部，则继续运算。\n首先强行创造一个离 $ x_i $ 最近的接触点 $ x_i^{new} $ ，然后计算出当前速度的 \\(xyz\\) 分量。新的点的垂直速度反向，并且乘以衰减参数 $ _N $ ；平行速度乘以摩擦衰减参数 $ a $ 。将速度分量重新合成为 $ v_i^{new} $ 此速度即为当前点的速度。 \\[ {\\rm collision}\\quad\\mathbf x^{new}\\leftarrow\\mathbf x+|\\phi(\\mathbf x)|\\mathbf N=\\mathbf x=\\phi(\\mathbf x)\\nabla\\phi(\\mathbf x) \\] 又因为刚体的属性中只有线性速度和角速度，求得的点速度无法用于更新，所以引入冲量 \\(j\\) 。因为冲量 $ j = Ft $\n易得 $ v = t = j $ ， $ = t= t = I^{-1}(r j)$\n列出方程组： \\(\\begin{array}{l}\\mathbf v^{new}=\\mathbf v+\\dfrac{1}{M}\\mathbf j\\\\\\mathbf \\omega^{new}=\\mathbf \\omega+\\mathbf I^{-1}(\\mathbf Rr_i\\times \\mathbf j)\\\\\\mathbf v_i^{new}=\\mathbf v^{new}+\\omega^{new}\\times\\mathbf R\\mathbf r_i\\end{array}\\)\n即可求出 $ v^{new} $ 与 $ ^{new} $ 。\nShape Matching Shape Matching 方法将物体上的点当作粒子进行状态更新，允许点有自己的速度，点与点之间没有任何相互作用力，然后再强行将其约束成为一个刚体。将点云的质心作为下一时刻刚体的质心，然后让刚体尽可能接近点云的形态。但是因为实际应用不多，具体方法不再赘述。\n约束 到目前为止，我们都讨论的是无约束系统的动力学。意思就是说，粒子或者刚体可以沿任何方向运动，仅受外力影响。但在基于物理的动画中，存在许多内在和约束有关的问题。比如轨道上的列车，车轮因为钢轨施加的作用力受到约束，沿轨道运行。轨道产生向上的作用力，支撑列车的重量，在转弯时，轨道也会产生横向作用力，保证车轮沿轨道前行。\n我们把约束视为减少运动的自由度。没有约束的刚体存在6个自由度——3个平移自由度和3个旋转自由度。刚体可以沿 \\(xyz\\) 方向移动、旋转。\n罚函数 罚函数法是维持约束最简单的方法。这种方法本质上就是先让刚体自由运动，当运动和约束有偏差的时候，再施加一个外力，使运动回到约束。因为这种方法是基于偏差而产生的校正力，所以不能维持刚性约束。刚性约束指永远不可能违反的约束。实现刚性约束需要使用其他方法（之后会讲到）。但很多例子中会使用暂时允许产生小幅偏差的柔性约束。\nP（比例）控制器 P控制器是罚函数法使用的最简单的控制系统。这张图表示的是灰珠受到约束而沿线运动的例子。细线表示线的约束路径，粗线表示灰珠的实际路径。灰珠的中心位置为 \\(\\mathbf x(t)\\) ，约束路径上离灰珠最近的点为 \\(\\mathbf c(\\mathbf x)\\) 表示和约束误差的向量为 \\(\\mathbf e(\\mathbf x)=\\mathbf c(\\mathbf x)-\\mathbf x(t)\\) 。强度常量为 $ k_p $ 的P控制器将施加以下校正力： \\[ \\mathbf F_p=-k_p\\mathbf e \\] 使用这种方法，灰珠会沿着约束路径运动，但两者之间仍存在较大的偏差，灰珠会在约束路径附近振动。并且当灰珠趋于静止时，和路径有一个恒定的偏差，此时控制器施加的力正好与重力抵消。\nPD（比例微分）控制器 给P控制器加一个微分项可以预防未来的误差变化。施加一个误差向量方向上的力，该力正比于误差变化率，因此控制器合力为： \\[ \\mathbf F_{pd}=-[k_p\\mathbf e+k_d(\\dot{\\mathbf e}\\cdot\\hat{\\mathbf e})\\hat{\\mathbf e}] \\] $ k_d $ 为误差微分的可调增益。一般而言误差函数 \\(\\mathbf e(\\mathbf x)\\) 没有直接的解析式，只要我们能计算 \\(\\mathbf e\\) ，即可用两个时间步的误差估计当前时步的误差变化率： \\[ \\dot{\\mathbf e}^{[n]}\\approx(\\mathbf e^{[n]}-\\mathbf e^{[n-1]})/h \\] 使用PD控制器仍然解决不了当灰珠趋于静止时，和路径有一个恒定的偏差。因为除非误差在一直变化，否则微分项不会施加力。\nPID（比例积分微分）控制器 静止状态下的误差问题可以通过添加积分项解决。这意味着只要灰珠与约束路径存在误差，就会施加作用力： \\[ \\mathbf F_{pid}=-\\left[k_p\\mathbf e+k_d(\\dot{\\mathbf e}\\cdot\\hat{\\mathbf e})\\hat{\\mathbf e}+k_i\\int_0^t\\mathbf edt\\right] \\] 使用PID控制器的小球运动如图所示。最初小球的运动路径与PD控制器基本一致，担当小球减速，其运动轨迹更接近约束路径。当小球最终静止时，几乎完全符合约束。这是因为只要未回到约束，积分项将一直施加逐渐变大的力，使其刚好抵消重力。\n约束动力学 约束动力学通过产生作用力来抵消所施加的力，防止违反约束从而确保维持刚性约束。\n我们首先关注模拟平面内运动钟摆的约束动力学问题。钟摆轴位置为 $ x_0 $ ，因此所有的运动都应围绕该位置旋转。质量为 m 的摆球安装在长度为 r 的杆末端，杆是刚性的且质量忽略不计。摆球中心记为变量 $ x $ ，所有施加在摆球上的合外力为 $ f_a $ 。我们的目标是产生一个刚好可以抵消 $ f_a $ 中可能导致杆长度发生变化的约束力 $ f_c $ 。\n约束动力学的关键是创建一个约束函数。这个函数是一个判定函数，当满足约束条件时，该函数值 = 0。我们想要让系统永远满足约束条件，也就是约束函数恒为0。故该函数对时间的一阶导数始终为0。同时，我们还必须确保该函数的变化率也恒为0，也就是没有发生变化的趋势，所以我们需要该函数对时间的二阶导数也为0。对于钟摆问题，我们选择一个最为明显的约束函数： \\[ \\mathbf c(\\mathbf x)=\\|\\mathbf x-\\mathbf x_0\\|-r \\] 该函数计算导数非常困难，故我们使用该约束函数： \\[ \\mathbf c(\\mathbf x)=\\dfrac{1}{2}[(\\mathbf x-\\mathbf x_0)^2-r^2] \\] 当x与 $ x_0 $ 的距离刚好为r时，约束函数为0。约束函数对x的一阶导数为: $ x - x_0 $ ，根据链式法则，约束函数对时间的一阶导数为： \\[ \\dot {\\mathbf c}=(\\mathbf x-\\mathbf x_0)\\cdot\\dot {\\mathbf x} \\] 二阶导数为： \\[ \\ddot {\\mathbf c}=\\dot{\\mathbf x}^2+(\\mathbf x-\\mathbf x_0)\\cdot\\ddot {\\mathbf x} \\] 施加在摆球上的合力是外力与约束力的总和。根据牛顿第二定律： \\[ \\ddot{\\mathbf x}=\\dfrac{1}{m}{\\mathbf f_a + \\mathbf f_c} \\] 因为联立以上三式，又因为 $ = 0, = 0 $ ，经整理得： \\[ \\dfrac{1}{m}(\\mathbf x - \\mathbf x_0)\\cdot \\mathbf f_c = -\\dot{\\mathbf x}^2-\\dfrac{1}{m}(\\mathbf x-\\mathbf x_0)\\cdot\\mathbf f_a \\] 又因为约束力必须与杆平行，可得： \\[ \\mathbf f_c=\\lambda(\\mathbf x - \\mathbf x_0) \\] 其中，\\(\\lambda\\) 为待定的比例因子。再联立以上两式，即可求解 \\(\\lambda\\) ： \\[ \\displaystyle\\lambda=-\\frac{m\\dot{\\mathbf x}^2+(\\mathbf x-\\mathbf x_0)\\cdot\\mathbf f_a}{(\\mathbf x-\\mathbf x_0)^2} \\] 因此钟摆的系统动力学函数首先要求计算作用于钟摆的外力 $ f_a $，然后计算出比例因子 \\(\\lambda\\)，再计算出约束力 $ f_c $ 。已知 $ f_a \\(，\\) f_c $ ，在计算出摆球的总加速度。\n该单一约束的问题也可以推广到多约束的复杂系统。设定多个约束函数来求解多个约束力。由于篇幅限制，所以我们不再过多介绍。\n总结\n约束会减少系统的自由度。\n罚函数法先不考虑任何约束，直接计算运动，当运动与约束有所偏差时，再添加外力抵消。\n约束动力学通过计算约束力来维持刚性约束。\n以上，我们讲解了刚体的表示方法、表示刚体运动的方法、如何更新刚体运动状态、如何处理刚体运动的碰撞，以及如何对刚体创建约束。相信大家对刚体模拟都有了更深层次的了解。\nVFX中的刚体模拟 刚才，我们从底层原理的角度讲述了刚体的表示和模拟的计算方法，那么，这节课我们就来详细讲讲我们该如何实际使用刚体模拟来实现我们想要的一些效果。在VFX中，刚体模拟最常用的地方，就是创建物体毁灭的效果，英文中这个效果叫做Destruction。\nDestruction 电影《2012》是大范围的破坏视觉效果的分水岭，直到那时，还没有人看到过如此大规模的毁灭影像。这部电影加速了Bullet作为主要物理引擎的重要性和行业接受度。自2009年以后，视觉特效工作室、学术机构和开源项目继续为destruction工具做出贡献。\n实现Destruction效果的两种方法 RBS方法。这种方法主要有两种实现形式。\n第一种叫标准的RBS方法，最为广泛使用。此方法围绕现有物理库（如Bullet、PhysX或ODE）定制。其中，Bullet库最受欢迎。SPI、Frameworks、Weta和Dneg等公司是使用此方法的代表。这个方法还被众多商业软件和引擎如Houdini等使用。\n还有一种RBS方法是使用专业物理库的RBS方法，主要使用此方法的公司有：皮克斯、迪士尼、Industrial Light \u0026amp; Magic等。这种方法与标准RBS方法的区别体现在碰撞检测中，他们使用了水平集方法。\n有限元分析（FEA）。这种方法又被称为传统的大规模真实世界工程方法。这种方法目前只被MPC公司在电影视效中广泛使用。虽然这种方法在影视中不常见，但有许多游戏已经开始使用这种方法。\nRBS方法 RBS的三个阶段 第一阶段：分解RBS对象（预破碎） 第二阶段：设置约束和设计编排 第三阶段：运行模拟并进行碰撞检测 第一阶段：分解RBS对象（预破碎）\n在RBS中，物体不会受力自行发生破碎，而是在进行模拟前需要先人为的破碎成小块，再在模拟中进行解算。RBS的第一阶段是准备几何体，换句话说，就是研究如何将几何体分解为“小块”。埃尔文·库曼斯（Erwin Coumans）在加拿大温哥华SIGGRAPH提出了四种分解几何体的方法：\nA. 维诺图 Voronoi Diagrams\nB.CSG constructive solid geometry：使用布尔运算切割几何图形。\nC.凸分解 Convex Decomposition：这可以由艺术家手工或使用自动工具执行。\nD.四面体化，也可以通过将3D模型转换为tetras来实现。\nA.维诺图 Voronoi Diagrams 维诺图是一个数学概念，广泛用于生成看起来自然的断裂形状。这个原理非常简单，看起来非常自然。在两个点之间画一条等距离的线，与两点连线成直角。初始点（或称粒子）可以通过多种方式生成，包括随机生成。 这有效地将对象简化为点云，然后生成一组多边形的破碎子几何体。这一概念是RBS/刚体动力学程序化破碎的核心。\nB.CSG Constructive Solid Geometry\n这是一种已经存在多年的技术。它使用简单加法、减法和异或运算。这些数学运算称为布尔运算，这个方法称为构造立体几何或CSG。它可以在三维模型之间执行体积运算，使几个简单的几何图形或对象构建为更复杂、更自然的细分形状。可以将两个体积相加，或计算两个对象之间的差值，或求它们的交集。这些操作可以将原始三维模型分解为更小的部分，类似于饼干切割器。这个方法的优点是可以精确控制物体破碎后的几何形状，缺点是操作繁琐，不够程序化，并且在多边形中进行布尔运算容易出现问题。\nC.凸分解 Convex Decomposition\n“convex”一词的意思是向外弯曲或凸出，与向内弯曲的concave相反。凸分解是一种通常用于将复杂模型简化为更易于处理的较小子模型的技术。凸分解将一个复杂多面体划分为多个凸面几何体。由于凸对象的重要性质，许多算法在凸对象上比在非凸对象上更有效。因此，此种方法处理的几何体主要用于计算碰撞检测。艺术家可以使用简单的凸面图元（如长方体、球体和胶囊）手动创建凸面分解。也可以自动创建凸分解。\nD.四面体化 Tetrahedralization\n这种处理几何体的方法用于有限元分析，在传统的RBS流程中不会使用。但因这也是预处理几何体的方法之一，故在此做简单介绍。一个mesh可以使用德洛内（Delaunay）三角剖分分解为四面体网格。有一些开源软件实现可用，包括Netgen和Tetgen。Pixelux的Maya 2012 DMM数字分子物质插件在内部使用Netgen执行四面体化。\n第二阶段：设置约束并控制约束力的大小\n在几何体准备好并分解为预破碎的小块后，如果直接进行模拟，它们就是一个个独立的碎块，还没来得及发生外力的碰撞，就在重力的作用下发生坍塌了。因此，在预破碎几何体后，还需要一个方式将它们约束在一起。直到外力超过了约束的限制时，约束才会消失，从而看起来发生了破碎。\n设置约束的两种方法 A.定义每个部件和其他部件之间的连接。 B.基于碰撞检测自动计算连接。 A.定义每个部件和其他部件之间的连接。\n这提供了最多的控制，但如果连接太多，性能可能会比较慢。如果使用维诺图的方法进行预破碎，可以自然而然地得到各个子几何体的连接。因为维诺图使用的是代表子几何体的点云，每个点的连接就是子几何体的连接。因此很容易对连接进行程序化约束。\n现在，如果艺术家想要控制建筑的哪一侧倒塌，他们可以在约束上进行“绘制”，这是RBS设置的一部分。约束基本上是指导模拟的，比如说我们可以手动添加metaball来控制某一个区域的约束力大小，来削弱这个对象在这一帧这个区域内的所有约束。\nB.基于碰撞检测自动计算连接。\n计算相邻碎块之间的接触点，并且仅在存在接触点时创建连接。然后，你可以为这些连接创建中断阈值。一旦我们将这些片段粘合成一个刚体，我们就可以执行运行时断裂。如果发生碰撞，我们计算其冲量。如果该冲量大于所选阈值，我们将通过连接来传播该冲量。这些连接可能会减弱或断开。在此之后，需要确定断开连接的碎块，然后为每个单独的碎块创建新刚体。\n放射状破碎就是一个很好的例子。某些类型的玻璃在破裂时会出现维诺图无法立即提供的径向图案。此效果可以通过蒙版或break maps提供。径向裂纹是需要解决的较为典型的特殊情况之一。它们既有从碰撞点辐射的裂纹，也有围绕碰撞点的圆形裂纹。Dneg使用Dn-crack，这是一种程序化表面破碎器。它不像voronoi破碎器那样进行固体体积破碎，而是进行多边形表面破碎。\n它的工作原理是用户提供一组用脚本编写的规则，这些规则描述裂纹如何出现在表面上，如何传播到子裂纹，以及每个裂纹如何生成，然后底层代码根据这些规则在表面上生成这些裂纹，将它们相交，重要的是在裂缝交汇处终止，等等。然后最终的设定是它将所有几何体分割为最终的破碎碎块。\n第三阶段：运行模拟和碰撞检测\n碰撞检测最简单形式是Bounding Box。如果所有对象都包含在简单的boxes中，则避免boxes重叠从而避免物体碰撞。问题是，虽然这非常快，但大多数简单的长方体通常会生成过大的形状，无法生成高质量的模拟。显然，肉眼看起来不太靠近的物体似乎仍然会相互反弹。那么我们该怎么做才能使碰撞看起来尽可能精准，并且不太消耗算力呢？\n大多数碰撞检测管道中分为两个主要阶段，分别是broad-phase和narrow-phase。\nBroad-phase:\nBroad-phase阶段根据边界体积重叠（bounding volume overlap）减少潜在交互对象的总数。Bullet中有各种不同用途的broad-phase实现。最通用的broad-phase实现是基于动态边界体积层次结构（dynamic bounding volume hierarchies）：移动、添加或删除对象时更新轴对齐包围盒（axis aligned bounding box）。\n总的来说，就是先使用一个算法找到可能发生碰撞的物体，从而减少不必要的计算。\nNarrow-phase:\nNarrow-phase阶段处理的是成对碰撞对象之间精确接触点的生成。\nA.标准RBS方法\n最流行的解决方案是将主对象细分为一组较小的对象，但都是单独凸面的。这称为凸壳碰撞检测（Convex hull collision detection）。\nBullet使用了一些通用算法，如GJK（Gilbert–Johnson–Keerthi）来实现两个凸面形状之间的快速距离，并处理各种碰撞形状类型。支持计算移动和旋转对象之间碰撞时间的连续碰撞检测，但默认情况下Bullet计算离散时间点的最近距离和穿透深度，以生成接触点信息或进行碰撞检测。\n在确定可能发生碰撞的物体对后，将物体替换为它的凸壳，计算两个凸壳之间的距离以生成接触点信息。使用凸壳来计算是为了加快计算的速度，是模拟质量和模拟速度妥协的结果。\nB.水平集方法\n有向距离场的概念\n水平集的基本概念\n水平集数据结构用于表示离散采样的动态水平集函数。这种形式的数据结构通常用于高效的图像渲染。基本方法是构造一个从边界延伸的有向距离场，并可用于解算该场中边界的运动。\n“术语‘LSV’（level set value，水平集值）实际上是一个隐式曲面，用于模拟中的碰撞对象的倾向。PhysBAM使用水平集数据结构来实现它的narrow-phase 碰撞检测。当查询粒子与几何曲面的距离时，水平集具有快速查找的良好特性。PhysBAM使用的水平集数据结构将几何体的空域划分为box cells，每个cell存储其到曲面的距离（φ）。从附近cells的集合中，我们可以计算梯度场，该梯度场产生指向几何体表面的法向量。通过水平集上的法向量和φ函数，我们可以计算到几何体表面的精确距离。”\n通过查看这些向量和法线，可以判断你是在碰撞检测对象的内部还是外部。然后，ILM进一步利用这一点，使用水平集进行破碎。使用水平集可以轻松完成的一件事是在物体表面行走。我已经将所有空间分割成一个网格，在任何一点我都可以显示”我离表面有多近“，如果我不知道，那么我可以使用网格查找信息直接到达表面。”\n对于单个物体，当粒子进入碰撞检测包围盒时，为物体设置一个水平集，很容易确定粒子是位于物体的内部还是外部，因此，粒子从物体上更精确地反弹，而不仅仅是从包围盒上反弹。但在破碎中，ILM并没有以同样的方式使用水平集，水平集不是表示单个对象，而是表示一组或一组称之为zero iso contours的点，这些点在水平集中实际位于曲面上。\nZero iso contours与voronoi等破碎工具非常相关。Voronoi点是用来破碎对象的，但ILM获取Voronoi点，然后找到刚好在模型曲面上的点，因为Voronoi种子点云通常不知道表面在哪，它只是负责将空间分割开，但在ILM中，水平集将这种分割带到下一个级别，不基于水平集创建子几何体，而是直接使用水平集分割高分辨率的几何图形。\n斯坦福大学PhyBAM模拟软件的碰撞检测都基于水平集方法，基于SIGGRAPH 2003中Eran Guendelman的Nonconvex Rigid Bodies with Stacking（非凸刚体的堆叠）。他们的RBS要求你有一个体积，以便对象正确碰撞，因此他们在模拟开始时使用水平集方法生成此体积数据结构，在模拟期间，他们将使用刚体表面的粒子来测试它们可能与之交互的对象的水平集的深度。它的分析查找速度很快，水平集的优点是，在空间中的任何一点，我都可以快速且准确地告诉你离曲面有多远，因此它是一个很好的碰撞查找模型。但缺点是它需要很长的时间生成，并且水平集的存储空间以立方方式增加。\n幸运的是，水平集可以更改分辨率，ILM可以轻松控制此级别的精度。当你想让事情变得更复杂时，你必须不断增加水平集的存储空间。因此，与其他方法一样，ILM的艺术家和TD需要非常谨慎地在时间和准确性之间进行权衡。\n3.有限元分析 Finite Element Analysis FEA是一种物理上更精确的制作Destruction的方法，它使用有限元方法(finite element method)来求解控制弹性材料的动力学的偏微分方程。FEA是模拟变形的一种物理上更正确的方法，破碎是基于连续介质力学的。一个3D mesh是用一组元素来近似的，通常是四面体。应变、应力和刚度矩阵用于计算力和变形的影响。\n有限元法\n有限元法最初被称为矩阵近似方法，应用于航空器的结构强度计算，并由于其方便性、实用性和有效性而引起从事力学研究的科学家的浓厚兴趣。经过短短数十年的努力，随着计算机技术的快速发展和普及，有限元方法迅速从结构工程强度分析计算扩展到几乎所有的科学技术领域，成为一种丰富多彩、应用广泛并且实用高效的数值分析方法。\nFEA由R.Courant于1943年首次开发，并在20世纪70年代和80年代用于制造业，但直到21世纪10年代才找到了实现视觉效果的方法。MPC是FEA在视觉效果工作中的主要公司之一。“有可能这项技术现在才足够快，可以使用，别忘了RBS在VFX中花了相当长的时间才被采用。”\nFEA使用一个称为节点的复杂点系统，该节点构成称为mesh的三维网格。该网格被设计并包含材料和结构属性，这些属性定义了结构如何对特定荷载条件作出反应。根据特定区域的预期应力水平，在整个材料中以特定密度指定节点。承受大量应力的区域通常比承受很少或没有应力的区域具有更高的节点密度。网格就像一张网络，每个节点都延伸一个网格单元到每个相邻节点。这张矢量网将材质属性带到对象上，创建了许多单元。\nDMM系统 Digital Molecular Matter system\n问题是，有限元分析曾经的计算非常昂贵。但一个新的系统诞生了。Pixelux是DMM数字分子物质系统的开发者，该系统使用基于有限元的方法处理柔体，使用四面体网格，并将应力张量直接转换为节点力。通过一些非常聪明的假设和技巧，DMM是可以是实时的。\nDMM是从2004年开始，在六年半的时间里为电子游戏设计的。从2005年到2008年，作为《星球大战：原力释放计划》的一部分，Pixelux DMM技术是卢卡斯艺术娱乐公司的独家技术。DMM中的有限元系统利用了加利福尼亚大学伯克利教授，James F. O’Brien博士论文中的破碎和变形算法。Pixelux首席技术官Eric Parker领导的团队对O’Brien算法进行了改进、优化，并将其应用到DMM中间件中，Pixelux首席执行官Mitchell Bunnell领导的团队设计了DMM工具流程。\n与传统的基于刚体运动学的实时仿真引擎不同，FEA允许DMM非常快速地模拟大量的物理特性。开发人员可以给给定的对象分配物理属性，从而允许对象像在现实世界中一样行为。此外，对象的属性可以在运行时更改，从而产生更多有趣的效果(参见下面的“chopping”)。\nMPC的Kali destruction tool\n《美少女特工队》中，巨武士战役中有大量木头破碎的镜头，木头的破碎不同于刚体，木头具有大量的形变能力。传统的RBS并不能达到预期的效果。MPC看到在SIGGRAPH中使用四面体FEA进行实时应用的文章，他们认为，如果FEA可以通过实时实现，那么如果再深入研究一下，说不定在VFX中就可以实现。”MPC直接与Pixelux合作，在他们自己的代码中使用Pixelux的解算器。\n碰撞检测通常是由包围盒或凸面外壳（和水平集体积）实现的，但在FEA中，实际上完全使用网格，然后执行“tet-collision detection（四面体网格碰撞检测）”。原始对象完全包围在固定大小或分辨率的四面体网格（ tetrahedral mesh）中，这是一种基于速度/效率原因的非自适应网格解决方案。一个tet和另一个tet之间的碰撞检测比任意凸面和凸面的检测简单得多。\ntet网格与物体几何体不同，但它很接近。但由于tet的数量是固定的，因此必须将细节放在你认为可能需要的地方。你可以做一个自适应解决方案，使解算器在物体破裂时切换并添加更多细节，但实际上，在帧间进行比较是相当困难的。但是如果你知道tet的数量是固定的，你可以使用它进行比较。MPC使用该技巧进行render time chopping。“render time chopping”指的是模拟使用固定分辨率的网格，在渲染时将几何体替换为完全不同的几何体的能力。\n在FEA中没有预破碎，没有voronoi或切割，从某种意义上说，这是一个更纯粹的解决方案。tet连接在一起，形成一个大的组，其中有一个共同的节点。该点被定义为具有一定的强度、结构鲁棒性，如果超过阈值，则会断开该连接。用tet填充体积的算法具有一定的随机性，足以满足需要。艺术家可以控制tet的密度，但精确的顶点在材质内部。\nFEA的优点：基于材料属性破碎。\n破碎将取决于物体受力的方式。这是基于材料属性的，在传统的RBS方法中，在模拟发生前物体就已经被破碎了。你不需要使用FEA来实现这一点，因为你有明确的内力，因此碎块会按照你想要的方式，以及它应该的方式断裂。\nFEA的控制：\nMPC有一个大小限制，它可以控制最小碎片的大小，以免物体变成粉末。\n仍然可以预先破坏某些物体。MPC的TD基于voronoi贴图制作密度贴图，可以影响节点的密度云，但系统仍然基于实际材质断裂。\nFEA的附加效果：\n模拟的物体可以发生符合物理的塑性变形。结构蠕变、塑性或弹性变形可以作为标准系统的一部分进行，不需要任何造假和技巧。在MPC，艺术家可以通过对具有塑性变形的“钢”施加力来弯曲钢梁。\nMPC系统更简单，弯曲效果不需要单独进行设置，传统的RBS需要对每一个不同的材质进行特殊的绑定和预破碎。而MPC将所有物体都放在一个tet网格框架中。所有模拟都可以统一进行，并且通过rendertime chopping，随时可以替换框架中的几何体。这种抽象级别非常强大。\n这个概念与传统的自由变形晶格（Free Form Deformation lattice, FFD）类似。FFD框架可以使其内部的任何几何体变形，因此很容易想象弯曲框架然后交换内部的几何体——可以从低模转换为高模。虽然将高分辨率几何体切分为与tet网格相对应的碎块非常昂贵，但因为tet网格不会改变，只需在最后一帧执行一次，然后就可以在整个模拟过程中将其应用到每一帧的动画中。\n为什么其他公司没有使用有限元分析\n1.员工和整个软件系统需要重新培训和重建。目前为止，还没有发现需要改变。\n2.虽然传统RBS需要更多的设置，但是性能比FEA强很多。\nDestruction 方法总结 所有方法都是为了获得银幕上真实的效果。只要结果达到了，使用什么方法都是可行的。但随着计算力的发展，更符合物理的方法是必然的趋势。但就目前而言，是特效TD和动画师的技术、艺术以及经验使得影片的真实感达到了如此高的水平。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%88%9A%E4%BD%93%E7%B3%BB%E7%BB%9F-bylly/","summary":"注：本篇由同组同学LLY编写，本人代完成格式化\n刚体 在物理学里，刚体是一种形变为0，或者形变可以忽略的固体。理想刚体在运动中和受到力的作用后，形状和大小不变，而且内部各点的相对位置不变。这种物体不可能实际存在，但固体通常可以假定为刚体。所以我们使用刚体来对固体进行模拟。在模拟时，我们通常使用Mesh来表示一个刚体。\n刚体属性与表达 为了表示一个刚体，我们首先需要知道刚体的质心。在这里因为篇幅限制，我们不讨论质心是如何求得的，把质心当作已知量就可以了。质心有三维坐标 \\(\\mathbf x\\) 和速度 \\(\\mathbf v\\) 。其次，刚体还需要定向。选择一个相对刚体固定，原点在刚体质心的坐标系，称为局部坐标系。刚体及模拟的其他对象被放置在世界坐标系中。\n质心 为了指定刚体在世界坐标系中的放置方式，我们指定其位置 \\(\\mathbf x\\) 和 方向 \\(R\\) 。局部坐标为 \\(\\mathbf p_0\\) 的点，世界坐标系下的坐标为：\\(\\mathbf p = \\mathbf x + R \\mathbf p_0\\)\n物体坐标系和世界坐标系 我们想知道这个点在世界坐标系中如何随时间变化，所以对时间进行求导，得出： $ = + R + p_0 $\n因为在局部坐标系中 $ $ = 0 , 所以得出： $ = v + p_0 $\n所以我们只需要求出每个时间的 \\(\\mathbf v\\) 和 $ $ 就可以描述刚体随时间的运动状态了。\n为了确定方向的变化率，需要引入角速度的概念。角速度通常表示为三维矢量。方向代表旋转轴，大小代表旋转的快慢，通常以弧度/秒为计量单位。\n角速度 我们知道 \\(R\\) 的列是刚体坐标系的坐标轴的方向向量在世界坐标系下的坐标，因此， $ $ 由这些方向向量的导数组成： \\[ \\displaystyle\\dot{R} = [\\dot{\\hat{u_x}}\\quad\\dot{\\hat{u_y}}\\quad\\dot{\\hat{u_z}} ] \\] 于是 \\(\\dot{R}\\) 就被简化成为求旋转矢量的导数的问题。旋转中心位置是 \\(\\mathbf x\\) ，旋转点位置是 \\(\\mathbf p\\) ，旋转中心到位置 \\(\\mathbf p\\) 的向量为 \\(r\\) 。我们的目的是测定 \\(r\\) 的变化率。由于 \\(\\mathbf p\\) 以角速度 \\(\\omega\\) 旋转，所以其瞬时速度与 \\(r\\) 和 \\(\\omega\\) 垂直。瞬时速度方向由 \\(\\omega\\times r\\) 表示，大小与向量积大小一致。于是我们可以得到： $ = r$","title":"2021-12-05-影片技术分析Pre-基于物理的动画-刚体系统-byLLY"},{"content":"影视制作中的最新进展与应用 学术界发展动向 在讨论影视工业中物理模拟的最新方向之前，我们先看看学界这两年都在做什么——技术的发展顺序大部分情况下都是先从学术界开始的。\n我整理出了近三年国际图形学顶级学术会议Siggraph发表的论文中，基于物理的动画方向的所有论文：\nSiggraph 2021 Revisiting Integration in the Material Point Method: A Scheme for Easier Separation and Less Dissipation 重新审视物质点法（MPM）：更易分离、更少耗散的方法 Mechanics-Aware Deformation of Yarn Pattern Geometry 纱织物几何体的力学感知变形 Kelvin Transformations for Simulations on Infinite Domains 无限域模拟的开尔文变换 QuanTaichi: A Compiler for Quantized Simulations QuanTaichi：一种量化模拟编译器 A Unified Second-Order Accurate in Time MPM Formulation for Simulating Viscoelastic Liquids with Phase Change 相变粘弹性液体模拟的统一二阶时间精确MPM公式 Bijective and Coarse High-Order Tetrahedral Meshes 双射和粗高阶四面体网格 Physical validation of simulators in Computer Graphics: A new framework dedicated to slender elastic structures and frictional contact 计算机图形学模拟器的物理验证：一种细长弹性结构和摩擦接触的新型框架 Stream-Guided Smoke Simulations 流向烟雾模拟 Solid-Fluid Interaction with Surface-Tension-Dominant Contact 表面张力主导接触的固液相互作用 Fire in Paradise: Mesoscale Simulation of Wildfires 天堂之火：野火尺度模拟 Systematically Differentiating Parametric Discontinuities 系统区分参数不连续性 Thin-Film Smoothed Particle Hydrodynamics Fluid 薄膜平滑粒子流体动力学（SPH）流体 Clebsch Gauge Fluid Clebsch规范流体 Incompressible Flow Simulation on Vortex Segment Clouds 涡段云上的不可压缩流体 Codimensional Incremental Potential Contact 共维增量潜在接触（C-IPC） Intersection-free Rigid Body Dynamics 无交点刚体动力学 Medial IPC: Accelerated Incremental Potential Contact With Medial Elastics Medial IPC：结合Medial Elastics的IPC方法 High-order Differentiable Autoencoder for Nonlinear Model Reduction 非线性模型重建的高阶可微自动编码器 Fast Linking Numbers for Topology Verification 拓扑验证的快速链接数 of Loopy Structures 环状结构 Learning Contact Corrections for Handle-Based Subspace Dynamics 基于句柄的子空间动力学的接触修正学习 The Shape Matching Element Method: Direct Animation of Curved Surface Models 形状匹配元素方法：曲面模型的直接动画 GPU-Based Simulation of Cloth Wrinkles at Submillimeter Levels 基于 GPU 的亚毫米级布料皱纹模拟 Multiscale Cholesky Preconditioning for Ill-conditioned Problems 病态问题的多尺度Cholesky预处理 A Momentum-Conserving Implicit Material Point Method for Surface Tension with Contact Angles and Spatial Gradients 具有接触角和空间梯度的表面张力动量守恒隐式材料点法 SANM: A Symbolic Asymptotic Numerical Solver with Applications in Mesh Deformation SANM：网格变形中应用的符号渐近数值求解器 Learning Meaningful Controls for Fluids 流体有意义控制学习 Unified Particle System for Multiple-fluid Flow and Porous Material 多流体流动和多孔材料的统一粒子系统 Constrained Projective Dynamics: Real-time Simulation of Deformable Objects With Energy-momentum Conservation 约束投影动力学：能量-动量守恒的可形变物体的实时模拟 TOG:\nDynamic Upsampling of Smoke through Dictionary-based Learning 烟雾动态上采样的基于字典的学习 Frictional Contact on Smooth Elastic Solids 光滑弹性固体的摩擦接触 A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions 一种安全快速的基于GPU的布料自碰撞排斥方法 Optimized Refinement for Spatially Adaptive SPH 空间自适应SPH的优化细化 SIERE: A Hybrid Semi-implicit Exponential Integrator for Efficiently Simulating Stiff Deformable Objects SIERE：刚性可形变对象有效模拟的混合半隐式指数积分器 SIGGRAPH 2020 Homogenized Yarn-Level Cloth 均质纱织物 A Model for Soap Film Dynamics with Evolving Thickness 变化厚度的皂膜动力学模型 Fast and Scalable Turbulent Flow Simulation with Two-Way Coupling 双向耦合的快速可扩展湍流模拟 Constraint Bubbles and Affine Regions: Reduced Fluid Models for Efficient Immersed Bubbles and Flexible Spatial Coarsening 约束气泡和仿射区域：有效浸入气泡和灵活空间粗化的简化流体模型 Robust Eulerian-on-Lagrangian Rods 具有鲁棒性的EoL棒 Lagrangian Neural Style Transfer for Fluids 流体的拉格朗日神经风格迁移 NASOQ: Numerically Accurate Sparsity-Oriented QP Solver NASQQ：数值精确的面向稀疏性的QP求解器 A Massively Parallel and Scalable Multi-GPU Material Point Method 一种大规模并行和可扩展的多GPU物质点法 Projective Dynamics with Dry Frictional Contact 干性摩擦接触的投影动力学 N-Dimensional Rigid Body Dynamics N维刚体动力学 Incremental Potential Contact: Intersection- and Inversion-free, Large-Deformation Dynamic 增量潜在接触（IPC）：无交点无反转大变形动力学 Fast Tetrahedral Meshing in the Wild 自然环境快速四面体网格化 Chemomechanical Simulation of Soap Film Flow on Spherical Bubbles 肥皂膜在球形气泡上流动的化学动力学模拟 Wave Curves: Simulating Lagrangian Water Waves on Dynamically Deforming Surfaces 波曲线：模拟动态变形表面上的拉格朗日水波 An Implicit Compressible SPH Solver for Snow Simulation 一种雪体模拟的隐式可压缩SPH求解器 Codimensional Surface Tension Flow Using Moving-Least-Squares Particles 使用移动最小二乘粒子的共维表面张力流 AnisoMPM: Animating Anisotropic Damage Mechanics AnisoMPM：各向异性损伤力学动画 A Level-Set Method for Magnetic Substance Simulation 一种磁体模拟的水平集方法 Phong Deformation: A Better C0 Interpolant for Embedded Deformation Phong变形：一种更好的嵌入变形C0插值方法 Simple and Scalable Frictional Contacts for Thin Nodal Objects 薄节点对象 A Practical Octree Liquid Simulator With Adaptive Surface Resolution 一种具有自适应表面分辨率的实用八叉树液体模拟器 Adaptive Merging for Rigid Body Simulation 刚体模拟的自适应合并 IQ-MPM: An Interface Quadrature Material Point Method for Non-sticky Strongly Two-way Coupled Nonlinear Solids and Fluids IQ-MPM：一种非粘性强双向耦合非线性固体和流体的接口正交物质点方法 TOG:\nHierarchical Optimization Time Integration for CFL-rate MPM Stepping CFL率物质点法步进的分层优化时间积分 Medial Elastics: Efficient and Collision-ready Deformation via Medial Axis Transform Medial Elastics：通过中性轴变换的高效可碰撞变形 VoroCrust: Voronoi Meshing without Clipping VoroCrust：无需裁剪的Voronoi网格化 SIGGRAPH 2019 Anisotropic Elasticity for Inversion-Safety and Element Rehabilitation 反转安全、元素恢复的各向异性弹性 CD-MPM: Continuum Damage Material Point Methods for Dynamic Fracture Animation CD-MPM：动态断裂动画的连续损伤物质点法 Silly Rubber: An Implicit Material Point Method for Simulating Non-equilibrated Viscoelastic and Elastoplastic Solids Silly Rubber：模拟非平衡粘弹性和塑弹性固体的隐式物质点法 Decomposed Optimization Time Integrator for Large-Step Elastodynamics 大步长弹性动力学的分解优化时间积分器 Efficient and Conservative Fluids Using Bidirectional Mapping 使用双向映射的高效保守流体 On Bubble Rings and Ink Chandeliers 气泡环和水墨吊灯 Mixing Sauces: A Viscosity Blending Model for Shear Thinning Fluids Mixing Sauces：一种剪切稀化流体的粘度 On the Accurate Large-scale Simulation of Ferrofluids 磁流体的大规模精确模拟 An Adaptive Variational Finite Difference Framework for Efficient Symmetric Octree Viscosity 一种高效对称八叉树粘度的自适应可变有限差分方法 REDMAX: Efficient and Flexible Approach for Articulated Dynamics REDMAX：铰接体动力学的高效灵活方法 Fundamental solutions for water wave animation 水波动画的基础解决方案 Implicit Untangling: A Robust Solution for Modeling Layered Clothing 隐式分解：一种分层服装建模的稳健解决方案 Harmonic Triangulations 谐波三角化 Hand Modeling and Simulation Using Stabilized Magnetic Resonance Imaging 使用稳定磁共振成像的手部建模和模拟 TOG:\nAnalytic Eigensystems for Isotropic Distortion Energies 各向同性畸变能量的解析特征系统 Editing Fluid Animation using Flow Interpolation 使用流插值编辑流体动画 Interlinked SPH Pressure Solvers for Strong Rigid-Fluid Coupling 强刚性流体耦合的互连SPH压力求解器 Efficient and Accurate Collision Response for Elastically Deformable Models 弹性可形变模型的高效准确碰撞响应 Poly-Spline Finite Element Method 多边形样条有限元方法 我们可以看到，其中就有我们刚刚提到的MPM方法的数学论证和进一步优化。整理下来，整体来说主要有以下几个方面的工作：\n特殊材料、特殊问题的新型算法 更加精确的模拟算法 GPU/数学优化加速算法 某个方法的数学物理原理 那么我们就前三个（很显然数理原理的分析对我们制作不会太重要：我们知道方法对就行）讨论一下在我们电影制作中的发展方向。\n第一个，特殊材料、特殊问题的新型算法。参考《冰雪奇缘》对MPM的应用，我认为这类方法投入工业一般是具备了这两个条件：影片中出现了大量该特殊材料的镜头需要模拟；制作者具备足够的科研能力和时间成本、金钱成本去做工程化实践。因此，这件事我了解到的通常只会出现在一家公司的动画影片中，那就是Disney，尤其是旗下的Pixar公司。Disney不仅拥有非常棒的动画团队，还拥有目前全球可以说最强大的图形学科研团队Disney Research，前面的大量论文那就是他们产出的。同时他们还具有良好的营收情况，适合各种新方法实践的动画创意型影片生产线。这些条件都是很难复刻的。\n第二个，更精确的模拟算法。大家都知道，我们做娱乐用途的图形学领域有一句话说：“如果它看起来是对的，那么它就是对的”，我们观影看到各种大楼轰塌、水漫金山，也只是为了“好看”，而不会说“这滴水真的能溅到这么远吗，让我算算”。因此，我认为在模拟方法达到一定精确性的情况下，更精确的模拟算法对影视工业的意义并不很大。更多的用于工业生产的仿真工作中，例如导弹的弹道计算、桥梁的受冲击能力等等，这些更加需要精确性的行业。关于这一点大家也可以提出自己的看法。\n最后一个GPU/数学优化加速算法，我认为是对目前影视制作意义最大的一个方向，说白了就是更快。目前视效与动画制作最大的问题就在于速度，无论是物理模拟还是渲染，都是调整一次等待许久才能看到结果的一个离线工作流——当然渲染依托于GPU的渐进式渲染已经可以在很短的时间内看到结果，甚至借助实时渲染引擎已经开始有机会实现所见即所得的实时工作流。而基于物理的动画环节却还差得很远，我认为，物理模拟的实时化也是必然的趋势。\n影视/游戏中的物理模拟：实时化的发展趋势 在目前的影视/游戏的FX（特效）中，只有少数游戏具有简单的实时的交互物理动画，例如角色的Ragdoll系统（死亡后自然倒下）、刚体的掉落碰撞、简单的流体交互等等。大部分物理动画都是预先模拟完烘焙好的动画序列。那么在影视制作中，实时的物理模拟能够为哪些流程带来优势呢？\n传统的视效/动画工作流 在传统的视效/动画制作中，FX的制作方式前面已经提到。我在这里可以给大家演示一个简单的物理模拟程序，仅仅几十个节点组成的一个场景模拟，在我的5950X主机上，计算一帧就需要约4-6秒的时间。而在我们的影视制作中，一个镜头可能是几百个、甚至上千个节点组成的，其模拟的时间可想而知。在这种情况下，反复地调整参数是一件非常痛苦的事情，很多情况下，就只能靠经验判断。\n通过GPU或算法的优化、模型的简化提高模拟速率（甚至达到实时）在这里起到的作用和渲染领域中相似：预览和最终的高质量输出分离，用简化后的快速方法来获得预览画面——预览画面的基本动画要能保证与最终效果是一致的。如此，我们的FX艺术家就可以通过参数的调整，实时地来看参数的结果，从而细致化地调参，来达到更加精细的结果。\n电影虚拟化制作 电影虚拟化制作是相对较新的制作方式，从On-set Previz（实时交互预演）到今天的基于LED背景墙的电影虚拟化制作，实时渲染的内容的重要性进一步提升。\n在On-set Previz中，我们用实时渲染画面作为预览用的合成背景。在绿幕拍摄现场，通过摄影机跟踪将真实摄影机与实时渲染引擎中的摄影机绑定，使得现场画面的与实时渲染画面的运动匹配，再将绿幕画面实时抠像后作为前景、实时渲染画面作为背景实时合成输出至监看设备，提供给现场制作人员参考。这一流程中的实时渲染背景仅作为现场的制作者预览使用，不会作为真实的成片内容。因此，无论是模拟还是渲染的精度都不需要很高，目的在于告诉摄影师“爆炸的炸点在这”。因此在On-set Previz中应用游戏中常见的简单交互特效是可行的。这样我们可以设计与实时渲染引擎交互的触发装置，让演员能够比较轻松地判断与虚拟物体的交互。\n而在基于LED背景墙的电影虚拟化制作中，实时渲染画面需要用于最终成片。在On-set Previz的基础上，我们将实时渲染的场景通过mapping的方式投影至LED背景墙上，那么摄影机内就能直接拍摄得到正确透视、视差的背景画面，我们称为“摄影机内视效拍摄”，直接就完成了合成工作。这也意味着，我们实时渲染引擎产出的画面要用于最终的成片了，对资产的质量要求大大提高了——因此目前，涉及到基于物理的动画的资产，都是预先完成模拟计算、烘焙成动画的，仅在引擎中设计触发播放，无法产生交互。因而，我们也期待着物理模拟的实时化、以及实时化模拟的结果可以很快地转换至Mesh完成实时的光照与渲染，从而实现基于LED背景墙的电影虚拟化制作中的交互物理动画。\n总结 通过今天的课程，希望能给大家带来对基于物理的动画的一些认识。我们从视效/动画制作中的FX流程，到粒子、刚体、流体为代表的各种模拟系统发展及其在各类影片中的应用案例，最后我们畅想了一下基于物理的动画在影视工业应用中的发展方向。也算是基本涵盖了基于物理的动画的方方面面了。\n我们知道，这门课的内容对大家相对来说有些难，有很多的数学公式、很多的程序代码，要相信，课程的内容对我们俩也是困难的，但我们这几个月来不断地啃书本、Paper、代码，坚持着看教程、做实验，然后尽可能地为大家做简化——已经省去了大量的推导、求解和程序。最后，呈现到大家面前这样一个还算笼统的一个Pre，我们不求大家能完全听懂这个Pre的每一部分，只希望如果我们能展现那么几分在计算机中、在电影中重现物理世界这件事的魅力，能够让同学们对这个领域不再陌生，当进入行业后，如果有人提起相关的话题、工作中遇到相关的问题，可以想到当年有两位同学为我们介绍过，能应和两声，或者是回头想到我们这次提到的一些方法，去搜索学习就已经再好不过了。\n最后，我们不可免俗地cue一下近期的热点。我们现在讨论在电影中重现物理世界，电影是一个二维的视觉内容，我们现在经常说要拓展我们的维度、拓展我们的感官，也就是三维的、多种感官交互的内容——也就是我们正在向着电影《头号玩家》的绿洲那样的内容迈进，或者说热点词汇就是我们的“元宇宙”，也就是在虚拟世界中重现物理世界，用到的仍然会是我们今天讨论的这些技术，所以我觉得基于物理的动画既是一个已经发展了数十年的技术领域，也是正在蓬勃发展中，将为我们未来的“元宇宙”提供基础物理定律的一个高新领域。期待引领我们俩进入图形学世界的闫令琪老师口中的“无限月读”的世界能够早日实现，谢谢大家。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%9C%80%E6%96%B0%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/","summary":"影视制作中的最新进展与应用 学术界发展动向 在讨论影视工业中物理模拟的最新方向之前，我们先看看学界这两年都在做什么——技术的发展顺序大部分情况下都是先从学术界开始的。\n我整理出了近三年国际图形学顶级学术会议Siggraph发表的论文中，基于物理的动画方向的所有论文：\nSiggraph 2021 Revisiting Integration in the Material Point Method: A Scheme for Easier Separation and Less Dissipation 重新审视物质点法（MPM）：更易分离、更少耗散的方法 Mechanics-Aware Deformation of Yarn Pattern Geometry 纱织物几何体的力学感知变形 Kelvin Transformations for Simulations on Infinite Domains 无限域模拟的开尔文变换 QuanTaichi: A Compiler for Quantized Simulations QuanTaichi：一种量化模拟编译器 A Unified Second-Order Accurate in Time MPM Formulation for Simulating Viscoelastic Liquids with Phase Change 相变粘弹性液体模拟的统一二阶时间精确MPM公式 Bijective and Coarse High-Order Tetrahedral Meshes 双射和粗高阶四面体网格 Physical validation of simulators in Computer Graphics: A new framework dedicated to slender elastic structures and frictional contact 计算机图形学模拟器的物理验证：一种细长弹性结构和摩擦接触的新型框架 Stream-Guided Smoke Simulations 流向烟雾模拟 Solid-Fluid Interaction with Surface-Tension-Dominant Contact 表面张力主导接触的固液相互作用 Fire in Paradise: Mesoscale Simulation of Wildfires 天堂之火：野火尺度模拟 Systematically Differentiating Parametric Discontinuities 系统区分参数不连续性 Thin-Film Smoothed Particle Hydrodynamics Fluid 薄膜平滑粒子流体动力学（SPH）流体 Clebsch Gauge Fluid Clebsch规范流体 Incompressible Flow Simulation on Vortex Segment Clouds 涡段云上的不可压缩流体 Codimensional Incremental Potential Contact 共维增量潜在接触（C-IPC） Intersection-free Rigid Body Dynamics 无交点刚体动力学 Medial IPC: Accelerated Incremental Potential Contact With Medial Elastics Medial IPC：结合Medial Elastics的IPC方法 High-order Differentiable Autoencoder for Nonlinear Model Reduction 非线性模型重建的高阶可微自动编码器 Fast Linking Numbers for Topology Verification 拓扑验证的快速链接数 of Loopy Structures 环状结构 Learning Contact Corrections for Handle-Based Subspace Dynamics 基于句柄的子空间动力学的接触修正学习 The Shape Matching Element Method: Direct Animation of Curved Surface Models 形状匹配元素方法：曲面模型的直接动画 GPU-Based Simulation of Cloth Wrinkles at Submillimeter Levels 基于 GPU 的亚毫米级布料皱纹模拟 Multiscale Cholesky Preconditioning for Ill-conditioned Problems 病态问题的多尺度Cholesky预处理 A Momentum-Conserving Implicit Material Point Method for Surface Tension with Contact Angles and Spatial Gradients 具有接触角和空间梯度的表面张力动量守恒隐式材料点法 SANM: A Symbolic Asymptotic Numerical Solver with Applications in Mesh Deformation SANM：网格变形中应用的符号渐近数值求解器 Learning Meaningful Controls for Fluids 流体有意义控制学习 Unified Particle System for Multiple-fluid Flow and Porous Material 多流体流动和多孔材料的统一粒子系统 Constrained Projective Dynamics: Real-time Simulation of Deformable Objects With Energy-momentum Conservation 约束投影动力学：能量-动量守恒的可形变物体的实时模拟 TOG:","title":"2021-12-05-影片技术分析Pre-基于物理的动画-最新进展与应用"},{"content":"流体系统 最后，在相对简单的前两个部分介绍后，我们还是不得不面对一个需要更多数学的系统，流体。\n流体与流体力学 首先第一个问题是什么是流体。流体的定义是在承受剪应力（物体在外力作用时，内部任一截面上会出现的相互作用力，“内力”）时将会发生连续变形的连续介质，包括气体和液体。\n所有液体 所有气体 具备流动特征的固体：如沙丘 流体主要具备以下性质：\n流动性（fluidity）：流体间的分子作用力较小，难以保持一定的形状，在受到外界的作用力或能量不平衡时，流体会发生流动。\n变形性（deformability）：在受到剪切力持续作用时，与固体的微小变形或有限变形不同，流体产生程度很大的、甚至作用时间无限长的变形。\n粘性（viscosity）：相邻两层流体之间发生相对运动时，在两层流体的接触面会产生对于变形的抗力，与固体的摩擦力不同，这种抗力不与流体的变形大小有关，而与流体的变形速度正相关，这种抵抗变形的特性称为粘性。\n正相关的形式：\n线性相关 - 牛顿流体 \\(\\tau=\\mu\\dfrac{du}{dy}\\) 非线性相关 - 非牛顿流体 \\(\\tau=\\mu(T,p)\\left(\\dfrac{du}{dy}\\right)^2\\) 可压缩性（compressibility）/不可压缩性（incompressibility）：在一定的温度下，单位压强增量引起的体积变化率定义为流体的压缩性系数(coefficients of compressibility)，其值越大，流体越容易压缩，反之，不容易压缩。\n在影视制作的物理模拟中，一般模拟的是不可压缩流体。\nNavier-Stokes 方程 一般形式 \\[ 动量方程\\quad\\displaystyle\\underbrace{\\frac{\\mathrm D\\mathbf u}{\\mathrm Dt}}_{\\frac{\\partial\\mathbf u}{\\partial t}+\\mathbf u\\cdot\\nabla\\mathbf u}=\\frac{1}{\\rho}\\nabla\\cdot\\underbrace\\sigma_{应力加速度张量}+\\mathbf g\\\\ 质量方程\\quad\\nabla\\cdot\\mathbf u=0 \\]\n不可压缩流体 Navier-Stokes 方程 \\[ 动量方程\\quad\\displaystyle\\overbrace{\\underbrace{\\frac{\\partial\\mathbf u}{\\partial t}}_{非稳态加速度}+\\underbrace{\\mathbf u\\cdot\\nabla\\mathbf u}_{对流加速度}}^{惯性加速度\\frac{\\mathrm D\\mathbf u}{\\mathrm Dt}}+\\underbrace{\\frac{1}{\\rho}\\nabla p}_{压强梯度}=\\underbrace{\\mathbf g}_{外力加速度}+\\underbrace{\\nu\\nabla\\cdot\\nabla\\mathbf u}_{粘滞力加速度(经常忽略)}\\\\ 质量方程\\quad\\nabla\\cdot\\mathbf u=0 \\]\n补充数学： \\[ 哈密顿算子\\quad\\nabla=\\left(\\dfrac{\\partial}{\\partial x},\\ \\dfrac{\\partial}{\\partial y},\\ \\dfrac{\\partial}{\\partial z}\\right)\\quad\\\\ {\\bf散度}\\ \\nabla\\cdot \\vec F\\quad{\\bf旋度}\\ \\nabla\\times \\vec F\\ \\\\ 拉普拉斯算子\\quad\\Delta=\\nabla\\cdot\\nabla=\\nabla^2=\\left(\\dfrac{\\partial}{\\partial x},\\ \\dfrac{\\partial}{\\partial y},\\ \\dfrac{\\partial}{\\partial z}\\right)^2\\\\ {\\bf梯度}的{\\bf散度}\\ \\Delta\\vec F \\]\n流体模拟的两种视点 前面我们一直在用拉格朗日视点在考虑粒子和刚体的模拟，也就是“盯着运动物体看”。那在流体中，我们终于可以聊到两种视点。\n流体是一种连续介质——什么叫连续介质，简单来说就是很难分割，你没法把一杯水分成一块一块的独立件去模拟，除非细到分子程度——我们的第一种思路就有点像：用超大规模的粒子去模拟流体。那就回归到了我们第一节课讲过的粒子系统，又由于粒子之间是要考虑相互作用力的，那么就是一个比较复杂的交互粒子系统。这就是我们流体模拟的拉格朗日方法。拉格朗日方法的优势在于非常直观，相对来说更加精确，但是问题是很难追溯流体中的某一部分，或者说某一区域的粒子，要选取范围来做粒子操作——永远需要遍历每一个粒子，需要用非常复杂的数据结构来优化。\n另一种方法之前也给大家介绍过了：考虑空间网格而不是考虑单体的欧拉方法。在流体模拟中，也就是把流体运动的空间分割为网格，考虑每一个网格中是否有流体、流体的速度、加速度、受力等状态，然后迭代更新每一个网格的状态。欧拉方法则可以方便地调取某一区域的流体。后面会提到这个“方便调取”带来的优势。\n近两年也出现了拉格朗日和欧拉的混合方法，就是一会拉格朗日、一会欧拉，来结合两者的优点。后面也会给大家介绍。\n拉格朗日方法 欧拉方法 混合方法 拉格朗日方法：光滑粒子动力学 那么首先我们就为大家介绍一种最简单的拉格朗日流体模拟方法：SPH (Smoothed Particle Hydrodynamics)[2]。\nSPH的核心思想就是把流体考虑成一个个相互作用的粒子：每一个粒子根据周围一定范围的粒子的位置、受力、粘力等状态来更新自己的状态，从而计算出加速度和速度，进行反复迭代。\n首先我们来解释一下“光滑”的概念。先给大家讲一种比较形象的解释方式，两个小球，不接触（手做演示）时互不影响，一旦接触就反弹，这叫不光滑；而如果这两个小球接触时不会立即弹开，而是有一个缓冲，先接触、重合然后慢慢地弹开，就叫做光滑。严谨的表述是，两个粒子的相互影响在相近一定距离时发生（接触），相互影响的程度随着距离的接近从0开始逐渐增大（缓冲），即形成下图右图这样的相互影响程度 - 距离函数，我们称之为光滑核函数。\n设第 \\(i\\) 个粒子的坐标是 \\(\\mathbf x_i\\) ，对空间中任一点 \\(\\mathbf x\\) ， \\(\\mathbf r =\\mathbf x - \\mathbf x_i\\) ，核函数即为： \\[ \\omega_i(\\mathbf r)=\\omega(\\|\\mathbf r\\|)\\\\ \\]\n“最大半径”的概念我们也称为有限支撑，设该最大半径/有限支撑为 \\(r_{max}\\) 。 \\[ r\\ge r_{max}时,\\quad\\omega(r)=0\\\\ \\oint \\omega_{(r)}d\\mathbf r=1 \\]\n光滑核函数选择是很多的，只要满足以上条件的函数都可以用于核函数，一般根据我们的动画需要来选择，也可以根据动画效果来做一些参数的调整。可以是我们上图中这样的，也可以是接近0时趋向正无穷的。\n那么有空间中的任意场 \\(A\\) 、场梯度 \\(\\nabla A\\) 及密度 \\(\\rho\\) 计算方法分别为： \\[ A(\\mathbf x)=\\sum_i A_i \\dfrac{m_i}{\\rho_i}\\omega(\\|\\mathbf x-\\mathbf x_i\\|),\\quad\\rho_i=\\sum_j m_j\\omega(\\|\\mathbf x_i-\\mathbf x_j\\|)\\\\ \\nabla A_i=\\rho_i\\sum_j m_j\\left(\\dfrac{A_i}{\\rho_i^2}+\\dfrac{A_j}{\\rho_j^2}\\right)\\nabla_{\\mathbf x_i}\\omega(\\|\\mathbf x_i-\\mathbf x_j\\|)\\quad (\\nabla_{\\mathbf x_i}\\omega指核函数在位置{\\mathbf x_i}的梯度) \\]\n则我们就可以来做最简单的SPH算法了：WCSPH (Weakly Compressible SPH)。最终在程序中每一个时间步的计算步骤为：\n对于每个粒子 \\(i\\) ，计算其密度 \\(\\rho_i\\) ，从而得到压强 \\(p_i\\) ，进一步计算得到压强梯度 \\(\\nabla p_i\\) ： \\[ \\rho_i=\\sum_j m_j\\omega(\\|\\mathbf x_i-\\mathbf x_j\\|)\\\\ p_i=B((\\dfrac{\\rho_i}{\\rho_0})) \\]\n对于每个粒子 \\(i\\) ，计算所在位置的压强梯度 \\(\\nabla p_i\\) ，即： \\[ \\nabla p_i=\\rho_i\\sum_j m_j\\left(\\dfrac{p_i}{\\rho_i^2}+\\dfrac{p_j}{\\rho_j^2}\\right)\\nabla_{\\mathbf x_i}\\omega(\\|\\mathbf x_i-\\mathbf x_j\\|) \\]\n代入N-S方程（忽略了粘度项 \\(\\nu\\nabla\\cdot\\nabla\\mathbf u\\) ），计算每个粒子 \\(i\\) 的材料加速度 \\(\\dfrac{\\mathrm D\\mathbf u}{\\mathrm Dt}\\) ，从而直接计算当前时间步的速度与位移： \\[ a=-\\dfrac{\\nabla p}{\\rho}+g\\\\ 以显式时间积分方法为例\\quad\\begin{array}{l}\\mathbf v_{t+1}=\\mathbf v_t+\\Delta t\\left(-\\dfrac{\\nabla p}{\\rho}+\\mathbf g\\right)\\\\ \\mathbf x_{t+1}=\\mathbf x_t+\\Delta t\\mathbf v_{i+1}\\end{array} \\]\n除了我们最简单的WCSPH，还有一些拓展方法。\nWCSPH, Weakly Compressible SPH 最简单的显式求解 PCISPH, Predictive-Corrective Incompressible SPH 不断调整压力值控制密度，保证不可压缩性，循环修正过程即为“预估矫正 (Predictive-Corrective)” IISPH, Implicit Incompressible SPH 隐式求解，使用 Relaxed Jacobi Method 求解，PCISPH DFSPH, Divergence-Free SPH 不仅保证密度恒定，还要保证速度的散度为0 PCISPH 如这张图中的效果就是PCISPH方法在二维中的一个呈现，通过Taichi编程显示。\nSPH方法的优势在于理解起来相对简单，再加以一定的条件后也能够达到相当的精确性。但SPH方法在粒子量较大时计算会比较慢，尤其是在搜索附近粒子时没有很好的加速方法的话。此外，SPH想要保证流体的不可压缩性，只能通过PCISPH那种预估矫正的方法来保证。\n案例分享 近年来，SPH方法主要还是用于建筑、桥梁等土木工程流体仿真计算中，在电影中应用较少。我能搜到的一个应用粒子是《超人：英雄归来》中，Tweak (Shotgrid) 在一些流体镜头中应用了SPH方法。\n欧拉方法：Stable Fluids 纯拉格朗日方法有什么问题呢？前面我们提到过，我们无法对其中某些部分粒子单独操作，一旦模拟开始了，就无法控制，只能通过初始参数的设定来调整效果。我们看一个欧拉方法的案例：WebGL2-StableFluids。在网格化的方法中，我们就能比较方便地操作某一个区域的流体——网格是固定不动的，这一时间步的 \\((0.5,0.5)\\) 和下一时间步的都是指的同一个网格。\n在欧拉方法中，我们不再关注流体本身，而是关注流体流过的空间。那么我们就要把前面用到的材料导数拆开： \\(\\displaystyle \\frac{\\mathrm D\\mathbf u}{\\mathrm Dt}=\\frac{\\partial\\mathbf u}{\\partial t}+\\mathbf u\\cdot\\nabla\\mathbf u\\) ，我们现在要在网格里存的是 \\(\\dfrac{\\partial\\mathbf u}{\\partial t}\\) ，也就是我们比起拉格朗日方法直接得到 \\(\\dfrac{\\mathrm D\\mathbf u}{\\mathrm Dt}\\) ，现在要多计算 \\(-\\mathbf u\\cdot\\nabla\\mathbf u\\) 这一项了，这一项叫做对流项。\n我们这里用欧拉方法中最经典的一篇Paper，Stable Fluids[3]的实现为例来讲解欧拉方法的细节，Stable Fluids把N-S方程先做了一个变形： \\[ \\displaystyle\\frac{\\partial\\mathbf u}{\\partial t}=-\\frac{1}{\\rho}\\nabla p-\\mathbf u\\cdot\\nabla\\mathbf u+\\nu\\nabla\\cdot\\nabla\\mathbf u+\\mathbf g\\\\ \\Rightarrow\\quad\\displaystyle\\frac{\\partial\\mathbf u}{\\partial t}=\\mathbf P(-\\mathbf u\\cdot\\nabla\\mathbf u+\\nu\\nabla\\cdot\\nabla\\mathbf u+\\mathbf g)\\\\ (\\mathbf P 表示压强的投影算子，消去了单独的压强项-\\frac{1}{\\rho}\\nabla p) \\] 在拉格朗日方法中，我们把粒子的所有受力计算出来、叠加得到合力，最后再来做时间积分的。然而欧拉方法中我们是逐项逐步来做计算，每一步得到一次速度，每一步的输出要作为下一步的输入，如下图依次执行。 Add force 处理统一的外力，这一步相对简单，就是给流体一个统一的外力，比如重力 Advection 步进，计算对流项 \\(-\\mathbf u\\cdot\\nabla\\mathbf u\\) ，更新粒子速度和位置。 Diffusion 耗散，计算粘度项 \\(\\nu\\nabla\\cdot\\nabla\\mathbf u\\) ，这一条我们在这次讲解中就简单带过了，一般在模拟高粘度的流体比如胶水时，才比较需要这一项。 Projection 投影，计算投影算子 \\(\\mathbf P\\) 或者压强项 \\(-\\dfrac{1}{\\rho}\\nabla p\\) 。 在具体讲解之前呢，我们还是先了解一下，“网格化”的一些细节。网格化本身是一个很容易的事情，能够产生不一样的地方在于，我们怎样存储网格化的流体的状态。\n最简单的一种方式就是我们把所有属性：速度、压强存在每一个网格的中心； 另一种稍微复杂一些的方式是我们把压强存在网格的中心，而把速度拆成垂直分量和水平分量，分别存储在网格的左右两边中点和上下两边中点，这种方式我们也称为MAC网格。 这样能够避免掉简单的中心存储可能出现的“棋盘格图案 Checkerboard Pattern”。 Grid 在这个基础上，我们的下一个问题是，我在空间中任意取一点并不在网格存储点位置的点，怎样去求其状态——这里我们使用的就是简单的双线性插值。就像下图，用它周围的四个点的状态计算、用面积作为权重。\nAdvection 在计算对流项这一步，Stable fluid实现的方法被称为半拉格朗日法，为什么又要“拉格朗日”？\n我们考虑某一个网格位置当前的速度是什么？这里我们用粒子来考虑：就是一个粒子从上一个地方流到了这一个地方——就是粒子在的上一个地方的速度（要注意，我们这里计算的是对流项，因此不考虑压强带来的速度变化）。那Advection的思路就出来了：\n如下图，首先假定一个网格中心 \\(\\mathbf x\\) 处存在粒子 \\(p\\) ，由处当 \\(p\\) 前的速度 \\(\\mathbf u\\) 反向追溯得 \\(p\\) 前一个时间步的位置 \\(\\mathbf x_{old}\\) ，这个 \\(\\mathbf x_{old}\\) 就不一定在网格中心了，用它周围的速度场插值得到它的速度 \\(\\mathbf u_{old}\\) 也就是我们要更新的 \\(\\mathbf u_{new}\\) 。\n但是这时可能会存在下图这种现象，尤其是时间步长较大时非常明显：运动方向与我们的追溯方向偏差较大，不断地偏差下去就会一次比一次大，最终出现整个流体速度场的整体性偏移。那么怎么解决它呢：\n那根据我们之前做正向速度更新时的经验，我们就可以“往回走两步”，或者说是“先走半步、再走半步”，即我们熟悉的“中点法”，这样我们就能够追溯地更加精准。当然也可以走三步，相对来说就没那么必要了。这个过程，其实本质上是在解非线性常微分方程的数值解，用的方法叫做Runge-Kutta方法，我们最简单的走一步就是RK1，走两步就是RK2，三步就是RK3方法。\n此外呢，在插值问题上，后来也有人用样条插值（比如Catmull-Rom）来对线性插值做改进。\nDiffusion Diffusion这一步相对简单，如果要做的话。我们就直接逐网格求得粘度加速度，再在Advection得到的速度基础上做时间积分即可。 \\[ \\dfrac{\\partial\\mathbf u}{\\partial t}=\\nu\\nabla^2\\mathbf u \\] 以简单的前向时间积分为例就是： \\[ \\mathbf u^{n+1}=\\mathbf u^n+\\Delta t \\nu\\nabla^2\\mathbf u^n \\] 当然，这个前向时间积分也可以用隐式的时间积分方法（比如后向欧拉）来完成，Stable Fluids就是把上面这个计算过程换成用后向欧拉方法、使用共轭梯度法迭代来计算的，这里我们就省略过程了。\nProjection 在Projection这一步，我们求的其实是压强，压强这一项其实是为了保证流体的不可压缩性，因此我们有条件：速度的散度为0。我们这一步的条件其实就是： \\[ \\dfrac{\\partial\\mathbf u}{\\partial t}=-\\dfrac{1}{\\rho}\\nabla p\\ ,\\quad\\nabla\\mathbf u=0 \\] 那么我们用后向欧拉的思路就得到了压强的泊松方程（Pressure Poisson equation, PPE）： \\[ \\mathbf u^{n+1}-\\mathbf u^n=-\\Delta t\\dfrac{\\nabla p}{\\rho}\\ ,\\quad \\nabla\\mathbf u^{n+1}=0\\\\ \\Rightarrow\\ 泊松方程\\ \\nabla\\cdot\\nabla p=\\dfrac{\\rho}{\\Delta t}\\nabla\\cdot\\mathbf u \\] 我们用中心差分方法代替其中的哈密顿算子和拉普拉子算子后，这个泊松方程又是一个形如 \\(Ax=b\\) 的超大规模线性方程，我们用各种迭代方法去解它就好了。 \\[ \\begin{aligned}(\\mathbf Ap)_{i,j,k}\u0026amp;=(\\nabla\\cdot\\nabla p)_{i,j,k}\\\\\u0026amp;=\\dfrac{1}{\\Delta x^2}(-6p_{i,j,k}+p_{i+1,j,k}+p_{i-1,j,k}+p_{i,j+1,k}+p_{i,j-1,k}+p_{i,j,k+1}+p_{i,j,k-1})\\\\\\\\ \\mathbf b_{ij}\u0026amp;=\\left(\\dfrac{\\rho}{\\Delta t}\\nabla\\cdot\\mathbf u\\right)_{i,j,k}\\\\\u0026amp;=\\dfrac{\\rho}{\\Delta t\\Delta x}(\\mathbf u_{i+1,j,k}^x- \\mathbf u_{i,j,k}^x+\\mathbf u_{i,j+1,k}^y-\\mathbf u_{i,j,k}^y+\\mathbf u_{i,j,k+1}^z-\\mathbf u_{i,j,k}^z)\\end{aligned} \\] 不过这里的 \\(A\\) 是一个超大规模的稀疏对称正定矩阵（ \\(nml\\times nml,\\ nml\\ 分别为\\ xyz\\ 方向的网格数量\\) ），我们也会有一些计算方法去优化它。\n不过在烟雾这样的流体模拟中，温度也会带来变量。因此在模拟烟雾等流体时，压强场的泊松方程还需要做一些小变化：密度 \\(\\rho\\) 不是固定的了，针对每一网格要通过温度去计算浮力、从而得到新的 \\(\\rho\\) 来参与计算。这里不再赘述。\n案例分享 欧拉方法在混合方法出现之前，一度是电影工业界最流行的模拟方法。这里给大家讲一个趣事，就是我们前面分析的Stable Fluids这篇paper，刚投递到Siggraph时，审稿人直接给毙了：这写的什么东西啊，尤其是对它用半拉格朗日法求对流项速度的方法意见颇大——也太不精确了。但是很快，这一方法就在工业界被大量使用了：我们电影、游戏要多少物理精确啊，速度快、好看、好用才是对的。因此直到这一方法已经几乎成为工业界的成熟方案，才被会议接收发表。\n欧拉方法非常适合用于烟雾、火焰等流体的模拟，我们利用Houdini中的Pyro工具架也制作了一个简单的烟雾模拟DEMO：给大家演示一下。\n混合欧拉-拉格朗日方法 整体上来说，一个流体模拟系统总体来说大致主要就是Advection（步进：根据速度更新粒子状态或进行场的流动）和Projection（投影：更新速度，维持物质守恒/不可压缩性）两步。在拉格朗日方法的SPH中，我们虽然没有强调这两个概念，因为Advection步骤很轻松就完成了，但是Projection时需要复杂的数据结构（或者逐个遍历）来实现邻域的访问，因此很难保证流体的不可压缩性——直到PCISPH中引入了一个有点复杂的预估校正系统才能保证这一点。而在欧拉方法中的Advection步骤中却很难精确地处理场的流动，我们用RK2甚至RK3才能够消除误差，甚至还不能完全消除图形上的Artifact，而且很容易丢失能量和几何的细节；Projection却因为我们可以很方便地调取周边网格的状态变得非常好操作。所以我们就想，能不能将这两个方法混合一下。\n当然可以，那么这类混合方法的思路就是：在粒子上做速度与状态更新，在网格上做压强计算与边界条件处理。算法的核心是 P2G 和 G2P 两个函数，分别是把粒子上的信息转换到网格上和把网格上的信息转换到粒子上，然后在粒子上和网格上分别做适合的工作。\nParticle to Grid transfer (P2G) Grid Operation Pressure projection Boundary conditions … Grid to Particle transfer (G2P) Particle operation Move particles Update material … PIC, Particle in Cell 粒子元胞法 那么我们以最古老也最简单的一种混合欧拉-拉格朗日方法：PIC[4]，Particle in Cell，粒子元胞法为例，先给大家介绍 P2G 和 G2P 两个函数的实现。\n从这两张图就可以清晰地看到 P2G 和 G2P 的过程。\n我们通常先选择一个网格范围，这里是二维的 \\(3\\times 3\\) 的网格，作为 P2G 或 G2P 中的网格作用范围，把粒子的状态“摊”到这些网格上或者是把这些网格的状态收集起来作为粒子的状态。 这里我们就会又一次用到前面介绍的“核函数”。这里粒子对每一个网格、每一个网格对粒子的“贡献”是不一样的，所以我们在“分摊”或者“收集”时要用一个权重，这个权重就是我们关于距离的核函数 \\(\\omega\\|\\mathbf x_i-\\mathbf x_p\\|\\) 。 那么我们就可以实现我们的想法：在网格中做Projection（就如欧拉方法中那样），在粒子中做Advection（直接使用粒子携带的速度值移动）了。程序变得简单了起来（二维）：\n# P2G for p in x: base = (x[p] * inv_dx - 0.5).cast(int) fx = x[p] * inv_dx - base.cast(float) # Quadratic B-spline w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1) ** 2, 0.5 * (fx - 0.5) ** 2] for i in ti.static(range(3)): for j in ti.static(range(3)): offset = ti.Vector([i, j]) weight = w[i][0] * w[j][1] grid_v[base + offset] += weight * v[p] grid_m[base + offset] += weight # Grid normalize for i, j in grid_m: if grid_m[i, j] \u0026gt; 0: inv_m = 1 / grid_m[i, j] grid_v[i, j] = inv_m * grid_v[i, j] # G2P for p in x: base = (x[p] * inv_dx - 0.5).cast(int) fx = x[p] * inv_dx - base.cast(float) # Quadratic B-spline w = [0.5 * (1.5 - fx) ** 2, 0.75 - (fx - 1.0) ** 2, 0.5 * (fx - 0.5) ** 2] new_v = ti.Vector.zero(ti.f32, 2) for i in ti.static(range(3)): for j in ti.static(range(3)): weight = w[i][0] * w[j][1] new_v += weight * grid_v[base + ti.Vector([i, j])] x[p] = clamp_pos(x[p] + v[p] * dt) v[p] = new_v 但是这种方法有一个什么问题呢？试想如果同一个 \\(3\\times 3\\) 网格中有两个粒子，它们的速度都被均摊到了这九个网格上，在迭代完成后再次从这九个网格中收集到新的速度时，A粒子的新速度就包含了B粒子的旧速度的一部分，同理B也是——因此，在不断地迭代过程中，其实是一个速度的细节丢失、不断平均化的过程——尤其是旋转、拉伸等运动，动着动着可能就停下来了。\n换一种理解方式，我们的二维中9个网格有18个运动的自由度（每个网格xy两个方向），而转换到的粒子却只有2个移动的自由度，如果是三维的话这个数字会是：81/3——因此信息就会丢失掉非常多。\n所以人们就带来了新的思路，主要分为这两类：\nAPIC、PolyPIC：让粒子携带更多自由度的信息 FLIP：不直接传递值，而是传递前后时间步的差分或物理量的梯度/倒数 APIC, Affine Particle in Cell 第一种思路我们先说说APIC[5]。APIC其实就是通过给粒子增加一个Affine矩阵，来存储粒子的更多种速度信息——网格的不同自由度的作用中，就有下图（二维）这几种，刚好可以通过仿射变换包含进来。从而就将粒子的自由度拓展为原来的三倍，二维中就是6自由度，三维就是9个。\n当然这个方法还涉及到怎样来计算这个Affine矩阵的问题，数学推导非常复杂就不给大家讲解了。代码实现却非常简单：用一个张量积来计算这个Affine矩阵即可。也不演示了。效果上带来的区别非常明显：流体可以正常的旋转、拉伸、剪切运动了。\n而PolyPIC[6]则是进一步拓展了粒子的自由度——达到与网格一样的级别，当然复杂度也进一步提升了。\nPolyPIC APIC也逐渐在影视制作中使用，尤其适合海洋、瀑布等水体的模拟，在迪士尼影片《海洋奇缘》中就有应用。\nFLIP, Fluid Implicit Particles 隐式粒子流体法 影视工业目前最常用的方法\nFLIP方法[7][8]的核心想法在于，我们不把表述粒子状态的物理量直接与网格传递，而是传递一个时间步里的增量。\n还是以速度为例，我们在PIC系列方法中的 P2G 是 \\[ \\mathbf v_p^n={\\rm gather}(\\mathbf v_i^n) \\] 而FLIP方法中，则 \\[ \\mathbf v_p^{n+1}={\\rm gather}(\\mathbf v_i^{n+1}-\\mathbf v_i^n) \\] 这样，A粒子中包含B粒子的速度成分就只有B粒子速度对加速度的一点点影响，而不会被“平均”掉了。\n但是FLIP方法中，由于加速度的因素“成分”和原速度“成分”不一致，最终得到的结果会有很大的噪声——大家可以看到：毛毛刺刺的。到这里呢，我们刚好可以做一个多种常用模拟水的流体方法的对比（欧拉、PIC、APIC、FLIP）：\n那么怎么办呢：非常简单，我们把PIC方法和我们的FLIP做一个Blend，而且这个比例呢只需要混一点点PIC，可以通过这个网站例子来玩一下GPU-based Fluid Simulation (yuanming-hu.github.io)： \\[ \\rm FLIP0.99=0.99*FLIP+0.01*PIC \\] 这是跟前面对比的FLIP0.97方法的效果\nFLIP方法其实只是一个Advection步骤的实现方法，影视工业界通常把结合了FLIP的Advection和Chorin-Style pressure projection，再加上相应需要的粒子网格的工程实现（例如OpenVDB…）的整个流体解算器也称为FLIP——比如我们Houdini工具架上的FLIP模块。我们也利用这个工具制作了一小段流体动画。\n在我们的Houdini中，大家可以看到一个完整的FLIP Fluid包括了Geometry的导入、渲染和一个AutoDopNetwork，AutoDopNetwork中是我们的流体解算环节，其中最核心的节点是Filpsolver，大家可以看看这个Flipsolver中，是非常复杂的一个解算结构——但是在学习完前面的所有过程之后，根据每一个部分的名字，我们就逐渐能够看懂了。\nHoudini_FLIP_3 Houdini_FLIP_4 Houdini_FLIP_5 Houdini_FLIP_6 Houdini_FLIP_7 Houdini_FLIP_8 MPM, Material Point Method 物质点法 最后呢，我们来讲一点学术前沿，特别适合用于模拟雪、沙子这种带一点固体性质的流体的方法MPM物质点法[9]，甚至有人拿物质点法去模拟刚体，做我们上一节课介绍的破碎等效果。为什么这样一个流体方法可以用于模拟固体性质呢？\n原因在于，我们的粒子域过程中不再只有速度、加速度、受力、温度这些外部属性，而是加入了质量、体积这样的物质属性。而且不再局限于不可压缩流体的Advection和Projection。\n经典MPM方法的流程如下：\nP2G，传递质量、速度等信息 \\(\\begin{array}{l}m_i=\\sum\\nolimits_pm_p\\omega_{ip}^n\\\\\\mathbf v_i=\\sum\\nolimits_p\\mathbf v_p^nm_p\\omega_{ip}^n/m_i^n\\end{array}\\) 计算粒子体积和密度 \\(\\begin{array}{l}\\rho_i=m_i^0/h^3\\\\\\rho_p^0=\\sum\\nolimits_im_i^0\\omega_{ip}^0/h^3\\\\V_p^0=m_p/\\rho_p^0\\end{array}\\) 计算网格受力 更新网格速度场 基于网格的碰撞计算 求解线性方程（迭代法） 更新形变梯度 \\(\\begin{array}{l}\\mathbf F_p^{n+1}=(\\mathbf I+\\Delta t\\nabla\\mathbf v_p^{n+1})\\mathbf F_p^n\\\\\\nabla\\mathbf v_p^{n+1}=\\sum\\nolimits_i\\mathbf v_i^{n+1}(\\nabla\\omega_{ip}^n)\\end{array}\\) 更新粒子速度 \\(\\begin{array}{l}\\mathbf v_p^{n+1}=(1-\\alpha)\\mathbf v_{\\mathrm{PIC}p}^{n+1}+\\alpha\\mathbf v_{\\mathrm{FLIP}p}^{n+1}\\\\\\mathbf v_{\\mathrm{PIC}p}^{n+1}=\\sum\\nolimits_i\\mathbf v_i^{n+1}\\omega_{ip}^n\\\\\\mathbf v_{\\mathrm{FLIP}p}^{n+1}=\\mathbf v_p^n+\\sum\\nolimits_i(\\mathbf v_i^{n+1}-\\mathbf v_i^n)\\omega_{ip}^n\\end{array}\\) 基于粒子的碰撞计算 更新粒子位置 \\(\\mathbf x_p^{n+1}=x_p^n+\\Delta t \\mathbf v_p^{n+1}\\) 而近年，又有人在APIC的基础上简化了这么复杂的一套MPM方法，提出了MLS-MPM(Moving Least Squares MPM) 移动最小二乘物质点法。\n从代码上呈现，就是在前面APIC的代码上，除了Affine分量，还增加一个Stress分量，在更新速度和Affine分量时，利用该Stress分量参与计算，并且需要加上体积的更新。因此实现上相比较经典的MPM方法简单了非常多，也是目前比较流行的一个方法。\n这里MPM的数学原理相对复杂了非常多，就不再给大家推导了。\nMPM方法非常适合多种材质固体、流体的耦合模拟，处理自碰撞、大形变等等，因此也逐渐在影视工业中投入使用。其中最著名的一个应用案例，就是《冰雪奇缘》中的雪的交互。大家可以欣赏一下影片。当然，发明MLS-MPM的胡渊明博士还有非常火的一篇知乎分享，叫做《99行代码实现〈冰雪奇缘〉》，其实就是MLS-MPM的一个Taichi实现。\n案例分析与欣赏 最后还是为大家准备了一些影片中的流体案例。包括《夏日友情天》《寻龙传说》《蜘蛛侠：英雄归来》《沙丘》等。\n参考文献 [1] Particle-Based Fluid Simulation for Interactive Applications [2] Smoothed Particle Hydrodynamics Techniques for the Physics Based Simulation of Fluids and Solids [3] Stable fluids [4] Harlow, F.H. (1964) The Particle-in-Cell Computing Method for Fluid Dynamics. Methods in Computational Physics, 3, 319-343. [5] The Affine Particle-In-Cell Method [6] A Polynomial Particle-In-Cell Method [7] FLIP a method for adaptively zoned, particle-in-cell calculations of fluid flows in two dimensions [8] Animating Sand as a Fluid [9] A material point method for snow simulation\n","permalink":"https://elderlyaugustus.github.io/posts/2021-12-05-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%9F/","summary":"流体系统 最后，在相对简单的前两个部分介绍后，我们还是不得不面对一个需要更多数学的系统，流体。\n流体与流体力学 首先第一个问题是什么是流体。流体的定义是在承受剪应力（物体在外力作用时，内部任一截面上会出现的相互作用力，“内力”）时将会发生连续变形的连续介质，包括气体和液体。\n所有液体 所有气体 具备流动特征的固体：如沙丘 流体主要具备以下性质：\n流动性（fluidity）：流体间的分子作用力较小，难以保持一定的形状，在受到外界的作用力或能量不平衡时，流体会发生流动。\n变形性（deformability）：在受到剪切力持续作用时，与固体的微小变形或有限变形不同，流体产生程度很大的、甚至作用时间无限长的变形。\n粘性（viscosity）：相邻两层流体之间发生相对运动时，在两层流体的接触面会产生对于变形的抗力，与固体的摩擦力不同，这种抗力不与流体的变形大小有关，而与流体的变形速度正相关，这种抵抗变形的特性称为粘性。\n正相关的形式：\n线性相关 - 牛顿流体 \\(\\tau=\\mu\\dfrac{du}{dy}\\) 非线性相关 - 非牛顿流体 \\(\\tau=\\mu(T,p)\\left(\\dfrac{du}{dy}\\right)^2\\) 可压缩性（compressibility）/不可压缩性（incompressibility）：在一定的温度下，单位压强增量引起的体积变化率定义为流体的压缩性系数(coefficients of compressibility)，其值越大，流体越容易压缩，反之，不容易压缩。\n在影视制作的物理模拟中，一般模拟的是不可压缩流体。\nNavier-Stokes 方程 一般形式 \\[ 动量方程\\quad\\displaystyle\\underbrace{\\frac{\\mathrm D\\mathbf u}{\\mathrm Dt}}_{\\frac{\\partial\\mathbf u}{\\partial t}+\\mathbf u\\cdot\\nabla\\mathbf u}=\\frac{1}{\\rho}\\nabla\\cdot\\underbrace\\sigma_{应力加速度张量}+\\mathbf g\\\\ 质量方程\\quad\\nabla\\cdot\\mathbf u=0 \\]\n不可压缩流体 Navier-Stokes 方程 \\[ 动量方程\\quad\\displaystyle\\overbrace{\\underbrace{\\frac{\\partial\\mathbf u}{\\partial t}}_{非稳态加速度}+\\underbrace{\\mathbf u\\cdot\\nabla\\mathbf u}_{对流加速度}}^{惯性加速度\\frac{\\mathrm D\\mathbf u}{\\mathrm Dt}}+\\underbrace{\\frac{1}{\\rho}\\nabla p}_{压强梯度}=\\underbrace{\\mathbf g}_{外力加速度}+\\underbrace{\\nu\\nabla\\cdot\\nabla\\mathbf u}_{粘滞力加速度(经常忽略)}\\\\ 质量方程\\quad\\nabla\\cdot\\mathbf u=0 \\]\n补充数学： \\[ 哈密顿算子\\quad\\nabla=\\left(\\dfrac{\\partial}{\\partial x},\\ \\dfrac{\\partial}{\\partial y},\\ \\dfrac{\\partial}{\\partial z}\\right)\\quad\\\\ {\\bf散度}\\ \\nabla\\cdot \\vec F\\quad{\\bf旋度}\\ \\nabla\\times \\vec F\\ \\\\ 拉普拉斯算子\\quad\\Delta=\\nabla\\cdot\\nabla=\\nabla^2=\\left(\\dfrac{\\partial}{\\partial x},\\ \\dfrac{\\partial}{\\partial y},\\ \\dfrac{\\partial}{\\partial z}\\right)^2\\\\ {\\bf梯度}的{\\bf散度}\\ \\Delta\\vec F \\]","title":"2021-12-05-影片技术分析Pre-基于物理的动画-流体系统"},{"content":"这节课开始我们将花两节课的时间从粒子、刚体、流体三种系统，来简要介绍一些基于物理的动画的基本原理与实现，并给大家展示一些具体的制作方法和成果。\n粒子系统 基于粒子的模型是基于物理的动画的一个基础模型，是拉格朗日方法中最典型的一种。这里的粒子系统个人认为广义地来说就是基于粒子的模型，是以粒子视点对物理现象做点采样的所有动画系统，但业界我们往往狭义地认为其典型就是特指由发射器发射大规模粒子、通过外力驱动运动、渲染成具体的无定形形象的系统。我们这一章的陈述主要还是以典型的粒子系统为主，会拓展些基于粒子的、但并不一定称为粒子系统的模型。\n粒子系统一般用来表现雨、雪、火、烟、尘、沙尘暴、烟花、水花、喷雾等等“无定形现象（Amorphous Phenomena[1]）”，当然也包括我们常见的一些“非物理现象”，诸如哥斯拉的吐息、猩红女巫的魔法光效等等，这些非物理现象同样要通过我们的物理系统去驱动粒子来产生这些效果。\n一个粒子 在开始讲粒子系统之前，我们还是要讲一下一个粒子的运动：粒子的运动只有位移——就如我们中学物理中常做的质点模型一样，对一个粒子而言，所需要的动力学参数仅有、位置、速度、加速度、受力、质量等。在这之中，质量将受力与加速度联系为同一个概念，位置的变化（位移）是速度的积分、速度的变化又是加速度的积分。而且与中学物理不同的是，这里的每一个量都是三维空间中的向量了。\n那么在这里，我们就第一次涉及到了时间积分概念的应用，也就是我们上节课刚刚讲过的如何在时间离散系统里做积分。\n我们用上图这样的近似积分方式，就能够表达粒子随着时间的运动。那么知道了如何描述一个粒子的运动，我们就能够描述一堆粒子的运动了——换言之，我们可以开始了解一个基本的粒子系统。\n基本粒子系统 我们来了解一个基本的粒子系统。在一个基本粒子系统的模拟过程中，通常包含了生成、模拟、消失三个过程，再加上把模拟过程渲染出来的渲染环节，我们分别讲解。\n粒子生成 粒子生成器 粒子生成字面含义就是粒子是怎样初始化的，怎样给大量的粒子赋予初始的参数。因此我们设计了“生成器”，或者也可以称为“发射器”。\n从发射器的形状说起，我们一般有点发射、平面发射、三维表面发射三种。\n点发射顾名思义就是从同一个位置发射所有粒子，方向上有朝单一矢量、全方向两种。 平面发射中，平面主要有圆盘平面和多边形（三角形）平面两种。 三维表面发射中，以模型表面为发射器，可以认为是多个多边形平面发射的组合；另一种是在体积内发射，即在一个区域内随即发射。 生成器分类 粒子生成的随机算法 我们想象，以相同的质量、速度、加速度、方向、位置等参数来初始化大量粒子会出现什么现象：所有粒子会以相同或平行的轨迹运动。所以我们这里需要使用随机算法来初始化粒子的参数、方向矢量、位置，也就是需要生成随机数、随机矢量和随机点三种数据类型。\n随机数 —— 为了控制粒子形态，我们一般不会直接使用系统的 rand() 来产生均匀分布的随机数，这就涉及到随机分布的概念：\n均匀分布：均匀分布即每一个数出现的概率是均等的，经典案例就是抛硬币。只有我们希望空间中充满随机的点运动时才会使用。\n高斯分布 / 正态分布：概率密度函数 \\(p(x)=\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{\\frac{(x-\\mu)^2}{2\\sigma^2}}\\) （概率密度函数 PDF 指的是概率密度 - 数值，概率密度大家可以类比中学统计中的概率/区间宽度，区间宽度 -\u0026gt; 0） 利用高斯分布，我们就可以得到一个“大部分粒子以这个参数运动，少量随机发散”的结果，比如火花飞溅时，大部分火花都会溅射在一个区域范围内，有少量迸发到外面的样子。能够让我们更好地控制粒子的运动。\n随机矢量：首先我们要了解如何生成一个均匀的球面分布，大家想象我们的地球上的任意一个点，做与球心的连线投影到赤道平面上得到长度 \\(r\\) ，与子午分割线成 \\(\\theta\\) 角，那么我们只要随机 \\(h=\\sqrt{1-r^2}\\) 和 \\(\\theta\\) 两个值就能够得到随机矢量 \\(\\begin{bmatrix}r\\cos\\theta\\\\h\\\\r\\sin\\theta\\end{bmatrix}\\) ，经数学证明，球面上的点随 \\(\\theta\\) 和 \\(h\\) 线性分布，因此，只要控制这两个随机数就可以控制球面的随机矢量。\n同理我们可以得到控制下图两种：点向圆盘方向发射、圆盘发射时控制随机矢量的参数，分别是\\(\\theta \\ \\phi\\) 和 \\(\\theta\\ r\\) 。也就是把随机向量转换成了两个随机数的问题。\n随机点：三维空间中的一个点其实就是三个数，我们按照需要来生成三个随机数即可。当然也可以用一个随机矢量（两个随机数）+随机长度（一个随机数）的方式生成。随机点主要应用于表面发射的偏移和体积内发射。\n粒子模拟 碰撞 在不考虑交互的情况下（后面会专门讨论），粒子在模拟过程中除了随着力场一步一步地迭代和人工控制之外的会产生剧变的现象就是碰撞了。粒子系统通常工作在含有模型的场景中，我们就需要考虑与模型的碰撞，其实也就是与一个个平面三角形的碰撞。问题在于，粒子是一个无体积的点，而粒子所处的位置又是离散的点，粒子恰好停在一个表面的概率微乎其微，那么我们如何判定碰撞而不是让粒子直接穿越表面呢？下面我们就会讲到。\n碰撞主要分为两个步骤，分别是碰撞检测和碰撞响应。首先我们得发现产生了碰撞，在发现碰撞之后，就可以执行相应的碰撞响应，这里的响应可以是让粒子消失、吸附、飞出去各种，下面举例说最简单的反弹这种。\n处理一个点与一个面的碰撞主要有Penalty（惩罚）和Impulse（冲击）两种思路：\nPenalty 碰撞检测：通过点与面的距离 \\(\\phi(x)\\) 判断 碰撞响应：更新 \\(f\\) ，判定碰撞后的下一个时间步更新粒子状态\nQuadratic Penalty Method 碰撞条件 \\(\\phi(x)\u0026lt;0\\) ，状态更新 \\(f\\leftarrow -k\\phi(\\mathbf x)\\mathbf N\\quad (\\mathbf N为法线方向单位向量)\\) 这种方法仅当粒子在面内时才能完成碰撞检测，就会出现粒子穿越表面的问题。 Quadratic Penalty Method with a Buffer 碰撞条件 \\(\\phi(x)\u0026lt;\\epsilon\\) ，状态更新 \\(f\\leftarrow k(\\epsilon-\\phi(\\mathbf x))\\mathbf N\\) 虽然缓解了粒子穿越表面的问题，但很可能会出现由于 \\(k\\) 过大带来的 Overshooting 现象，导致碰撞响应时，粒子就飞出去了。 Log-Barrier Penalty Method 假定 \\(\\phi(x)\\ge0\\) 恒成立，碰撞条件 \\(\\phi(x)\u0026lt;\\epsilon\\) ，状态更新 \\(f\\leftarrow \\dfrac{\\rho}{\\phi(\\mathbf x)}\\mathbf N\\) 相当于在Quadratic Penalty Method with a Buffer的基础上，使Buffer的区域是可变的，一定程度上优化了上面提到的问题，但并不能根治。 Impulse 碰撞检测：通过点与面的距离 \\(\\phi(x)\\) 判断 碰撞响应：立即更新 \\(\\mathbf x\\) 和 \\(\\mathbf v\\) （相当于在下一个时间步前增加一个时间步）并重新得到 \\(f\\) ，判定碰撞后的“下一个时间步”直接使用已经更新完的粒子状态计算。\n另一种理解方式是： 我们以无碰撞系统考虑两步，也就是粒子的当前位置和下一个位置，如果这两个位置分别在某个表面的两侧，那么在这个两个时间步之间一定会产生碰撞。 如下图计算，直接将下一个时间步的位置改为反弹后的位置，速度、加速度垂直于表面的分量做相应的反向即可。\n粒子编排 在前面的介绍中，我们介绍了粒子的初始化和自动运行过程中的迭代、碰撞，下面我们具体来介绍我们怎样通过加速度操作和速度操作[2]来控制粒子的运动过程。\n加速度操作：加速度的改变即力的改变，也即通过力场来操作粒子。例如最典型的引力，构建一个趋向于某一点的力场，粒子可能会被吸引，可能会绕它旋转，这都取决于初始速度和合力的改变，这要求我们能够熟练应用力学才能够非常熟练地操作粒子。\n当然我们也可以构造一些“奇怪的力场”，比如对不同的粒子随机施加不同的加速度、为强行限制粒子的速度调整加速度、给粒子赋予一些自驱动力达到一些特殊效果（比如烟雾活起来了）之类。\n速度操作：速度操作则是更加违背物理学的操作，但在视觉创作时，我们当然可以这么干——创造一些不存在的物理规律达到想要的效果。当然，通常我们不会直接将点的速度突变为一个其他值，而是不只用加速度这一个加法维度来描述速度的改变，而是用仿射变换去实现速度的变化。从而就可以得到许多奇特的效果，比如《变形金刚4》中粒子变形法的惊破天——也即让粒子塑造成一些具体的形象。\n粒子渲染 这应该是我们这次课程唯一一次提到渲染——大家对三维模型的渲染都非常熟悉，体积渲染今天我们不会讲，但应该也比较容易理解。但没有体积的粒子怎样渲染呢？\n一个经典的想法是用球体渲染，把每一个粒子当作一颗球体。但是这样不好，为什么不好，这里告诉大家如果要得到一个看起来像球体的球，我们至少需要96个面。我们知道粒子系统通常是极大规模的，再乘以一百倍，这个渲染量显然是不可接受的。 那么我们考虑直接以点投影到屏幕上呢。一个问题是无法看出来深度感了——深度感的来源：近大远小、近亮远暗。那么我们就可以根据深度，渲染不同半径的圆（称为面元渲染）；此外还可以渲染不同的透明度。从而实现三维的感觉。但是仍然存在问题：帧率不够高时没有动态模糊，看起来就会非常卡，要知道我们大部分电影只有24帧。 因此，还有一种思路是“点即划痕”，也就是不渲染点，而是渲染粒子的两次时间步迭代之间的两个位置之间的连线——渲染线段，这样就自然而然带来了动态模糊。 粒子不只能表述一个点，还可以用于表述以点方式运动的物体。那么这个物体我们可以在渲染时表现出来。第一种是用材质，每一个粒子渲染一个矩形（也就是两个三角形），在矩形上上一个材质。这种渲染我们称之为“精灵”。 当然，“精灵”的渲染方式只能将粒子替换成平面，有时候我们还是需要用三维的东西去表现旋转等运动，比如落叶。所以我们也可以用几何形体去替换粒子，最后渲染模型。 最后一种思维是体积渲染，一般用于极大规模的粒子系统，比如流体、核爆。极大规模的渲染中对粒子逐个渲染显然不现实，我们把粒子所处的区域体素化，再渲染体积，也可以在体积上去处理材质。 案例分析与欣赏 Pyro烟雾案例（自制） 粒子影片案例 交互粒子系统 前面我们介绍了没有交互的基本粒子系统，现在我们进一步提高一下复杂度，给粒子之间加上交互。粒子之间的交互换句话说就是：每一个粒子都对其他每一个粒子施加了力，也就是每一次迭代，对每一个粒子都要做 \\(n-1\\) 次力的叠加。复杂度上相较无交互的粒子系统 \\(O(N)\\) 大幅提高至 \\(O(N^2)\\) ，计算量急剧增加。\nforeach particle i do Calculate the resultant force F on i; foreach particle j do Calculate the sum of the forces j acting on i end end foreach particle j do Update status of i end 减少计算量的可能性 这种复杂度是无法通过计算方法的优化来减少复杂度：每一个数据读取一遍就是 \\(O(N^2)\\) 了。因此我们只能考虑减少参与计算的数据。我们考虑到在真实物理世界中，粒子间的效应（即力）随着物理距离的增加急剧变弱——也就是我们常见的平方反比定律，引力场、电磁场均满足这条定律。因此我们可以忽略距离粒子足够远的粒子，或者是将远处的外围粒子做一簇一簇的近似计算而非精确计算。要完成这样的优化方法，我们首先得把粒子组成一簇一簇的，组合方法这里介绍均匀空间网格、八叉树、kd树三种。\n均匀空间网格：最为简单的组合方法，将空间按一定的长方体网格分割，来组合粒子。这样网格利用率很低。 八叉树：八叉树则是经典的一分八方法，就如我们能把一个矩形同样宽高比地分成四份一样，把一个长方体分割成八份，从而建立树结构。这样我们可以根据粒子的不均匀排布来分割空间。 kd树：kd树则是一种二叉树，也是渲染领域光线追踪算法中BVH的构建基础。我们生成一个能够恰好包含所有粒子的包围盒，再以其中某一个维度上所有点的中位值分割。这种分割方法的每个单元粒子数量相近，范围搜索非常方便。利用kd树忽略或近似部分计算，可以减少计算复杂到 \\(O(N\\log N)\\) 。 以天文系统、群集系统为例的交互粒子系统 天文系统 天文系统是最典型的简单交互粒子系统：天体的大小相比较之间的距离可以抽象化为质点；粒子之间存在相互引力——且只有相互引力。天体 \\(i\\) 收到天体 \\(j\\) 的引力为 \\(F_i^j = G\\dfrac{m_im_j}{r_{ij}^2}\\hat\\mathbf x_{ij}\\) 。\n而天文系统中，天体之间的质量差距、两个星系之间的距离都非常之大——大到可以忽略掉很大部分的力。比如地球受到最近的恒星系比邻星的引力已经微乎其微，就算需要精确计算，也只需要将比邻星系作为一个整体来考虑。\n因此，天文系统非常适合实践我们前面提到的空间优化方法，我们将这种远距离的粒子聚成的整体称为“聚簇”，我们可以很快地估算一个聚簇带来的引力。根据天体系统的特征，我们还可以用不同大小的簇：例如仙女星系对太阳的引力，和一个相邻星系的引力，各自用一个簇来计算是合理的，这两个簇的大小显然不一样。\n群集系统 另一个例子是：给粒子赋予生命，或者说赋予一些“意识力”。这个力显然不是一个物理力学上的力，而是我们用粒子系统来模拟大规模生物的运动，例如鸟群。模拟生命体的运动，就会有更加复杂的逻辑表达。\n[3]我们将群集系统中的一个被模拟生命体称为“boid”，假定每个boid遵循三个规则：碰撞规避、速度匹配、集中，根据这三个规则得到三个加速度，根据三个加速度的有权或无权加和作为迭代用的加速度。\n碰撞规避：越靠近另一个“boid”，反向飞离的速度就越大 \\(a_{ij}^a=-\\dfrac{k_a}{d_{ij}}\\hat{x}_{ij}\\) 速度匹配：与“同伴”保持相对速度，保持群体运动一致性 \\(a_{ij}^v=k_v(\\mathbf v_j-\\mathbf v_i)\\) 集中：朝向近邻的加速度，以保持群体完整 \\(a_{ij}^c=k_c\\mathbf x_{ij}\\) 距离与视域：现在我们要考虑需要计算哪些 \\(boid_j\\) 。考虑真实生物，就会发现距离远的看不到、视线外的看不到。按照这两条，我们可以分别得到两个关于距离和视域的近邻boid的计算权重，以加权值来作为最终迭代使用的加速度。\n加速度的权重：根据不同生物、环境的特点，三种加速度的“紧迫程度”不一样，而生物能达到的加速度是有限的。那么可以根据具体情况，分配三种加速度最终加权计算的权重。\n外界干扰：绕过障碍：如果没有外界干扰，上述条件就能使我们的群集系统运作起来了。但环境中往往出现障碍——在“有生命”的群集中，不太可能傻乎乎地直接就碰撞了。所以我们可以为环境中的障碍物建立带有斥力的势场、操控粒子根据“观察角度”中出现的障碍更新加速度等方式处理避障。\n案例分析与欣赏 群集系统影片案例 交互粒子系统还可以引入黏度等更加复杂的交互力，来模拟更加复杂的系统。在流体的章节中，我们会再次见到基于交互粒子系统的流体模拟方法。\n弹性网格 粒子这一节的最后，我们来讲一种基于粒子的其他模型——严格说就不再是典型的粒子系统了。我们在粒子之间添加了一根线、比如一根“弹簧”，就构成了我们的可形变弹性网格[4]。这种结构可以就可以用于我们的头发、布料、软体模拟，再比如我们在DCC软件中常用的晶格变形器：驱动刚体的扭曲变形。由于时间的关系，我们这次的课程没有单开对应的章节，只是在粒子这一章，介绍其中的一种基于粒子的方法。\n弹簧-质量-阻尼模型 弹簧-质量-阻尼模型是可形变弹性网格的核心系统，即粒子之间的连接所施加的力由弹力和阻力两种。\n弹力： \\(\\mathbf f_k=-kx\\) ， \\(k\\) 为劲度系数（\\(x\\) 为形变长度） 阻力： \\(\\mathbf f_d=-dv\\) ， \\(d\\) 为阻尼系数（通常得到的是阻尼因子 \\(\\zeta=\\dfrac{d}{2\\sqrt{km}}\\)） 设其他外力和为 \\(\\mathbf f_e\\) ，则有 \\(ma=\\mathbf f_e-kx-dv\\) 即 \\(m\\ddot{x}+d\\dot{x}+kx=\\mathbf f_e\\) ，又是一个二阶微分方程。\n面的受力 当我们将点连接起来时，不可避免地就出现了面。虽然面不参与与粒子的交互，但面受到阻力、风等外部力的作用效果也需要参与到粒子的迭代计算中去。这里主要是有升力和空气阻力两种力，前者推动网格运动，后者阻碍。这里时间原因我们就不再详细分析。\n升力： \\(\\mathbf f_d=-C_dA(\\hat \\mathbf n\\dot\\ \\mathbf v_r)\\mathbf v_r\\) 拖拽力： \\(\\mathbf f_l=-C_lA(\\hat \\mathbf n\\dot\\ \\mathbf v_r)(\\mathbf v_r\\times\\dfrac{\\hat \\mathbf n\\times\\mathbf v_r}{\\left \\|\\hat \\mathbf n\\times\\mathbf v_r\\right \\| })\\) 弹性网格模拟 对每一个粒子，逐连接体、逐面计算合力。\nforeach particle do Calculate F_e; foreach rod do Calculate F_k and F_d foreach face do Calculate F_face end end end foreach particle i do Update status of i end 碰撞 这里，我们需要用一个形体的观点来看待弹性网格了，这与粒子的碰撞截然不同了。对于一个几何形体，我们需要从点、线、面三个结构上来判定碰撞。实际情况中，“顶点与顶点”、“顶点与线”、“线与面”的碰撞情况非常少——概率几乎为零，因此我们一般只会判断“顶点与面”和“边与边”。\n顶点-面检测：这种检测我们在介绍粒子碰撞时就已经提过。 边-边检测：思路上是取两条线上面到另一条线最近的点（作垂面交点），求这两个点的距离。 案例分析与欣赏 布料系统影片案例 [1] Particle systems - A technique for modeling a class of fuzz objects [2] Particle animation and rendering using data parallel computation [3] Flocks, Herds, and Schools: A Distributed Behavioral Model [4] The behavioral test-bed: Obtaining complex behavior from simple rules\n","permalink":"https://elderlyaugustus.github.io/posts/2021-11-23-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/","summary":"这节课开始我们将花两节课的时间从粒子、刚体、流体三种系统，来简要介绍一些基于物理的动画的基本原理与实现，并给大家展示一些具体的制作方法和成果。\n粒子系统 基于粒子的模型是基于物理的动画的一个基础模型，是拉格朗日方法中最典型的一种。这里的粒子系统个人认为广义地来说就是基于粒子的模型，是以粒子视点对物理现象做点采样的所有动画系统，但业界我们往往狭义地认为其典型就是特指由发射器发射大规模粒子、通过外力驱动运动、渲染成具体的无定形形象的系统。我们这一章的陈述主要还是以典型的粒子系统为主，会拓展些基于粒子的、但并不一定称为粒子系统的模型。\n粒子系统一般用来表现雨、雪、火、烟、尘、沙尘暴、烟花、水花、喷雾等等“无定形现象（Amorphous Phenomena[1]）”，当然也包括我们常见的一些“非物理现象”，诸如哥斯拉的吐息、猩红女巫的魔法光效等等，这些非物理现象同样要通过我们的物理系统去驱动粒子来产生这些效果。\n一个粒子 在开始讲粒子系统之前，我们还是要讲一下一个粒子的运动：粒子的运动只有位移——就如我们中学物理中常做的质点模型一样，对一个粒子而言，所需要的动力学参数仅有、位置、速度、加速度、受力、质量等。在这之中，质量将受力与加速度联系为同一个概念，位置的变化（位移）是速度的积分、速度的变化又是加速度的积分。而且与中学物理不同的是，这里的每一个量都是三维空间中的向量了。\n那么在这里，我们就第一次涉及到了时间积分概念的应用，也就是我们上节课刚刚讲过的如何在时间离散系统里做积分。\n我们用上图这样的近似积分方式，就能够表达粒子随着时间的运动。那么知道了如何描述一个粒子的运动，我们就能够描述一堆粒子的运动了——换言之，我们可以开始了解一个基本的粒子系统。\n基本粒子系统 我们来了解一个基本的粒子系统。在一个基本粒子系统的模拟过程中，通常包含了生成、模拟、消失三个过程，再加上把模拟过程渲染出来的渲染环节，我们分别讲解。\n粒子生成 粒子生成器 粒子生成字面含义就是粒子是怎样初始化的，怎样给大量的粒子赋予初始的参数。因此我们设计了“生成器”，或者也可以称为“发射器”。\n从发射器的形状说起，我们一般有点发射、平面发射、三维表面发射三种。\n点发射顾名思义就是从同一个位置发射所有粒子，方向上有朝单一矢量、全方向两种。 平面发射中，平面主要有圆盘平面和多边形（三角形）平面两种。 三维表面发射中，以模型表面为发射器，可以认为是多个多边形平面发射的组合；另一种是在体积内发射，即在一个区域内随即发射。 生成器分类 粒子生成的随机算法 我们想象，以相同的质量、速度、加速度、方向、位置等参数来初始化大量粒子会出现什么现象：所有粒子会以相同或平行的轨迹运动。所以我们这里需要使用随机算法来初始化粒子的参数、方向矢量、位置，也就是需要生成随机数、随机矢量和随机点三种数据类型。\n随机数 —— 为了控制粒子形态，我们一般不会直接使用系统的 rand() 来产生均匀分布的随机数，这就涉及到随机分布的概念：\n均匀分布：均匀分布即每一个数出现的概率是均等的，经典案例就是抛硬币。只有我们希望空间中充满随机的点运动时才会使用。\n高斯分布 / 正态分布：概率密度函数 \\(p(x)=\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{\\frac{(x-\\mu)^2}{2\\sigma^2}}\\) （概率密度函数 PDF 指的是概率密度 - 数值，概率密度大家可以类比中学统计中的概率/区间宽度，区间宽度 -\u0026gt; 0） 利用高斯分布，我们就可以得到一个“大部分粒子以这个参数运动，少量随机发散”的结果，比如火花飞溅时，大部分火花都会溅射在一个区域范围内，有少量迸发到外面的样子。能够让我们更好地控制粒子的运动。\n随机矢量：首先我们要了解如何生成一个均匀的球面分布，大家想象我们的地球上的任意一个点，做与球心的连线投影到赤道平面上得到长度 \\(r\\) ，与子午分割线成 \\(\\theta\\) 角，那么我们只要随机 \\(h=\\sqrt{1-r^2}\\) 和 \\(\\theta\\) 两个值就能够得到随机矢量 \\(\\begin{bmatrix}r\\cos\\theta\\\\h\\\\r\\sin\\theta\\end{bmatrix}\\) ，经数学证明，球面上的点随 \\(\\theta\\) 和 \\(h\\) 线性分布，因此，只要控制这两个随机数就可以控制球面的随机矢量。\n同理我们可以得到控制下图两种：点向圆盘方向发射、圆盘发射时控制随机矢量的参数，分别是\\(\\theta \\ \\phi\\) 和 \\(\\theta\\ r\\) 。也就是把随机向量转换成了两个随机数的问题。\n随机点：三维空间中的一个点其实就是三个数，我们按照需要来生成三个随机数即可。当然也可以用一个随机矢量（两个随机数）+随机长度（一个随机数）的方式生成。随机点主要应用于表面发射的偏移和体积内发射。\n粒子模拟 碰撞 在不考虑交互的情况下（后面会专门讨论），粒子在模拟过程中除了随着力场一步一步地迭代和人工控制之外的会产生剧变的现象就是碰撞了。粒子系统通常工作在含有模型的场景中，我们就需要考虑与模型的碰撞，其实也就是与一个个平面三角形的碰撞。问题在于，粒子是一个无体积的点，而粒子所处的位置又是离散的点，粒子恰好停在一个表面的概率微乎其微，那么我们如何判定碰撞而不是让粒子直接穿越表面呢？下面我们就会讲到。\n碰撞主要分为两个步骤，分别是碰撞检测和碰撞响应。首先我们得发现产生了碰撞，在发现碰撞之后，就可以执行相应的碰撞响应，这里的响应可以是让粒子消失、吸附、飞出去各种，下面举例说最简单的反弹这种。\n处理一个点与一个面的碰撞主要有Penalty（惩罚）和Impulse（冲击）两种思路：\nPenalty 碰撞检测：通过点与面的距离 \\(\\phi(x)\\) 判断 碰撞响应：更新 \\(f\\) ，判定碰撞后的下一个时间步更新粒子状态","title":"2021-11-23-影片技术分析Pre-基于物理的动画-粒子系统与基于粒子的模型"},{"content":"基于物理的动画/物理模拟 Physically Based Animation\n今天我和李乐游给大家讲一下基于物理的动画这个题目。首先我们来解释一下这个题目，这个动画指的不是一部动画片的那个动画，是指在动画片/视效制作中的一个环节，也是计算机图形学的三个大方向之一：建模Modeling、动画Animation、渲染Rendering。也就是驱动我们的模型动起来的过程——那么怎样驱动我们的模型动起来呢。大家最熟悉的一种方式就是Key关键帧，比如大家建了一个肖翱的模型，要驱动我去运动，那自然是要把我绑定到骨骼上，对每个关节去打关键帧，比如把我的手十秒后挪到这里。但是呢，不是所有的动画都适合用关键帧来驱动，比如窗外雪花飘飘、一辆车跌落悬崖、瀑布飞流直下，这样的镜头如果用Key关键帧的方法去完成，那就不是Key我身上的几十个关节这么“容易”的事了。但这种物理现象往往是遵循物理规律的，我们想让他看起来真实，那么我们就可以用物理规律去驱动它运动；又或者是一个非自然的物理现象，我们也可以创造非自然的物理规律去驱动它运动。这样的动画方法我们称之为基于物理的动画，也称为物理模拟，也有人将模拟Simulation单独作为图形学的第四个方向。下面我们说到这两个词大家知道都是指同一个东西就行了。\n那么基于物理的动画，在我们的电影中能做出什么样的效果呢，我们剪了一段经典影片中的Showreel给大家欣赏一下。然后我们将从发展历史、基本概念出发，介绍影视制作中的物理模拟制作流程、几种系统的算法原理与实现、展示一些我们自己制作的和经典影片中的基于物理的动画镜头，最后对物理模拟这项技术的未来再做一个分析和展望。\n发展历史 1940年代和1950年代 基于物理的动画来源于计算机模拟技术。它的首次大规模开发是著名的曼哈顿计划中的一个重要部分。在第二次世界大战中，为了模拟核爆炸的过程，人们应用蒙特·卡罗方法用12个坚球模型进行了模拟。计算机模拟最初被作为其他的方面研究的补充，但当人们发现它的重要性之后，它便作为一门单独的课题被使用得相当广泛。 之后便逐渐应用于军事和制造业。但在很长一段时间内，计算机计算非常昂贵，通常只有军事会使用这项技术。\n20世纪70年代和80年代初 计算机图像生成技术兴起，1972年，第一部计算机生成的动画《A Computer Animated Hand》诞生，其中的一部分在1976年的电影《未来世界》中出现。这是电影第一次使用计算机生成图像。1982年《星际迷航II：可汗之怒》中的“创世纪”片段被普遍认为是VFX和计算机图形学的里程碑。这个片段首次使用了粒子系统，用CG的形式表现了爆炸效果。它是SIGGRAPH军事研究和电影工业早期交叉的产物之一。\n20世纪80年代初至90年代 20世纪80年代的技术进步使电脑比前几十年更便宜、功能更强，这促进了Xbox游戏等的兴起。1985年，任天堂发布了任天堂娱乐系统（NES），NES成为视频游戏史上最畅销的游戏机之一。20世纪90年代，随着模拟人生、命令与征服等游戏的发布，以及台式电脑的不断增强，电脑游戏变得越来越流行。\n1993年，电影《侏罗纪公园》成为第一部广泛使用计算机生成图形的电影，将计算机模拟的模拟恐龙几乎无缝地融入到实景中，这一事件改变了电影业。1995年，《玩具总动员》是第一部只使用计算机生成图像的电影，1998年，《蚁哥正传》第一次在动画中使用流体模拟。到了21世纪，计算机生成图像成为电影特效的主要选择。\n21世纪初至今 计算机图形学技术走向成熟，游戏和电影领域普遍使用基于物理的动画，在虚拟世界中模拟真实世界中物体之间的相互作用。\n基本概念 讲完发展历史，我们要开始正式进入基于物理的动画的世界。我把影视制作中基于物理的动画的制作归结为：“在计算机系统中、建立一定的物理模型、模拟生成动画并渲染成画面”。那么我们就需要首先了解一些基本概念。\n物理学的运动 在进入计算机之前，我们就需要把我们想要表现的画面、或者说想要模拟的现象，依据物理定律建构为物理模型。所以我们所有模拟首先要依赖于物理定律，由于目前影视制作的物理特效还很少涉及微观物理世界和超宏观物理世界（《蚁人2》、《星际穿越》这样的影片也仅仅是通过物理学家作为顾问来补齐一些“科幻设定”），所以我们使用的物理定律主要还是一般宏观视角的规律，如牛顿三大运动定律、各种守恒：\n牛顿运动定律 第一定律 假若施加于某物体的外力为零，则该物体的运动速度不变（惯性定律）【力是改变物体运动状态的原因】 第二定律 \\(F = ma\\) 【核心】 第三定律 当两个物体相互作用于对方时，彼此施加于对方的力，其大小相等、方向相反（作用力与反作用力定律） 三大守恒 质量守恒 动量守恒 \\(\\dfrac{d}{dt}mv=0\\Rightarrow mv={\\bf constant}\\) 【来源自牛二定律】 能量守恒 在力学模拟中常常体现为机械能守恒 \\(\\dfrac{1}{2}mv^2+mgh+\\dfrac{1}{2}k\\Delta x^2(\\Delta x=\\int adt)+\\dots={\\bf constant}\\) 有了基本定律，我们就可以考虑要建构怎样的模型了。不同性质的物体，所形成的物理模型显然是不同的，典型的物体性质按材料分有刚体、软体、流体等等，针对不同的物体，我们有不同的物理模型，用各种系统去做模拟方法，第二节课我们就会说到其中一些代表性的模拟系统。\n计算机的离散系统 计算机与真实的物理世界最大的不同在于离散与连续。真实世界是一个连续的世界，我手在空中划过，我可以任取无数个时间点、我的手所在的位置，我的手的运动轨迹上的每一个点都是存在的。而如果在计算机系统中，这就是不可能的，我的手在计算机中一定会有一个计算精度，导致大量的点是不存在的，我手的运动其实是一次次“瞬移”组合而成的。这种离散化体现在两个方面：空间上和时间上。\n空间上的离散化 两种基本的观察视点 我们在观测一个物理现象时，一般有两种观察的方法：一种是盯着某个物体，观察物体的运动，视线随着物体走；一种是盯着某个区域，观察物体在这个区域的运动。到计算机中离散存储空间运动时，也需要用这两种观察方法：记录物体、把物体的状态信息存储在物体上，即拉格朗日视点；把空间网格化，记录某一位置是否有物体、物体的属性是什么，即欧拉视点（需要强调，这里的欧拉与前面的欧拉法解线性方程并不一样，我们伟大的数学、物理学家的名字可不能只用在一种地方啊）。\n拉格朗日视点 欧拉视点 视效工作中常用的三种表达方法 我们再具体一点，在视效工作中，离散化一个物理系统通常有以下几种：\n粒子 Particle 粒子就是把物体作为一个个“质点”的组合，假设还是观察挥手这个动作，那么把我的手当成一群点组成的点集（大家可以理解为细胞？或者我手上的所有分子？），追溯每一个点的位置、速度、加速度，对每一个点去迭代。这是一个很典型的拉格朗日视点方法。 物体网格 Mesh （粒子的复合体） 第二种大家应该是比较熟悉的。我们在雪松老师的建模课上、在MAYA中处理的大多数模型都是这种离散化方法。用一个个的面去组成我们的风车、无人机、甲壳虫，再如我的手。而我们建模课上，雪松老师无数次强调要用“四边面”来方便进一步细分曲面处理，但无论是四边面还是最终渲染管线中的三角面，都是由一个个的点组成的。我们在模拟迭代计算时，仍然考虑点的状态，因此这也是一种拉格朗日视点的方法。 空间网格/体素 Grid/Voxel 现在大家考虑把我手的运动的这个区域框成一个空间，把这个空间网格化，这个过程可以类比二维情况下的像素化，我们称为“体素”，以1mm*1mm*1mm的立方体作为一个体素来描述这个空间。我的手从左到右挥过这个空间，首先是左边的空间有物体存在，然后中间，最后右边。我们记录每一个体素上是否有物体、物体的运动速度、加速度等信息，来迭代。这种方法就是欧拉视点的方法了。 在后面我们的具体方法介绍中，大多数都使用的拉格朗日视点的方法，到流体部分会涉及到欧拉视点和两种视点混合的新型方法。\n时间上的离散化 时间维度上，我们用“时间步”的概念来离散化我们的物理模型，每一次需要计算的“点”称为一个时间步。假定我们的时间步长是1/24s，那么我们就会对相应物理模型每1/24s做一次计算（这个1/24s是物理模型的1/24s，不是我计算花的时间，事实上计算一个时间步所花的时间一般要比时间步长长得多），例如我的手花了1s挥过，那么我只计算其中的24个点、我的手位于什么位置，最终组合成一个动画。\n而离散化的多种方法主要是来源于考虑基于“何时”的状态来做下一步的计算。我们要计算当前时刻物体的位置，即上一个已知位置之后发生的位移，那么我们理应得到速度发生的变化，对其积分得到总的位置，但现在我们只知道上一个时间步的位置和速度，那么显而易见的，我们可以直接用上一个时间步的参数来计算——这就是我们所谓的显式时间积分；但显式时间积分很容易出问题：容易发生发散、不收敛的现象，导致数值爆炸，但如果我们硬要用当前时间步的状态，数值就稳定了，但我们的当前状态是“隐藏的”——因此要称为隐式时间积分。\n显式时间积分 前向欧拉 \\(v_{t+1}=v_t+a_t\\Delta t \\\\ x_{t+1}=x_t+v_t\\Delta t\\) 这就是完全使用前一时间步的速度、加速度来计算 半隐式欧拉 \\(v_{t+1}=v_t+a_t\\Delta t \\\\ x_{t+1}=x_t+v_{t+1}\\Delta t\\) 这里，我们先算出了当前时间步的速度，这样我们就可以用当前时间步的速度来计算了，称之为“半隐式”是因为速度这个参数确实是隐藏的，但其确实是通过前一个时间步的加速度“顺着”算出来的，本质上仍然是一个明显的量，所以本质上还是显示的时间积分方法。那么什么样是“不明显的”呢，我们接着看。 隐式时间积分 后向欧拉 \\(v_{t+1}=v_t+a_{t+1}\\Delta t \\\\ x_{t+1}=x_t+v_{t+1}\\Delta t\\) 可以看到我们这里把加速度也换成当前时间步的加速度了，除了上一时间步的位置作为初值，不再有使用前一时间步的任何状态参数，那么怎么求解呢？我们把这个公式替换、变形、泰勒展开，最终得到了 \\([{\\bf I}-\\Delta t^2 {\\bf M}^{-1}\\dfrac{\\partial f(x_t)}{\\partial x}]v_{t+1}=v_t+\\Delta t{\\bf M}^{-1}{\\bf f}(x_t)\\) ，形如 \\(Ax=b\\) 的一个线性方程：至于怎么解线性方程，大家大一是学过其中的数值解法的，也即Gauss消元、三角分解这些，但这些方法在解这样庞大、复杂的方程显得无能为力。因此我们引入迭代法去求解，也即再把式子做一些变形，得到一个满足迭代条件的结构，任给其一个初值，去不断重复计算，来逼近真实的解——迭代次数越多，越精准。经典的迭代方法有牛顿迭代法、Jacobi迭代法、共轭梯度法等等。这里就不再展开了。 有了这些基本概念，我们终于可以进入到具体的基于物理的动画的介绍中了。接下来，我们会轻松一会，远离数理概念一段时间，介绍在一个电影制作流程中、一家影视视效公司里，基于物理的动画、或者说物理模拟工作的制作流程、分工。然后我们会就粒子系统、刚体系统、流体系统三种物理模拟系统来给大家介绍一些物理模拟的基本算法与效果。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-11-18-%E5%BD%B1%E7%89%87%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90pre-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E5%8A%A8%E7%94%BB-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","summary":"基于物理的动画/物理模拟 Physically Based Animation\n今天我和李乐游给大家讲一下基于物理的动画这个题目。首先我们来解释一下这个题目，这个动画指的不是一部动画片的那个动画，是指在动画片/视效制作中的一个环节，也是计算机图形学的三个大方向之一：建模Modeling、动画Animation、渲染Rendering。也就是驱动我们的模型动起来的过程——那么怎样驱动我们的模型动起来呢。大家最熟悉的一种方式就是Key关键帧，比如大家建了一个肖翱的模型，要驱动我去运动，那自然是要把我绑定到骨骼上，对每个关节去打关键帧，比如把我的手十秒后挪到这里。但是呢，不是所有的动画都适合用关键帧来驱动，比如窗外雪花飘飘、一辆车跌落悬崖、瀑布飞流直下，这样的镜头如果用Key关键帧的方法去完成，那就不是Key我身上的几十个关节这么“容易”的事了。但这种物理现象往往是遵循物理规律的，我们想让他看起来真实，那么我们就可以用物理规律去驱动它运动；又或者是一个非自然的物理现象，我们也可以创造非自然的物理规律去驱动它运动。这样的动画方法我们称之为基于物理的动画，也称为物理模拟，也有人将模拟Simulation单独作为图形学的第四个方向。下面我们说到这两个词大家知道都是指同一个东西就行了。\n那么基于物理的动画，在我们的电影中能做出什么样的效果呢，我们剪了一段经典影片中的Showreel给大家欣赏一下。然后我们将从发展历史、基本概念出发，介绍影视制作中的物理模拟制作流程、几种系统的算法原理与实现、展示一些我们自己制作的和经典影片中的基于物理的动画镜头，最后对物理模拟这项技术的未来再做一个分析和展望。\n发展历史 1940年代和1950年代 基于物理的动画来源于计算机模拟技术。它的首次大规模开发是著名的曼哈顿计划中的一个重要部分。在第二次世界大战中，为了模拟核爆炸的过程，人们应用蒙特·卡罗方法用12个坚球模型进行了模拟。计算机模拟最初被作为其他的方面研究的补充，但当人们发现它的重要性之后，它便作为一门单独的课题被使用得相当广泛。 之后便逐渐应用于军事和制造业。但在很长一段时间内，计算机计算非常昂贵，通常只有军事会使用这项技术。\n20世纪70年代和80年代初 计算机图像生成技术兴起，1972年，第一部计算机生成的动画《A Computer Animated Hand》诞生，其中的一部分在1976年的电影《未来世界》中出现。这是电影第一次使用计算机生成图像。1982年《星际迷航II：可汗之怒》中的“创世纪”片段被普遍认为是VFX和计算机图形学的里程碑。这个片段首次使用了粒子系统，用CG的形式表现了爆炸效果。它是SIGGRAPH军事研究和电影工业早期交叉的产物之一。\n20世纪80年代初至90年代 20世纪80年代的技术进步使电脑比前几十年更便宜、功能更强，这促进了Xbox游戏等的兴起。1985年，任天堂发布了任天堂娱乐系统（NES），NES成为视频游戏史上最畅销的游戏机之一。20世纪90年代，随着模拟人生、命令与征服等游戏的发布，以及台式电脑的不断增强，电脑游戏变得越来越流行。\n1993年，电影《侏罗纪公园》成为第一部广泛使用计算机生成图形的电影，将计算机模拟的模拟恐龙几乎无缝地融入到实景中，这一事件改变了电影业。1995年，《玩具总动员》是第一部只使用计算机生成图像的电影，1998年，《蚁哥正传》第一次在动画中使用流体模拟。到了21世纪，计算机生成图像成为电影特效的主要选择。\n21世纪初至今 计算机图形学技术走向成熟，游戏和电影领域普遍使用基于物理的动画，在虚拟世界中模拟真实世界中物体之间的相互作用。\n基本概念 讲完发展历史，我们要开始正式进入基于物理的动画的世界。我把影视制作中基于物理的动画的制作归结为：“在计算机系统中、建立一定的物理模型、模拟生成动画并渲染成画面”。那么我们就需要首先了解一些基本概念。\n物理学的运动 在进入计算机之前，我们就需要把我们想要表现的画面、或者说想要模拟的现象，依据物理定律建构为物理模型。所以我们所有模拟首先要依赖于物理定律，由于目前影视制作的物理特效还很少涉及微观物理世界和超宏观物理世界（《蚁人2》、《星际穿越》这样的影片也仅仅是通过物理学家作为顾问来补齐一些“科幻设定”），所以我们使用的物理定律主要还是一般宏观视角的规律，如牛顿三大运动定律、各种守恒：\n牛顿运动定律 第一定律 假若施加于某物体的外力为零，则该物体的运动速度不变（惯性定律）【力是改变物体运动状态的原因】 第二定律 \\(F = ma\\) 【核心】 第三定律 当两个物体相互作用于对方时，彼此施加于对方的力，其大小相等、方向相反（作用力与反作用力定律） 三大守恒 质量守恒 动量守恒 \\(\\dfrac{d}{dt}mv=0\\Rightarrow mv={\\bf constant}\\) 【来源自牛二定律】 能量守恒 在力学模拟中常常体现为机械能守恒 \\(\\dfrac{1}{2}mv^2+mgh+\\dfrac{1}{2}k\\Delta x^2(\\Delta x=\\int adt)+\\dots={\\bf constant}\\) 有了基本定律，我们就可以考虑要建构怎样的模型了。不同性质的物体，所形成的物理模型显然是不同的，典型的物体性质按材料分有刚体、软体、流体等等，针对不同的物体，我们有不同的物理模型，用各种系统去做模拟方法，第二节课我们就会说到其中一些代表性的模拟系统。\n计算机的离散系统 计算机与真实的物理世界最大的不同在于离散与连续。真实世界是一个连续的世界，我手在空中划过，我可以任取无数个时间点、我的手所在的位置，我的手的运动轨迹上的每一个点都是存在的。而如果在计算机系统中，这就是不可能的，我的手在计算机中一定会有一个计算精度，导致大量的点是不存在的，我手的运动其实是一次次“瞬移”组合而成的。这种离散化体现在两个方面：空间上和时间上。\n空间上的离散化 两种基本的观察视点 我们在观测一个物理现象时，一般有两种观察的方法：一种是盯着某个物体，观察物体的运动，视线随着物体走；一种是盯着某个区域，观察物体在这个区域的运动。到计算机中离散存储空间运动时，也需要用这两种观察方法：记录物体、把物体的状态信息存储在物体上，即拉格朗日视点；把空间网格化，记录某一位置是否有物体、物体的属性是什么，即欧拉视点（需要强调，这里的欧拉与前面的欧拉法解线性方程并不一样，我们伟大的数学、物理学家的名字可不能只用在一种地方啊）。\n拉格朗日视点 欧拉视点 视效工作中常用的三种表达方法 我们再具体一点，在视效工作中，离散化一个物理系统通常有以下几种：\n粒子 Particle 粒子就是把物体作为一个个“质点”的组合，假设还是观察挥手这个动作，那么把我的手当成一群点组成的点集（大家可以理解为细胞？或者我手上的所有分子？），追溯每一个点的位置、速度、加速度，对每一个点去迭代。这是一个很典型的拉格朗日视点方法。 物体网格 Mesh （粒子的复合体） 第二种大家应该是比较熟悉的。我们在雪松老师的建模课上、在MAYA中处理的大多数模型都是这种离散化方法。用一个个的面去组成我们的风车、无人机、甲壳虫，再如我的手。而我们建模课上，雪松老师无数次强调要用“四边面”来方便进一步细分曲面处理，但无论是四边面还是最终渲染管线中的三角面，都是由一个个的点组成的。我们在模拟迭代计算时，仍然考虑点的状态，因此这也是一种拉格朗日视点的方法。 空间网格/体素 Grid/Voxel 现在大家考虑把我手的运动的这个区域框成一个空间，把这个空间网格化，这个过程可以类比二维情况下的像素化，我们称为“体素”，以1mm*1mm*1mm的立方体作为一个体素来描述这个空间。我的手从左到右挥过这个空间，首先是左边的空间有物体存在，然后中间，最后右边。我们记录每一个体素上是否有物体、物体的运动速度、加速度等信息，来迭代。这种方法就是欧拉视点的方法了。 在后面我们的具体方法介绍中，大多数都使用的拉格朗日视点的方法，到流体部分会涉及到欧拉视点和两种视点混合的新型方法。\n时间上的离散化 时间维度上，我们用“时间步”的概念来离散化我们的物理模型，每一次需要计算的“点”称为一个时间步。假定我们的时间步长是1/24s，那么我们就会对相应物理模型每1/24s做一次计算（这个1/24s是物理模型的1/24s，不是我计算花的时间，事实上计算一个时间步所花的时间一般要比时间步长长得多），例如我的手花了1s挥过，那么我只计算其中的24个点、我的手位于什么位置，最终组合成一个动画。","title":"2021-11-18-影片技术分析Pre-基于物理的动画-发展历史与基本概念"},{"content":"Lecture07 Rendering Pipeline, Post-Process and Everything Ambient Occlusion 接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。\nAO：单目视觉中形成3D感的重要元素\n不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。\nPrecomputed AO 使用Ray Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。\n效果好，计算复杂，且无法处理多物体之间的AO。\nSSAO, Screen Space AO @GAMES202 SSAO\nHBAO, Horizon-based Ambient Occlusion 在法线方向半球空间内积分 \\[ A=1-\\dfrac{1}{2\\pi}\\int_{\\theta=-\\pi}^\\pi\\int_{\\alpha=t(\\theta)}^h(\\theta)W(\\vec\\omega)\\cos\\alpha\\,\\mathrm d\\alpha\\mathrm d\\theta \\] 利用深度图做Ray Marching GTAO, Ground Truth - based AO SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)\n\\[ \\hat A(x)=\\dfrac{1}{\\pi}\\int_0^\\pi\\int_{\\theta_1(\\phi)}^{\\theta_2(\\phi)}\\cos(\\theta-\\gamma)^+|\\sin(\\theta)|\\,\\mathrm d\\theta\\mathrm d\\phi\\\\\\gamma={\\rm angle}(\\vec n, \\vec v) \\]\n根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO\nRay-Tracing AO @GAMES202 RTRT\nFog Depth Fog 随着深度透明度下降\nLinear fog: factor = (end-z) / (end - start) Exp fog: factor = exp(- density * z) Exp Squared fog: factor = exp(- (density * z) ^ 2) Height Fog 设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减\n观察方向的Height Fog积分 \\[ \\begin{array}{c}D(h)=D_\\max\\cdot e^{-\\sigma\\cdot\\max(h-H_s, 0)}\\\\ \\begin{aligned}{\\rm FogDensityIntegration}=\u0026amp;\\ D_\\max\\cdot d\\int_0^1 e^{-\\sigma\\cdot\\max(v_z+t\\cdot d_z-H_s, 0)}\\,\\mathrm dt\\\\=\u0026amp;\\ D_\\max\\cdot de^{-\\sigma\\cdot\\max(v_z-H_s, 0)}\\dfrac{1-e^{-\\sigma\\cdot d_z}}{\\sigma\\cdot d_z} \\end{aligned}\\end{array} \\] Fog颜色 \\[ {\\rm FogInscatter}=1-\\exp^{- \\rm FogDensityIntegration}\\\\ {\\rm FinalColor} = {\\rm FogColor}\\cdot{\\rm FogInscatter} \\]\nVoxel-based Volumetric Fog 现代的雾效，可以实现丁达尔效应\n对整个相机空间Voxelize，以不同大小的四棱台作Voxel 计算方法与Atmosphere计算相似 用一个3D Texture存储，长宽尽量与屏幕成整数倍（eg. 160*90） Anti-aliasing @GAMES202 AA\n三种走样：Edge Sampling, Texture Sampling（MIPMAP可解决）, Specular Sampling\nPost-process Bloom 光晕 检测提取高光区域（计算灰度，比较阈值） 对高光区域作Gaussian Blur（横向/纵向各一轮减少计算） -\u0026gt; Pyramid Gaussian Blur 将模糊完的图像叠加到图像上 Tone Mapping HDR to SDR\nflimic s-curve ACES Color Grading LUT Tone Mapping and Color Grading is my area hhhhh (at DFTT of BFA)\nRendering Pipeline Forward Rendering Shadow Pass -\u0026gt; Shading -\u0026gt; Post-process 逐物体绘制 透明材质排序，由远及近绘制 -\u0026gt; 各种问题 多光源绘制复杂 Deferred Rendering Pass 1\nfor each object: write G-Buffer; Pass 2\nfor each pixel: gbuffer = readGBuffer(G-Buffer); for each light: computeShading(gbuffer, light); Tiled-based Rendering 移动端读写能耗大\n切成小块，小块渲染、小块读写\n光源也可以被切割成Tile\n深度上也可对光源优化\nTiled Deferred Rendering Forward+ (Tiled Forward) Rendering Cluster-based Rendering Visibility Buffer V-Buffer Depth PrimitiveID Barycentrics Unreal Engine Rendering Pipeline V-Sync / FreeSync / VRR ","permalink":"https://elderlyaugustus.github.io/posts/2022-05-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture7-postprocessingandothers/","summary":"Lecture07 Rendering Pipeline, Post-Process and Everything Ambient Occlusion 接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。\nAO：单目视觉中形成3D感的重要元素\n不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。\nPrecomputed AO 使用Ray Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。\n效果好，计算复杂，且无法处理多物体之间的AO。\nSSAO, Screen Space AO @GAMES202 SSAO\nHBAO, Horizon-based Ambient Occlusion 在法线方向半球空间内积分 \\[ A=1-\\dfrac{1}{2\\pi}\\int_{\\theta=-\\pi}^\\pi\\int_{\\alpha=t(\\theta)}^h(\\theta)W(\\vec\\omega)\\cos\\alpha\\,\\mathrm d\\alpha\\mathrm d\\theta \\] 利用深度图做Ray Marching GTAO, Ground Truth - based AO SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)\n\\[ \\hat A(x)=\\dfrac{1}{\\pi}\\int_0^\\pi\\int_{\\theta_1(\\phi)}^{\\theta_2(\\phi)}\\cos(\\theta-\\gamma)^+|\\sin(\\theta)|\\,\\mathrm d\\theta\\mathrm d\\phi\\\\\\gamma={\\rm angle}(\\vec n, \\vec v) \\]\n根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO\nRay-Tracing AO @GAMES202 RTRT\nFog Depth Fog 随着深度透明度下降\nLinear fog: factor = (end-z) / (end - start) Exp fog: factor = exp(- density * z) Exp Squared fog: factor = exp(- (density * z) ^ 2) Height Fog 设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减","title":"2022-05-03-GAMES104现代游戏引擎-Lecture7-Rendering Pipeline, Post-Process and Everything"},{"content":"Lecture06-2 Sky and Atmosphere Atmosphere 大气 Analytic Atmosphere Appearance Modeling 不必按照物理模拟，根据观察找模型拟合\n两个参数\n观察向量与垂直向上向量的夹角 \\(\\theta\\) 观察向量与太阳方向的夹角 \\(\\gamma\\) \\[ \\mathbb{F}(\\theta,\\gamma)=(1+Ae^{\\frac{B}{\\cos\\theta+0.01}})\\cdot(C+De^{E\\gamma}+F\\cos^2\\gamma+G\\cdot\\chi(H,\\gamma)+I\\cdot\\cos^{\\frac{1}{2}}\\theta)\\\\ L_\\lambda = \\mathbb{F}(\\theta,\\gamma)\\cdot L_{M\\lambda} \\]\n优势：简单快捷，直接代入计算即可\n劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气\nParticipating Media 物理属性 大气中：空气、气溶胶，形成各种折射和反射\n光在Participating Media中：\nAbsorption 吸收 \\[ \\dfrac{\\mathrm dL(\\mathrm x,\\omega)}{\\mathrm d\\mathrm x}=-\\sigma_\\alpha\\cdot L(\\mathrm x,\\omega)\\\\ \\sigma_\\alpha:\\text{Absorption Coeffcient} \\]\nOut-scattering 对外散射 \\[ -\\sigma_sL(\\mathrm x,\\omega)\\\\ \\sigma_s:\\text{Scattering Coeffcient} \\]\nEmission 自发光（火焰、辉光等） \\[ \\sigma_\\alpha L_e(\\mathrm x,\\omega) \\]\nIn-Scattering 对内散射 接收周围分子的Out-Scattering \\[ \\sigma_s\\int_{S^2}f_p(\\mathrm x,\\omega,\\omega\u0026#39;)L(\\mathrm x,\\omega\u0026#39;)\\,\\mathrm d\\omega\u0026#39;\\\\ f_p(\\mathrm x,\\omega,\\omega\u0026#39;):\\text{Phase Function} \\]\nRadiative Transfer Equation, RTE \\[ \\sigma_t(\\mathrm x)=\\sigma_\\alpha(\\mathrm x)+\\sigma_s(\\mathrm x)\\\\ \\dfrac{\\mathrm dL(\\mathrm x,\\omega)}{\\mathrm d\\mathrm x}=-\\sigma_t\\cdot L(\\mathrm x,\\omega)+\\sigma_\\alpha L_e(\\mathrm x,\\omega)+\\sigma_s\\int_{S^2}f_p(\\mathrm x,\\omega,\\omega\u0026#39;)L(\\mathrm x,\\omega\u0026#39;)\\,\\mathrm d\\omega\u0026#39; \\]\nVolume Rendering Equation, VRE 对RTE梯度的路径积分 \\[ L(P,\\omega)=\\int_{\\mathrm x=0}^\\mathrm d T(\\mathrm x)[\\sigma_\\alpha\\cdot L_e(\\mathrm x,\\omega)+\\sigma_s\\cdot L_i(\\mathrm x,\\omega)]\\,\\mathrm d\\mathrm x + T(M)L(M,\\omega)\\\\ T(\\mathrm x)=e^{-\\int_\\mathrm x ^P\\sigma_t(s)\\,\\mathrm d s}\\\\ L_i(\\mathrm x,\\omega)=\\int_{S^2}f_p(\\mathrm x,\\omega,\\omega\u0026#39;)L(\\mathrm x,\\omega\u0026#39;)\\,\\mathrm d\\omega\u0026#39; \\]\n两个关键部分\nTransmitters：远处物体有多少能透视到眼睛 光打到空气中的散射、折射后，沿观察方向的光路有多少能进入眼睛 Rayleigh Scattering 瑞利散射 空气中介质尺寸远小于光的波长时，光形成较为均匀的散射；波长越短（蓝紫色）散射越强，波长越长（红色）散射越弱\n\\[ S(\\lambda,\\theta,h)=\\dfrac{\\pi^2(n^2-1)}{2}\\cdot\\dfrac{\\rho(h)}{N}\\cdot\\dfrac{1}{\\lambda^4}\\cdot(1+\\cos^2\\theta)\\\\ \\lambda\\,\\text{波长}\\ h\\,\\text{海拔高度}\\ N\\,\\text{标准大气压}\\ \\theta\\,\\text{观察方向与光传播方向夹角} \\] 左半边固定，只需求右半边Phase Function部分\nScattering Coefficient \\(\\sigma_s^\\text{Rayleigh}(\\lambda,h)=\\dfrac{8\\pi^3(n^2-1)}{3}\\cdot\\dfrac{\\rho(h)}{N}\\cdot\\dfrac{1}{\\lambda^4}\\) Phase Function 腰果形函数 \\(F_\\text{Rayleigh}(\\theta)=\\dfrac{3}{16\\pi}(1+\\cos^2\\theta)\\) Mie Scattering 米氏散射 主要针对气溶胶，介质尺寸接近或大于光的波长时，光形成有一定方向性的散射、沿着光的方向较强；但对波长不敏感\n\\[ S(\\lambda,\\theta,h)=\\pi^2(n^2-1)\\cdot\\dfrac{\\rho(h)}{N}\\cdot\\dfrac{1-g}{2+g^2}\\cdot\\dfrac{(1+\\cos^2\\theta)}{(1-g^2-2g\\cos\\theta)^\\frac{3}{2}}\\\\ g\\,\\text{几何参数，一般由艺术家控制} \\]\nScattering Coefficient \\(\\sigma_s^\\text{Mie}(\\lambda,h)=\\dfrac{8\\pi^3(n^2-1)}{3}\\cdot\\dfrac{\\rho(h)}{N}\\) Phase Function \\(F_\\text{Mie}(\\theta)=\\dfrac{3}{8\\pi}\\cdot\\dfrac{1-g}{2+g^2}\\cdot\\dfrac{(1+\\cos^2\\theta)}{(1-g^2-2g\\cos\\theta)^\\frac{3}{2}}\\) \\(g=0\\) 时，退化成与瑞利散射分布相同的形状（类似花生豆）； \\(g\u0026gt;0\\) 时，沿米氏散射方向更多 \\(g\u0026lt;0\\) 时，反向更多 eg. 雾：即一种气溶胶，对太阳光不同波长无差别散射，故呈白色\neg. 日晕也是米氏散射带来的\n光的吸收\n臭氧吸收长波，红橙黄；甲烷吸收红光 假设：臭氧和甲烷均匀分布在大气中 单次散射和多次散射 Single Scattering \u0026amp; Multiple Scattering\nSingle Scattering \\[ L_1=\\int_A^BL_{P\\to A}\\,\\mathrm ds \\]\nMultiple Scattering \\[ L_{n+1}=\\int_A^B\\int_{4\\pi}L_n(P,v\u0026#39;)\\cdot S(\\lambda,\\theta,h)\\cdot T(P\\to A)\\,\\mathrm dv\u0026#39;\\mathrm ds \\]\nSingle Scattering的背阳面呈现死黑，Multi Scattering有亮度 解决方法 Ray Marching：沿着观察视线，一步一步积分\nPrecomputed Atmospheric Scattering\n把大气散射用Ray Marching预计算成 \\(\\cos\\theta\\) 和 \\(h\\) 为维度的LUT，计算时直接查表（\\(\\theta\\) 为观察视角与垂直向上方向夹角） 大气散射的两个部分：通透度Transmittance、散射度Scattering 通透度 Transmittance 预计算 \\(T(\\mathrm x)=e^{-\\int_\\mathrm x^P\\sigma_t(s)\\,\\mathrm ds}\\) 查表 \\(T(\\mathrm x_\\mathrm v\\to \\mathrm x_\\mathrm m)=\\dfrac{T(\\mathrm x_\\mathrm v\\to B)}{T(\\mathrm x_\\mathrm m\\to B)}\\) 二维LUT Single Scattering 预计算 \\(L_\\text{sun}\\displaystyle\\int_A^BS(\\lambda,\\theta,h)\\cdot(T(\\text{sun}\\to P)+T(P\\to A))\\,\\mathrm ds\\) 查表 \\(L(\\mathrm x_\\mathrm v\\to \\mathrm x_\\mathrm m)=L(\\mathrm x_\\mathrm v\\to B)-L(\\mathrm x_\\mathrm m\\to B)\\cdot T(\\mathrm x_\\mathrm v\\to \\mathrm x_\\mathrm m)\\) 四维LUT，但数值平滑，可以低精度插值，用Virtual Texture放在一张图上 Multi Scattering 利用前面两张LUT，积分预计算得Multi Scattering LUT（一般计算3-4次结果即可） 问题 预计算开销大 天气变化时难以均匀过渡 查表插值计算开销也不够小 A Scalable and Production Ready Sky and Atmosphere Rendering Technique\n核心思想：\n假设：对于空气中的一个分子，来自各个方向的散射是等同的\n问题转换为能量衰减问题，每次衰减百分之多少，Multi Scattering计算衰减百分比的级数求和即可\n取消海拔高度和太阳位置两个参数，不计算全部情况；只保留天顶角和环方向角两个维度\nRay marching预计算LUT\n不物理正确，但效率高、效果好，符合艺术家需要\nCloud 云 云的种类：层云、积云、卷云\n早期：Mesh、Billboard 片状贴图\nVolumetric Cloud Modeling 优势：全动态，runtime生成 劣势：算法复杂开销大\nWeather Texture 是否有值表示云的分布 0-1值表示当前位置云的厚度\n云的运动：Texture位移、扰动\nNoise Function\nPerlin Noise Worley Noise 先用Weather Texture生成柱状图 再用低频Noise Map腐蚀 最后加以高频Noise Map增加细节 Ray Marching渲染云\n","permalink":"https://elderlyaugustus.github.io/posts/2022-04-30-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.2-atmospherecloud/","summary":"Lecture06-2 Sky and Atmosphere Atmosphere 大气 Analytic Atmosphere Appearance Modeling 不必按照物理模拟，根据观察找模型拟合\n两个参数\n观察向量与垂直向上向量的夹角 \\(\\theta\\) 观察向量与太阳方向的夹角 \\(\\gamma\\) \\[ \\mathbb{F}(\\theta,\\gamma)=(1+Ae^{\\frac{B}{\\cos\\theta+0.01}})\\cdot(C+De^{E\\gamma}+F\\cos^2\\gamma+G\\cdot\\chi(H,\\gamma)+I\\cdot\\cos^{\\frac{1}{2}}\\theta)\\\\ L_\\lambda = \\mathbb{F}(\\theta,\\gamma)\\cdot L_{M\\lambda} \\]\n优势：简单快捷，直接代入计算即可\n劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气\nParticipating Media 物理属性 大气中：空气、气溶胶，形成各种折射和反射\n光在Participating Media中：\nAbsorption 吸收 \\[ \\dfrac{\\mathrm dL(\\mathrm x,\\omega)}{\\mathrm d\\mathrm x}=-\\sigma_\\alpha\\cdot L(\\mathrm x,\\omega)\\\\ \\sigma_\\alpha:\\text{Absorption Coeffcient} \\]\nOut-scattering 对外散射 \\[ -\\sigma_sL(\\mathrm x,\\omega)\\\\ \\sigma_s:\\text{Scattering Coeffcient} \\]\nEmission 自发光（火焰、辉光等） \\[ \\sigma_\\alpha L_e(\\mathrm x,\\omega) \\]\nIn-Scattering 对内散射 接收周围分子的Out-Scattering \\[ \\sigma_s\\int_{S^2}f_p(\\mathrm x,\\omega,\\omega\u0026#39;)L(\\mathrm x,\\omega\u0026#39;)\\,\\mathrm d\\omega\u0026#39;\\\\ f_p(\\mathrm x,\\omega,\\omega\u0026#39;):\\text{Phase Function} \\]","title":"2022-04-30-GAMES104现代游戏引擎-Lecture6.2-Sky and Atmosphere"},{"content":"Lecture06 Rendering of Mother Nature Lecture06-1 Terrain Rendering 地形渲染 Simple Idea - Heightfield Height Map Contour Map\n符合分形原则 渲染 均匀网格，依据Heightfield位移每一个顶点 问题：世界过大时过于复杂\n解决方法：LoD -\u0026gt; 非均匀网格 -\u0026gt; 保证场景连续，保证LoD过渡均匀 Adaptive Mesh Tessellation\n优化原则\n依据Distance to Camera和FoV做LoD Error Bound：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小） Tessellation Triangle-Based Subdivision 在等腰直角三角形的长边切割 -\u0026gt; 得到两个新的等腰直角三角形 二叉树结构，因此又称Binary Triangle-Based Subdivision T-Junctions 解决方法：判断若邻边切分更密，则当前边也需同样进行切分 实际应用中不广泛 QuadTree-Based Subdivision 四叉树分割 优势 易于建构 易于管理几何分区数据，Objects Culling和Data Streaming 符合Texture存储规范 劣势 Mesh细分没有三角形细分灵活 叶子节点的网格层级锁定 符合直觉，应用主流 T-Junctions 与三角形分割类似的问题，细分层级边界处产生 解决方法：Stitching 吸附 吸附生成的三角形：退化三角形 Triangulated Irregular Network (TIN) 几何细节不丰富处，用较粗的三角形 优势 易于Runtime渲染 更少的三角形 劣势 需要预计算 不够通用 特殊的游戏会用 GPU-Based Tessellation DX11开始： Hull-Shader Stage：生成Subdivision用的Patch，告诉Control point数据和Tessellation数量 Tessellator Stage：做Tessellation Domain-Shader Stage：根据高度图移动顶点 Geometry Shader Stage：算Vertex Mesh Shader Pipeline (DX12) GPU-Based Tessellation -\u0026gt; Runtime Tessellation -\u0026gt; Real-Time Deformable Terrain 假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation\nNon-Heightfield Terrain 悬崖、山洞等 传统做法：在悬崖、山洞处悬空插入物体 一种Trick：山洞处的顶点做标记，GPU处理退化消除；再向山洞中加入物体 目前用的较少一种的方法——体素化 体素化表达世界，在每个体素上存当前空间物质密度 Marching Cube：14种方法把cube切分成三角面 问题：Marching Cube怎么解决近密远疏并保证密封，LUT方法解决 全动态地形——支持打洞 Paint Terrain Materials 混合贴图 问题：边缘过渡羽化 return texture1.rgb * a1 + texture2.rgb * a2; 解决：Height作为Alpha return height1 \u0026gt; height2 ? texture1.rgb : texture2.rgb 问题：0-1切换信息高频，在远观时过于Sharp 解决：Biased 扰动 float depth = 0.2; //Height Bias float ma = max(texture1.a + height1, texture2.a + height2) - depth; float b1 = max(texture1.a + height1 - ma, 0); float b2 = max(texture2.a + height2 - ma, 0); return (texture1.rgb * b1 + texture2.rgb * b2) / (b1 + b2); 实战中：更多Texture -\u0026gt; Texture Array TextureArray[Index]\nParallax and Displacement Mapping 由于表面高度，看到位置B而非A 更彻底的方法：Displacement Mapping，直接改变Mesh 大量材质图读写的性能开销 -\u0026gt; Virture Texture\n核心思想：把用到的部分装载在内存中，不用的放在硬盘上 把地形分成块（2的幂次切割），只加载能看到的地形 Virtual Texture Implementation, DirectStorage \u0026amp; DMA GPU cache管理 DirectStorage DMA 浮点数精度溢出 浮点数数值小时精度高、数值大时精度低\n摄影机离物体过远时，出现严重抖动与闪烁\nCamera-Relative Rendering 相机相对性渲染 在MVP变换之前，将相机位置设为世界坐标系原点；重新计算MVP矩阵\n其他方法 eg. UE Sublevels，每个Sublevel重置坐标系\nTree Rendering Decorator Rendering 装饰物，草、灌木等 Road and Decals Rendering Road Spline Spline to Mesh，放置在地形上 路面侵蚀地形，处理高度场 Decal 贴片，贴花 全部直接Bake到Virtual Texture上 ","permalink":"https://elderlyaugustus.github.io/posts/2022-04-28-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.1-terrain/","summary":"Lecture06 Rendering of Mother Nature Lecture06-1 Terrain Rendering 地形渲染 Simple Idea - Heightfield Height Map Contour Map\n符合分形原则 渲染 均匀网格，依据Heightfield位移每一个顶点 问题：世界过大时过于复杂\n解决方法：LoD -\u0026gt; 非均匀网格 -\u0026gt; 保证场景连续，保证LoD过渡均匀 Adaptive Mesh Tessellation\n优化原则\n依据Distance to Camera和FoV做LoD Error Bound：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小） Tessellation Triangle-Based Subdivision 在等腰直角三角形的长边切割 -\u0026gt; 得到两个新的等腰直角三角形 二叉树结构，因此又称Binary Triangle-Based Subdivision T-Junctions 解决方法：判断若邻边切分更密，则当前边也需同样进行切分 实际应用中不广泛 QuadTree-Based Subdivision 四叉树分割 优势 易于建构 易于管理几何分区数据，Objects Culling和Data Streaming 符合Texture存储规范 劣势 Mesh细分没有三角形细分灵活 叶子节点的网格层级锁定 符合直觉，应用主流 T-Junctions 与三角形分割类似的问题，细分层级边界处产生 解决方法：Stitching 吸附 吸附生成的三角形：退化三角形 Triangulated Irregular Network (TIN) 几何细节不丰富处，用较粗的三角形 优势 易于Runtime渲染 更少的三角形 劣势 需要预计算 不够通用 特殊的游戏会用 GPU-Based Tessellation DX11开始： Hull-Shader Stage：生成Subdivision用的Patch，告诉Control point数据和Tessellation数量 Tessellator Stage：做Tessellation Domain-Shader Stage：根据高度图移动顶点 Geometry Shader Stage：算Vertex Mesh Shader Pipeline (DX12) GPU-Based Tessellation -\u0026gt; Runtime Tessellation -\u0026gt; Real-Time Deformable Terrain 假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation","title":"2022-04-28-GAMES104现代游戏引擎-Lecture6.1-Terrain Rendering"},{"content":"Lecture05 Lighting, Materials and Shaders The Rendering Equation \\[ {\\displaystyle L_{\\text{o}}(\\mathbf {x} ,\\omega _{\\text{o}},\\lambda ,t)=L_{\\text{e}}(\\mathbf {x} ,\\omega _{\\text{o}},\\lambda ,t)\\ +\\int _{\\Omega }f_{\\text{r}}(\\mathbf {x} ,\\omega _{\\text{i}},\\omega _{\\text{o}},\\lambda ,t)L_{\\text{i}}(\\mathbf {x} ,\\omega _{\\text{i}},\\lambda ,t)(\\omega _{\\text{i}}\\cdot \\mathbf {n} )\\operatorname {d} \\omega _{\\text{i}}} \\]\n多重挑战：\n如何得到入射光 Visibility to Lights, Shadow Light Source Complexity, 尤其面光源 如何快速地积分 如何计算次级光源，全局光照，无限递归 从简单开始 Ambient + Simple Light == Result\n环境光贴图反射\n相当于Rendering Equation特例化\nBlinn-Phong \\[ \\begin{aligned}L\u0026amp;=L_{\\text{ambient}}+L_{\\text{diffuse}}+L_{\\text{specular}}\\\\ \u0026amp;=k_{\\text{ambient}}I_{\\text{ambient}}+k_{\\text{diffuse}}(I/r^2)\\max(0,\\mathbf n\\cdot\\mathbf l)+k_{\\text{specular}}(I/r^2)\\max(0,\\mathbf n\\cdot\\mathbf l)^p \\end{aligned} \\] 问题：\n能量不守恒/保守（离线渲染时能量会超出） 质感太塑料 Shadow Map 从灯光位置渲染深度Buffer\n问题：\n采样问题 -\u0026gt; 自遮挡 加入阈值 -\u0026gt; 阴影与实体有距离 预计算GI @GAME202 PRT\n利用SH，用24bit就可以存储一个点的光场\nSH Lightmap UV Atlas 烘焙光照 优点：高效、细节 缺点：预计算量大；只能处理静态（动态物体可以有Hack方法，但有问题）；GPU存储量大 Light Probe 在空间中撒采样点（Probe） 每个Probe计算其光照 自动均匀撒采样点 反射Probe 一种特殊的Probe 采样精度高 分布密度低 提供非常好的反射效果 优点：高效，静态动态均可用，可以处理diffuse和specular 缺点：效果没有Lightmap好（采样稀疏） Physical-Based Material @GAME202 Physically-Based Material\nMicrofacet BRDF\nDisney Principled BRDF\n主流应用：Specular Glossiness模型\nDiffuse - RGB - sRGB Specular - RGB - sRGB Glossiness - Grayscale - Linear 问题：过于灵活，Specular项易导致Fresnel项错乱 主流应用：Metallic Roughness模型\nBase Color - RGB - sRGB Roughness - Grayscale - Linear Metallic - Grayscale - Linear 在SG基础上封装，Metallic限制Specular的应用 非金属和金属过渡时可能有白边 Image-Based Lighting @GAMES202 Environment Lighting\nDiffuse Irradiance Map Specular : Split Sum Classic Shadow Solution Cascaded Shadow Map 挑战：不同层级之间的Blend\n缺点：计算开销大（4ms）\n软阴影 @GAMES202 Soft Shadow\nPCF -\u0026gt; PCSS Variance Soft Shadow Map 上一世代的3A游戏渲染 Lightmap + Lightprobe PBR + IBL CSM + VSSM 现代3A游戏渲染 @GAMES202 GI \u0026amp; RTRT\nRTRT Real-Time GI SSGI SDF GI VXGI RSM RTXGI … 更复杂的材质模型 BSDF 头发 BSSRDF Virtual Shadow Maps 把Shadow Maps放到一个巨大的Shadow Map上（类似Virtual Texture） Shader管理 Uber Shader 宏定义做分支，GPU不适合分支，再将Uber Shader编译成大量Shader。需要修改时，只需要修改Uber Shader，一次编译所有结果。 跨平台的Shader编译 SPIR-V ","permalink":"https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/","summary":"Lecture05 Lighting, Materials and Shaders The Rendering Equation \\[ {\\displaystyle L_{\\text{o}}(\\mathbf {x} ,\\omega _{\\text{o}},\\lambda ,t)=L_{\\text{e}}(\\mathbf {x} ,\\omega _{\\text{o}},\\lambda ,t)\\ +\\int _{\\Omega }f_{\\text{r}}(\\mathbf {x} ,\\omega _{\\text{i}},\\omega _{\\text{o}},\\lambda ,t)L_{\\text{i}}(\\mathbf {x} ,\\omega _{\\text{i}},\\lambda ,t)(\\omega _{\\text{i}}\\cdot \\mathbf {n} )\\operatorname {d} \\omega _{\\text{i}}} \\]\n多重挑战：\n如何得到入射光 Visibility to Lights, Shadow Light Source Complexity, 尤其面光源 如何快速地积分 如何计算次级光源，全局光照，无限递归 从简单开始 Ambient + Simple Light == Result\n环境光贴图反射\n相当于Rendering Equation特例化\nBlinn-Phong \\[ \\begin{aligned}L\u0026amp;=L_{\\text{ambient}}+L_{\\text{diffuse}}+L_{\\text{specular}}\\\\ \u0026amp;=k_{\\text{ambient}}I_{\\text{ambient}}+k_{\\text{diffuse}}(I/r^2)\\max(0,\\mathbf n\\cdot\\mathbf l)+k_{\\text{specular}}(I/r^2)\\max(0,\\mathbf n\\cdot\\mathbf l)^p \\end{aligned} \\] 问题：","title":"2022-04-17-GAMES104现代游戏引擎-Lecture5-Lighting, Materials and Shaders"},{"content":"Lecture04 Rendering in Game Engine 挑战\n场景极其复杂 实时，帧率稳定 大纲\n基础 硬件架构 渲染数据结构 可见性 材质、Shader、光照 PBR Shader Permutation 光照 点/方向光照 IBL / Simple GI 特殊的渲染 地形 天空 / 雾 后处理 Pipeline 前向渲染 Forward、延迟渲染 Deferred、Forward Plus Ring buffer and V-Sync Tiled-based Rendering @GAMES101\nVertex Data -\u0026gt; Triangle Data -\u0026gt; Material Parameters -\u0026gt; Textures\n投影 -\u0026gt; 光栅化\neg. Computation - Texture Sampling\nStep 1 : 使用相邻两层MIPMAP Step 2 : 在两层MIPMAP之间双线性插值 Step 3 : 结果像素之间的线性插值 GPU SIMD and SIMT SIMD : Single Instruction Multiple Data eg.四维向量同时加减\nSIMT : Single Instruction Multiple Threads 同时处理大量SIMD任务\n计算单元 GPC Graphics Processing Cluster SM Streaming Multiprocessor Texture Units CUDA Core Warp (a collection of threads) Application Performance is limited by:\nMemory Bounds ALU Bounds TMU(Texture Mapping Unit) Bound BW(Bandwidth) Bound Renderable - 可渲染的内容（Component） Mesh Mesh Primitives Vertex and Index Buffer \u0026gt; 每顶点存储法向：避免有两个顶点重合时法向错乱 Material Textures Shaders 一个Mesh有多种材质 —— SubMesh\n节约空间：Mesh / Shader / Texture 各存储一个Pool，使用时用索引 —— Instance\n对场景按场景排序渲染 —— 对GPU友好，可以加速\nGPU Batch Rendering 渲染一次，再做Offset\nVisibility Culling View Frustum之外的不渲染 对空间做划分（前文介绍，四叉树 / BVH） BVH构建块，应用多 PVS, Potential Visibility Set 根据房间门是否可见裁剪 现在已应用不广，但思想可以用于资源加载等场景 GPU Culling 利用G-Buffer，延迟渲染 纹理压缩 不能用JPG/PNG等复杂压缩 Block Compression：将图片切分为一个个小块（例如4*4）压缩 eg. 在小块中保留最大值最小值，其他值使用这两值的线性插值 Authoring Tools of Modeling Polygon : MAX / MAYA / Blender Sculpting : Zbrush Scanning Procedural : Houdini Cluster-Based Mesh Pipeline 核心思想：对于非常精细的模型，将其分成无数一组面片组成的Cluster 提供Mesh Shader：GPU处理同样的Cluster，实现更精细的细节 可以基于Cluster做裁剪 Nanite in UE5 ","permalink":"https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/","summary":"Lecture04 Rendering in Game Engine 挑战\n场景极其复杂 实时，帧率稳定 大纲\n基础 硬件架构 渲染数据结构 可见性 材质、Shader、光照 PBR Shader Permutation 光照 点/方向光照 IBL / Simple GI 特殊的渲染 地形 天空 / 雾 后处理 Pipeline 前向渲染 Forward、延迟渲染 Deferred、Forward Plus Ring buffer and V-Sync Tiled-based Rendering @GAMES101\nVertex Data -\u0026gt; Triangle Data -\u0026gt; Material Parameters -\u0026gt; Textures\n投影 -\u0026gt; 光栅化\neg. Computation - Texture Sampling\nStep 1 : 使用相邻两层MIPMAP Step 2 : 在两层MIPMAP之间双线性插值 Step 3 : 结果像素之间的线性插值 GPU SIMD and SIMT SIMD : Single Instruction Multiple Data eg.","title":"2022-04-17-GAMES104现代游戏引擎-Lecture4-Rendering in Game Engine"},{"content":"Lecture02 游戏引擎分层结构 工具层 Tool Layer 编辑器\n功能层 Function Layer 渲染/模拟/玩法/交互/…\n资源层 Resource Layer 数据和文件\n核心层 Core Layer 内存管理/资源分配/数学模块\n平台层 Platform Layer 硬件设备的调用\nPS：中间件/第三方库\n情景：制作一个动画角色\nResource 怎么获取数据\nOffline Importing resource -\u0026gt; assets 将resource转换为asset的文件格式 asset读取更快 建构所有资产的关联关系（reference） GUID 实时/运行时（Runtime）资产管理器 基于路径加载/卸载asset 通过Handle系统管理asset的生命周期和参考 Function 怎么使世界动起来\ntick() tickLogic() tickRender() 有大量系统组成 必定属于引擎功能层的：渲染/模拟等 引擎功能层/游戏Gameplay有时有一定冲突 多线程 固定线程：不同线程作不同功能 主流用法，Job join：将模拟/动画等适合多线程的任务平均分配 原子化/任务系统：转换为一个个Job分配给所有线程 Core\n数学库\n线性代数\n为什么要单独写数学库 - 效率\neg. 卡马克快速平方根（牛顿迭代）\nSIMD 一条指令完成四个数操作（非常适合齐次坐标运算）\n数据结构\nvector / map / tree / … 为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作 内存管理 - 追求最高效率\n性能的主要瓶颈 内存池 / 分配器 减少cache浪费 内存对齐 PMR 多种内存资源 cache level 1 / 2 / 3 / RAM / Storage 优化核心思路 把数据放一起 按顺序读取数据 按块分配/释放内存 Platform\n文件系统（路径） 图形API OpenGL / Vulkan / DirectX / Metal RHI (Render Haraware Interface) 实现一套“API”，封装各种底层API 硬件架构 PC / PlayStation / 手机 / … 多核逻辑（大小核） Tool 允许他人创作游戏\n开发相对灵活，根据用户需求，工具层的代码量和工作量可能比其他四层还大 DCC, Asset Conditioning Pipeline 引擎工具层的编辑器和DCC的编辑器要数据通畅 为什么游戏引擎要分层\n解耦并减少复杂度 上下层相互独立 上层不需要知道底层怎样实现 迎合不断变化的需求 上层变化大，底层较稳定 Lecture03 如何构建游戏世界 Game Object (GO) 游戏对象 动态游戏对象 eg.坦克、飞机… 静态游戏对象 eg.建筑、陈设… 环境 eg.场景、天空、植被（随风运动，也可以是动态游戏对象）… 其他对象 eg.空气墙、规则区… 以一个无人机为例\nProperty 属性 外形 位置 血量 电池量 … Behaviors 行为 运动 侦察 … class Drone { /* Properties */ vec3 position; float health; float fuel; ... /* Behavior */ void move(); void scout(); ... } 拓展一个武装无人机：继承\nclass ArmedDrone : public Drone { public: float ammo; void fire(); } 游戏复杂后，没有那么清晰的从属关系——组件化\n如何让世界动起来 Tick()\n每个物体、每个组件Tick() 工程中，以系统为单位Tick()：Gameplay、模拟、渲染… GO之间的交互 eg.坦克击中人\nHardcode：坦克发射，生成新的子弹GO，逐个碰撞对象判断、处理。但工程复杂后非常难用。 Events事件机制：用Event标记伤害，Tick()时读取Event作出响应执行回调函数 ——解耦合，可扩展的消息系统，每个component对接消息进行处理 如何管理GO\n在场景中标记GO UID 空间位置 场景管理方法 不分割 效率低，适合小游戏 Grid分割 适合不是特别大的游戏 GO分布不均匀时 -\u0026gt; 层级结构 BVH BSP Binary Space Partitioning 四叉/八叉树 Scene Graph 还有很多问题…\nGO的绑定 eg.人在车上时，人和车应共同移动\nEvent系统GO互相发消息的问题：多个消息冲突，引入中心发信机构，“邮局”\nGO之间的循环依赖\n","permalink":"https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/","summary":"Lecture02 游戏引擎分层结构 工具层 Tool Layer 编辑器\n功能层 Function Layer 渲染/模拟/玩法/交互/…\n资源层 Resource Layer 数据和文件\n核心层 Core Layer 内存管理/资源分配/数学模块\n平台层 Platform Layer 硬件设备的调用\nPS：中间件/第三方库\n情景：制作一个动画角色\nResource 怎么获取数据\nOffline Importing resource -\u0026gt; assets 将resource转换为asset的文件格式 asset读取更快 建构所有资产的关联关系（reference） GUID 实时/运行时（Runtime）资产管理器 基于路径加载/卸载asset 通过Handle系统管理asset的生命周期和参考 Function 怎么使世界动起来\ntick() tickLogic() tickRender() 有大量系统组成 必定属于引擎功能层的：渲染/模拟等 引擎功能层/游戏Gameplay有时有一定冲突 多线程 固定线程：不同线程作不同功能 主流用法，Job join：将模拟/动画等适合多线程的任务平均分配 原子化/任务系统：转换为一个个Job分配给所有线程 Core\n数学库\n线性代数\n为什么要单独写数学库 - 效率\neg. 卡马克快速平方根（牛顿迭代）\nSIMD 一条指令完成四个数操作（非常适合齐次坐标运算）\n数据结构\nvector / map / tree / … 为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作 内存管理 - 追求最高效率","title":"2022-04-17-GAMES104现代游戏引擎-Lecture2-3-游戏引擎架构"},{"content":"Lecture 5-6 Environment Lighting Recap\n环境光贴图 球面贴图 Spherical Map / 立方体贴图 Cube Map Shading from Environment Lighting / Image-Based Lighting (IBL) 解渲染方程（不考虑阴影） \\[ L_o(\\mathrm p,\\omega_o)=\\int_{\\Omega^+}L_i(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\xcancel{V(\\mathrm p,\\omega_i)}\\,\\mathrm d\\omega_i \\]\n蒙特卡洛积分——数值解、大量采样，非常慢 PS: 一旦涉及采样，就很难实时，近年开始有一些进展 观察：\nglossy BRDF : BRDF覆盖很小 diffuse BRDF : BRDF覆盖大，但是平滑 因此考虑近似方法 \\[ \\int_\\Omega f(x)g(x)\\,\\mathrm dx\\approx\\dfrac{\\int_{\\Omega_G}f(x)\\,\\mathrm dx}{\\int_{\\Omega_G}\\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm dx \\] （该式在 \\(g(x)\\) 范围小/结果平滑时较为准确）\n则有 \\[ L_o(\\mathrm p,\\omega_o)\\approx\\dfrac{\\int_{\\Omega_{f_r}}L_i(\\mathrm p,\\omega_i)\\,\\mathrm d\\omega_i}{\\int_{\\Omega_{f_r}}\\,\\mathrm d\\omega_i}\\int_{\\Omega^+}f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d\\omega_i \\]\n\\(\\dfrac{\\int_{\\Omega_{f_r}}L_i(\\mathrm p,\\omega_i)\\,\\mathrm d\\omega_i}{\\int_{\\Omega_{f_r}}\\,\\mathrm d\\omega_i}\\) 表示对环境光贴图做模糊化处理，即滤波\nPrefiltering：在渲染之前就做好滤波 多种大小滤波核的结果，类似MIPMAP，计算时再做查询插值 【积分某区域的结果 = 先做区域的求和再取值】 \\(\\int_{\\Omega^+}f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d\\omega_i\\) 部分则做预计算\neg. Microfacet BRDF : Fresnel + NDF + Shadowing-Masking 需要一个巨大的表（至少五维参数）\nFresnel : Schlick’s approximation \\[ R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0=\\left(\\dfrac{n_1-n_2}{n_1+n_2}\\right)^2 \\]\nNDF : eg. Beckmann distribution \\[ D(h)=\\dfrac{e^{-\\frac{\\tan^2\\theta_h}{\\alpha^2}}}{\\pi\\alpha^2\\cos^4\\theta_h}\\quad\\text{$\\alpha$:Roughness} \\]\n将半程向量与入射出射光夹角、法线与入射出射光夹角、入射出射光夹角的一半都近似认为是 \\(\\theta\\) ，则减少至三维参数表\n将Fresnel项写在原式中作近似： \\[ \\begin{aligned}\u0026amp;\\int_{\\Omega^+}f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ \\approx\u0026amp; R_0\\int_{\\Omega^+}\\dfrac{f_r}{F}(1-(1-\\cos\\theta_i)^5)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ +\u0026amp;\\int_{\\Omega^+}\\dfrac{f_r}{F}(1-\\cos\\theta_i)^5\\cos\\theta_i\\,\\mathrm d\\omega_i\\end{aligned} \\] 将基础反射率 \\(R_0\\) （Base Color）解放出来 -\u0026gt; 二维参数表\n二维参数表：\\(\\text{Roughness}(\\alpha) - \\cos\\theta\\) 这一方法称为 Split Sum （积分 -\u0026gt; 求和）\nPrecomputed Radiance Transfer, PRT 实时渲染中很难做到环境光下的阴影\n把环境光看作大量光源：需要大量的shadow map 把问题看成一个采样问题：有不同的遮挡情况、不同的Visibility，Visibility项也不能用近似方法分离出来 一个解决思路：从最亮的光源下生成阴影（例如太阳） 相关工作 Imperfect shadow maps Light cuts RTRT (might be the Ultimate Solution) PRT Spherical Harmonics, SH 球面谐波函数 傅里叶级数：把一个函数拆成无数sin/cos函数（基函数）之和 Filtering 滤波 形如 \\(\\int_{\\Omega}f(x)g(x)\\,\\mathrm dx\\) 可以视作滤波操作 低频信息 == 平滑的函数 积分后频率是两个相乘的函数中较低的那个 基函数：\\(f(x)=\\sum_ic_i\\cdot B_i(x)\\) ，则 \\(B_i(x)\\) 称基函数 SH：定义在球面上的一系列二维的基函数（理解为关于方向的函数，球面上的方向用 \\(\\theta\\,\\phi\\) 描述）\n很像一维的傅里叶级数 （颜色深度表示值，黄蓝表示正负？；l：阶数）\nSH的基函数，用勒让德多项式表示（这里不必写出公式）\n用基函数 \\(B_i(\\omega)\\) 的线性组合，即可表示二维函数\n基函数 \\(B_i(\\omega)\\) 的系数用 \\(f(\\omega)\\) 表示，则有 \\[ c_i=\\int_\\Omega f(\\omega)B_i(\\omega)\\,\\mathrm d\\omega \\] （求系数的过程数学上称为“投影”）\n用前 \\(n\\) 阶系数可恢复出近似的原函数， \\(n\\) 越大，保留系数越多\n对Diffuse材质应用SH Recall : Prefiltering of Envirnment Light Prefiltering + single query == No filtering + Multiple queries\nDiffuse BRDF 很像低通滤波器（光照与BRDF做逐点相乘再积分，即Product Integrate）\n考虑用少量SH来描述Diffuse BRDF（例如前3阶）\n高频函数与低频函数Product Integrate，频率由低频函数决定 -\u0026gt; 既然Diffuse BRDF是低频的，那么光照也无需记录高频\n考虑也用SH来描述来描述光照（例如前3阶）\n非常简单的实现\nsurface float1 irradmat(matrix4 M, float3 v) { float4 n = {v, 1}; return dot(n, M*n); } 解决阴影、不限制Diffuse的方法：PRT \\[ L_o(\\mathrm p,\\omega_o)=\\int_{\\Omega^+}L_i(\\mathrm p,\\omega_i)V(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d\\omega_i \\]\nLight、Visibility、BRDF三项均描述成球面函数\neg. 用Cubemap存时，每个shading point的计算量过大\n考虑用SH来预计算部分内容\n认为Light在场景中可变；Visibility、BRDF等无关项认为是Light Transport，不可变 Light：用SH近似 \\(L_i\\approx\\sum l_iB_i\\) Light Transport：渲染之前做预计算 Diffuse情况 运行时则只需要算点乘\n但是Visibility项固定意味着场景不能动\nLight：光源本身旋转不可用（后面会说可以计算）\n重新理解\nLight : \\(L(\\omega_i)\\approx\\sum_pc_pB_p(\\omega_i)\\) Light Transport : \\(T(\\omega_i)\\approx\\sum_qc_qB_q(\\omega_i)\\) 则渲染方程 \\[ L_o(\\mathrm p,\\omega_o)=\\sum_p\\sum_qc_pc_q\\int_{\\Omega^+}B_p(\\omega_i)B_q(\\omega_i)\\,\\mathrm d\\omega_i \\] 由于SH基函数正交，则仅当 \\(p=q\\) 时，右边积分结果有意义，否则为零。复杂度 \\(O(n^2)\\) 降低至 \\(O(n)\\) 。 SH的性质\n基函数相互正交 易于计算投影（函数与任一基函数做Product Integrate即可） 易于计算旋转 相当于旋转每一个SH基函数 SH基函数的旋转可以用同阶基函数的线性组合表示 打表格 易于卷积 少量基函数代表低频 把多次Bounce的过程也视作Light Transport，预计算，可实现GI\nGlossy情况\nLight Transport 包含Visibility和BRDF，对于给定的出射方向 \\(\\mathrm o\\) ，BRDF都不一样 -\u0026gt; \\(T_i(\\mathrm o)\\)\n\\[ T_i(\\mathbf o)=\\sum t_{ij}B_j(\\mathbf o)\\\\ L_o\\approx\\sum l_iT_i(\\mathbf o)\\approx\\sum\\left(\\sum l_i t_{ij}\\right)B_j(\\mathbf o) \\]\n对于不同的出射方向 \\(\\mathrm o\\) ，得到一个Transport matrix。\n代价：存储的Transport matrix，且一般用五阶SH，因此存储量大；且渲染需要计算向量与矩阵乘，相对复杂。 Transport Paths\n\\(LE\\) : Light -\u0026gt; Eye \\(LGE\\) : Light -\u0026gt; Glossy -\u0026gt; Eye \\(L(D|G)^*E\\) \\(LS^*(D|G)^*E\\) \\(LSDE\\) Caustics “焦散”（翻译不好） 可以预计算任意复杂的Light Transport 另一种理解 \\(T_i\\approx\\int_{\\Omega}B_i(\\mathbf i)V(\\mathbf i)\\max(0,\\mathbf n\\cdot\\mathbf i)\\,\\mathrm d\\mathbf i\\) 中，将 \\(B_i(\\mathbf i)\\) 视作入射光，预计算过程就相当于用这些“奇怪”的光照渲染场景。\n限制\nSH只适合描述低频信息（镜面反射） 固定场景 大量的预计算和存储 进一步的工作\n新型基函数 两项点乘 -\u0026gt; 三项相乘 动态场景 动态材质 透明材质、头发、… 预计算 -\u0026gt; 不做预计算的解析解 … 其他基函数\n小波 Wavelet 二维小波 投影 小波变换 大量系数为零 -\u0026gt; 用于压缩 全频率的表示 用Cubemap存储光照，6张图每张做小波变换 把低频存在图左上1/4，剩下3/4存高频，对低频的1/4图递归地做这样的操作 -\u0026gt; 发现高频信息很少，非常适合压缩 问题：不支持快速旋转 Zonal Harmonics Spherical Gaussian Piecewise Constant ","permalink":"https://elderlyaugustus.github.io/posts/2022-04-16-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture5-6-environmentlight/","summary":"Lecture 5-6 Environment Lighting Recap\n环境光贴图 球面贴图 Spherical Map / 立方体贴图 Cube Map Shading from Environment Lighting / Image-Based Lighting (IBL) 解渲染方程（不考虑阴影） \\[ L_o(\\mathrm p,\\omega_o)=\\int_{\\Omega^+}L_i(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\xcancel{V(\\mathrm p,\\omega_i)}\\,\\mathrm d\\omega_i \\]\n蒙特卡洛积分——数值解、大量采样，非常慢 PS: 一旦涉及采样，就很难实时，近年开始有一些进展 观察：\nglossy BRDF : BRDF覆盖很小 diffuse BRDF : BRDF覆盖大，但是平滑 因此考虑近似方法 \\[ \\int_\\Omega f(x)g(x)\\,\\mathrm dx\\approx\\dfrac{\\int_{\\Omega_G}f(x)\\,\\mathrm dx}{\\int_{\\Omega_G}\\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm dx \\] （该式在 \\(g(x)\\) 范围小/结果平滑时较为准确）\n则有 \\[ L_o(\\mathrm p,\\omega_o)\\approx\\dfrac{\\int_{\\Omega_{f_r}}L_i(\\mathrm p,\\omega_i)\\,\\mathrm d\\omega_i}{\\int_{\\Omega_{f_r}}\\,\\mathrm d\\omega_i}\\int_{\\Omega^+}f_r(\\mathrm p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d\\omega_i \\]\n\\(\\dfrac{\\int_{\\Omega_{f_r}}L_i(\\mathrm p,\\omega_i)\\,\\mathrm d\\omega_i}{\\int_{\\Omega_{f_r}}\\,\\mathrm d\\omega_i}\\) 表示对环境光贴图做模糊化处理，即滤波","title":"2022-04-16-GAMES202高质量实时渲染-Lecture5-6-Environment Light"},{"content":"Lecture 14 Practical Industrial Solutions Temporal Anti-Aliasing, TAA Recall: why aliasing\n光栅化的采样数不够 终极解决方案：加样本（MSAA） TAA：应用Temporal信息，与RTRT的降噪思路一致\n每四帧复用：\n（如果不是4个固定位置而是是随机生成，引入了其他高频信息，效果并不好）\nNotes on AA\nMSAA vs SSAA SSAA：按几倍分辨率渲染场景，再下变换，效果好开销大 MSAA：对SSAA的效率改进 对一个像素内的一个Primitive，只采样一次（取中心或其他代表点） 空间上的Sample Reuse：样本分布上的Trick 基于图像的反走样方法 SMAA, Enhanced Subpixel Morphological AA FXAA -\u0026gt; MLAA(Morphological AA) -\u0026gt; SMAA G-Buffer一定不能反走样！（信息会出错） Temporal Super Resolution Super resolution == Super sampling\n提升分辨率 eg. DLSS DLSS 1.0 全靠猜，每个游戏/场景单独训练一个网络 DLSS 2.0 利用Temporal信息 应用类似TAA的思路 重用Samples 问题：Temporal failure时不能clamp——因为每一个像素需要一个明确的值 DL不输出图像，而是输出关于上一帧的Temporal信息如何利用 Deferred Shading 延迟渲染 提高Shading效率 传统管线 Triangles -\u0026gt; Fragments -\u0026gt; Depth Test -\u0026gt; Shading -\u0026gt; Pixel 每一个Fragment都需要做Shading 复杂度：\\(O(\\text{\\#Fragment}*\\text{\\#Light})\\) 关键想法：有很多Fragment不会被看到 -\u0026gt; 只对被看到的Fragment做Shading 修改管线 光栅化两次场景 Pass 1 : 不做Shading，更新Depth Buffer Pass 2 : 对可见的Fragment做Shading 复杂度：\\(O(\\text{\\#Vis.Fragment}*\\text{\\#Light})\\) 问题：难以做AA，可以用TAA/图像AA 【疑惑：延迟渲染更广义地应该是指两次光栅化，一次记录G-Buffer，一次着色的渲染方式？这里闫老师只讲了深度Buffer的应用。】 Tiled Shading 在Deferred Shading基础上，考虑减少光源的复杂度 把屏幕分成Tile 减少了每一个Tile中光源的数量：光源强度距离平方衰减（设定半径范围内有效） 复杂度：\\(O(\\text{\\#Vis.Fragment}*\\text{avg(\\#Light per tile)})\\) Clustered Shading 在Tiled Shading基础上，把空间分成网格 进一步减少了需要计算的光源数量 复杂度：\\(O(\\text{\\#Vis.Fragment}*\\text{avg(\\#Light per cluster)})\\) LoD, Level of Detail Solutions 在工业界，也称这种思路为“Cascaded” eg. Cascaded Shadow Maps 离Camera越远的，用更粗糙的Shadow Map eg. Cascaded LPV 传播越远，用更粗的格子传播 Geometric LoD 困难：过渡的Blending，可以用TAA eg. Nanite in UE5 Global Illumination Solutions SSR的问题（参考相关章节） 用Ray Tracing解决 软件Tracing SDF Trace, HQ for individual obj, SQ for global RSM 方向性/点光源 空间网格中存储Irradiance的Probe（DDGI, Dynamic Diffuse GI） 硬件Tracing 用简化模型Tracing RTXGI eg. Lumen in UE5：加粗条 More Topics Texturing an SDF 透明材质，透明材质的渲染顺序 Particle Rendering Post Processing 随机数/蓝噪声 Foveated Rendering Probe based GI (DDGI/RTXGI…) ReSTIR, Neural Radiance Caching … 多光源理论，Light Cuts Participating Media, SSSSS Hair … ","permalink":"https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture14-industry/","summary":"Lecture 14 Practical Industrial Solutions Temporal Anti-Aliasing, TAA Recall: why aliasing\n光栅化的采样数不够 终极解决方案：加样本（MSAA） TAA：应用Temporal信息，与RTRT的降噪思路一致\n每四帧复用：\n（如果不是4个固定位置而是是随机生成，引入了其他高频信息，效果并不好）\nNotes on AA\nMSAA vs SSAA SSAA：按几倍分辨率渲染场景，再下变换，效果好开销大 MSAA：对SSAA的效率改进 对一个像素内的一个Primitive，只采样一次（取中心或其他代表点） 空间上的Sample Reuse：样本分布上的Trick 基于图像的反走样方法 SMAA, Enhanced Subpixel Morphological AA FXAA -\u0026gt; MLAA(Morphological AA) -\u0026gt; SMAA G-Buffer一定不能反走样！（信息会出错） Temporal Super Resolution Super resolution == Super sampling\n提升分辨率 eg. DLSS DLSS 1.0 全靠猜，每个游戏/场景单独训练一个网络 DLSS 2.0 利用Temporal信息 应用类似TAA的思路 重用Samples 问题：Temporal failure时不能clamp——因为每一个像素需要一个明确的值 DL不输出图像，而是输出关于上一帧的Temporal信息如何利用 Deferred Shading 延迟渲染 提高Shading效率 传统管线 Triangles -\u0026gt; Fragments -\u0026gt; Depth Test -\u0026gt; Shading -\u0026gt; Pixel 每一个Fragment都需要做Shading 复杂度：\\(O(\\text{\\#Fragment}*\\text{\\#Light})\\) 关键想法：有很多Fragment不会被看到 -\u0026gt; 只对被看到的Fragment做Shading 修改管线 光栅化两次场景 Pass 1 : 不做Shading，更新Depth Buffer Pass 2 : 对可见的Fragment做Shading 复杂度：\\(O(\\text{\\#Vis.","title":"2022-04-14-GAMES202高质量实时渲染-Lecture14-Practical Industrial Solutions"},{"content":"Lecture 12-13 Real-Time Ray-Tracing RTX : 10G rays per second == 1 sample per pixel\n1 SPP path tracing == 1 rasterization (primary) + 1 ray (primary visibility) + 1 ray (primary bounce) + 1 ray (primary vis.) +\n1 SPP is Extremely Noisy\nKey Tech : Denosing\nGoals : + Quality (no overblur, no artifacts, keep all details) + Speed (\u0026lt; 2ms to denoise per frame)\n==\u0026gt; Temporal !\nTemporal Filtering Key idea ：\n假定前一帧已完成降噪，直接使用 使用motion vectors找前一位置 增加了SPP（引用前一帧的SPP，前一帧又引用了前两帧……） Geometry buffer\n渲染时生成的附加信息，消耗较少 像素深度、法线、世界坐标等 屏幕空间的信息 Back Projection\n找到同一像素在上一帧的位置 直接使用G-Buffer： \\(s=M^{-1}V^{-1}P^{-1}E^{-1}x\\ ({\\rm Still\\ with\\ }z{\\rm \\ value})\\) Motion : \\(s^{\u0026#39;}\\xrightarrow{T}s\\quad\\Rightarrow\\quad s^{\u0026#39;}=T^{-1}s\\) 前一帧的屏幕坐标： \\(x^{\u0026#39;}=E^{\u0026#39;}P^{\u0026#39;}V^{\u0026#39;}M^{\u0026#39;}s^{\u0026#39;}\\) Temporal Accum. / Denoising \\[ \\overline{C}^{(i)}={\\rm SpatialFilter}(\\widetilde{C}^{(1)})\\\\ C^{(i)}=\\alpha\\overline{C}^{(i)}+(1-\\alpha)C^{(i-1)}\\quad \\alpha\\approx0.1\\sim0.2 \\]\n滤波不会使画面改变亮度，低SPP的“暗”来源于超亮噪声被削波\nTemporal Failure\n切换场景/镜头：Burn-in period 黑帧预热 Dolly out / Zoom out，几何信息不断增多：尽量避免这种情况 突然出现被遮挡的物体，出现残影： Clamping：把前一帧的结果“拉”近当前帧，减小残影 Detection： 使用Object ID检测Temporal failure（判断前后帧motion vector对应的物体是否相同） 改变 \\(\\alpha\\) ，在Temporal failure时减少对前一帧的依赖 增强Spatial filtering 问题：重新带来了噪声 光源移动时，阴影“拖影” 物体移动时，镜面反射“延迟”（Glossy材质） Spatial Filtering Low-pass filter：减少高频噪声，但可能会导致高频信号丢失、低频噪声保留\nGaussian filtering\nFor each pixel i sum_of_weights = sum_of_weighted_values = 0.0 For each pixel j around i Calculate the weight w_ij = G(|i - j|, sigma) sum_of_weighted_values += w_ij * C^{input}[j] sum_of_weights += w_ij C^{output}[I] = sum_of_weighted_values / sum_of_weights *高斯模糊理论范围是无限远，但往往限制在周围一圈像素计算（远处权重极低，直接忽略）\nBilateral filtering 双边滤波 Problem of Gaussian filtering：边界也被模糊，高频信息丢失\n边界：颜色突变\n做法：不让颜色突变的像素参与贡献\n权重函数： \\[ \\displaystyle w(i,j,k,l)={\\rm exp}\\left(-\\frac{(i-k)^2+(j-l)^2}{2\\sigma_d^2}-\\frac{\\|I(i,j)-I(k,l)\\|^2}{2\\sigma_r^2}\\right)\\\\ (i,j)为某一像素，(k,l)为其周边一像素 \\] Problem：如何区分边界/噪声？ 参考SVGF\n==\u0026gt; key idea：增加滤波的条件——渲染过程中的G-Buffer 联合双边滤波\n大滤波核计算方法\nSeparate Passes：先做横向滤波、再做纵向滤波 \\(O(n^2)\\to O(n+n)=O(n)\\) 二维高斯函数的定义 \\(G_{2D}(x,y)=G_{1D}(x)\\cdot G_{1D}(y)\\) Filtering == convolution \\(\\displaystyle\\iint F(x_0,y_0)G_{2D}(x_0-x,y_0-y)\\,\\mathrm dx\\mathrm dy=\\int\\left(\\int F(x_0,y_0)G_{1D}(x_0-x)\\,\\mathrm dx\\right)G_{1D}(y_0-y)\\,\\mathrm dy\\) 理论上复杂的双边滤波不能这么计算，但近似强行如此计算 Progressively Growing Sizes 多次滤波，逐渐增加大小 eg. a-trous wavelet 多次pass，每次都是 \\(5\\times 5\\) 大小 每次pass，采样间隔为 \\(2^{i-1}\\) eg. \\(64^2\\to5^2\\times5\\) 在Filter之前去除超亮/超暗像素（Outlier）\nOutlier detection 对 \\(7\\times7\\) 网格计算均值和方差 超出 \\([\\mu-k\\sigma,\\mu+k\\sigma]\\) -\u0026gt; Outlier Outlier removal clamp to \\([\\mu-k\\sigma,\\mu+k\\sigma]\\) Specific Filtering Approaches for RTRT SVGF, Spatiotemporal Variance-Guided Filtering 与前文基本时空降噪方法相似，多了一些Trick和Variance分析方法\n联合双边滤波 - 3个因素\n深度 \\[ w_z=\\exp\\left(-\\dfrac{|z(p)-z(q)|}{\\sigma_z|\\nabla z(p)\\cdot(p-q)|+\\epsilon}\\right)\\quad \\text{$z$为深度} \\]\n只要是衰减函数就可以，这里不是高斯函数\n\\(\\epsilon\\) 为了防止分母为零，一般为很小的值\n\\(\\nabla z(p)\\) 深度的梯度，为了防止如图AB点情况，斜侧面深度差异过大时出现误差，用关于垂直法线方向/切平面的深度变化（如图AB的物理空间距离即所在面上法线垂直方向的深度变化） 法线 \\[ w_n=\\max(0,n(p)\\cdot n(q))^{\\sigma_n} \\] \\(\\sigma_n\\) 控制衰减快慢，即法线之间的差异要求是否严格 PS: 使用应用法线贴图之前的法线（应用法线贴图后表面凹凸不平，难以判断）\nLuminance (gray scale) \\[ w_l=\\exp\\left(-\\dfrac{|l_i(p)-l_i(q)|}{\\sigma_l\\sqrt{g_{3\\times 3}({\\rm Var}(l_i(p)))+\\epsilon}}\\right) \\] 亮度差异大的点不参与贡献——但单个像素亮度受噪声影响，故除以附近区域标准差（例如\\(7\\times7\\)区域）（使用Temporal累计标准差，再进行一次\\(3\\times3\\)滤波平均）。\nTradeoff：相比较noise，宁愿选择overblur 改进：ASVGF，优化overblur的问题（也可以理解为选择noise）\n问题：动态光源阴影残影\nRAE, Recurrent AutoEncoder 基本想法：用Recurrent denoising AutoEncoder对Path Tracing结果降噪，神经网络方法。\n后处理方法\n利用部分G-Buffer信息（作为神经网络输入）\n神经网络自动累计Temporal信息\nAutoEncoder (U-Net) Recurrent：每一层神经网络不止连接下一层，还要连接自身（Temporal） 问题：暗、存在边缘错误、overblur\n优势：对于不同的spp数输入，结果稳定\n","permalink":"https://elderlyaugustus.github.io/posts/2022-04-12-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture12-13-rtrt/","summary":"Lecture 12-13 Real-Time Ray-Tracing RTX : 10G rays per second == 1 sample per pixel\n1 SPP path tracing == 1 rasterization (primary) + 1 ray (primary visibility) + 1 ray (primary bounce) + 1 ray (primary vis.) +\n1 SPP is Extremely Noisy\nKey Tech : Denosing\nGoals : + Quality (no overblur, no artifacts, keep all details) + Speed (\u0026lt; 2ms to denoise per frame)\n==\u0026gt; Temporal !","title":"2022-04-12-GAMES202高质量实时渲染-Lecture12-13-Real Time Ray Tracing"},{"content":"Lecture 3-4 Soft Shadow Recap of Shadow Mapping - 点光源 从“Light”处看向场景，生成场景关于光源的深度图，即Shadow Map； 从相机处看向场景渲染画面，利用Shadow Map判断像素是否在阴影中。 Feature：\n基于二维图像的算法，而不需要三维几何场景 使用透视投影后Z值或透视投影前实际距离生成深度图皆可，Shadow Map与阴影生成时的深度判定方式一致即可 Problem\nSelf occlusion 自遮挡\nShadow Map的每一个像素记录同一深度，形成下图现象。在单个/行像素采样处，形成尺寸为像素宽高的遮挡面。 解决方案：在反射表面邻近区域不计算遮挡。不计算区域Light长度（Bias）由Light与反射表面法线夹角决定。（Light垂直于表面时不产生自遮挡问题）。——带来新问题：丢失遮挡关系。\nDetached shadow 由解决自遮挡的Bias不计算带来的阴影残缺问题。\n工业界无法彻底解决该问题，通过找到合适的Bias值减少视觉问题。\n学术解决方案：Second-depth shadow mapping\n存储第一深度和次级深度（离得第二近的表面距离），取中间值作为深度判断的值。 存在问题：要求所有物体watertight（有正反面）；计算量过大。 实时渲染不相信复杂度，只相信绝对速度！因此工业界不适用。 Aliasing 采样\nThe math behind shadow mapping 微积分中常见的不等式： \\[ \\begin{array}{c} Schwarz不等式： \\displaystyle\\left[\\int_a^bf(x)g(x)\\,\\mathrm d x\\right]^2\\le\\int_a^bf^2(x)\\,\\mathrm d x\\cdot\\int_a^bg^2(x)\\,\\mathrm d x\\\\ Minkowski不等式：\\displaystyle\\left\\{\\int_a^b\\left[f(x)+g(x)\\right]^2\\,\\mathrm d x\\right\\}^\\frac{1}{2}\\le\\left\\{\\int_a^bf^2(x)\\,\\mathrm d x\\right\\}^\\frac{1}{2}+\\left\\{\\int_a^bg^2(x)\\,\\mathrm d x\\right\\}^\\frac{1}{2} \\end{array} \\] Approximation in RTR: But we care more about “approximately equal”. 实时渲染中常将不等式当作约等式使用。\nAn important approximation: \\[ \\displaystyle\\int_\\Omega f(x)g(x)\\,\\mathrm d x\\approx\\frac{\\int_\\Omega f(x)\\,\\mathrm d x}{\\int_\\Omega \\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm d x \\]\n其中 \\(\\int_\\Omega \\,\\mathrm d x\\) 为归一化常数。\n该式何时较准确：\n积分域较小时 \\(g(x)\\) 在积分域内变化不大（Smooth） Recall：Rendering Equation with Explicit Visibility \\[ L_o(p,\\omega_o)=\\int_{\\Omega+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)\\cos\\theta_iV(p,\\omega_i)\\,\\mathrm d \\omega_i \\] Approximated as: \\[ L_o(p,\\omega_o)\\approx\\frac{\\int_{\\Omega+}V(p,\\omega_i)d\\omega_i}{\\int_{\\Omega+}d\\omega_i}\\cdot\\int_{\\Omega+}L_i(p,L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)\\cos\\theta_i\\,\\mathrm d \\omega_i \\] 即将Visibility部分 \\(V(p,\\omega_i)\\) 单独计算。则非Visibility部分为纯Shading部分，Visibility近似部分为“Shadow Mapping”部分。\n何时准确：\n点光源/方向光源（积分域小） Diffuse/面光源（其中一个积分函数平滑） Ambient Occlusion 环境光遮蔽中将再次用到类似的约等式\nPCSS: Percentage Closer Soft Shadows PCF: Percentage Closer Filtering [ For anti-aliasing at shadows’ edges - Not for soft shadows ] Filtering the result of shadow comparisons [Solution]\n根据Shadow Map判断像素是否在阴影中：不判断一个像素，判断对应像素周围的一圈像素（如7*7网格） 得到该组像素判断的平均值，赋给中心像素（原判断像素） 计算量？PCSS时一并解决 将Filter范围再放大得到软阴影？！ PCSS 软阴影：近处锐利，远处模糊 —— Filter Size \u0026lt;-\u0026gt; Blocker Distance\n\\(w_{Penumbra}=(d_{recevier}-d_{Blocker})\\cdot w_{Light}/d_{Blocker}\\) Block Depth: Average block depth 在一定范围内，一个Shading Point被遮挡的平均深度值\nComplete algorithm\nBlocker search : Getting the average depth in a certain region （视面光源中心为点光源生成Shadow Map） Penumbra estimation : Use the average blocker depth to determine filter size Percentage Closer Filtering Blocker search的范围（得到Average block depth的方式）如何确定？\n取固定范围，如5*5\n[Better] 取决于光源面积和光照接收面到光源的距离 \\[ \\rm size_{Blocker}=distance_{ShadowMap2Scene}/distance_{Light2Scene}\\cdot size_{Light} \\]\n开销巨大：下节课解决\nA deeper look at PCF The math behind PCF: Filter/Convolution \\[ [w*f](p)=\\sum_{q\\in\\mathcal{N}(p)}w(p,q)f(q)\\quad\\quad N(p):p的邻域 \\] In PCSS \\[ V(x)=\\sum_{q\\in\\mathcal{N}(p)}w(p,q)\\cdot\\chi^+[D_{SM}(q)-D_{scene}(x)]\\quad\\quad\\chi^+(A)=A\u0026gt;0?1:0 \\] 因此：\nPCF并不是对Shadow Map的滤波 \\[ V(x)\\neq\\chi^+\\{[w*D_{SM}](q)-D_{scene}(x)\\} \\] PCF也不是对结果图像做滤波 \\[ V(x)\\neq\\sum_{q\\in\\mathcal{N}(p)}w(p,q)V(q) \\] More about PCSS [Blocker Search] and [PCF] is slow to look at every texel.\n[Blocker Search] 随机取样 =\u0026gt; Noise [PCF] Filter范围过大，随机采样 -\u0026gt; 图像空间降噪 Variance Soft Shadow Mapping Fast blocker search and filtering [ Filter ] PCF：根据正态分布可估计 Percentage Closer Value 正态分布由均值mean和方差variance定义\nMean Hardware Mipmaping 但只能正方形 Summed Area Tables (SAT) Variance \\[ Var(X)=E(X^2)-E^2(X)\\quad E:期望=均值 \\] 另一张“Shadow Map”记录深度的平方，称为“Square depth map” 由此得到正态分布图，求得CDF(x) of the Gaussian PDF即可（即0-x的积分）。 该积分没有解析解只有数值解，可通过高斯分布积分表Error Function得到CDF值。在cpp中使用erf()求数值解，但计算仍较复杂。\n因此引入切比雪夫不等式估计值： \\[ P(x\u0026gt;t)\\le\\frac{\\sigma^2}{\\sigma^2+(t-\\mu)^2}\\quad\\quad\\begin{aligned}\\mu\u0026amp;: mean\\\\\\sigma^2\u0026amp;:variance\\end{aligned} \\] 对任意分布方式，通过切比雪夫不等式估得右侧积分值 \\(P(x\u0026gt;t)\\) ，再由 \\(1-P(x\u0026gt;t)\\) 得到 \\(CDF(x)\\) 。 仅t\u0026gt;mean时较准，但工业界往往直接用。\n总结 + Shadow map generation + “Square depth map” + Runtime + Mean of depth in a range: O(1) + Mean of depth square in a range: O(1) + Chebychev: O(1) + No samples / loops needed + Perfectly ? 改变视角需要重新生成map 产生较大开销 GPU解决起来速度非常快\n[ Block Search ]\nTarget: The average depth of blockers ( texels whose depth z \u0026lt; t, \\(z_{occ}\\) ) \\(\\Rightarrow\\begin{array}{l}blocker:z_{occ}\\\\non-blocker:z_{unocc}\\end{array}\\)\n\\[ \\displaystyle\\frac{N_1}{N}z_{unocc}+\\frac{N_2}{N}z_{occ}=z_{avg} \\]\nChebychev Approximation: \\(\\displaystyle\\frac{N_1}{N}=P(x\u0026gt;t)\\quad\\frac{N_2}{N}=1-P(x\u0026gt;t)\\)\nApproximation: \\(z_{unocc}=t\\)\nMIPMAP and Summed-Area Variance Shadow Maps Recall: MIPMAP fast, approx., square range queries 非 \\(1/n^i\\) 方形区域，需使用线性插值 不精准，限制多 SAT (Summed-Area Table) in 1D: 第 \\(i\\) 位存储 \\(0-i\\) 的和\nSAT[0] = Arr[0]; for(int i = 1, i \u0026lt; n, ++i) { SAT[i] = SAT[i-1] + Arr[i]; } //Sum of a to b float sum(int a, int b) { return SAT[b] - SAT[a-1]; } in 2D: 第 \\((i,j)\\) 位存储 \\((0,0)-(i,j)\\) 的矩形区域和\n// m * n for(int i = 0, i \u0026lt; n, ++i) { SAT[i][0] = Arr[i][0]; for(int j = 1, j \u0026lt; n, ++j) { SAT[i][j] = SAT[i][j-1] + Arr[i][j-1]; } } for(int j = 0, i \u0026lt; n, ++i) { for(int i = 1, j \u0026lt; n, ++j) { SAT[i][j] += SAT[i-1][j]; } } //Sum of a to b float sum(int a, int b) { return SAT[a-1][b] + SAT[a][b-1] - SAT[a-1][b-1]; } Moment Shadow Mapping VSSM Problem: 遮挡物简单情况下，遮挡深度分布非正态/不符合切比雪夫估计 ，估计值不准\n与实际值相比较暗：视觉无影响 与实际值相比较亮：漏光（Light Leaking，工业界也有称Light Bleeding） 解决分布描述不准方法——引入高阶矩（Moments）\n简单理解为“ \\(x^i\\) 即 \\(x\\) 的 \\(i\\) 阶矩” 使用前 \\(m\\) 阶矩的组合（ \\(x^1,x^2,\\dots,x^m\\) ）可以描述一个具有 \\(m/2\\) 个“台阶”的阶跃函数 可视为一种展开，将原函数展开为前 \\(m\\) 阶矩的线性组合 在MSM中，前4阶矩可较好描述遮挡深度分布，在使用VSSM的想法计算所需值（可在Blocker Search和PCF环节使用该方法） Distance Field Soft Shadows Distance Field / Distance Function: Minimum distance to the closet location on an object SDF(Signed Distance Field) 是较好的混合方式，比线性插值得到结果更平滑连续——[ 最优传输理论 ]\nUsages:\nRay marching (Sphere Tracing) 在某一点，作SDF值（距离物体的最小距离）为半径的球，则球体内任意方向发射光线均不与物体相交，将该半径定义为“安全距离”（safe distance）。则光线可以朝原方向走该半径长度的距离，得到新的点和SDF值，同理迭代。直到沿着同一方向与物体距离足够小，或光线路径过长（认为无物体与之相交）时停止追踪。 Soft Shadows 类Ray Marching，对每一根光线，算出”安全角度”（safe angle）。（光线上所有点的SDF值的最小值为半径，该点为圆心作圆，与光线发射点两条切线的夹角） \\(\\text{smaller safe angle}\\Rightarrow\\text{less visibility}\\) \\[ \\begin{array}{l} \\displaystyle V=\\arcsin\\frac{SDF(p)}{\\|p-o\\|}\\quad \\arcsin 计算量过大\\\\ \\displaystyle V\\approx \\min\\left\\{\\frac{k\\dot SDF(p)}{\\|p-o\\|},1.0\\right\\}\\quad 直接使用比值近似，其中k值决定过渡带宽度，即阴影软硬程度\\\\ \\end{array} \\]\n优势：快\n局限性：SDF的计算量、存储量，以及物体运动后重新计算的复杂度。（对多个物体的SDF，取最小值即可。）and some artifact\nmisc：利用SDF在实时渲染中生成矢量字符\n","permalink":"https://elderlyaugustus.github.io/posts/2021-04-05-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture3-4-softshadow/","summary":"Lecture 3-4 Soft Shadow Recap of Shadow Mapping - 点光源 从“Light”处看向场景，生成场景关于光源的深度图，即Shadow Map； 从相机处看向场景渲染画面，利用Shadow Map判断像素是否在阴影中。 Feature：\n基于二维图像的算法，而不需要三维几何场景 使用透视投影后Z值或透视投影前实际距离生成深度图皆可，Shadow Map与阴影生成时的深度判定方式一致即可 Problem\nSelf occlusion 自遮挡\nShadow Map的每一个像素记录同一深度，形成下图现象。在单个/行像素采样处，形成尺寸为像素宽高的遮挡面。 解决方案：在反射表面邻近区域不计算遮挡。不计算区域Light长度（Bias）由Light与反射表面法线夹角决定。（Light垂直于表面时不产生自遮挡问题）。——带来新问题：丢失遮挡关系。\nDetached shadow 由解决自遮挡的Bias不计算带来的阴影残缺问题。\n工业界无法彻底解决该问题，通过找到合适的Bias值减少视觉问题。\n学术解决方案：Second-depth shadow mapping\n存储第一深度和次级深度（离得第二近的表面距离），取中间值作为深度判断的值。 存在问题：要求所有物体watertight（有正反面）；计算量过大。 实时渲染不相信复杂度，只相信绝对速度！因此工业界不适用。 Aliasing 采样\nThe math behind shadow mapping 微积分中常见的不等式： \\[ \\begin{array}{c} Schwarz不等式： \\displaystyle\\left[\\int_a^bf(x)g(x)\\,\\mathrm d x\\right]^2\\le\\int_a^bf^2(x)\\,\\mathrm d x\\cdot\\int_a^bg^2(x)\\,\\mathrm d x\\\\ Minkowski不等式：\\displaystyle\\left\\{\\int_a^b\\left[f(x)+g(x)\\right]^2\\,\\mathrm d x\\right\\}^\\frac{1}{2}\\le\\left\\{\\int_a^bf^2(x)\\,\\mathrm d x\\right\\}^\\frac{1}{2}+\\left\\{\\int_a^bg^2(x)\\,\\mathrm d x\\right\\}^\\frac{1}{2} \\end{array} \\] Approximation in RTR: But we care more about “approximately equal”.","title":"2021-04-05-GAMES202高质量实时渲染-Lecture3-4-Soft Shadow"},{"content":"Lecture 10-11 Physically-Based Material Content\nReal-Time Physically-Based Materials Microfacet BRDF Disney principled BRDF Shading with microfacet BRDFs under polygonal lighting Linearly Transformed Cosines (LTC) Concept\nPhysically-Based Rendering (PBR) Everything in rendering should be physically based Materials, lighting, camera, light transport, etc. Not just materials, but usually referred to as materials PBR materials in RTR The RTR community is much behind the offline community “PB” in RTR is usually not actually physically based PBR materials in RTR\nFor surfaces\nMicrofacet models (used wrong so not “PBR”) Disney principled BRDFs (artist friendly but still not “PBR”) For volumes (cloud, hair, skin, etc.)\nfocused on fast and approximate single scattering and multiple scattering\nRecap: Microfacet BRDF Fresnel term 精确表达非常复杂，需要考虑S/P极化 Schlick’s approximation 近似为基础反射率 \\(R_0\\) 的变化 \\[ R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0=\\left(\\dfrac{n_1-n_2}{n_1+n_2}\\right)^2 \\]\nNormal Distribution Function (NDF) 此处NDF中的Normal为“法线”，须与表示“正态分布”的“Normal Distribution”中的Normal区分\n法线分布集中 ==\u0026gt; glossy 法线分布分散 ==\u0026gt; diffuse （diffuse的微表面可以视作specular的微表面纵向scale而得到，而纵向scale使得diffuse的微表面“沟壑”较深）\n描述NDF的模型\nBeckmann NDF \\[ D(h)=\\dfrac{e^{-\\frac{\\tan^2\\theta_h}{\\alpha^2}}}{\\pi\\alpha^2\\cos^4\\theta_h}\\\\ \\alpha:\\text{roughness of the surface}\\\\ \\theta_h:\\text{angle between half vector }h\\text{ and normal }n \\]\n类似Gaussian 在slope space（坡度空间）上定义 如图即定义在 \\(\\tan\\theta\\) 所在平面上（可以保证不出现面朝下的微表面，但较难解决反射光朝下的情况） 在project solid angle上积分为1 GGX （or Trowbridge-Reitz） \\[ D_{\\rm GGX}(\\theta_h) = \\frac{\\alpha^2}{\\pi\\cos^4\\theta_ m(\\alpha^2 + \\tan^2\\theta_h)^2}\\\\ \\alpha:\\text{roughness}^2 \\]\n特征：long tail 长尾巴 衰减到一定程度后非常慢，可使Specular出现“光晕” 对比 Extending GGX\nGTR (Generalized Trowbridge-Reitz) （\\(\\gamma\\) 较大时，接近Beckmann，相当于统一了两种model） Shadowing-Masking Term Or Geometry Term : G\n解决微表面之间的自遮挡问题\nShadowing 光线照射到微表面 Masking 光线反射进入眼睛 变暗操作，靠近垂直方向时几乎不变暗（G值为1），Grazing angle（掠视）时变暗（G值减小，直至接近0）\n常用的Shadowing-Masking Term\nSmith Shadowing-Masking Term\n把Shadowing和Masking拆开（假定两者无关，事实上有关） \\[ G(i,o,m)\\approx G_1(i,m)G_1(o,m) \\]\nBeckmann（绿）和GGX（红）分别的Shadowing-Masking项 eg. 与GGX法线分布匹配的Smith模型 \\[ G_{\\rm Smith}(\\mathbf{i},\\mathbf{o},\\mathbf{h})=G_{\\rm Schlick}(\\mathbf{l},\\mathbf{h})G_{\\rm Schlick}(\\mathbf{v},\\mathbf{h})\\\\ k=\\dfrac{({\\rm roughness}+1)^2}{8}\\\\ G_{\\rm Schlick}(\\mathbf{v},\\mathbf{n})=\\dfrac{\\mathbf{n}\\cdot \\mathbf{v}}{\\mathbf{n}\\cdot \\mathbf{v}(1-k)+k} \\]\n问题：能量损失 白炉测试 White Furnace Test：在完全均匀的全局环境光下渲染物体，若物体与背景同色，说明不存在能量损失，若变暗说明存在能量损失。\n发现，Roughness值增大会导致能量损失（图2为白炉测试） Roughness越大，微表面沟壑越多，越容易自遮挡（Shadowing-Masking程度大） ——而现实中，自遮挡的光线经过多次弹射最终会反射出来，不会损失能量，此时Microfacet模型中只考虑了一次弹射\n精确地还原损失的能量（Heitz et al. 2016）对实时渲染来说开销过大\nKulla-County Approximation\n被遮挡 == 发生下次弹射，从而有该经验性补全多次反射丢失能量的方法\n考虑一次反射时有多少能量能够保留：假定入射光 \\(L_i=1\\) ，BRDF项为 \\(f(\\mu_o,\\mu_i,\\phi)\\) ，则出射能量（BRDF、cosine、Lighting乘积）的积分为： \\[ E(\\mu_0)=\\int_0^{2\\pi}\\int_0^1f(\\mu_o,\\mu_i,\\phi)\\mu_i\\,\\mathrm d \\mu_i\\mathrm d\\phi\\\\\\mu=\\sin\\theta\\quad(\\text{用}\\ \\theta,\\phi\\ \\text{定义立体角，换元积分}) \\]\n则损失能量为 \\(1-E(\\mu_o)\\) ，则只需补上这部分能量\n\\(E(\\mu_o)\\) 的积分值与观察方向有关\n由于BRDF的可逆性（入射出射互相可逆），则其表示应具有对称性，因此损失能量的形式为： \\[ c(1-E(\\mu_i))(1-E(\\mu_o)) \\] （凑积分简化的一种思路）\n可得： \\[ f_{\\rm ms}(\\mu_o,\\mu_i)=\\dfrac{(1-E(\\mu_i))(1-E(\\mu_o))}{\\pi(1-E_{\\rm avg})},\\quad E_{\\rm avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm d \\mu \\] （推导略）\n此时将 \\(f_{\\rm ms}(\\mu_o,\\mu_i)\\) 作为补全BRDF加入到渲染方程的积分中，就能够补全丢失的能量\n总结：设计一个function，即“补充的BRDF”，使得其积分等于丢失能量\n问题1： \\(E_{\\rm avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm d \\mu\\) 未知且计算困难\n预计算/打表 维度/依赖的参数 —— \\(\\mu_o\\) 和roughness 形成一张二维的表在渲染时直接查询 效果 问题2：若BRDF含有颜色\n颜色意味着有额外的能量损失（属于应该损失的）\n先考虑没有颜色的全局能量损失，求出补全BRDF，再考虑由于颜色造成的能量损失\nAverage Fresnel：不管入射角大小平均反射的能量占比 \\[ F_{\\rm avg}=\\dfrac{\\int_0^1F(\\mu)\\mu\\,\\mathrm d\\mu}{\\int_0^1\\mu\\,\\mathrm d\\mu}=2\\int_0^1F(\\mu)\\mu\\,\\mathrm d\\mu \\]\n\\(E_{\\rm avg}\\) 不参与后续弹射，因此将能量逐步计算\n可以直接看到的 \\(F_{\\rm avg}E_{\\rm avg}\\)\n1次弹射后可以看到 \\(F_{\\rm avg}(1-E_{\\rm avg})\\cdot F_{\\rm avg}E_{\\rm avg}\\)\nk次弹射后可以看到 \\(F_{\\rm avg}^k(1-E_{\\rm avg})^k\\cdot F_{\\rm avg}E_{\\rm avg}\\)\n求和求级数得Color Term \\(\\dfrac{F_{\\rm avg}E_{\\rm avg}}{1-F_{\\rm avg}(1-E_{\\rm avg})}\\)\n将Color Term乘到没有考虑颜色的补全BRDF上，得到最终的补全BRDF，加入渲染方程积分\n结果 ↓ 近年出现的不用Kulla-County方法的、不好的Hack： 直接对Microfacet BRDF增加一个diffuse lobe\neg. 在CV领域作材质识别时 “完全错误” “不能更糟糕” “我从来没有这么教过你” 物理错误，无法保证能量守恒 Shading with Microfacet BRDFs under polygonal lighting – Linearly Transformed Cosines (LTC) 解决微表面模型着色问题\n主要针对GGX的NDF时（当然其他NDF也可以） 不考虑阴影 在多边形光源的情况下（不需要采样的方法） Lobe：瓣，如图蓝色区域，表示从视点发射的光线反射的分布，分布的形状类似一片花瓣。严格定义：BRDF的二维切片（BRDF输入两维、输出两维， \\(\\theta\\) 和 \\(\\phi\\) ，共四维）。\n核心想法：\nBRDF的入射/出射的Lobe可以通过线性变换转换成余弦函数（转换到顶部，90度时最大，逐步向外减小） 多边形光源也可以作同样的线性变换 在这种情况下，在余弦Lobe上积分变形后的光源可以得到解析解 具体做法：\n\\[ {\\rm BRDF}\\xrightarrow{M^{-1}}{\\rm Cosine}\\\\ 方向:\\omega_i\\xrightarrow{M^{-1}}\\omega_i\u0026#39;\\\\ 积分域:P\\xrightarrow{M^{-1}}P\u0026#39; \\] 替换一个变量 假设多边形光源是uniform的，即\\(L_i\\)对各方向保持一致，则 \\[ \\text{渲染方程}\\quad L(\\omega_o)=L_i\\cdot\\int_P F(\\omega_i)\\,\\mathrm d\\omega_i\\text{（BRDF、Cosine合并为$F()$）}\\\\ \\omega_i=\\dfrac{M\\omega\u0026#39;_i}{\\|M\\omega\u0026#39;_i\\|}\\quad\\text{代入替换得}\\\\ \\begin{aligned}L(\\omega_o)\u0026amp;=L_i\\cdot\\int_P\\cos(\\omega\u0026#39;_i)\\,\\mathrm d\\dfrac{M\\omega\u0026#39;_i}{\\|M\\omega\u0026#39;_i\\|}\\\\\u0026amp;=L_i\\cdot\\int_{P\u0026#39;}\\cos(\\omega\u0026#39;_i)J\\,\\mathrm d\\omega\u0026#39;_i\\end{aligned} \\]\n如何得到\\(M\\)：预计算（给初始值通过优化方法计算）\nDisney Principled BRDF 为什么需要？\nMicrofacet模型不能表征所有真实感材质 不够Diffuse 无法解释多层材质（eg.刷有清漆的表面） Microfacet模型不够Artist-friendly eg. 定义折射率的\\(n\\)和\\(k\\) Disney Principled BRDF设计原则\nArt directable，不必须物理真实 还是一定程度上基于物理的（在实时渲染中） Principle 原则\n看起来直观，不用物理量 尽可能减少参数 0-1范围 允许\u0026lt;0和\u0026gt;1情况，呈现特殊效果 具有稳健性 Disney Principled BRDF建立在拟合的基础上，有开放源码\nsheen : 绒毛，在grazing angle上有类似羽化效果 clearcoat : 类似清漆的透明层\n维度多时，会出现多种参数呈现类似结果的现象\n优劣势\n易于理解/控制 能描述的材质广泛 开源的实现 不完全基于物理 巨大的参数空间 Non-Photorealistic Rendering == (fast and reliable) stylization\n风格化\n描边 模型简化、色块 阴影分界线 轮廓\n分类\n边界 Boundary / Border edge 折痕 Crease 材质边缘 Material edge 有多个面共享的外轮廓线 Silhouette edge Silhouette edge 描边绘制\nSilhouette edge处观察方向与法线方向几乎垂直\n设定观察方向与发现夹角的阈值，超过的像素设黑 问题：描边粗细不一样 背面的三角形/模型扩大一小圈渲染为黑\n图像后处理：Edge Detect\nSobel Detector 纵向/横向，色块处两侧抵消，分界线两侧不抵消 \\[ \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1\\\\ 2 \u0026amp; 0 \u0026amp; -2\\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\quad \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix} \\]\n利用G-Buffer信息，深度、法线等\n色块\n先得到正常的shading结果，再做一个阈值化（多值化 Quantization） 在不同的部分（Diffuse、Specular…）应用不同的阈值化方法 素描效果\n阴影部分打横竖线格，格子密度与阴影明暗相关 提前设计不同密度的格状纹理查询（结果邻近像素查询纹理邻近像素，保证笔触连续） 对每种纹理做MIPMAP时，保证每一级MIPMAP的密度一致（类似裁切而非等比缩小） 真实感模型是非真实感渲染的基础。\n","permalink":"https://elderlyaugustus.github.io/posts/2022-04-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture10-11-pbm/","summary":"Lecture 10-11 Physically-Based Material Content\nReal-Time Physically-Based Materials Microfacet BRDF Disney principled BRDF Shading with microfacet BRDFs under polygonal lighting Linearly Transformed Cosines (LTC) Concept\nPhysically-Based Rendering (PBR) Everything in rendering should be physically based Materials, lighting, camera, light transport, etc. Not just materials, but usually referred to as materials PBR materials in RTR The RTR community is much behind the offline community “PB” in RTR is usually not actually physically based PBR materials in RTR","title":"2022-04-02-GAMES202高质量实时渲染-Lecture10-11-Physically-Based Material"},{"content":"7.5 - 7.7 Runge-Kutta方法 单步高阶方法构造思路 设 \\(y(x)\\) 是一阶常微分方程初值问题的精确解，Taylor展开得： \\[ \\begin{aligned} \\displaystyle y(x_{n+1})\u0026amp;=y(x_n)+y\u0026#39;(x_n)h+\\frac{y\u0026#39;\u0026#39;(x_n)}{2!}h^2+\\dots+\\frac{y^{(p)}(x_n)}{p!}h^p+\\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\\\ \u0026amp;=y(x_n)+hf(x_n,y(x_n))+\\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\\dots+\\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\\end{aligned} \\] 因此可建立节点处近似值 \\(y_n\\) 满足的差分公式： \\[ \\left\\{\\begin{array}{l}\\displaystyle y_{n+1}=y_n+hf(x_n,y_n)+\\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\\dots+\\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\\\y_0=\\alpha,\\quad n=0,1,\\dots,N-1\\end{array}\\right. \\] 称之为 \\(\\mathbf p\\) 阶Taylor展开方法。 其中： \\(\\begin{array}{l}\\displaystyle f^{(1)}(x,y)=\\frac{\\partial f(x,y)}{\\partial x}+\\frac{\\partial f(x,y)}{\\partial y}f(x,y)\\\\\\displaystyle f^{(2)}(x,y)=\\frac{\\partial^2f}{\\partial x^2}+2\\frac{\\partial^2f}{\\partial x\\partial y}f+\\frac{\\partial^2 f}{\\partial y^2}f^2+\\frac{\\partial f}{\\partial x}\\frac{\\partial f}{\\partial y}+\\left(\\frac{\\partial f}{\\partial y}\\right)^2f\\\\\\dots\\end{array}\\)\n计算过于复杂，很少直接使用\n减少Taylor展开次数得： \\[ y(x_{n+1})=y(x_n)+hy\u0026#39;(\\xi)=y(x_n)+hf(\\xi,y(\\xi)),\\quad x_n\\le\\xi\\le x_{n+1} \\] 构造差分方法即利用适当的函数值来近似计算 \\(f(\\xi,y(\\xi))\\) 。\nEuler方法用 \\(K_1\\) 作为其近似，其 \\(y_{n+1}\\) 表达式与精确解的Taylor展式前 \\(2\\) 项一致。为 \\(1\\) 阶方法。 改进Euler方法用 \\(K_1,K_2\\) 的线性组合作为其近似，其 \\(y_{n+1}\\) 表达式与精确解的Taylor展式前 \\(3\\) 项一致。为 \\(2\\) 阶方法。 能否增加计算 \\(f(x,y)\\) 的次数来提高方法阶数？ Runge-Kutta方法 \\[ \\left\\{\\begin{array}{l} y_{n+1}=y_n+h(\\lambda_1K_1+\\lambda_2K_2+\\dots+\\lambda_pK_p)\\\\ K_1=f(x_n,y_n)\\\\ K_2=f(x_n+\\alpha_2h,y_n+h\\beta_{21}K_1)\\\\ \\dots\\\\ K_p=f(x_n+\\alpha_ph,y_n+h\\sum\\limits_{i=1}^{p-1}\\beta_{pi}K_i) \\end{array}\\right. \\] 其中 \\(\\{\\lambda_i,\\alpha_i,\\beta_{ij}\\}\\) 为待定系数，此公式称为 \\(\\mathbf p\\) 级Runge-Kutta方法。 若该公式局部截断误差为 \\(O(h^{p+1})\\) ，则称其为 \\(\\mathbf p\\) 阶Runge-Kutta方法。\n\\(\\mathbf{p=2}\\) 时，二级R-K公式： \\[ \\left\\{\\begin{array}{l} y_{n+1}=y_n+h(\\lambda_1K_1+\\lambda_2K_2)\\\\ K_1=f(x_n,y_n)\\\\ K_2=f(x_n+\\alpha h,y_n+h\\beta K_1)\\\\ \\end{array}\\right. \\] Taylor展开分析易得，只要令 \\(\\lambda_1+\\lambda_2=1,\\ \\alpha\\lambda_2=1/2,\\ \\beta\\lambda_2=1/2\\) 即可使局部截断误差达到 \\(O(h^3)\\) ，为二阶R-K公式。该条件有多组解： \\(\\alpha=1,\\ \\lambda_1=\\lambda_2=1/2,\\ \\beta=1\\) 时即为改进Euler公式。 \\(\\lambda_1=0,\\ \\lambda_2=1,\\ \\alpha=\\beta=1/2\\) 时为中点公式。 \\(\\mathbf{p=3}\\) 时，三阶R-K公式： \\[ \\left\\{\\begin{array}{l} \\displaystyle y_{n+1}=y_n+\\frac{h}{6}(K_1+4K_2+K_3)\\\\ \\displaystyle K_1=f(x_n,y_n)\\\\ \\displaystyle K_2=f(x_n+\\frac{1}{2}h,y_n+\\frac{1}{2}hK_1)\\\\ \\displaystyle K_3=f(x_n+h,y_n-hK_1+2hK_2) \\end{array}\\right. \\] \\(\\mathbf{p=4}\\) 时，四阶R-K公式： \\[ \\left\\{\\begin{array}{l} \\displaystyle y_{n+1}=y_n+\\frac{h}{6}(K_1+2K_2+2K_3+K_4)\\\\ \\displaystyle K_1=f(x_n,y_n)\\\\ \\displaystyle K_2=f(x_n+\\frac{1}{2}h,y_n+\\frac{1}{2}hK_1)\\\\ \\displaystyle K_3=f(x_n+\\frac{1}{2}h,y_n+\\frac{1}{2}hK_2)\\\\ \\displaystyle K_4=f(x_n+h,y_n+hK_3) \\end{array}\\right. \\] 隐式Runge-Kutta方法 一般形式： \\[ \\left\\{\\begin{array}{l} \\displaystyle y_{n+1}=y_n+h\\sum_{r=1}^p\\lambda_rK_r\\\\ \\displaystyle K_r=f(x_n+\\alpha_rh,y_n+h\\sum_{i=1}^r\\lambda_{ri}K_i),\\quad r=1,2,\\dots,p \\end{array}\\right. \\] 称为 \\(\\mathbf p\\) 级隐式Runge-Kutta方法。（如梯形公式就是二级隐式R-K方法。）\n缺点是计算量较大，优点是数值稳定性好。\n变步长Runge-Kutta方法 设从 \\(x_n\\) 以步长 \\(h\\) 计算 \\(y(x_{n+1})\\) 的近似值为 \\(y_{n+1}^{(h)}\\) ，设有局部截断误差 \\(y(x_{n+1})-y_{n+1}^{(h)}=Ch^{p+1}\\) 。\n设从 \\(x_n\\) 以步长 \\(\\frac{h}{2}\\) 计算 \\(y(x_{n+1})\\) 的近似值为 \\(y_{n+1}^{(\\frac{h}{2})}\\) ，则有局部截断误差 \\(\\displaystyle y(x_{n+1})-y_{n+1}^{(\\frac{h}{2})}\\approx \\frac{1}{2^p}Ch^{p+1}\\) 。\n两式相除得 \\(\\displaystyle\\frac{y(x_{n+1})-y_{n+1}^{(\\frac{h}{2})}}{y(x_{n+1})-y_{n+1}^{(h)}}\\approx\\frac{1}{2^p}\\) ，从而得事后误差估计 \\(\\displaystyle y_{n+1}^{(\\frac{h}{2})}-y_{n+1}^{(h)}\\approx\\frac{1}{2^p-1}(y_{n+1}^{(\\frac{h}{2})}-y_{n+1}^{(h)})\\) 。\n因此当 \\(\\displaystyle\\left|y_{n+1}^{(\\frac{h}{2})}-y_{n+1}^{(h)}\\right|\\le\\varepsilon\\) 时，可取 \\(\\displaystyle y_{n+1}^{(\\frac{h}{2})}\\approx y_{n+1}^{(h)}\\) ，否则将步长减半计算，直至满足精度要求。\n7.7 - 7.11 单步方法的性质 收敛性 求解初值问题的单步显式方法可统一写为如下形式： \\[ y_{n+1}=y_n+h\\Phi(x_n,y_n,h) \\] 其中 \\(\\Phi(x,y,h)\\) 称为增量函数。不同方法对应着不同的增量函数。\n定义：设 \\(y(x)\\) 是一阶常微分方程初值问题的精确解， \\(y_n\\) 是某单步方法产生的近似解，如任一固定点 \\(x_n\\) ，均有： \\[ \\displaystyle\\lim_{h\\to0}y_n=y(x_n) \\] 则称此单步方法收敛。因为此时 \\(y(x_n)-y_n\\) 不仅与 \\(y_{n+1}\\) 一步计算有关，而与前面的 \\(n\\) 步计算均有关，故称之为整体截断误差。（该定义也适用于单步隐式方法和多步方法。）\n定理：若某单步显式方法满足： + 是 \\(p\\) 阶方法，也即局部截断误差为 \\(O(h^{p+1})\\) ； + 增量函数 \\(\\Phi(x,y,h)\\) 在区域 \\(\\{a\\le x\\le b,-\\infty\u0026lt;y\u0026lt;+\\infty,0\\le h\\le h_0\\}\\) 上连续，且关于 \\(y\\) 满足Lipschitz条件，即存在常数 \\(L\u0026gt;0\\) 使 \\(|\\Phi(x,y,h)-\\Phi(x,\\bar{y},h)|\\le L|y-\\bar{y}|\\) ； + 初始近似 \\(y_0=y(\\alpha)=\\alpha\\) 。 则此单步方法收敛，且存在与 \\(h\\) 无关的常数 \\(C\\) ，使得 \\(|y(x_n)-y_n|\\le Ch^p\\) 。\n易证，Euler方法、改进Euler方法均是收敛的。\n（注意，此处差分方法的收敛性与前面构造改进Euler方法时所用到的“校正步骤的收敛性不同。）\n稳定性 收敛性反映截断误差，稳定性反映舍入误差。\n下面用 \\(y(x_n)\\) 表示精确值， \\(y_n\\) 表示理论计算值（只考虑截断误差）， \\(\\bar{y}_n\\) 表示实际计算值（还考虑舍入误差）。\n讨论数值方法稳定性通常仅限于典型试验方程： \\(\\displaystyle\\frac{dy}{dx}=\\lambda y\\) ，其中 \\(\\lambda\\) 为复数且 \\(Re(\\lambda)\u0026lt;0\\) 。\n定义1：对于某给定初值问题（试验方程），假设只在一个节点值 \\(y_n\\) 上产生计算误差 \\(\\delta\\) ，若该误差引起之后各节点的计算值变化均不超过 \\(\\delta\\) ，则称此差分方法绝对稳定。（对一般差分方法。）\n定义2：将单步方法应用于解试验方程，假设得 \\(y_{n+1}=E(\\lambda h)y_n\\) ，若满足条件 \\(|E(\\lambda h)|\u0026lt;1\\) ，则称此单步方法绝对稳定。在复平面上，变量 \\(\\lambda h\\) 满足 \\(|E(\\lambda h)|\u0026lt;1\\) 的区域称为该方法的绝对稳定域，其与实轴的交集称为绝对稳定区间。（ \\(|E(\\lambda h)|=1\\) 时也可认为误差没有增长，方法稳定。）（对单步方法。）\nEuler方法：绝对稳定域 \\(|1+\\lambda h|\u0026lt;1\\) ，绝对稳定区间 \\((-2,0)\\) 。 梯形公式：绝对稳定域 \\(Re(\\lambda h)\u0026lt;0\\) ，绝对稳定区间 \\((-\\infty,0)\\) 。 改进Euler方法：绝对稳定区间 \\((-2,0)\\) 。 二阶R-K方法：绝对稳定区间 \\((-2,0)\\) 。 三阶R-K方法：绝对稳定区间 \\((-2.51,0)\\) 。 四阶R-K方法：绝对稳定区间 \\((-2.78,0)\\) 。 综上，单步显式方法的稳定性与步长密切相关。步长过小时又会导致计算量过大。\n7.12 - 7.13 线性多步方法 单步方法计算简便，但精度较低。精度较高的单步方法（如四阶R-K方法），计算量较大。\n待定参数法构造线性多步方法 \\[ \\displaystyle y_{n+1}=\\sum_{i=0}^r\\alpha_iy_{n-i}+h\\sum_{i=-1}^r\\beta_if_{n-1} \\]\n若 \\(\\beta_{-1}\\neq0\\) 公式为隐式，反之为显式。\n参数 \\(\\{\\alpha_i,\\beta_i\\}\\) 的选择原则是使方法局部截断误差 \\(y(x_{n+1})-y_{n+1}=O(h^{r+2})\\) 。（指在 \\(y(x_{n-i})=y_{n-i}\\) 前提下的截断误差。）\n数值积分构造线性多步方法 由 \\[ \\displaystyle y(x_{n+1})=y(x_n)+\\int_{x_n}^{x_{n+1}}f(x,y(x))dx \\] 设 \\(p_r(x)\\) 为函数 \\(f(x,y(x))\\) 的某个 \\(r\\) 次插值多项式，则有 \\[ \\displaystyle y(x_{n+1})=y(x_n)+\\int_{x_n}^{x_{n+1}}p_r(x)dx+R_n \\] 其中 \\(R_n=\\int_{x_n}^{x_{n+1}}(f(x,y(x))-p_r(x))dx\\) 。由此可建立差分公式： \\[ \\displaystyle y_{n+1}=y_n+\\int_{x_n}^{x_{n+1}}p_r(x)dx \\]\nAdams显式公式 设精确解 \\(y(x)\\) 在步长为 \\(h\\) 的等距节点 \\(x_{n-r},\\dots,x_n\\) 上的近似值 \\(y_{n-r},\\dots,y_n\\) 。 记 \\(f_k=f(x_k,y_k)\\) ，利用 \\(r+1\\) 个数据 \\((x_{n-r},f_{n-r}),\\dots,(x_n,f_n)\\) 构造 \\(r\\) 次Lagrange插值多项式： \\[ \\displaystyle p_r(x)=\\sum_{j=0}^rl_{n-j}(x)f_{n-j} \\] 其中: \\[ \\displaystyle l_{n-j}(x)=\\prod_{k=0,k\\neq j}^r\\frac{x-x_{n-k}}{x_{n-j}-x_{n-k}},\\quad j=0,1,\\dots,r \\] 由此建立差分公式： \\[ \\displaystyle y_{n+1}=y_n+\\sum_{j=0}^r\\left(\\int_{x_n}^{x_{n+1}}l_{n-j}(x)dx\\right)f_{n-j} \\]\n由此整理得差分公式的具体形式： \\[ \\begin{array}{c}\\displaystyle y_{n+1}=y_n+h\\sum_{j=0}^r\\beta_{rj}f_{n-j}\\\\ 令x=x_n+th,\\displaystyle\\quad\\beta_{rj}=\\frac{(-1)^j}{j!(r-j)!}\\int_0^1\\prod_{k=0,k\\neq j}^r(t+k)dt,\\quad j=0,1,\\dots,r\\end{array} \\] 称之为 \\(\\mathbf{r+1}\\) 步Adams显式公式。\n\\(r=0,\\quad\\displaystyle y_{n+1}=y_n+hf_n+\\frac{1}{2}h^2y\u0026#39;\u0026#39;(x_n)\\) \\(r=1,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{2}(3f_n-f_{n-1})+\\frac{5}{12}h^3y\u0026#39;\u0026#39;\u0026#39;(x_n)\\) \\(r=2,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{12}(23f_n-16f_{n-1}+5f_{n-2})+\\frac{3}{8}h^4y^{(4)}(x_n)\\) \\(r=3,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{24}(55f_n-59f_{n-1}+37f_{n-2}-9f_{n-3})+\\frac{251}{720}h^5y^{(5)}(x_n)\\) Adams隐式公式 利用 \\(r+1\\) 个数据 \\((x_{n-r+1},f_{n-r+1}),\\dots,(x_{n+1},f_{n+1})\\) ，则可到处数值稳定性较好的隐式公式，其一般形式为： \\[ \\begin{array}{c}\\displaystyle y_{n+1}=y_n+h\\sum_{j=0}^r\\beta_{rj}^*f_{n-j+1}\\\\ 令x=x_n+th,\\displaystyle\\quad\\beta_{rj}^*=\\frac{(-1)^j}{j!(r-j)!}\\int_{-1}^0\\prod_{k=0,k\\neq j}^r(t+k)dt,\\quad j=0,1,\\dots,r\\end{array} \\]\n\\(r=0,\\quad\\displaystyle y_{n+1}=y_n+hf_{n+1}+\\frac{1}{2}h^2y\u0026#39;\u0026#39;(x_n)\\) \\(r=1,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{2}(f_{n+1}+f_n)-\\frac{1}{12}h^3y\u0026#39;\u0026#39;\u0026#39;(x_n)\\) \\(r=2,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{12}(5f_{n+1}-8f_n-f_{n-1})-\\frac{1}{24}h^4y^{(4)}(x_n)\\) \\(r=3,\\quad\\displaystyle y_{n+1}=y_n+\\frac{h}{24}(9f_{n+1}+19f_n-5f_{n-1}+f_{n-2})-\\frac{19}{720}h^5y^{(5)}(x_n)\\) Adams预估-校正公式 由显式公式提供一个预估值，再用隐式公式校正一次得到数值解，称为预估-校正方法。 一般预估公式和校正公式都采用同阶公式（ \\(r\\) 相等）。\n如使用四阶Adams显式公式和隐式公式则： \\[ \\bar{f}_{n+1}=f(x_{n+1},\\bar{y}_{n+1}),\\ n=3,4,\\dots \\] 称为四阶Adams预估校正公式，实际计算中通常用四阶单步方法（如四阶R-K公式）为其提供起始值 \\(y_1,y_2,y_3\\) 。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-03-11-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day14-rungekutta%E6%96%B9%E6%B3%95-%E7%BA%BF%E6%80%A7%E5%A4%9A%E6%AD%A5%E6%96%B9%E6%B3%95/","summary":"7.5 - 7.7 Runge-Kutta方法 单步高阶方法构造思路 设 \\(y(x)\\) 是一阶常微分方程初值问题的精确解，Taylor展开得： \\[ \\begin{aligned} \\displaystyle y(x_{n+1})\u0026amp;=y(x_n)+y\u0026#39;(x_n)h+\\frac{y\u0026#39;\u0026#39;(x_n)}{2!}h^2+\\dots+\\frac{y^{(p)}(x_n)}{p!}h^p+\\frac{y^{({p+1})}(x_n)}{(p+1)!}h^{p+1}\\\\ \u0026amp;=y(x_n)+hf(x_n,y(x_n))+\\frac{h^2}{2!}f^{(1)}(x_n,y(x_n))+\\dots+\\frac{h^p}{p!}f^{(p-1)}(x_n,y(x_n))+O(h^{p+1})\\end{aligned} \\] 因此可建立节点处近似值 \\(y_n\\) 满足的差分公式： \\[ \\left\\{\\begin{array}{l}\\displaystyle y_{n+1}=y_n+hf(x_n,y_n)+\\frac{h^2}{2!}f^{(1)}(x_n,y_n)+\\dots+\\frac{h^p}{p!}f^{(p-1)}(x_n,y_n)\\\\y_0=\\alpha,\\quad n=0,1,\\dots,N-1\\end{array}\\right. \\] 称之为 \\(\\mathbf p\\) 阶Taylor展开方法。 其中： \\(\\begin{array}{l}\\displaystyle f^{(1)}(x,y)=\\frac{\\partial f(x,y)}{\\partial x}+\\frac{\\partial f(x,y)}{\\partial y}f(x,y)\\\\\\displaystyle f^{(2)}(x,y)=\\frac{\\partial^2f}{\\partial x^2}+2\\frac{\\partial^2f}{\\partial x\\partial y}f+\\frac{\\partial^2 f}{\\partial y^2}f^2+\\frac{\\partial f}{\\partial x}\\frac{\\partial f}{\\partial y}+\\left(\\frac{\\partial f}{\\partial y}\\right)^2f\\\\\\dots\\end{array}\\)\n计算过于复杂，很少直接使用\n减少Taylor展开次数得： \\[ y(x_{n+1})=y(x_n)+hy\u0026#39;(\\xi)=y(x_n)+hf(\\xi,y(\\xi)),\\quad x_n\\le\\xi\\le x_{n+1} \\] 构造差分方法即利用适当的函数值来近似计算 \\(f(\\xi,y(\\xi))\\) 。\nEuler方法用 \\(K_1\\) 作为其近似，其 \\(y_{n+1}\\) 表达式与精确解的Taylor展式前 \\(2\\) 项一致。为 \\(1\\) 阶方法。 改进Euler方法用 \\(K_1,K_2\\) 的线性组合作为其近似，其 \\(y_{n+1}\\) 表达式与精确解的Taylor展式前 \\(3\\) 项一致。为 \\(2\\) 阶方法。 能否增加计算 \\(f(x,y)\\) 的次数来提高方法阶数？ Runge-Kutta方法 \\[ \\left\\{\\begin{array}{l} y_{n+1}=y_n+h(\\lambda_1K_1+\\lambda_2K_2+\\dots+\\lambda_pK_p)\\\\ K_1=f(x_n,y_n)\\\\ K_2=f(x_n+\\alpha_2h,y_n+h\\beta_{21}K_1)\\\\ \\dots\\\\ K_p=f(x_n+\\alpha_ph,y_n+h\\sum\\limits_{i=1}^{p-1}\\beta_{pi}K_i) \\end{array}\\right.","title":"2021-03-11-数值分析-Day14-RungeKutta方法-线性多步方法"},{"content":"Lecture 8-9 Real-time Global Illumination （Screen Space） Screen Space : 利用相机视角渲染出来的屏幕中的所有信息 可以认为是对渲染结果的Post Processing\nScreen Space Ambient Occlusion (SSAO) AO 环境光遮蔽 : 通过Contact Shadow使物体间相对位置明显SSAO : 对全局光照的近似的屏幕空间方法\nKey idea :\n不知道间接光照 假定间接光照值是常数（对所有着色点、从所有方向） like Blinn-Phong 考虑不同着色点对各方向的Visibility（不同于Blinn-Phong的地方） 离线渲染中的AO——“天光”：等同于一个完全均匀的光照\nTheory :\nRendering Equation \\[ L_o(\\mathrm p,\\omega_0)=\\int_{\\Omega_\\mathrm{patch}}L_i(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)V(\\mathrm p,\\omega_i)\\cos\\theta_i\\,\\mathrm d\\omega_i \\]\n考虑对Rendering Equation的近似（“The RTR Approximation / Equation”） \\[ \\int_\\Omega f(x)g(x)\\,\\mathrm d x\\approx\\dfrac{\\int_{\\Omega_G} f(x)\\,\\mathrm d x}{\\int_{\\Omega_G} \\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm d x \\] 将Visibility项拆出，得： \\[ \\begin{aligned} L_o^{\\rm indir}(\\mathrm p,\\omega_0)\\approx\u0026amp;\\dfrac{\\int_{\\Omega_+} V(\\mathrm p,\\omega_i)\\cos\\theta_i\\,\\mathrm d\\omega_i}{\\int_{\\Omega_+}\\cos\\theta_i\\,\\mathrm d\\omega_i}\\cdot\\\\ \\approx\u0026amp;\\int_{\\Omega_+}L_i^{\\rm indir}(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ =\u0026amp;k_A\\cdot \\underbrace{L_i^{\\rm indir}(p)\\rho}_{\\rm constant\\ for\\ AO} \\end{aligned} \\]\nA deeper understanding 1 \\[ \\begin{aligned} \\int_\\Omega f(x)g(x)\\,\\mathrm d x\u0026amp;\\approx\\dfrac{\\int_{\\Omega_G} f(x)\\,\\mathrm d x}{\\int_{\\Omega_G} \\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm d x\\\\ \u0026amp;=\\overline{f(x)}\\cdot\\int_\\Omega g(x)\\,\\mathrm d x \\end{aligned} \\] 由于 \\(g(x)\\) 值小且平滑时该近似较准确，此处 \\(g(x)\\) 为常数，为准确拆分。\nA deeper understanding 2 前面积分中， \\(\\,\\mathrm d x\\) 总是跟着 \\(\\cos\\theta_i\\) =\u0026gt; 半球上的立体角投影 \\(\\,\\mathrm d x_\\perp=\\cos\\theta_i\\,\\mathrm d \\omega_i\\) ，将球面积分转换为圆盘积分（积分值为圆盘面积 \\(\\pi\\) ） 回到SSAO的简单情况：\n均匀间接光照 \\(L_i\\) [常数]\nDiffuse材质BRDF \\(f_r=\\dfrac{\\rho}{\\pi}\\) [常数]\nRendering Equation拆成： \\[ \\begin{aligned} L_o(\\mathrm p,\\omega_0)\u0026amp;=\\int_{\\Omega_+}L_i(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)V(\\mathrm p,\\omega_i)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ \u0026amp;=\\dfrac{\\rho}{\\pi}\\cdot L_i(p)\\cdot\\int_{\\Omega_+}V(\\mathrm p,\\omega_i)\\cos\\theta_i\\mathrm d\\omega_i \\end{aligned} \\] 则即需求 \\(k_A\\)\nHow to compute : + In object space + Raycasting against geometry + Slow, require simplifications and / or spatial data structures + Depends of scene complexity + In screen space + Done in a post-rendering pass + No pre-processing required + Doesn’t depend on scene comple + Simple + Not physically accurate\nSSAO\n考虑特定半径半球范围内的遮挡关系（忽略远处的间接光照） 在半径范围内随机撒点，通过点在物体内/外判断对光源可见性 判断方法：通过Z-Buffer记录的物体深度直接判断（可能出现中图红线处的判断失误，忽略该失误） 理论上应在法线方向半球范围内考虑，但渲染过程不一定有Normal-Buffer。 则考虑，仅当随机点中有超过一半在物体内时考虑AO问题。计算时 \\({\\rm AO} = \\dfrac{物体外的点}{物体内的点-随机点总数/2}\\) 随机点采样数不足时，易出现噪点，可以后期直接降噪应用，对画面影响较小 问题：在两个完全不接触的物体边界可能出现AO效果 HBAO , Horizon based Ambient Occlusion : 在有Normal-Buffer情况下，在半球范围内撒点采样，对不同方向加权（根据方向与法线的差值）。（更加精确，也改善了不接触的物体边界的问题。）\nScreen Space Directional Occlusion (SSDO) 在SSAO基础上的提升，考虑更加精确的间接光照\nKey idea :\n不再假设间接光照都是均匀的 有一些间接光照的信息已经知道——参考RSM中，直接光照的接收者 效果 : 遮蔽不再简单变暗，而是带有Color Blending效果\n思路 :\n很像Path Tracing 在着色点P处随机发射一根光线 若未hit物体，则判为直接光照 若hit物体，则判为间接光照 Comparison with SSAO :\nAO : 未被挡住的有间接光照、被挡住的没有 DO : 未被挡住的无间接光照、被挡住的有 原因：AO假设间接光照来自远处、DO假设间接光照来自近处。理论正确方法=AO+DO。\nTheory : \\[ L_o^{\\rm dir}(\\mathrm p,\\omega_0)=\\int_{\\Omega_+,\\,V=1}L_i^{\\rm dir}(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ L_o^{\\rm indir}(\\mathrm p,\\omega_0)=\\int_{\\Omega_+,\\,V=0}L_i^{\\rm indir}(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d\\omega_i \\] 则关注下式，求 \\(V=0\\) 时得到的间接光照，来自一个patch/pixel的间接光照求法在前课中已介绍\n具体做法\n对着色点P法线方向的半球内，随机取几个点（eg. 下图ABCD）\n同SSAO，用相机对采样点的可见性替代P点对采样点的可见性，得到满足要求的不可见点\n将满足要求的不可见点作为间接光源计算P点处间接光照\nBUG：如下图出现前后非接触物体时，用相机对采样点的可见性替代P点对采样点的可见性会错误 问题 :\n只能实现小范围的全局光照（半球范围内）\n可见性问题（参考具体做法.BUG）\n丢失不可见面信息（所有SS方法都有的问题） eg. 下图中图3/4旋转后，丢失了方块深度面上的DO Screen Space Reflection (SSR) // “Screen Space Ray Tracing”\nSSR : 在屏幕空间作光线追踪\nIntersection : 任意光线与屏幕空间的场景求交 Shading : 交点处像素对着色点的“贡献” PS.反射信息绝大部分都是屏幕空间中已有的内容\n可以做\nSpecular 从着色点处trace镜面方向光线 Glossy 从着色点处，trace多根光线（根据BRDF） Medium smoothness + normals 不光滑平面，根据法线和BRDF… Variable smoothness 做法\nIntersection\n逐渐往前走一小步\n每步与Z-Buffer对比深度，若在深度内则判定相交 步长过大不精准、过小效率低——动态自适应步长\n作深度的Mipmap（每一层的像素是下一层对应四个像素中的最小值，“最小池化”） 类似BVH、KD-Tree的加速结构\n在与上层（低分辨率）的深度图相交的情况下，下层（高分辨率）的深度图才可能相交 先以低步长前进、与高精度Mipmap判断，若无相交则增大步长、降低Mipmap精度，若无相交则继续增大步长、降低Mipmap精度，直到产生相交则减小步长，提高Mipmap精度，直至最高精度\nmip = 0; while (level \u0026gt; -1) step through current cell; if (above Z plane) ++level; if (below Z plane) --level; 问题 : Screen Space 被遮挡的物体、范围外的物体均不参与反射，通常在反射边界做虚化\nTheory : 与Path Tracing无异——仅假设被反射物（非反射材质）和次级光源为diffuse。（没有距离衰减、没有次级光源与着色点之间的可见性问题。）\n类似Path Tracing带来的效果\n通过不同BRDF（不同数量光线）实现镜面、Glossy等多种反射 Contact hardening 离反射面越近越Sharp的现象 Specular elongation 各向同性问题（雨天灯光拉长） 逐像素的Roughness和Normal Improvements\nBRDF的重要性采样 邻近pixel的hit复用，增加了采样数 屏幕空间先做模糊，再做单次查询（filter较难做） Summary\nPros 快速的Specular/Gloss反射 高质量 没有Spike和遮挡问题 Cons 效率较Diffuse情况低 丢失屏幕空间以外的信息 ","permalink":"https://elderlyaugustus.github.io/posts/2022-03-11-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture8-9-giinss/","summary":"Lecture 8-9 Real-time Global Illumination （Screen Space） Screen Space : 利用相机视角渲染出来的屏幕中的所有信息 可以认为是对渲染结果的Post Processing\nScreen Space Ambient Occlusion (SSAO) AO 环境光遮蔽 : 通过Contact Shadow使物体间相对位置明显SSAO : 对全局光照的近似的屏幕空间方法\nKey idea :\n不知道间接光照 假定间接光照值是常数（对所有着色点、从所有方向） like Blinn-Phong 考虑不同着色点对各方向的Visibility（不同于Blinn-Phong的地方） 离线渲染中的AO——“天光”：等同于一个完全均匀的光照\nTheory :\nRendering Equation \\[ L_o(\\mathrm p,\\omega_0)=\\int_{\\Omega_\\mathrm{patch}}L_i(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)V(\\mathrm p,\\omega_i)\\cos\\theta_i\\,\\mathrm d\\omega_i \\]\n考虑对Rendering Equation的近似（“The RTR Approximation / Equation”） \\[ \\int_\\Omega f(x)g(x)\\,\\mathrm d x\\approx\\dfrac{\\int_{\\Omega_G} f(x)\\,\\mathrm d x}{\\int_{\\Omega_G} \\,\\mathrm d x}\\cdot\\int_\\Omega g(x)\\,\\mathrm d x \\] 将Visibility项拆出，得： \\[ \\begin{aligned} L_o^{\\rm indir}(\\mathrm p,\\omega_0)\\approx\u0026amp;\\dfrac{\\int_{\\Omega_+} V(\\mathrm p,\\omega_i)\\cos\\theta_i\\,\\mathrm d\\omega_i}{\\int_{\\Omega_+}\\cos\\theta_i\\,\\mathrm d\\omega_i}\\cdot\\\\ \\approx\u0026amp;\\int_{\\Omega_+}L_i^{\\rm indir}(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d\\omega_i\\\\ =\u0026amp;k_A\\cdot \\underbrace{L_i^{\\rm indir}(p)\\rho}_{\\rm constant\\ for\\ AO} \\end{aligned} \\]","title":"2022-03-11-GAMES202高质量实时渲染-Lecture8-9-GI in Screen Space"},{"content":"7.1 - 7.4 差分公式 一阶常微分方程初值问题 一阶常微分方程初值问题的一般形式为：\n\\[ \\left\\{\\begin{array}{l}\\displaystyle\\frac{dy}{dx}=f(x,y),\\quad a\\le x\\le b\\\\y(a)=\\alpha\\end{array}\\right. \\] 其中 \\(f(x,y)\\) 为已知函数， \\(\\alpha\\) 为给定的值。\n在许多数学模型中，上述方程通常以 \\(x\\) 描述时间，而定解条件 \\(y(a)=\\alpha\\) 则给出了函数 \\(y(x)\\) 在初始时刻的取值。因此称为初值问题。\n问题： + 上述方程何时存在唯一解 + 如何计算 \\(y(x)\\)\nLipschitz条件： 若函数 \\(f(x,y)\\) 在区域 \\(\\{a\\le x\\le b,\\ m\u0026lt;y\u0026lt;M\\}\\) 上连续，满足 \\[ \\forall y,\\bar{y},\\ |f(x,y)-f(x,\\bar{y})|\\le L|y-\\bar{y}| \\] 其中 \\(L\u0026gt;0\\) 为Lipschitz常数（此处Lipschitz常数可以 \\(\\ge1\\) ），则初值问题在初始时刻 \\(a\\) 的某个邻域上存在唯一解。 （不满足Lipschitz条件时，不一定存在唯一解。）\n构造一阶常微分方程初值问题数值解法 假设初值问题的解 \\(y=y(x)\\) 唯一存在且足够光滑。对求解区域 \\([a,b]\\) 做等距剖分 \\(a=x_0\u0026lt;x_1\u0026lt;x_2\u0026lt;\\dots\u0026lt;x_n\u0026lt;\\dots\u0026lt;x_N=b\\) 。称 \\(h=(b-a)/N\\) 为剖分步长， \\(x_n=a+nh,\\ n=0,1,\\dots,N\\) 为剖分节点。数值解法即求精确解 \\(y(x)\\) 在剖分节点 \\(x_n\\) 上的值 \\(y(x_n)\\) 的近似值 \\(y_n\\) 。\n差分公式：在区间 \\([x_n,x_{n+1}]\\) 上对微分方程两端同时积分有： \\[ \\displaystyle y(x_{n+1})-y(x_n)=\\int_{x_n}^{x_{n+1}}f(x,y(x))dx \\] 对该式右边积分部分应用不同的数值积分公式（参考前一章）做逼近，就得到相应不同的差分公式。\nEuler公式：对右边积分应用左矩形公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx(b-a)f(a)\\) ，得到Euler差分公式： \\[ \\left\\{\\begin{array}{l}y_{n+1}=y_n+hf(x_n,y_n)\\\\y_0=\\alpha\\\\n=0,1,\\dots,N-1\\end{array}\\right. \\] 梯形公式：对右边积分应用梯形公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx\\frac{(b-a)}{2}[f(a)+f(b)]\\) ，得到梯形差分公式： \\[ \\left\\{\\begin{array}{l}\\displaystyle y_{n+1}=y_n+\\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y_{n+1})]\\\\y_0=\\alpha\\\\n=0,1,\\dots,N-1\\end{array}\\right. \\] Euler中点公式：将积分范围扩大为 \\([x_{n-1},x_{n+1}]\\) ，有 \\[ \\displaystyle y(x_{n+1})-y(x_{n-1})=\\int_{x_{n-1}}^{x_{n+1}}f(x,y(x))dx \\] 对右边积分应用中矩形公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx(b-a)[f(\\frac{a+b}{2})]\\) ，得到Euler中点公式（或称双步Euler公式）： \\[ \\left\\{\\begin{array}{l}\\displaystyle y_{n+1}=y_{n-1}+2hf(x_n,y_n)\\\\y_0=\\alpha\\\\n=0,1,\\dots,N-1\\end{array}\\right. \\] 该公式属于多步方法，需要更多初值信息。 其中，Euler公式和Euler中点公式为显式方法，梯形公式为隐式方法。\n改进Euler方法 梯形公式计算精度好，但属于隐式公式，不便计算。\n根据非线性方程迭代法的思想，进行如下近似计算： \\[ \\left\\{\\begin{aligned} \\displaystyle\u0026amp;y_{n+1}^{[0]}=y_n+hf(x_n)\\\\ \\displaystyle\u0026amp;y_{n+1}^{[k+1]}=y_n+\\frac{h}{2}[f(x_n,y_n),f(x_{n+1},y_{n+1}^{[k]})]\\\\ \u0026amp;\u0026amp;k=0,1,\\dots\\\\ \u0026amp;y_0=\\alpha,\\ n=0,1,\\dots,N-1 \\end{aligned}\\right. \\] 即首先应用Euler公式提供 \\(y_{n+1}\\) 的初始值（预估），然后采用梯形公式框架进行关于 \\(y_{n+1}\\) 值的迭代计算（校正）。\n校正过程中迭代计算是否一定收敛？\n考察迭代格式，迭代函数为 \\[ \\displaystyle\\varphi(x)=y_n+\\frac{h}{2}[f(x_n,y_n)+f(x_{n+1},y)] \\]\n压缩映射原理：设函数 \\(f\\) 定义域和值域均为 \\([a,b]\\) ，并存在一个常数 \\(L\\) ，满足 \\(0\u0026lt;L\u0026lt;1\\) ，使得对 \\(\\forall x,y\\in[a,b]\\) ，都有 \\(|f(x)-f(y)|\\le L|x-y|\\) ，则称 \\(f\\) 是 \\([a,b]\\) 上的一个压缩映射，称常数 \\(L\\) 为Lipschitz常数（压缩常数）。\n假设 \\(\\displaystyle\\frac{\\partial f}{\\partial y}\\) 存在，则当 \\(|\\varphi\u0026#39;(y)|\\le L\u0026lt;1\\) 也即 \\(\\displaystyle\\frac{h}{2}\\left|\\frac{\\partial f}{\\partial y}\\right|\\le L\u0026lt;1\\) 时，迭代必然收敛。理论上只需令剖分步长 \\(h\\) 足够小即可满足条件。 计算中，当 \\(\\left|y_{n+1}^{[k+1]}-y_{n+1}^{[k]}\\right|\u0026lt;\\varepsilon\\) ，取 \\(y_{n+1}=y_{n+1}^{[k+1]}\\)\n若仅迭代一步则有： \\[ \\left\\{\\begin{aligned} \\displaystyle\u0026amp;\\bar{y}_{n+1}=y_n+hf(x_n)\\\\ \\displaystyle\u0026amp;y_{n+1}=y_n+\\frac{h}{2}[f(x_n,y_n),f(x_{n+1},\\bar{y}_{n+1})]\\\\ \u0026amp;y_0=\\alpha,\\ n=0,1,\\dots,N-1 \\end{aligned}\\right. \\] 称之为改进Euler方法，属于单步显式方法。也可写作： \\[ \\left\\{\\begin{aligned} \\displaystyle\u0026amp;y_{n+1}=y_n+h(K_1+K_2)\\\\ \u0026amp;K_1=f(x_n,y_n)\\\\ \u0026amp;K_2=f(x_n+h,y_n+hK_1)\\\\ \u0026amp;y_0=\\alpha,\\ n=0,1,\\dots,N-1 \\end{aligned}\\right. \\]\n误差分析 在节点 \\(x_{n+1}\\) 处的误差 \\(y(x_{n+1})-y_{n+1}\\) ，不仅与 \\(y_{n+1}\\) 这一步计算，而且与前 \\(n\\) 步均有关。为简化误差分析，着重研究一步计算时产生的截断误差，假设 \\(y_n=y(x_n)\\) ，称 \\(y(x_{n+1})-y_{n+1}\\) 为局部截断误差。\n若单步差分公式的局部截断误差为 \\(O(h^{p+1})\\) （同阶无穷小），则称该公式为 \\(p\\) 阶方法。 \\(p\\) 为非负整数，阶数越高精度越好。\n由一元Taylor公式： \\[ \\displaystyle y(x_{n+1})=y(x_n+h)=y(x_n)+y\u0026#39;(x_n)h+\\frac{y\u0026#39;\u0026#39;(x_n)}{2!}h^2+\\frac{y\u0026#39;\u0026#39;\u0026#39;(x_n)}{3!}h^3+O(h^4) \\] 由二元Taylor公式： \\[ \\displaystyle\\begin{aligned}f(x_n+h,y_n+k)=\u0026amp;f(x_n,y_n)+\\frac{\\partial f(x_n,y_n)}{\\partial x}h+\\frac{\\partial f(x_n,y_n)}{\\partial y}k\\\\ \u0026amp;+\\frac{1}{2!}\\left[\\frac{\\partial^2f(x_n,y_n)}{\\partial x^2}h^2+2\\frac{\\partial^2 f(x_n,y_n)}{\\partial x \\partial y}hk+\\frac{\\partial^2f(x_n,y_n)}{\\partial y^2} k^2\\right]\\\\ \u0026amp;+\\dots+\\frac{1}{k!}\\left[h\\frac{\\partial}{\\partial x}+k\\frac{\\partial}{\\partial y}\\right]^kf(x_n,y_n)+\\dots \\end{aligned} \\]\n常见差分公式的局部截断误差 + Euler公式： \\[ \\displaystyle y(x_{n+1})-y_{n+1}=\\frac{y\u0026#39;\u0026#39;(x_n)}{2!}h^2+O(h^3)=O(h^2) \\] 因此Euler公式为 \\(1\\) 阶方法。 + 改进Euler公式： \\[ y(x_{n+1})-y_{n+1}=O(h^3) \\] 因此Euler公式为 \\(2\\) 阶方法。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-03-10-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day13-%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F/","summary":"7.1 - 7.4 差分公式 一阶常微分方程初值问题 一阶常微分方程初值问题的一般形式为：\n\\[ \\left\\{\\begin{array}{l}\\displaystyle\\frac{dy}{dx}=f(x,y),\\quad a\\le x\\le b\\\\y(a)=\\alpha\\end{array}\\right. \\] 其中 \\(f(x,y)\\) 为已知函数， \\(\\alpha\\) 为给定的值。\n在许多数学模型中，上述方程通常以 \\(x\\) 描述时间，而定解条件 \\(y(a)=\\alpha\\) 则给出了函数 \\(y(x)\\) 在初始时刻的取值。因此称为初值问题。\n问题： + 上述方程何时存在唯一解 + 如何计算 \\(y(x)\\)\nLipschitz条件： 若函数 \\(f(x,y)\\) 在区域 \\(\\{a\\le x\\le b,\\ m\u0026lt;y\u0026lt;M\\}\\) 上连续，满足 \\[ \\forall y,\\bar{y},\\ |f(x,y)-f(x,\\bar{y})|\\le L|y-\\bar{y}| \\] 其中 \\(L\u0026gt;0\\) 为Lipschitz常数（此处Lipschitz常数可以 \\(\\ge1\\) ），则初值问题在初始时刻 \\(a\\) 的某个邻域上存在唯一解。 （不满足Lipschitz条件时，不一定存在唯一解。）\n构造一阶常微分方程初值问题数值解法 假设初值问题的解 \\(y=y(x)\\) 唯一存在且足够光滑。对求解区域 \\([a,b]\\) 做等距剖分 \\(a=x_0\u0026lt;x_1\u0026lt;x_2\u0026lt;\\dots\u0026lt;x_n\u0026lt;\\dots\u0026lt;x_N=b\\) 。称 \\(h=(b-a)/N\\) 为剖分步长， \\(x_n=a+nh,\\ n=0,1,\\dots,N\\) 为剖分节点。数值解法即求精确解 \\(y(x)\\) 在剖分节点 \\(x_n\\) 上的值 \\(y(x_n)\\) 的近似值 \\(y_n\\) 。","title":"2021-03-10-数值分析-Day13-差分公式"},{"content":"续：6.1 - 6.11 数值积分 复化求积公式 Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数 \\(\\ge8\\) 时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即复化求积公式的基本思想。\n在区间 \\([a,b]\\) 上，取等距节点 \\(x_k=a+kh,\\ k=0,1,\\dots,n\\) ，\n由定积分的区间可加性得 \\(\\displaystyle\\int_a^bf(x)dx=\\sum_{k=1}^n\\int_{x_{k-1}}^{x_k}f(x)dx\\) 。\n若在每个小区间 \\(x_{k-1},x_k\\) 用梯形公式，则有复化梯形公式 \\(T_n\\) ：\n\\[ \\displaystyle I=\\int_a^bf(x)dx\\approx T_n=\\frac{h}{2}\\sum_{k=1}^n\\left[f(x_{k-1})+f(x_k)\\right]=\\frac{h}{2}\\left[2\\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\\right] \\]\n复化梯形公式的的误差为：\n\\[ \\begin{array}{l}\\displaystyle I-T_n=-\\frac{h^3}{12}[f\u0026#39;\u0026#39;(\\xi_1)+\\dots+f\u0026#39;\u0026#39;(\\xi_n)]=-\\frac{h^2(b-a)}{12}f\u0026#39;\u0026#39;(\\eta),\\quad\\eta\\in(a,b)\\\\\\displaystyle \\left|I-T_n\\right|\\le\\frac{(b-a)^3}{12n^2}\\max_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|\\end{array} \\]\n可知复化梯形公式收敛，且要使得误差 \\(\\le\\varepsilon\\) ，只要 \\(\\left|I-T_n\\right|\\le\\varepsilon\\) 或 \\(\\displaystyle n\u0026gt;\\sqrt{\\frac{(b-a)^3\\max_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|}{12\\varepsilon}}\\) 。 同理，复化Simpson公式 \\(S_n\\) ：\n\\[ \\displaystyle I=\\int_a^bf(x)dx\\approx S_n=\\frac{h}{6}\\left[4\\sum_{k=1}^nf(x_{k-\\frac{1}{2}})+2\\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\\right] \\]\n复化Simpson公式的误差为：\n\\[ \\begin{array}{l}\\displaystyle I-S_n=-\\frac{h^4(b-a)}{2880}f^{4}(\\eta),\\quad\\eta\\in(a,b)\\\\\\displaystyle \\left|I-S_n\\right|\\le\\frac{(b-a)^5}{2880n^4}\\max_{a\\le x\\le b}|f^{(4)}(x)|\\end{array} \\]\n可知收敛，且要使得误差 \\(\\le\\varepsilon\\) ，只要 \\(\\left|I-S_n\\right|\\le\\varepsilon\\) 或 \\(\\displaystyle n\u0026gt;\\sqrt[4]{\\frac{(b-a)^5\\max_{a\\le x\\le b}|f^{(4)}(x)|}{2880\\varepsilon}}\\) 。 同理，复化Cotes公式 \\(C_n\\) ：\n\\[ \\begin{aligned}\\displaystyle I\u0026amp;=\\int_a^bf(x)dx\\approx C_n\\\\\u0026amp;=\\frac{h}{90}\\left\\{32\\sum_{k=1}^n\\left[f(x_{k-\\frac{3}{4}})+f(x_{k-\\frac{1}{4}})\\right]+12\\sum_{k=1}^nf(x_{k-\\frac{1}{2}})+14\\sum_{k=1}^{n-1}f(x_k)+7f(a)+7f(b)\\right\\}\\end{aligned} \\]\n复化Cotes公式的误差为：\n\\[ \\begin{array}{l}\\displaystyle I-S_n=-\\frac{h^6(b-a)}{1935360}f^{6}(\\eta),\\quad\\eta\\in(a,b)\\\\\\displaystyle \\left|I-S_n\\right|\\le\\frac{(b-a)^7}{1935360n^6}\\max_{a\\le x\\le b}|f^{(6)}(x)|\\end{array} \\]\n可知收敛，且要使得误差 \\(\\le\\varepsilon\\) ，只要 \\(\\left|I-S_n\\right|\\le\\varepsilon\\) 或 \\(\\displaystyle n\u0026gt;\\sqrt[6]{\\frac{(b-a)^7\\max_{a\\le x\\le b}|f^{(6)}(x)|}{1935360\\varepsilon}}\\) 。 Romberg求积公式 复化求积公式对步长有较高要求。\n由复化梯形公式推导 由梯形公式 \\(\\begin{array}{l}\\displaystyle I-T_n=-\\frac{(b-a)^3}{12n^2}f\u0026#39;\u0026#39;(\\eta)\\quad\\eta\\in(a,b)\\\\\\displaystyle I-T_{2n}=-\\frac{(b-a)^3}{36n^2}f\u0026#39;\u0026#39;(\\tilde{\\eta})\\quad\\tilde{\\eta}\\in(a,b)\\end{array}\\) ，视 \\(f\u0026#39;\u0026#39;(\\eta)\\approx f\u0026#39;\u0026#39;(\\tilde{\\eta})\\) ，\n得 \\(\\displaystyle I\\approx\\frac{4T_{2n}-T_n}{3}\\) 或 \\(\\displaystyle I-T_{2n}\\approx\\frac{T_{2n}-T_n}{3}\\) 。\n该二式表述精度更高，代入有 \\(\\displaystyle\\frac{4T_{2n}-T_n}{3}=\\frac{h}{6}\\left[4\\sum_{k=1}^nf(x_{k-\\frac{1}{2}})+2\\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\\right]=S_n\\) ，即为Simpson公式。且 \\(\\displaystyle T_{2n}=\\frac{T_n}{2}+\\frac{h}{2}\\sum_{k=1}^nf(x_{k-\\frac{1}{2}})\\) 。\n由此得逐次分半的复化梯形公式的递推公式： \\[ \\left\\{\\begin{array}{l} \\displaystyle T_{2^0}=T_1=\\frac{b-a}{2}[f(a)+f(b)]\\\\ \\displaystyle T_{2^k}=\\frac{T_{2^{k-1}}}{2}+\\frac{b-a}{2^k}\\sum_{i=1}^{2^{k-1}}f(a+\\frac{(2i-1)(b-a)}{2^k}),\\quad k=1,2,\\dots \\end{array}\\right. \\] 且要使得 \\(|I-T_{2^k}|\u0026lt;\\varepsilon\\) ，只要 \\(|T_{2^k}-T_{2^{k-1}}|\u0026lt;3\\varepsilon\\) 。 同理得逐次分半的复化Simpson公式的递推公式： \\[ \\left\\{\\begin{array}{l} \\displaystyle T_{2^0}=T_1=\\frac{b-a}{2}[f(a)+f(b)]\\\\ \\displaystyle T_{2^k}=\\frac{T_{2^{k-1}}}{2}+\\frac{b-a}{2^k}\\sum_{i=1}^{2^{k-1}}f(a+\\frac{(2i-1)(b-a)}{2^k}),\\quad k=1,2,\\dots\\\\ \\displaystyle S_{2^{k-1}}=\\frac{4T_{2^k}-T_{2^{k-1}}}{3},\\quad k=1,2,\\dots \\end{array}\\right. \\] 由复化Simpson公式推导 类似的推法得到 \\(\\displaystyle I\\approx\\frac{16S_{2n}-S_n}{15}\\) 或 \\(\\displaystyle I-S_{2n}\\approx\\frac{S_{2n}-S_n}{15}\\) 。且有 \\(\\displaystyle\\frac{16S_{2n}-S_n}{15}=C_n\\) 。\n由复化Cotes公式推导\n同理得 \\(\\displaystyle I\\approx\\frac{64C_{2n}-C_n}{63}\\) 或 \\(\\displaystyle I-C_{2n}\\approx\\frac{C_{2n}-C_n}{63}\\) 。记 \\(\\displaystyle R_n=\\frac{64C_{2n}-C_n}{63}\\) ，即为Romberg求积公式。\n一般化推论 令 \\(T_{2^k}^{(1)}=T_{2^k},\\ T_{2^k}^{(1)}=S_{2^k},\\ T_{2^k}^{(2)}=C_{2^k},\\ T_{2^k}^{(3)}=R_{2^k}\\) ，则有： \\[ \\left\\{\\begin{array}{l} \\displaystyle T_{2^0}=T_1=\\frac{b-a}{2}[f(a)+f(b)]\\\\ \\displaystyle T_{2^k}^{(0)}=\\frac{T_{2^{k-1}}}{2}+\\frac{b-a}{2^k}\\sum_{i=1}^{2^{k-1}}f(a+\\frac{(2i-1)(b-a)}{2^k}),\\quad k=1,2,\\dots\\\\ \\displaystyle T_{2^k}^{(m)}=\\frac{4^mT_{2^{k+1}}^{(m-1)}-T_{2^k}^{(m-1)}}{4^m-1},\\quad k=1,2,\\dots,\\ m=1,2,\\dots \\end{array}\\right. \\] 且要使得 \\(|I-T_{2^k}^{(m)}|\u0026lt;\\varepsilon\\) ，只要 \\(|T_{2^k}^{(m)}-T_{2^{k-1}}^{(m)}|\u0026lt;(4^{m+1}-1)\\varepsilon,\\ m=0,1,\\dots\\) 。\n正交多项式 函数内积：若 \\(f(x),g(x)\\in C[a,b]\\) ，则称 \\(\\displaystyle\\int_a^bf(x)g(x)dx\\) 为 \\(f(x)\\) 和 \\(g(x)\\) 的内积，记为： \\((f,g)\\) ，其满足： + \\((f,g)=(g,f)\\) + \\((cf,g)=c(f,g)\\) + \\((f_1+f_2,g)=(f_1,g)+(f_2,g)\\) 若 \\((f,g)=0\\) ，则称 \\(f(x)\\) 与 \\(g(x)\\) 正交，记为 \\(f\\perp g\\) 。\n利用内积可定义函数的平方模 \\(\\displaystyle\\|f\\|_2=\\sqrt{(f,f)}=\\sqrt{\\int_a^bf^2(x)dx}\\) ，其满足： + \\(\\|f\\|_2\\ge0,\\ \\|f\\|_2=0\\Leftrightarrow f(x)=0\\) + \\(\\|cf\\|_2=|c|\\|f\\|_2\\) + \\(\\|f,g\\|_2\\le\\|f\\|_2+\\|g\\|_2\\) + \\(\\|(f,g)\\|_2\\le\\|f\\|_2\\|g\\|_2\\)\n常引进加权形式定义： \\(\\displaystyle(f,g)=\\int_a^b\\rho(x)f(x)g(x)dx\\) ，则 \\(\\displaystyle\\|f\\|_2=\\sqrt{\\int_a^b\\rho(x)f^2(x)dx}\\) 。\n定理1：若 \\(f_0(x),f_1(x),\\dots,f_n(x)\\) 为 \\(C[a,b]\\) 上的一组线性无关函数，则由 \\(f_k(x)\\) 线性组合可得到 \\(C[a,b]\\) 上的一组两两正交的函数组 \\(g_0(x),g_1(x),\\dots,g_n(x)\\) ，单位化（平方模变为 \\(1\\) ）为规范正交组 \\(e_0(x),r_1(x),\\dots,r_n(x)\\) 。（Schemite正交化）\n将 \\(P_n\\) 上由线性无关函数 \\(1,x,x^2,\\dots,x^n\\) 经过Schemite正交化得到的多项式 \\(p_0(x),p_1(x),\\dots,p_n(x)\\) 称为 \\([a,b]\\) 上的正交多项式。\n若 \\(p_0(x),p_1(x),\\dots,p_n(x)\\) 为 \\([a,b]\\) 上权函数为 \\(\\rho(x)\\) 的正交多项式，则满足： + \\(p_k(x)\\) 时首项系数不为零的 \\(k\\) 次多项式 + \\(p_0(x),p_1(x),\\dots,p_n(x)\\) 构成 \\(P_n\\) 上的一组正交基 + \\(p_n(x)\\) 与不高于 \\(n-1\\) 次的多项式正交, \\(p_n(x)\\perp P_{n-1}\\) + 方程 \\(p_n(x)=0\\) 在 \\([a,b]\\) 上有 \\(n\\) 个单根 + 方程 \\(p_{n-1}(x)=0\\) 的根与方程 \\(p_n(x)=0\\) 在 \\([a,b]\\) 上交错分布\n常用正交多项式系\nLegendre多项式 \\(\\displaystyle L_n(x)=\\frac{1}{2^nn!}\\frac{d^n}{dx^n}(x^2-1)^n\\quad x\\in[-1,1],\\ n=0,1,\\dots\\) ，权函数 \\(\\displaystyle\\rho(x)=1\\) \\(\\displaystyle (L_m,L_n)=\\left\\{\\begin{aligned}\u0026amp;0\u0026amp;m\\neq n\\\\\u0026amp;\\frac{2}{2n+1}\u0026amp;m=n\\end{aligned}\\right.\\) 有三项递推关系 \\(\\left\\{\\begin{array}{l}\\displaystyle (n+1)L_{n+1}(x)=(2n+1)xL_n(x)-nL_{n-1}(x),\\quad n\\ge1\\\\L_0(x)=1,\\ L_1(x)=x\\end{array}\\right.\\) Chebyshev多项式 \\(T_n(x)=\\cos(n\\arccos x)\\quad x\\in[-1,1],\\ n=0,1,\\dots\\) ，权函数 \\(\\displaystyle\\rho(x)=\\frac{1}{\\sqrt{1-x^2}}\\) \\(\\displaystyle (T_m,T_n)=\\left\\{\\begin{array}{l}0\\quad\\quad m\\neq n\\\\\\pi\\quad\\quad m=n=0\\\\\\pi/2\\quad m=n\\neq0\\end{array}\\right.\\) 有三项递推关系 \\(\\left\\{\\begin{array}{l}\\displaystyle T_{n+1}(x)=2xT_n(x)-nT_{n-1}(x),\\quad n=1,2,\\dots\\\\T_0(x)=1,\\ T_1(x)=x\\end{array}\\right.\\) \\(T_n(x)\\) 在 \\([-1,1]\\) 上的 \\(n\\) 个零点为 \\(\\displaystyle x_k^{(n)}=\\cos\\frac{2k-1}{2n}\\pi,\\quad k=1,2,\\dots,n\\) Laguere多项式 \\(\\displaystyle L_n(x)=e^x\\frac{d^n}{dx^n}(x^ne^{-x}),\\quad0\u0026lt;x\u0026lt;+\\infty,\\quad n=0,1,2,\\dots\\) ，权函数 \\(\\rho(x)=e^{-x}\\) \\(\\displaystyle (L_m,L_n)=\\left\\{\\begin{aligned}\u0026amp;0\u0026amp;m\\neq n\\\\\u0026amp;(n!)^2\u0026amp;m=n\\end{aligned}\\right.\\) 有三项递推关系 \\(\\left\\{\\begin{array}{l}\\displaystyle L_{n+1}(x)=(2n+1-x)L_n(x)-n^2L_{n-1}(x),\\quad n=1,2,\\dots\\\\L_0(x)=1,\\ L_1(x)=1-x\\end{array}\\right.\\) Hermite多项式 \\(\\displaystyle H_n(x)=(-1)^ne^{x^2}\\frac{d^n}{dx^n}(e^{-x^2}),\\quad-\\infty\u0026lt;x\u0026lt;+\\infty,\\quad n=0,1,2,\\dots\\) ，权函数 \\(\\rho(x)=e^{-x^2}\\) \\(\\displaystyle (L_m,L_n)=\\left\\{\\begin{aligned}\u0026amp;0\u0026amp;m\\neq n\\\\\u0026amp;2^nn!\\pi\u0026amp;m=n\\end{aligned}\\right.\\) 有三项递推关系 \\(\\left\\{\\begin{array}{l}\\displaystyle H_{n+1}(x)=2xH_n(x)-nH_{n-1}(x),\\quad n\\ge1\\\\H_0(x)=1,\\ H_1(x)=2x\\end{array}\\right.\\) Gauss型求积公式 对一个求积公式而言，若不固定节点位置，节点数不变的情况下，代数精度如何提高。\n定理1：区间 \\([a,b]\\) 上权函数为 \\(\\rho(x)\\) 的具有 \\(n\\) 个节点的数值积分公式代数精度不超过 \\(2n-1\\) 次。\nGauss型求积公式：使求积公式具有 \\(2n-1\\) 次代数精度的节点 \\(x_1,x_2,\\dots,x_n\\) 称为Gauss点，此时的插值型求积公式称为Gauss型求积公式： \\(I\\approx\\displaystyle\\sum_{i=1}^nA_if(x_i)\\) 。\n定理2：取区间 \\([a,b]\\) 上权函数为 \\(\\rho(x)\\) 的正交多项式 \\(p_n(x)\\) 的 \\(n\\) 个零点 \\(x_1,x_2,\\dots,x_n\\) 恰为Gauss点。\n因此构造Gauss型求积公式的方法为：\n求出区间 \\([a,b]\\) 上权函数为 \\(\\rho(x)\\) 的正交多项式 \\(p_n(x)\\) ； 求出 \\(p_n(x)\\) 的 \\(n\\) 个零点； 计算积分系数 \\(A_i=\\displaystyle\\int_a^bl_i(x)\\rho(x)dx\\) 。 定理3：设 \\(f(x)\\in C^{2n}[a,b]\\) ，则Gauss公式的误差为： \\(\\displaystyle R[f]=\\int_a^bf(x)\\rho(x)dx-\\sum_{i=1}^nA_if(x_i)=\\frac{f^{(2n)}(\\eta)}{(2n)!}\\int_a^b\\rho(x)\\omega^2(x)dx,\\quad \\eta\\in(a,b)\\)\n常见Gauss型求积公式\nGauss-Legendre求积公式：区间 \\([-1,1]\\) 上权函数 \\(\\rho(x)=1\\) 的Guass型求积公式 \\(\\displaystyle\\int_{-1}^1f(x)dx\\approx\\displaystyle\\sum_{i=1}^nA_if(x_i)\\) ，其Gauss点为Legendre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为 \\(\\displaystyle R[f]=\\frac{2^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\\eta),\\quad\\eta\\in(-1,1)\\) 。\n利用积分变换 \\(\\displaystyle\\int_a^bf(x)dx=\\frac{b-a}{2}\\int_{-1}^1(\\frac{a+b}{2}+\\frac{b-a}{2}t)dt,\\quad(x=\\frac{(a+b)+(b-a)t}{2})\\)\n可用Gauss-Legendre求积公式求任意区间的数值积分，其在 \\([a,b]\\) 上权函数 \\(\\rho(x)=1\\) 的求积公式为 \\(\\displaystyle\\int_a^bf(x)dx\\approx\\frac{b-a}{2}\\sum_{i=1}^{n}A_if(\\frac{a+b}{2}+\\frac{b-a}{2}x_i)\\) 。余项为 \\(\\displaystyle R[f]=\\frac{(b-a)^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}f^{(2n)}(\\eta),\\quad\\eta\\in(a,b)\\) 。\nGauss-Laguerre求积公式：区间 \\([0,+\\infty)\\) 上权函数 \\(\\rho(x)=e^{-x}\\) 的Guass型求积公式 \\(\\displaystyle\\int_0^\\infty e^{-x}f(x)dx\\approx\\sum_{i=1}^nA_if(x_i)\\) ，其Gauss点为Laguerre多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为 \\(\\displaystyle R[f]=\\frac{(n!)^2}{(2n)!}f^{(2n)}(\\eta),\\quad\\eta\\in(0,+\\infty)\\) 。\n对 \\([0,+\\infty)\\) 上权函数 \\(\\rho(x)=1\\) 的积分，也可构造Gauss-Laguerre求积公式（再乘一个 \\(e^x\\) ）： \\(\\displaystyle\\int_0^\\infty f(x)dx\\approx\\sum_{i=1}^nA_ie^{x_i}f(x_i)\\) 。\nGauss-Hermite求积公式：区间 \\((-\\infty,+\\infty)\\) 上权函数 \\(\\rho(x)=e^{-x^2}\\) 的Guass型求积公式 \\(\\displaystyle\\int_{-\\infty}^\\infty e^{-x^2}f(x)dx\\approx\\sum_{i=1}^nA_if(x_i)\\) ，其Gauss点为Herimite多项式的零点。可通过数学用表查询对应Gauss点和求积系数。余项为 \\(\\displaystyle R[f]=\\frac{n!\\sqrt\\pi}{2^n(2n)!}f^{(2n)}(\\eta),\\quad\\eta\\in(-\\infty,+\\infty)\\) 。\n同理，对 \\((-\\infty,+\\infty)\\) 上权函数 \\(\\rho(x)=1\\) 的积分，也可构造Gauss-Hermite求积公式（再乘一个 \\(e^{x^2}\\) ）： \\(\\displaystyle\\int_{-\\infty}^\\infty f(x)dx\\approx\\sum_{i=1}^nA_ie^{x_i^2}f(x_i)\\) 。\n6.12 - 6.13 数值微分 数值微分是指用函数值的线性组合近似函数在某点的导数值。\n差商型数值微分 向前差商数值微分公式： \\(\\displaystyle f\u0026#39;(x_0)\\approx\\frac{f(x_0+h)-f(x_0)}{h}\\)\nTaylor展开得 \\(\\displaystyle f(x_0+h)=f(x_0)+f\u0026#39;(x_0)h+\\frac{h^2}{2}f\u0026#39;\u0026#39;(x_0+\\theta h)\\quad0\\le\\theta\\le1\\)\n可得误差 \\(\\displaystyle f\u0026#39;(x_0)-\\frac{f(x_0+h)-f(x_0)}{h}=-\\frac{h}{2}f\u0026#39;\u0026#39;(x_0+\\theta h)\\quad0\\le\\theta\\le1\\)\n向后差商数值微分公式： \\(\\displaystyle f\u0026#39;(x_0)\\approx\\frac{f(x_0)-f(x_0-h)}{h}\\)\nTaylor展开得 \\(\\displaystyle f(x_0-h)=f(x_0)-f\u0026#39;(x_0)h+\\frac{h^2}{2}f\u0026#39;\u0026#39;(x_0-\\theta h)\\quad0\\le\\theta\\le1\\)\n可得误差 \\(\\displaystyle f\u0026#39;(x_0)-\\frac{f(x_0)-f(x_0-h)}{h}=\\frac{h}{2}f\u0026#39;\u0026#39;(x_0-\\theta h)\\quad0\\le\\theta\\le1\\)\n中心差商数值微分公式： \\(\\displaystyle f\u0026#39;(x_0)\\approx\\frac{f(x_0+h)-f(x_0-h)}{2h}\\)\n可得误差 \\(\\begin{aligned}\\displaystyle f\u0026#39;(x_0)-\\frac{f(x_0+h)-f(x_0-h)}{2h}\u0026amp;=-\\frac{h^2}{12}[f\u0026#39;\u0026#39;\u0026#39;(x_0+\\theta_1 h)+f\u0026#39;\u0026#39;\u0026#39;(x_0-\\theta_2 h)]\\\\\u0026amp;=-\\frac{h^2}{6}f\u0026#39;\u0026#39;\u0026#39;(x_0+\\theta h)\\quad\\quad-1\\le\\theta\\le1\\end{aligned}\\)\n二阶中心差商数值微分公式： \\(\\displaystyle f\u0026#39;\u0026#39;(x_0)\\approx\\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}\\)\nTaylor展开得 \\(\\begin{array}{l}\\displaystyle f(x_0+h)=f(x_0)+hf\u0026#39;(x_0)+\\frac{h^2}{2}f\u0026#39;\u0026#39;(x_0)+\\frac{h^3}{6}f\u0026#39;\u0026#39;\u0026#39;(x_0)+\\frac{h^4}{24}f^{(4)}(x_0+\\theta_1 h)\\\\\\displaystyle f(x_0-h)=f(x_0)-hf\u0026#39;(x_0)+\\frac{h^2}{2}f\u0026#39;\u0026#39;(x_0)-\\frac{h^3}{6}f\u0026#39;\u0026#39;\u0026#39;(x_0)+\\frac{h^4}{24}f^{(4)}(x_0-\\theta_2 h)\\end{array}\\)\n两式相加可得误差 \\(\\displaystyle f\u0026#39;(x_0)-\\frac{f(x_0+h)-2f(x_0)+f(x_0-h)}{h^2}=-\\frac{h^2}{12}f^{(4)}(x_0+\\theta h)\\quad\\theta\\in(-1,1)\\)\n从截断误差的角度看，步长 \\(h\\) 越小，计算越精确；但是 \\(h\\) 过小时，计算过程中有相近的数相减，会严重损失数值精度。实际应用中，可采用步长逐次减半的方法确定最终补偿。记 \\(G(h),\\ G(h/2)\\) 分别为对应步长取值时的差商公式，对给定精度 \\(\\varepsilon\u0026gt;0\\) ，若 \\(|G(h)-G(h/2)|\u0026lt;\\varepsilon\\) 就取步长为 \\(h/2\\) ，反之取 \\(h\\) 。\n插值型数值微分 建立插值多项式 \\(L_n(x)\\) ，取 \\(L_n\u0026#39;(x)\\) 作为 \\(f\u0026#39;(x)\\) 的近似。误差余项 \\(\\displaystyle f\u0026#39;(x_k)-L_n\u0026#39;(x_k)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\omega_{n+1}(x_k)\\) （ \\(x\\neq x_k\\) 时难以分析）\n仅考察节点处的导数值，假定所给节点等距。\n两点公式：线性插值函数 \\(\\displaystyle L_1(x)=\\frac{x-x_1}{x_0-x_1}f(x_0)+\\frac{x-x_0}{x_1-x_0}f(x_1)\\) ，对公式两端求导，记 \\(x_1-x_0=h\\) ，有：\n\\(\\displaystyle L_1\u0026#39;(x)=\\frac{1}{h}[f(x_1)-f(x_0)]\\) ，\n得到两个两点公式： \\(\\displaystyle L_1\u0026#39;(x_0)=L_1\u0026#39;(x_1)=\\frac{1}{h}[f(x_1)-f(x_0)]\\)\n三点公式：二次插值函数 \\(L_2(x)\\) ，对其求导，记 \\(x=x_0+th\\) ，有：\n\\(\\displaystyle L_2\u0026#39;(x)=\\frac{1}{2h}[(2t-3)f(x_0)-(4t-4)f(x_1)+(2t-1)f(x_2)]\\)\n得到三个三点公式： \\(\\begin{array}{l}\\displaystyle L_2\u0026#39;(x_0)=\\frac{1}{2h}[-3f(x_0)+4f(x_1)-f(x_2)]\\\\L_2\u0026#39;(x_1)=\\frac{1}{2h}[-f(x_0)+f(x_2)]\\\\L_2\u0026#39;(x_2)=\\frac{1}{2h}[f(x_0)-4f(x_1)+3f(x_2)]\\end{array}\\)\n再次求导，可以得到更高阶的数值微分公式 \\(\\displaystyle L_2\u0026#39;\u0026#39;(x)=\\frac{1}{h^2}[f(x_0)-2f(x_1)+f(x_2)]\\)\n","permalink":"https://elderlyaugustus.github.io/posts/2021-03-09-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day12-%E7%BB%AD%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86-%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/","summary":"续：6.1 - 6.11 数值积分 复化求积公式 Newton-Cotes求积公式的精度随着求积节点数的增加而增加，但求积节点数 \\(\\ge8\\) 时，Newton-Cotes公式数值不稳定。实际应用中，将积分区间分成若干个小区间分别求积分再求和，即复化求积公式的基本思想。\n在区间 \\([a,b]\\) 上，取等距节点 \\(x_k=a+kh,\\ k=0,1,\\dots,n\\) ，\n由定积分的区间可加性得 \\(\\displaystyle\\int_a^bf(x)dx=\\sum_{k=1}^n\\int_{x_{k-1}}^{x_k}f(x)dx\\) 。\n若在每个小区间 \\(x_{k-1},x_k\\) 用梯形公式，则有复化梯形公式 \\(T_n\\) ：\n\\[ \\displaystyle I=\\int_a^bf(x)dx\\approx T_n=\\frac{h}{2}\\sum_{k=1}^n\\left[f(x_{k-1})+f(x_k)\\right]=\\frac{h}{2}\\left[2\\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\\right] \\]\n复化梯形公式的的误差为：\n\\[ \\begin{array}{l}\\displaystyle I-T_n=-\\frac{h^3}{12}[f\u0026#39;\u0026#39;(\\xi_1)+\\dots+f\u0026#39;\u0026#39;(\\xi_n)]=-\\frac{h^2(b-a)}{12}f\u0026#39;\u0026#39;(\\eta),\\quad\\eta\\in(a,b)\\\\\\displaystyle \\left|I-T_n\\right|\\le\\frac{(b-a)^3}{12n^2}\\max_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|\\end{array} \\]\n可知复化梯形公式收敛，且要使得误差 \\(\\le\\varepsilon\\) ，只要 \\(\\left|I-T_n\\right|\\le\\varepsilon\\) 或 \\(\\displaystyle n\u0026gt;\\sqrt{\\frac{(b-a)^3\\max_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|}{12\\varepsilon}}\\) 。 同理，复化Simpson公式 \\(S_n\\) ：\n\\[ \\displaystyle I=\\int_a^bf(x)dx\\approx S_n=\\frac{h}{6}\\left[4\\sum_{k=1}^nf(x_{k-\\frac{1}{2}})+2\\sum_{k=1}^{n-1}f(x_k)+f(a)+f(b)\\right] \\]\n复化Simpson公式的误差为：\n\\[ \\begin{array}{l}\\displaystyle I-S_n=-\\frac{h^4(b-a)}{2880}f^{4}(\\eta),\\quad\\eta\\in(a,b)\\\\\\displaystyle \\left|I-S_n\\right|\\le\\frac{(b-a)^5}{2880n^4}\\max_{a\\le x\\le b}|f^{(4)}(x)|\\end{array} \\]\n可知收敛，且要使得误差 \\(\\le\\varepsilon\\) ，只要 \\(\\left|I-S_n\\right|\\le\\varepsilon\\) 或 \\(\\displaystyle n\u0026gt;\\sqrt[4]{\\frac{(b-a)^5\\max_{a\\le x\\le b}|f^{(4)}(x)|}{2880\\varepsilon}}\\) 。 同理，复化Cotes公式 \\(C_n\\) ：","title":"2021-03-09-数值分析-Day12-续数值积分-数值微分"},{"content":"6.1 - 6.11 数值积分 牛顿-莱布尼茨公式： \\(\\displaystyle\\int_a^bf(x)dx=F(b)-F(a)\\)\n问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。\n【例】弧长积分： \\(L=\\displaystyle\\int_a^b\\sqrt{1+(f\u0026#39;(x))^2}dx\\)\n由定积分的定义 \\(\\displaystyle I=\\int_a^bf(x)dx=F(b)-F(a)=\\lim_{\\Delta x\\to0}\\sum_{i=0}^nf(x_i)\\Delta x_i\\) ，可以想到利用被积函数在区间 \\([a,b]\\) 上一些离散节点 \\(x_k\\) 处的函数值 \\(f(x_k)\\) 的线性组合来得到近似积分值： \\(\\displaystyle I=\\sum_{k=0}^nA_kf(x_k)\\) 。则得求积公式的一般形式： \\(\\displaystyle\\int_a^bf(x)dx\\approx\\sum_{k=0}^nA_kf(x_k)\\) ，其中 \\(\\{x_k\\}\\) 为求积点， \\(A_k\\) 为求积系数。或表示为 \\(\\displaystyle\\int_a^bf(x)dx=\\sum_{k=0}^nA_kf(x_k)+R[f]\\) ，其中 \\(R[f]\\) 为求积公式的误差或余项。\n积分中值定理：在 \\([a,b]\\) 内存在一点 \\(\\xi\\) ，有 \\(\\displaystyle\\int_a^bf(x)dx=(b-a)f(\\xi)\\) 。\n问题： \\(\\xi\\) 未知\n取特殊点为 \\(\\xi\\) 求近似解：\n左矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(a)(b-a),\\quad R[f]=\\frac{(b-a)^2}{2}f\u0026#39;(\\xi)\\ (\\xi\\in(a,b))\\)\n右矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(b)(b-a),\\quad R[f]=-\\frac{(b-a)^2}{2}f\u0026#39;(\\eta)\\ (\\eta\\in(a,b))\\)\n中矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(\\frac{a+b}{2})(b-a),\\quad R[f]=-\\frac{(b-a)^3}{24}f\u0026#39;\u0026#39;(\\eta)\\ (\\eta\\in(a,b))\\)\n代数精度 若求积公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx\\sum_{k=0}^nA_kf(x_k)\\) 对 \\(f(x)=x^j\\ (j=0,1,\\dots,m)\\) 都精确成立，但对 \\(f(x)=x^{m+1}\\) 不精确成立。即： \\(\\left\\{\\begin{array}{l}\\displaystyle\\int_a^bx^jdx=\\sum_{k=0}^nA_kx_k^j\\quad j=0,1,\\dots,m\\\\\\displaystyle\\int_a^bx^{m+1}dx\\approx\\sum_{k=0}^nA_kx_k^{m+1}\\end{array}\\right.\\) ，则称此公式具有 \\(\\mathbf m\\) 次代数精度。\n可见，具有 \\(m\\) 次代数精度的求积公式对最高次 \\(\\le m\\) 的多项式函数均是精确成立的。由由于，所有函数均可由多项式函数逼近，因此代数精度越高，求积公式的精度就越高。\n利用代数精度求求积公式：若求积公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx\\sum_{k=0}^nA_kf(x_k)\\) 具有 \\(n\\) 次代数精度，则： \\[ \\begin{array}{c}\\left\\{\\begin{array}{l}A_0+A_1+\\dots+A_n=b-a\\\\ \\displaystyle x_0A_0+x_1A_1+\\dots+x_nA_n=\\frac{b^2-a^2}{2}\\\\ \\dots\\\\\\displaystyle x_0^n+x_1^n+\\dots+x_n^nA_n=\\frac{b^{n+1}-a^{n+1}}{n+1} \\end{array}\\right.\\\\ 即\\begin{pmatrix} 1 \u0026amp;1 \u0026amp;\\cdots \u0026amp;1 \\\\ x_0 \u0026amp;x_1 \u0026amp;\\cdots \u0026amp;x_n \\\\ \\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots \\\\ x_0^n \u0026amp;x_1^n \u0026amp;\\cdots \u0026amp;x_n^n \\end{pmatrix} \\begin{pmatrix} A_0 \\\\ A_1 \\\\ \\vdots \\\\ A_n \\end{pmatrix}= \\begin{pmatrix} b-a \\\\ (b^2-a^2)/2 \\\\ \\vdots \\\\ (b^{n+1}-a^{n+1})/(n+1) \\end{pmatrix}\\\\ D=\\begin{vmatrix} 1 \u0026amp;1 \u0026amp;\\cdots \u0026amp;1 \\\\ x_0 \u0026amp;x_1 \u0026amp;\\cdots \u0026amp;x_n \\\\ \\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots \\\\ x_0^n \u0026amp;x_1^n \u0026amp;\\cdots \u0026amp;x_n^n \\end{vmatrix}=\\displaystyle\\prod_{0\\le i\u0026lt;j\\le n}(x_j-x_i)\\neq0 \\end{array} \\] 因此该方程组有唯一解。\n插值型数值求积公式 定义：已知定积分 \\(I=\\displaystyle \\int_a^bf(x)dx\\) 的被积函数 \\(f(x)\\) 在节点 \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b\\) 上的函数值 \\(y_k=f(x_k),\\ k=0,1,\\dots,n\\) 。则可构造 \\(n\\) 次Lagrange插值多项式 \\(L_n(x)=\\displaystyle\\sum_{k=0}^nf(x_k)l_k(x)\\) ，其中 \\(l_k(x)\\) 为Lagrange插值的基函数。因此\n\\(\\displaystyle I_n=\\int_a^bf(x)dx\\approx\\int_a^bL_n(x)dx=\\int_a^b\\left[\\sum_{k=0}^nf(x_k)l_k(x)\\right]dx=\\sum_{k=0}^n\\left[\\int_a^bl_k(x)dx\\right]f(x_k)\\) 。\n记 \\(A_k=\\displaystyle\\int_a^bl_k(x)dx\\) ，称之为求积系数，则有 \\(\\int_a^bL_n(x)dx=\\sum_{k=0}^nA_kf(x_k)\\) ，称之为插值型求积公式。\n误差：若 \\(f(x)\\) 在 \\([a,b]\\) 有 \\(n+1\\) 阶连续导数，则Lagrange插值余项为：\n\\(\\displaystyle f(x)-L_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\omega_{n+1}(x),\\ \\xi_x\\in(a,b)\\)\n从而得到插值型求积公式的误差如下 \\(\\displaystyle R[f]=\\int_a^b[f(x)-L_n(x)]dx=\\frac{1}{(n+1)!}\\int_a^bf^{n+1}(\\xi_x)\\omega_{n+1}(x)dx,\\ \\xi_x\\in(a,b)\\)\n加入权函数项非负连续函数 \\(\\rho(x)\\) （物理意义为密度函数），则求积系数 \\(\\displaystyle A_k=\\int_a^b\\rho(x)l_k(x)dx\\) ，误差表达式 \\(\\displaystyle R[f]=\\frac{1}{(n+1)!}\\int_a^b\\rho(x)f^{n+1}(\\xi_x)\\omega_{n+1}(x)dx,\\ \\xi_x\\in(a,b)\\) 。\nNewton-Cotes公式 定义：为简化计算，取等距节点 \\(x_k=a+kh\\ (k=0,1,\\dots,n,\\ h=(b-a)/n)\\) ，则： \\[ \\begin{array}{c} \\displaystyle A_k=\\int_a^bl_k(x)dx=\\int_a^b\\left[\\prod_{i=0,i\\neq k}^n\\right]dx\\xlongequal{令x=a+th}\\frac{(-1)^{n-k}h}{k!(n-k)!}\\int_0^n\\left[\\prod_{i=0,i\\neq k}^n(t-i)\\right]dt\\\\ 令\\ C_k^{(n)}=\\displaystyle\\frac{1}{b-a}A_k=\\frac{(-1)^{n-k}}{nk!(n-k)!}\\int_0^n\\left[\\prod_{i=0,i\\neq k}^n(t-i)\\right]dt,\\quad k=0,1,\\dots,n\\\\ 则有\\ \\displaystyle\\int_a^bf(x)dx\\approx(b-a)\\sum_{k=0}^nC_k^{(n)}f(x_k) \\end{array} \\] 称最后一行式为Newton-Cotes公式， \\(C_k^{(n)}\\) 为Cotes系数。\n设 \\(f(x)\\in C^2[a,b]\\) ，则 \\(n=1\\) 时，Newton-Cotes公式为：\n\\(\\displaystyle\\int_a^bf(x)dx\\approx\\frac{b-a}{2}[f(a)+f(b)]\\) ，\n误差为 \\(R[f]=\\displaystyle-\\frac{(b-a)^3}{12}f\u0026#39;\u0026#39;(\\eta)\\le\\frac{\\max\\limits_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|}{12}(b-a)^3,\\ \\eta\\in(a,b)\\) 。\n由于图像为梯形，称为梯形公式，记为 \\(\\mathbf T\\) 。 设 \\(f(x)\\in C^4[a,b]\\) ，则 \\(n=2\\) 时，Newton-Cotes公式为：\n\\(\\displaystyle\\int_a^bf(x)dx\\approx\\frac{b-a}{6}\\left[f(a)+4f\\left(\\frac{a+b}{2}\\right)+f(b)\\right]\\) ，\n误差为 \\(R[f]=\\displaystyle-\\frac{(b-a)^5}{2880}f^{(4)}(\\eta)\\le\\frac{\\max\\limits_{a\\le x\\le b}|f^{(4)}(x)|}{2880}(b-a)^5,\\ \\eta\\in(a,b)\\) 。\n由于图像为抛物线，称为抛物线公式或Simpson公式，记为 \\(\\mathbf S\\) 。其代数精度为 \\(3\\) 。 依次，Cotes系数可查【Cotes系数表】。当Cotes系数出现相反数时，公式数值不稳定，因此高次Newton-Cotes公式没有实用价值。 Newton-Cotes公式的截断误差为： \\(\\begin{array}{r}R[f]=\\left\\{\\begin{array}{l}\\displaystyle\\frac{f^{(n+1)}(\\eta)}{(n+1)!}\\int_a^b\\omega_{n+1}(x)dx\\quad n为奇数\\\\\\displaystyle\\frac{f^{(n+2)}(\\eta)}{(n+2)!}\\int_a^b\\omega_{n+1}(x)dx\\quad n为偶数\\end{array}\\right.\\\\\\eta\\in(a,b)\\end{array}\\) 。\n\\(n+1\\) 个节点的插值型求积公式至少具有 \\(n\\) 次代数精度， \\(n\\) 是偶数时Newton-Cotes公式具有 \\(n+1\\) 次代数精度。\n","permalink":"https://elderlyaugustus.github.io/posts/2021-03-08-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day11-%E6%8F%92%E5%80%BC%E5%9E%8B%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/","summary":"6.1 - 6.11 数值积分 牛顿-莱布尼茨公式： \\(\\displaystyle\\int_a^bf(x)dx=F(b)-F(a)\\)\n问题：很多函数找不到原函数；很多函数只知道离散的点值而无表达式。\n【例】弧长积分： \\(L=\\displaystyle\\int_a^b\\sqrt{1+(f\u0026#39;(x))^2}dx\\)\n由定积分的定义 \\(\\displaystyle I=\\int_a^bf(x)dx=F(b)-F(a)=\\lim_{\\Delta x\\to0}\\sum_{i=0}^nf(x_i)\\Delta x_i\\) ，可以想到利用被积函数在区间 \\([a,b]\\) 上一些离散节点 \\(x_k\\) 处的函数值 \\(f(x_k)\\) 的线性组合来得到近似积分值： \\(\\displaystyle I=\\sum_{k=0}^nA_kf(x_k)\\) 。则得求积公式的一般形式： \\(\\displaystyle\\int_a^bf(x)dx\\approx\\sum_{k=0}^nA_kf(x_k)\\) ，其中 \\(\\{x_k\\}\\) 为求积点， \\(A_k\\) 为求积系数。或表示为 \\(\\displaystyle\\int_a^bf(x)dx=\\sum_{k=0}^nA_kf(x_k)+R[f]\\) ，其中 \\(R[f]\\) 为求积公式的误差或余项。\n积分中值定理：在 \\([a,b]\\) 内存在一点 \\(\\xi\\) ，有 \\(\\displaystyle\\int_a^bf(x)dx=(b-a)f(\\xi)\\) 。\n问题： \\(\\xi\\) 未知\n取特殊点为 \\(\\xi\\) 求近似解：\n左矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(a)(b-a),\\quad R[f]=\\frac{(b-a)^2}{2}f\u0026#39;(\\xi)\\ (\\xi\\in(a,b))\\)\n右矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(b)(b-a),\\quad R[f]=-\\frac{(b-a)^2}{2}f\u0026#39;(\\eta)\\ (\\eta\\in(a,b))\\)\n中矩形求积公式： \\(\\displaystyle\\int_a^bf(x)dx\\approx f(\\frac{a+b}{2})(b-a),\\quad R[f]=-\\frac{(b-a)^3}{24}f\u0026#39;\u0026#39;(\\eta)\\ (\\eta\\in(a,b))\\)\n代数精度 若求积公式 \\(\\displaystyle\\int_a^bf(x)dx\\approx\\sum_{k=0}^nA_kf(x_k)\\) 对 \\(f(x)=x^j\\ (j=0,1,\\dots,m)\\) 都精确成立，但对 \\(f(x)=x^{m+1}\\) 不精确成立。即： \\(\\left\\{\\begin{array}{l}\\displaystyle\\int_a^bx^jdx=\\sum_{k=0}^nA_kx_k^j\\quad j=0,1,\\dots,m\\\\\\displaystyle\\int_a^bx^{m+1}dx\\approx\\sum_{k=0}^nA_kx_k^{m+1}\\end{array}\\right.","title":"2021-03-08-数值分析-Day11-插值型数值积分"},{"content":"续：5.8 - 5.10 三次样条插值 三转角方法 考虑第一种一般边界条件： \\(S\u0026#39;(x_0)=f_0\u0026#39;,\\ S\u0026#39;(x_n)=f_n\u0026#39;\\) ，即已知两端点一阶导数值。\n令 \\(m_i=S\u0026#39;(x_i),\\ i=0,1,\\dots,n\\) ，利用三次Hermite插值，得到 \\(S(x)=\\displaystyle \\sum_{j=0}^n[y_j\\alpha_j(x)+m_j\\beta_j(x)]\\) ，其中 \\(\\alpha_j(x),\\ \\beta_j(x)\\) 为分段三次Hermite插值的基函数。再由边界条件得 \\(S\u0026#39;(x_0)=f_0\u0026#39;,\\ S\u0026#39;(x_n)=f_n\u0026#39;\\) 即可解出 \\(m_i\\) 在各插值点的取值。记\n\\(\\displaystyle \\lambda_i=\\frac{h_{i+1}}{h_i+h_{i+1}},\\ \\mu_i=1-\\lambda_i=\\frac{h_i}{h_i+h_{i+1}},\\ g_i=3(\\lambda_if[x_{i-1},x_i]+\\mu_if[x_i,x_{i+1}])\\) ，\n最终解得： \\[ \\begin{array}{c}\\lambda_im_{i-1}+2m_i+\\mu_im_{i+1}=g_i\\\\ \\begin{pmatrix} 2 \u0026amp;\\mu_1 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\ \\lambda_2 \u0026amp;2 \u0026amp;\\mu_2 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;\\lambda_{n-2} \u0026amp;2 \u0026amp;\\mu_{n-2} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;\\lambda_{n-1} \u0026amp;2 \\end{pmatrix} \\begin{pmatrix} m_1 \\\\ m_2 \\\\ \\vdots \\\\ \\vdots \\\\ m_{n-2} \\\\ m_{n-1} \\end{pmatrix}= \\begin{pmatrix} g_1-\\lambda_iy_0\u0026#39; \\\\ g_2 \\\\ \\vdots \\\\ \\vdots \\\\ g_{n-2} \\\\ g_{n-1}-\\mu_{n-1}y_n\u0026#39; \\end{pmatrix} \\end{array} \\] 利用大型稀疏矩阵线性方程数值解法，解出 \\(m_i\\) ，即解得 \\(x\\in[x_{i-1},x_i]\\) 时，有：\n\\(\\begin{aligned}\\displaystyle S(x)\u0026amp;=\\frac{ (2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i }{h_i^3}\\\\ \u0026amp;+\\frac{ (x-x_{i-1})(x-x_i)[(x-x_i)m_{i-1}+(x-x_{i-1})m_i] }{h_i^2} \\end{aligned}\\)\n其他边界条件也可用类似方法解得，计算方法较复杂。\n三弯矩方法 二阶导数 \\(S\u0026#39;\u0026#39;(x)=M_j\\ (j=0,1,\\dots,n)\\) 在力学上解释为细梁在 \\(x_j\\) 截面处的弯矩。\n令 \\(M_i=S\u0026#39;\u0026#39;(x_i),\\ i=0,1,\\dots,n\\) ，则对 \\(x\\in[x_{i-1},x_i]\\) ，有：\n\\(\\displaystyle S\u0026#39;\u0026#39;(x)=\\frac{x-x_i}{x_{i-1}-x_i}M_{i-1}+\\frac{x-x_{i-1}}{x_i-x_{i-1}}M_i\\) ，对此连续积分两次，记 \\(S(x_i)=y_i\\) ，得：\n\\(\\begin{aligned}\\displaystyle S(x)\u0026amp;=\\frac{1}{6h_i}\\left[(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i\\right]\\\\\u0026amp;+\\left(\\frac{y_{i-1}}{h_i}-\\frac{h_iM_{i-1}}{6}\\right)(x_i-x)+\\left(\\frac{y_i}{h_i}-\\frac{h_iM_i}{6}\\right)(x-x_{i-1})\\\\\u0026amp;=\\frac{(x_i-x)^3M_{i-1}+(x-x_{i-1})^3M_i+(6y_{i-1}-h_i^2M_{i-1})(x_i-x)+(6y_i-h_i^2M_i)(x-x_{i-1})}{6h_i}\\end{aligned}\\)\n利用 \\(S\u0026#39;(x_i-0)=S\u0026#39;(x_i+0)\\) 求出 \\(M_i\\) ，记\n\\(\\displaystyle \\lambda_i=\\frac{h_{i+1}}{h_i+h_{i+1}}=,\\ \\mu_i=\\frac{h_i}{h_i+h_{i+1}},\\ d_i=6f[x_{i-1},x_i,x_{i+1}]\\) ，\n则有： \\(\\mu_iM_{i-1}+2M_i+\\lambda_iM_{i+1}=d_i\\)\n结合边界条件 \\(M_0=S\u0026#39;\u0026#39;(x_0)=y\u0026#39;\u0026#39;_0,\\ M_n=S\u0026#39;\u0026#39;(x_n)=y\u0026#39;\u0026#39;_n\\) ，可得： \\[ \\begin{array}{c}\\mu_iM_{i-1}+2M_i+\\lambda_iM_{i+1}=d_i\\\\ \\begin{pmatrix} 2 \u0026amp;\\mu_1 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\ \\mu_2 \u0026amp;2 \u0026amp;\\lambda_2 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;\\mu_{n-2} \u0026amp;2 \u0026amp;\\lambda_{n-2} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;\\mu_{n-1} \u0026amp;2 \\end{pmatrix} \\begin{pmatrix} M_1 \\\\ M_2 \\\\ \\vdots \\\\ \\vdots \\\\ M_{n-2} \\\\ M_{n-1} \\end{pmatrix}= \\begin{pmatrix} d_1-\\mu_iy_0\u0026#39; \\\\ d_2 \\\\ \\vdots \\\\ \\vdots \\\\ d_{n-2} \\\\ d_{n-1}-\\lambda_{n-1}y_n\u0026#39;\u0026#39; \\end{pmatrix} \\end{array} \\] 或结合边界条件 \\(S\u0026#39;(x_0)=y_0\u0026#39;,\\ S\u0026#39;(x_n)=y_n\u0026#39;\\) ，得： \\[ \\begin{array}{c}\\mu_iM_{i-1}+2M_i+\\lambda_iM_{i+1}=d_i\\\\2M_0+M_1=d+0\\\\M_{n-1}+2M_n=d_n\\\\ \\begin{pmatrix} 2 \u0026amp;_1 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\ \\mu_1 \u0026amp;2 \u0026amp;\\lambda_1 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;\\mu_{n-1} \u0026amp;2 \u0026amp;\\lambda_{n-1} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \u0026amp;2 \\end{pmatrix} \\begin{pmatrix} M_1 \\\\ M_2 \\\\ \\vdots \\\\ \\vdots \\\\ M_{n-2} \\\\ M_{n-1} \\end{pmatrix}= \\begin{pmatrix} d_0 \\\\ d_1 \\\\ \\vdots \\\\ \\vdots \\\\ d_{n-1} \\\\ d_n \\end{pmatrix} \\end{array} \\] 或结合周期边界条件 \\(S\u0026#39;(x_0)=S\u0026#39;(x_n),\\ S\u0026#39;\u0026#39;(x_0)=S\u0026#39;\u0026#39;(x_n)\\) ，同样得到稀疏矩阵线性方程。 采用稀疏矩阵线性方程解法即可。\n综上，当边界条件为第一类（已知一阶导数值）时，适合采用三转角方法；当边界条件为第二类（已知二阶导数值）时适合采用三弯矩方法；对周期边界条件，两种方法计算量一致。\n最小二乘法 数据拟合问题 经由观察或测试得到 \\(y(x)\\) 的一组离散数据，在给定的函数类 \\(\\Phi\\) 上根据这组离散数据做出逼近曲线，要求逼近曲线在 \\(x_i\\) 处与离散数据尽可能接近。\n对函数 \\(\\varphi(x)\\in\\Phi\\) ，要求以 \\(\\varphi(x)\\) 在离散点的误差 \\(\\delta_i=\\phi(x_i)-y_i,\\ i=0,1,\\dots,m\\) 为分量的误差向量 \\(\\delta=(\\delta_0,\\delta_1,\\dots,\\delta_m)^T\\) ，使某一向量范数 \\(\\|\\delta\\|\\) 达到最小。对不同的范数，可以构造出不同意义下的拟合函数。\n函数类 \\(\\Phi\\) 通常取为 \\(\\Phi=Span\\{\\varphi_0(x),\\varphi_1(x),\\dots,\\varphi_n(x)\\}\\) ，其中函数系 \\(\\varphi_0(x),\\varphi_1(x),\\dots,\\varphi_n(x)\\) 在包含节点 \\(\\{x_i\\}\\) 的区间 \\([a,b]\\) 上线性无关， \\(\\Phi\\) 中任一函数 \\(\\varphi(x)\\) 可表示为： \\(\\varphi(x)=a_0\\varphi_0(x)+a_1\\varphi_1(x)+\\dots+a_n\\varphi_n(x)\\) 。\n常用函数系包括幂函数系 \\(\\{x^j\\}\\) ，三角函数系 \\(\\{\\sin jx\\}\\ \\{\\cos jx\\}\\) ，指数函数系 \\(\\{e^{\\lambda_jx}\\}\\) ，正交函数系等。\n在求误差向量 \\(\\delta\\) 的范数时，常用 \\(2\\) -范数，对应的曲线拟合方法就称为最小二乘法。\n推导：在函数类 \\(\\Phi\\) 中找到函数 \\(y=\\varphi^*(x)\\) ，使误差向量 \\(\\delta\\) 的 \\(2\\) -范数达到最小值。（通常取误差向量的加权形式 \\(\\rho(x)\\varphi(x)\\) 求 \\(2\\) -范数的平方 \\(\\|\\delta\\|_2^2\\) ）。该范数为关于 \\((a_0,a_1,\\dots,a_n)\\) 的函数，记其为 \\(G(a_0,a_1,\\dots,a_n)\\) ，则问题转换为求该函数最小值问题。\n记 \\(\\left\\{\\begin{array}{l}\\varphi_j=(\\varphi_j(x_0),\\varphi_j(x_1),\\dots,\\varphi_j(x_m))^T,\\ j=0,1,2,\\dots,n\\\\f=(y_0,y_1,\\dots,y_m)^T\\\\(\\varphi_j,\\varphi_k)=\\displaystyle\\sum_{i=0}^m\\rho(x_i)\\varphi_j(x_i)\\varphi_k(x_i)\\\\(f,\\varphi_k)=\\displaystyle\\sum_{i=0}^m\\rho(x_i)y_i\\varphi_k(x_i)\\end{array}\\\\\\right.\\)\n得到关于系数向量 \\((a_0,a_1,\\dots,a_n)^T\\) 的线性方程组： \\[ \\begin{array}{c}\\displaystyle\\sum_{j=0}^n(\\varphi_j,\\varphi_k)a_j=(f,\\varphi_k)\\quad k=0,1,\\dots,n\\\\ \\begin{pmatrix} (\\varphi_0,\\varphi_0) \u0026amp;(\\varphi_0,\\varphi_1) \u0026amp;\\cdots \u0026amp;(\\varphi_j,\\varphi_k) \\\\ (\\varphi_1,\\varphi_0) \u0026amp;(\\varphi_1,\\varphi_1) \u0026amp;\\cdots \u0026amp;(\\varphi_1,\\varphi_n) \\\\ \\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots \\\\ (\\varphi_n,\\varphi_0) \u0026amp;(\\varphi_n,\\varphi_1) \u0026amp;\\cdots \u0026amp;(\\varphi_n,\\varphi_n) \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{pmatrix} =\\begin{pmatrix} (f,\\varphi_0) \\\\ (f,\\varphi_1) \\\\ \\vdots \\\\ (f,\\varphi_n) \\end{pmatrix}\\end{array} \\] 称之为正则方程组或法方程组。\n正则方程组的系数矩阵为对称矩阵。若向量组 \\(\\varphi_0,\\varphi_1,\\dots,\\varphi_n\\) 线性无关，则其为对称正定矩阵，可以通过迭代法求得唯一解 \\(a_j^*\\) ，从而得到拟合函数 \\(\\varphi^*(x)\\) 。\n取函数类 取函数类为幂函数系，则正则方程组为：\n\\[ \\begin{pmatrix} \\sum\\rho_i \u0026amp;\\sum\\rho_i x_i \u0026amp;\\cdots \u0026amp;\\sum\\rho_i x_i^n \\\\ \\sum\\rho_i x_i \u0026amp;\\sum\\rho_i x_i^2 \u0026amp;\\cdots \u0026amp;\\sum\\rho_i x_i^{n+1} \\\\ \\vdots \u0026amp;\\vdots \u0026amp;\\ddots \u0026amp;\\vdots \\\\ \\sum\\rho_i x_i^n \u0026amp;\\sum\\rho_i x_i^{n+1} \u0026amp;\\cdots \u0026amp;\\sum\\rho_i x_i^{2n} \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{pmatrix} =\\begin{pmatrix} \\sum\\rho_iy_i \\\\ \\sum\\rho_ix_iy_i \\\\ \\vdots \\\\ \\sum\\rho_ix_i^ny_i \\end{pmatrix} \\] 其中 \\(\\rho_i=\\rho(x_i),\\ \\sum=\\sum\\limits_{i=0}^m\\) 。此时拟合曲线 \\(\\varphi^*(x)=p_n^*(x)=a_0^*+a_1^*x+\\dots+a_n^*x^n\\) ，称之为多项式拟合曲线。\n取函数类为正交函数系，则 \\((\\varphi_i,\\varphi_j)=0,\\ (i\\neq j)\\) ，正则方程组的系数矩阵为对角矩阵， \\(a_k^*=(f,\\varphi_k)/(\\varphi_k,\\varphi_k),\\ k=0,1,\\dots,n\\) 。\n代码：本节计算主要过程为解线性方程组，列出对应元计算式，调用对应函数即可。线性方程组解法在之前章节已给出，不再重复。 ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-07-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day10-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/","summary":"续：5.8 - 5.10 三次样条插值 三转角方法 考虑第一种一般边界条件： \\(S\u0026#39;(x_0)=f_0\u0026#39;,\\ S\u0026#39;(x_n)=f_n\u0026#39;\\) ，即已知两端点一阶导数值。\n令 \\(m_i=S\u0026#39;(x_i),\\ i=0,1,\\dots,n\\) ，利用三次Hermite插值，得到 \\(S(x)=\\displaystyle \\sum_{j=0}^n[y_j\\alpha_j(x)+m_j\\beta_j(x)]\\) ，其中 \\(\\alpha_j(x),\\ \\beta_j(x)\\) 为分段三次Hermite插值的基函数。再由边界条件得 \\(S\u0026#39;(x_0)=f_0\u0026#39;,\\ S\u0026#39;(x_n)=f_n\u0026#39;\\) 即可解出 \\(m_i\\) 在各插值点的取值。记\n\\(\\displaystyle \\lambda_i=\\frac{h_{i+1}}{h_i+h_{i+1}},\\ \\mu_i=1-\\lambda_i=\\frac{h_i}{h_i+h_{i+1}},\\ g_i=3(\\lambda_if[x_{i-1},x_i]+\\mu_if[x_i,x_{i+1}])\\) ，\n最终解得： \\[ \\begin{array}{c}\\lambda_im_{i-1}+2m_i+\\mu_im_{i+1}=g_i\\\\ \\begin{pmatrix} 2 \u0026amp;\\mu_1 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\ \\lambda_2 \u0026amp;2 \u0026amp;\\mu_2 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp;\\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp;\\lambda_{n-2} \u0026amp;2 \u0026amp;\\mu_{n-2} \\\\ \u0026amp; \u0026amp; \u0026amp; \u0026amp;\\lambda_{n-1} \u0026amp;2 \\end{pmatrix} \\begin{pmatrix} m_1 \\\\ m_2 \\\\ \\vdots \\\\ \\vdots \\\\ m_{n-2} \\\\ m_{n-1} \\end{pmatrix}= \\begin{pmatrix} g_1-\\lambda_iy_0\u0026#39; \\\\ g_2 \\\\ \\vdots \\\\ \\vdots \\\\ g_{n-2} \\\\ g_{n-1}-\\mu_{n-1}y_n\u0026#39; \\end{pmatrix} \\end{array} \\] 利用大型稀疏矩阵线性方程数值解法，解出 \\(m_i\\) ，即解得 \\(x\\in[x_{i-1},x_i]\\) 时，有：","title":"2021-03-07-数值分析-Day10-三次样条插值-最小二乘拟合"},{"content":"5.6 - 5.7 分段插值 Runge现象：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。\n分段Lagrange插值 分段线性插值 通过相邻两个插值点作线性插值。已知节点 \\(a=x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n=b\\) ，记 \\(h_k=x_{k+1}-x_k,\\ h=\\max\\limits_{0\\le k\\le n-1}h_k\\) ，记分段插值函数为 \\(I_h(x)\\) ，为 \\(n-1\\) 段折线。\n余项估计有 \\(|f(x)-I_h(x)|\\le \\displaystyle\\frac{\\max\\limits_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|}{8}h^2\\) ，说明分段线性插值函数具有一致收敛性。\n分段二次插值 相邻三个插值点作二次插值。\n课程中以线性插值中两邻点中间值，作为补充条件，即取 \\(x_{i-0.5}=(x_i+x_{i-1})/2\\) 作为每组中的第三个插值点，使得两点间距为 \\(h_k/2\\) 。按照这种方式得到余项估计 \\(|f(x)-I_h(x)|\\le \\displaystyle\\frac{\\max\\limits_{a\\le x\\le b}|f\u0026#39;\u0026#39;\u0026#39;(x)|}{72\\sqrt{3}}h^3\\) 。\nPS：个人认为应直接取连续三个插值点，即 \\(\\{x_0,x_1,x_2\\}\\ \\{x_2,x_3,x_4\\}\\ \\{x_4,x_5,x_6\\}\\ \\dots\\) 作为插值点进行二次插值。\n分段Lagrange插值的问题：区间内出现不可导点 分段Hermite插值 设节点 \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b,\\ h_i=x_i-x_{i-1}\\ (i=1,2,\\dots,n)\\) ，给出插值条件： \\(y_k=f(x_k),\\ y\u0026#39;_k=f\u0026#39;(x_k),\\ (k=0,1,\\dots,n)\\) 。则每区间 \\([x_{i-1},x_i]\\) 具有四个插值条件。构造三次多项式 \\(H_3^{(i)}(x)\\) ： \\[ \\begin{array}{c}H_3^{(i)}(x)=\\varphi_{i-1}(x)y_{i-1}+\\varphi_i(x)y_i+\\psi_{i-1}(x)y\u0026#39;_{i-1}+\\psi_i(x)y\u0026#39;_i\\\\ \\left\\{\\begin{aligned} \u0026amp;\\varphi_{i-1}(x_{i-1})=1 \u0026amp;\u0026amp;\\varphi_{i-1}(x_i)=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_{i-1}(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_{i-1}(x_i)=0\\\\ \u0026amp;\\varphi_i(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi_i(x_i)=1 \u0026amp;\u0026amp;\\varphi\u0026#39;_i(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_i(x_i)=0\\\\ \u0026amp;\\psi_{i-1}(x_{i-1})=0 \u0026amp;\u0026amp;\\psi_{i-1}(x_i)=0 \u0026amp;\u0026amp;\\psi\u0026#39;_{i-1}(x_{i-1})=1 \u0026amp;\u0026amp;\\psi\u0026#39;_{i-1}(x_i)=0\\\\ \u0026amp;\\psi_i(x_{i-1})=0 \u0026amp;\u0026amp;\\psi_i(x_i)=0 \u0026amp;\u0026amp;\\psi\u0026#39;_i(x_{i-1})=0 \u0026amp;\u0026amp;\\psi\u0026#39;_i(x_i)=1\\\\ \\end{aligned}\\right.\\\\\\Longrightarrow\\quad\\left\\{\\begin{aligned} \u0026amp;H_3^{(i)}(x_{i-1})=y_{i-1}\u0026amp;\u0026amp;H_3^{(i)}(x_i)=y_i\\\\ \u0026amp;H_3\u0026#39;^{(i)}(x_{i-1})=y\u0026#39;_{i-1}\u0026amp;\u0026amp;H_3\u0026#39;^{(i)}(x_i)=y\u0026#39;_i \\end{aligned}\\right.\\end{array} \\] 其中，称 \\(\\varphi_{i-1}(x),\\ \\varphi_i(x),\\ \\psi_{i-1}(x),\\ \\psi_i(x)\\) 为三次Hermite插值基函数。\n求得： \\[ \\begin{array}{c}\\left\\{\\begin{aligned}\\displaystyle \u0026amp;\\varphi_{i-1}(x_{i-1})=\\frac{1}{h_i^3}(2x-3x_{i-1}+x_i)(x-x_i)^2\\\\ \u0026amp;\\varphi_i(x_{i-1})=\\frac{1}{h_i^3}(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2\\\\ \u0026amp;\\psi_{i-1}(x_{i-1})=\\frac{1}{h_i^2}(x-x_{i-1})(x-x_i)^2\\\\ \u0026amp;\\psi_i(x_{i-1})=\\frac{1}{h_i^2}(x-x_{i-1})^2(x-x_i) \\end{aligned}\\right.\\\\ \\begin{aligned}\\displaystyle H_3^{(i)}(x)\u0026amp;=\\frac{ (2x-3x_{i-1}+x_i)(x-x_i)^2y_{i-1}+(-2x-x_{i-1}+3x_i)(x-x_{i-1})^2y_i }{h_i^3}\\\\ \u0026amp;+\\frac{ (x-x_{i-1})(x-x_i)[(x-x_i)y\u0026#39;_{i-1}+(x-x_{i-1})y\u0026#39;_i] }{h_i^2} \\end{aligned}\\end{array} \\]\n余项分析：若 \\(f(x)\\in C^4[a,b]\\) （四阶连续可微），则当 \\(x\\in[x_{i-1},x_i]\\) 时，有： \\[ \\begin{array}{c}\\displaystyle f(x)-H_3^{(i)}(x)=\\frac{f^{(4)}(\\xi_i)}{4!}(x-x_{i-1})^2(x-x_i)^2,\\quad\\xi\\in[x_{i-1},x_i]\\\\ \\displaystyle |f(x)-H_3(x)|\\le\\frac{\\max\\limits_{a\\le x\\le b}|f^{(4)}(x)|\\times h^4}{4!\\times16}=\\frac{\\max\\limits_{a\\le x\\le b}|f^{(4)}(x)|\\times h^4}{384}\\end{array} \\] 可知 \\(H_3(x)\\) 是收敛的，且在 \\([a,b]\\) 内具有一阶连续导数。\n5.8 - 5.10 三次样条插值 Hermite分段插值只能保证一阶连续可导，引入三次样条插值保证二阶连续可导。\n三次样条函数：若函数 \\(S(x)\\in C^2[a,b]\\) ，且在每个小区间 \\([x_j,x_{j+1}]\\) 上是三次多项式，其中 \\(a=x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n=b\\) 是给定节点，则称 \\(S(x)\\) 是节点 \\(x_0,x_1,\\dots,x_n\\) 上的三次样条函数。\n分段三次多项式： \\(S(x)=a_jx^3+b_jx^2+c_jx+d_j,\\ j=0,1,2,\\dots,n-1\\) ，其中 \\(a_j\\ b_j\\ c_j\\ d_j\\) 为待定系数，因此函数共有 \\(4n\\) 个待定参数。函数满足关系： \\(\\left\\{\\begin{array}{l}S(x_j-0)=S(x_j+0)\\\\S\u0026#39;(x_j-0)=S\u0026#39;(x_j+0)\\\\S\u0026#39;\u0026#39;(x_j-0)=S\u0026#39;\u0026#39;(x_j+0)\\end{array}\\right.\\) ，共 \\(3n-3\\) 个条件，加上插值条件 \\(S(x_j)=f_j,\\ j=0,1,\\dots,n\\) 共 \\(4n-2\\) 个条件。在此基础上在区间端点处添加一对边界条件即可满足唯一确定 \\(4n\\) 个待定参数的 \\(4n\\) 个条件。\n边界条件：一般来说有两种边界条件，即两端点的一阶导数值或二阶导数值。\n周期边界条件：当 \\(f(x)\\) 是以 \\(x_n-x_0\\) 为周期的周期函数时，要求 \\(S(x)\\) 也是周期函数，此时边界条件满足： \\(\\left\\{\\begin{array}{l}S(x_0+0)=S(x_n-0)\\\\S\u0026#39;(x_0+0)=S\u0026#39;(x_n-0)\\\\S\u0026#39;\u0026#39;(x_0+0)=S\u0026#39;\u0026#39;(x_n-0)\\end{array}\\right.\\) ，且端点二阶导数值均为 \\(0\\) 。称这样的样条函数为周期样条函数。\n代码：Hermite插值 // // Created by xa on 2021-03-06. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::vector; double x_im1; double x_i; double y_im1; double y_i; double y_1_im1; double y_1_i; // x, y, y_1 vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; array; double H(double x); int main() { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; array_ {{100, 10, 1/20}, {121, 11, 1/22}, {144, 12, 1/24}, {169, 13, 1/26}}; array.assign(array_.begin(), array_.end()); std::cout \u0026lt;\u0026lt; H(125); } double H(double x) { sort(array.begin(), array.end(), [](const vector\u0026lt;double\u0026gt; \u0026amp;a, const vector\u0026lt;double\u0026gt; \u0026amp;b) {return a[0] \u0026lt; b[0]; }); for (int i = 0; i \u0026lt; array.size(); ++i) { if ( x \u0026lt; array[i][0]) continue; else { x_im1 = array[i][0]; x_i = array[i+1][0]; y_im1 = array[i][1]; y_i = array[i+1][1]; y_1_im1 = array[i][2]; y_1_i = array[i+1][2]; break; } } double h_i = x_i - x_im1; double h = ( ( (2 * x - 3 * x_im1 + x_i) * pow((x - x_i), 2) * y_im1 + (- 2 * x - x_im1 + 3 * x_i) * pow((x - x_im1), 2) * y_i ) + h_i * (x - x_im1) * (x - x_i) * ((x - x_i) * y_1_im1 + (x - x_im1) * y_1_i ) ) / pow(h_i, 3); return h; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-06-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day09-%E5%88%86%E6%AE%B5%E6%8F%92%E5%80%BC-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/","summary":"5.6 - 5.7 分段插值 Runge现象：在一组等间插值点上使用具有高次多项式的多项式插值时出现的区间边缘处的振荡问题。\n分段Lagrange插值 分段线性插值 通过相邻两个插值点作线性插值。已知节点 \\(a=x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n=b\\) ，记 \\(h_k=x_{k+1}-x_k,\\ h=\\max\\limits_{0\\le k\\le n-1}h_k\\) ，记分段插值函数为 \\(I_h(x)\\) ，为 \\(n-1\\) 段折线。\n余项估计有 \\(|f(x)-I_h(x)|\\le \\displaystyle\\frac{\\max\\limits_{a\\le x\\le b}|f\u0026#39;\u0026#39;(x)|}{8}h^2\\) ，说明分段线性插值函数具有一致收敛性。\n分段二次插值 相邻三个插值点作二次插值。\n课程中以线性插值中两邻点中间值，作为补充条件，即取 \\(x_{i-0.5}=(x_i+x_{i-1})/2\\) 作为每组中的第三个插值点，使得两点间距为 \\(h_k/2\\) 。按照这种方式得到余项估计 \\(|f(x)-I_h(x)|\\le \\displaystyle\\frac{\\max\\limits_{a\\le x\\le b}|f\u0026#39;\u0026#39;\u0026#39;(x)|}{72\\sqrt{3}}h^3\\) 。\nPS：个人认为应直接取连续三个插值点，即 \\(\\{x_0,x_1,x_2\\}\\ \\{x_2,x_3,x_4\\}\\ \\{x_4,x_5,x_6\\}\\ \\dots\\) 作为插值点进行二次插值。\n分段Lagrange插值的问题：区间内出现不可导点 分段Hermite插值 设节点 \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b,\\ h_i=x_i-x_{i-1}\\ (i=1,2,\\dots,n)\\) ，给出插值条件： \\(y_k=f(x_k),\\ y\u0026#39;_k=f\u0026#39;(x_k),\\ (k=0,1,\\dots,n)\\) 。则每区间 \\([x_{i-1},x_i]\\) 具有四个插值条件。构造三次多项式 \\(H_3^{(i)}(x)\\) ： \\[ \\begin{array}{c}H_3^{(i)}(x)=\\varphi_{i-1}(x)y_{i-1}+\\varphi_i(x)y_i+\\psi_{i-1}(x)y\u0026#39;_{i-1}+\\psi_i(x)y\u0026#39;_i\\\\ \\left\\{\\begin{aligned} \u0026amp;\\varphi_{i-1}(x_{i-1})=1 \u0026amp;\u0026amp;\\varphi_{i-1}(x_i)=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_{i-1}(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_{i-1}(x_i)=0\\\\ \u0026amp;\\varphi_i(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi_i(x_i)=1 \u0026amp;\u0026amp;\\varphi\u0026#39;_i(x_{i-1})=0 \u0026amp;\u0026amp;\\varphi\u0026#39;_i(x_i)=0\\\\ \u0026amp;\\psi_{i-1}(x_{i-1})=0 \u0026amp;\u0026amp;\\psi_{i-1}(x_i)=0 \u0026amp;\u0026amp;\\psi\u0026#39;_{i-1}(x_{i-1})=1 \u0026amp;\u0026amp;\\psi\u0026#39;_{i-1}(x_i)=0\\\\ \u0026amp;\\psi_i(x_{i-1})=0 \u0026amp;\u0026amp;\\psi_i(x_i)=0 \u0026amp;\u0026amp;\\psi\u0026#39;_i(x_{i-1})=0 \u0026amp;\u0026amp;\\psi\u0026#39;_i(x_i)=1\\\\ \\end{aligned}\\right.","title":"2021-03-06-数值分析-Day09-分段插值-三次样条函数"},{"content":"5.1 - 5.3 插值的引入与Lagrange插值 插值的定义 设函数 \\(y=f(x)\\) 在区间 \\([a,b]\\) 上连续，给定 \\(n+1\\) 个点： \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b\\) 。\n已知 \\(f(x_k)=y_k(k=0,1,\\dots,n)\\) ，在函数类 \\(P\\) 中寻找一函数 \\(\\varphi(x)\\) 作为 \\(f(x)\\) 的近似表达式，使满足：\n$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 \\(y=f(x)\\) 为被插值函数，称 \\(\\varphi(x)\\) 为插值函数。称 \\(x_0,x_1,\\dots,x_n\\) 为插值节点； \\(\\varphi(x_k)=f(x_k)=y_k,\\ k=0,1,2,\\dots,n\\) 为插值条件，寻求插值函数的方法称为插值方法。\n在构造插值函数时，函数类 \\(P\\) 的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即多项式插值。若用 \\(P_n\\) 表示所有次数不超过 \\(n\\) 的多项式函数类，则若 \\(p_n(x)\\in P_n\\) ，则 有\\(p_n(x)=a_0+a_1x+\\dots+a_nx^n\\) ，由 \\(n+1\\) 个系数唯一确定。若 \\(p_n(x)\\) 满足插值条件，即 \\(\\left\\{\\begin{array}{l}a_0+a_1x_1+\\dots+a_nx_1^n\\\\a_0+a_1x_2+\\dots+a_nx_2^n\\\\\\dots\\\\a_0+a_1x_n+\\dots+a_nx_n^n\\end{array}\\right.\\) 。令 \\(\\{a_0,a_1,\\dots,a_n\\}\\) 为元，则该方程系数行列式为 \\(\\begin{vmatrix}1\u0026amp;x_0\u0026amp;\\cdots\u0026amp;x_0^n\\\\1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}\\) ，由范德蒙行列式得: \\(\\begin{vmatrix}1\u0026amp;x_0\u0026amp;\\cdots\u0026amp;x_0^n\\\\1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}=\\begin{vmatrix}1\u0026amp;1\u0026amp;\\cdots\u0026amp;1\\\\x_0\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\x_0^n\u0026amp;x_2^n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}=\\prod\\limits_{0\\le\u0026lt;j\\le n}(x_j-x_i)\\neq0\\) ，因此该方程有解。\n由此得定理：满足上述条件的插值问题， \\(p_n(x)\\) 存在且唯一。\nLagrange插值 线性插值 最简单的插值问题：已知两点 \\((x_0,y_0)\\ (x_1,y_1)\\) 。通过此两点的插值多项式是一条直线，即两点式： \\(\\displaystyle L_1(x)=\\frac{x-x_1}{x_0-x_1}y_0+\\frac{x-x_0}{x_1-x_0}y_1\\) 。称 \\(L_1(x)\\) 为线性插值函数。\n令 \\(\\left\\{\\begin{array}{l}\\displaystyle l_0(x)=\\frac{x-x_1}{x_0-x_1}\\\\\\displaystyle l_1(x)=\\frac{x-x_0}{x_1-x_0}\\end{array}\\right.\\) ，则有 \\(\\left\\{\\begin{array}{l}L_1(x)=y_0l_0(x)+y_1l_1(x)\\\\l_0(x_0)=1\\quad l_0(x_1)=0\\\\l_1(x_0)=0\\quad l_1(x_1)=1\\end{array}\\right.\\) ，称 \\(l_0(x),\\ l_1(x)\\) 为关于 \\(x_0,\\ x_1\\) 的线性插值基函数。\n抛物插值 已知三点 \\((x_0,y_0)\\ (x_1,y_1)\\ (x_2,y_2)\\) 。构造插值函数 \\(L_2(x)\\) 。称 \\(L_2(x)\\) 为抛物插值函数。\n设 \\(L_2(x)=y_0l_0(x)+y_1l_1(x)+y_2l_2(x)\\) ，则由插值条件可知 \\(\\left\\{\\begin{array}{l}l_0(x_0)=1\\quad l_0(x_1)=0\\quad l_2(x_2)=0\\\\l_0(x_0)=0\\quad l_0(x_1)=1\\quad l_2(x_2)=0\\\\l_0(x_0)=0\\quad l_0(x_1)=0\\quad l_2(x_2)=1\\end{array}\\right.\\) ，可解得 \\(\\left\\{\\begin{array}{l}\\displaystyle l_0(x)=\\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}\\\\\\displaystyle l_1(x)=\\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}\\\\\\displaystyle l_2(x)=\\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\\end{array}\\right.\\) ，称为二次插值基函数。\n得到 \\(\\displaystyle L_2(x)=y_0\\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}+y_1\\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}+y_2\\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\\) 。\n\\(\\mathbf n\\) 次插值 推广到一般形式：考虑已知 \\(n+1\\) 个点 \\((x_i,y_i)(i=0,1,2,\\dots,n)\\) ，构造插值多项式 \\(L_n(x)\\) 。\n设 \\(\\displaystyle L_n(x)=\\sum_{i=0}^{n}y_il_i(x)\\) ，则 \\(l_i(x_j)=\\left\\{\\begin{array}{l}1,\\ j=i\\\\0,\\ j\\neq i\\end{array}\\right.\\ i,j=0,1,\\dots,n\\) ，解得 \\(\\displaystyle l_i(x)=\\prod_{j=0,j\\neq i}^{n}\\frac{x-x_j}{x_i-x_j}\\) 。 \u0026gt; 引入记号： \\(\\displaystyle \\omega_{n+1}(x)=\\prod_{i=0}^{n}(x-x_i)\\) 则有： \\[ \\begin{aligned}L_n\u0026amp;=\\displaystyle\\sum_{i=0}^n\\left(\\prod_{j=0,j\\neq i}^n\\frac{x-x_j}{x_i-x_j}\\right)y_i\\\\ \u0026amp;=\\displaystyle\\sum_{i=0}^n\\frac{\\omega_{n+1}(x)}{(x-x_i)\\omega_{n+1}\u0026#39;(x_i)}y_i\\end{aligned} \\] 称这两式为 \\(\\mathbf n\\) 次插值多项式，也称为Lagrange插值多项式。\nLagrange插值余项 若在 \\([a,b]\\) 上用 \\(L_n(x)\\) 近似 \\(f(x)\\) ，则其截断误差为 \\(R_n(x)=f(x)-L_n(x)\\) ，也称其为插值多项式的余项。\n设 \\(f^{(n)}(x)\\) 在 \\([a,b]\\) 上连续， \\(f^{(n+1)}(x)\\) 在 \\((a,b)\\) 内存在，节点 \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b\\) ， \\(L_n(x)\\) 是插值多项式，则 \\(\\forall x\\in [a,b],\\ R_n=\\displaystyle\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\omega_{n+1}(x)\\) ，其中 \\(a\u0026lt;\\xi\u0026lt;b\\) 且依赖于 \\(x\\) 。\n插值多项式 \\(L_n(x)\\) 逼近 \\(f(x)\\) 的截断误差限为 \\(\\left|R_n(x)\\right|\\le\\displaystyle\\frac{\\max_{a\u0026lt;x\u0026lt;b}\\left|f^{(n+1)}(x)\\right|}{(n+1)!\\left|\\omega_{n+1}(x)\\right|}\\) 。\n当被插值函数未知时，无法用上述插值余项估计误差。\n事后误差估计 求 \\(L_n(x)\\) 为 \\(f(x)\\) 以 \\(x_0,x_1,\\dots,x_n\\) 为节点的 \\(n\\) 次插值多项式；\n求 \\(L_n^{(1)}(x)\\) 为 \\(f(x)\\) 以 \\(x_1,x_2,\\dots,x_n,x_{n+1}\\) 为节点的 \\(n\\) 次插值多项式；\n认为两者较 \\(f(x)\\) 误差相近，则有： \\[ \\begin{array}{c} \\displaystyle\\frac{f(x)-L_n(x)}{f(x)-L_n^{(1)}}\\approx\\frac{x-x_0}{x-x_{n+1}}\\\\ \\displaystyle f(x)\\approx\\frac{x-x_{n+1}}{x_0-x_{n+1}}L_n(x)+\\frac{x-x_0}{x_{n+1}-x_0}L_n^{(1)}(x)\\\\ \\displaystyle f(x)-L_n(x)\\approx\\frac{x-x_0}{x_0-x_{n+1}}(L_n(x)-L_n^{(1)}(x)) \\end{array} \\]\n则第三式可用于事后误差估计，第二式可用于较精确的插值多项式。\n5.4 - 5.5 差商与Newton插值 差商（或称均差） 定义：\n称 \\(f[x_0,x_k]=\\displaystyle\\frac{f(x_k)-f(x_0)}{x_k-x_0}\\) 为函数 \\(f(x)\\) 关于点 \\(x_0,\\ x_k\\) 的一阶差商； 称 \\(f[x_0,x_1,x_k]=\\displaystyle\\frac{f[x_1,x_k]-f[x_0,x_1]}{x_k-x_0}\\) 为函数 \\(f(x)\\) 关于点 \\(x_0,\\ x_k\\) 的二阶差商； 称 \\(f[x_0,x_1,\\dots,x_k]=\\displaystyle\\frac{f[x_1,\\dots,x_{k-1},x_{k}]-f[x_0,x_1,\\dots,x_{k-1}]}{x_k-x_0}\\) 为函数 \\(f(x)\\) 关于点 \\(x_0,\\ x_k\\) 的 \\(k\\) 阶差商。 性质：\n\\(\\displaystyle f[x_0,\\dots,x_k]=\\sum_{j=0}^k\\frac{f(x_j)}{(x_j-x_0)\\cdots(x_j-x_{j-1})(x_j-x_{j+1})\\cdots(x_j-x_k)}=\\sum_{j=0}^k\\frac{f(x_j)}{\\omega_{k+1}(x_j)}\\) 差商与节点的排列次序无关； 若 \\(f(x)\\) 在 \\([a,b]\\) 上存在 \\(n\\) 阶导数，且差商节点位于区间内，则：\n\\(f[x_0,\\dots,x_n]=\\displaystyle\\frac{f^{(n)}(\\xi)}{n!},\\quad\\xi\\in[a,b]\\) 。 Newton插值 由直线方程点斜式得到线性插值函数： \\[ L_1(x)=y_0+a_1(x-x_0),\\quad a_1=\\frac{y_1-y_0}{x_1-x_0} \\]\n推广至三点情况得到二次插值函数： \\[ \\begin{array}{c} L_2(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)\\\\ \\left\\{\\begin{array}{l} a_0=y_0\\\\ a_1=\\displaystyle\\frac{y_1-y_0}{x_1-x_0}\\\\ a_2=\\displaystyle\\frac{\\displaystyle\\frac{y_2-y_0}{x_2-x_0}-\\frac{y_1-y_0}{x_1-x_0}}{x_2-x_1} \\end{array}\\right. \\end{array} \\]\n推广至 \\(n+1\\) 点情况得到 \\(n+1\\) 次插值函数： \\[ \\begin{aligned} L_n(x)\u0026amp;=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+\\dots+a_n(x-x_0)\\dots(x-x_{n-1})\\\\ \u0026amp;=\\displaystyle\\sum_{i=0}^{n}\\left[a_i\\left(\\prod_{j=0}^{i-1}(x-x_j)\\right)\\right]\\end{aligned} \\] 由前面的推导和差商的定义可知 \\(a_i=f[x_0,x_1,\\dots,x_i]\\) ；或进行如下推导： \\[ \\begin{aligned} \u0026amp;\\quad\\left\\{\\begin{array}{l} f(x)=f(x_0)+f[x,x_0](x-x_0)\\\\ f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1])(x-x_1)\\\\ f[x,x_0,\\dots,x_{n-1}]=f[x_0,x_1,\\dots,x_n]+f[x,x_0,\\dots,x_n]\\end{array}\\right.\\\\ \u0026amp;\\begin{aligned}\\Rightarrow\\ f(x)\u0026amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\\\ \u0026amp;+\\dots+f[x_0,x_1,\\dots,x_n](x-x_0)\\cdots(x-x_{n-1})+f[x,x_0,\\dots,x_n]\\omega_{n+1}(x)\\\\ \u0026amp;\\equiv N_n(x) + R_n(x)\\\\\\end{aligned}\\\\ \u0026amp;\\begin{aligned} N_n(x)\u0026amp;=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\\\ \u0026amp;+\\dots+f[x_0,x_1,\\dots,x_n](x-x_0)\\cdots(x-x_{n-1})\\\\ R_n(x)\u0026amp;=f[x,x_0,\\dots,x_n]\\omega_{n+1}(x) \\end{aligned}\\end{aligned} \\] 其中 \\(N_n(x)\\) 就称作Newton插值多项式，其与Lagrange插值多项式是等价的。 \\(R_n(x)\\) 为Newton插值多项式的余项，它比Lagrange插值多项式的余项更具有一般性，对于离散函数 \\(f\\) 或 \\(f\\) 导数不存在时均适用。\nLagrange插值多项式的缺陷：当节点发生改变时，所有计算需要重新计算。\n代码：Lagrange插值 // // Created by xa on 2021-03-05. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; double L(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; xy_array, double x); int main() { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; sqrt_xy {{100, 10}, {121, 11}, {144, 12}}; std::cout \u0026lt;\u0026lt; L(sqrt_xy, 120) \u0026lt;\u0026lt; std::endl; } double L(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; xy_array, double x) { double sum = 0; for (int i = 0; i \u0026lt; xy_array.size(); ++i) { double prod = 1; for (int j = 0; j \u0026lt; xy_array.size(); ++j) if (j != i) prod *= (x-xy_array[j][0]) / (xy_array[i][0]-xy_array[j][0]); sum += prod * xy_array[i][1]; } return sum; } 代码：Newton插值（含生成差商表） // // Created by xa on 2021-03-05. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; xy_array; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; DD; void refreshDD(); void printDD(); double N(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; xy_array, double x); int main() { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; sqrt_xy {{-2, 5}, {-1, 3}, {1, 17}, {2, 21}}; std::cout \u0026lt;\u0026lt; N(sqrt_xy, 0); } //获取Divided Difference 差商表 void refreshDD() { vector\u0026lt;double\u0026gt; tmp; if (DD.size() \u0026lt; 1 \u0026amp;\u0026amp; xy_array.size() \u0026gt;= 2) { for (int i = 0; i \u0026lt; xy_array.size()-1; ++i) { for (int j = 0; j \u0026lt;= DD.size(); ++j) { if (j \u0026lt; 1) tmp.push_back((xy_array[i][1]-xy_array[i+1][1])/(xy_array[i][0]-xy_array[i+1][0])); else tmp.push_back((DD[i-1][j-1]-tmp[j-1])/(xy_array[i-j][0]-xy_array[i+1][0])); } DD.push_back(tmp); tmp.clear(); } } else if (DD.size() \u0026gt;= 1 \u0026amp;\u0026amp; xy_array.size() \u0026gt;= 2 \u0026amp;\u0026amp; xy_array.size() \u0026gt; DD.size()+1) { int i = xy_array.size() - 2; for (int j = 0; j \u0026lt; xy_array.size()-1; ++j) { if (j \u0026lt; 1) tmp.push_back((xy_array[i][1]-xy_array[i+1][1])/(xy_array[i][0]-xy_array[i+1][0])); else { tmp.push_back((DD[i-1][j-1]-tmp[j-1])/(xy_array[i-j][0]-xy_array[i+1][0])); } } DD.push_back(tmp); tmp.clear(); } printDD(); } void printDD() { std::cout \u0026lt;\u0026lt; \u0026quot;(\u0026quot; \u0026lt;\u0026lt; DD.size() \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; DD.back().size() \u0026lt;\u0026lt; \u0026quot;)\u0026quot; \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; DD.size(); ++i) { for (int j = 0; j \u0026lt; DD[i].size(); ++j) std::cout \u0026lt;\u0026lt; DD[i][j] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; std::cout \u0026lt;\u0026lt; std::endl; } } double N(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; xy_array_, double x) { xy_array.assign(xy_array_.begin(), xy_array_.end()); refreshDD(); double sum = xy_array[0][1]; double prod = 1; for (int i = 1; i \u0026lt; xy_array.size(); ++i) { for (int j = 0; j \u0026lt; i; ++j) prod *= x - xy_array[j][0]; sum += DD[i-1].back() * prod; prod = 1; } return sum; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-05-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day08-lagrange%E6%8F%92%E5%80%BC-newton%E6%8F%92%E5%80%BC/","summary":"5.1 - 5.3 插值的引入与Lagrange插值 插值的定义 设函数 \\(y=f(x)\\) 在区间 \\([a,b]\\) 上连续，给定 \\(n+1\\) 个点： \\(a\\le x_0\u0026lt;x_1\u0026lt;\\dots\u0026lt;x_n\\le b\\) 。\n已知 \\(f(x_k)=y_k(k=0,1,\\dots,n)\\) ，在函数类 \\(P\\) 中寻找一函数 \\(\\varphi(x)\\) 作为 \\(f(x)\\) 的近似表达式，使满足：\n$(x_k)=f(x_k)=y_k, k=0,1,2,,n $ 。则称 \\(y=f(x)\\) 为被插值函数，称 \\(\\varphi(x)\\) 为插值函数。称 \\(x_0,x_1,\\dots,x_n\\) 为插值节点； \\(\\varphi(x_k)=f(x_k)=y_k,\\ k=0,1,2,\\dots,n\\) 为插值条件，寻求插值函数的方法称为插值方法。\n在构造插值函数时，函数类 \\(P\\) 的不同选取，对应不同的插值方法，这里主要讨论函数类为代数多项式的插值方法，即多项式插值。若用 \\(P_n\\) 表示所有次数不超过 \\(n\\) 的多项式函数类，则若 \\(p_n(x)\\in P_n\\) ，则 有\\(p_n(x)=a_0+a_1x+\\dots+a_nx^n\\) ，由 \\(n+1\\) 个系数唯一确定。若 \\(p_n(x)\\) 满足插值条件，即 \\(\\left\\{\\begin{array}{l}a_0+a_1x_1+\\dots+a_nx_1^n\\\\a_0+a_1x_2+\\dots+a_nx_2^n\\\\\\dots\\\\a_0+a_1x_n+\\dots+a_nx_n^n\\end{array}\\right.\\) 。令 \\(\\{a_0,a_1,\\dots,a_n\\}\\) 为元，则该方程系数行列式为 \\(\\begin{vmatrix}1\u0026amp;x_0\u0026amp;\\cdots\u0026amp;x_0^n\\\\1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}\\) ，由范德蒙行列式得: \\(\\begin{vmatrix}1\u0026amp;x_0\u0026amp;\\cdots\u0026amp;x_0^n\\\\1\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_1^n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\1\u0026amp;x_n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}=\\begin{vmatrix}1\u0026amp;1\u0026amp;\\cdots\u0026amp;1\\\\x_0\u0026amp;x_1\u0026amp;\\cdots\u0026amp;x_n\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\x_0^n\u0026amp;x_2^n\u0026amp;\\cdots\u0026amp;x_n^n\\end{vmatrix}=\\prod\\limits_{0\\le\u0026lt;j\\le n}(x_j-x_i)\\neq0\\) ，因此该方程有解。\n由此得定理：满足上述条件的插值问题， \\(p_n(x)\\) 存在且唯一。\nLagrange插值 线性插值 最简单的插值问题：已知两点 \\((x_0,y_0)\\ (x_1,y_1)\\) 。通过此两点的插值多项式是一条直线，即两点式： \\(\\displaystyle L_1(x)=\\frac{x-x_1}{x_0-x_1}y_0+\\frac{x-x_0}{x_1-x_0}y_1\\) 。称 \\(L_1(x)\\) 为线性插值函数。","title":"2021-03-05-数值分析-Day08-Lagrange插值-Newton插值"},{"content":"4.11 - 15 牛顿迭代法 Newton迭代法 泰勒级数： \\(\\displaystyle f(x)=\\sum_{n=0}^{\\infty}\\frac{f^{(n)}(a)}{n!}(x-a)^n\\)\n泰勒展开公式： \\(\\displaystyle f(x)=\\sum_{n=0}^n\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\\)\n皮亚诺型余项： \\(R_n(x)=o[(x-a)^n]\\) ，即当 \\(x\\to a\\) 时，余项为 \\((x-a)^n\\) 的高阶无穷小 拉格朗日型余项： \\(R_n(x)=\\displaystyle\\frac{f^{(n+1)}(\\theta)}{(n+1)!}(x-a)^{(n+1)},\\ \\theta\\in(a,x)\\)\n积分型余项： \\(R_{n}(x)=\\displaystyle\\int_{a}^{x}{\\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\\,dt\\) 原理：将非线性方程线性化——Taylor展开\n取 \\(x_0\\) 作为初始近似值，将 \\(f(x)\\) 在 \\(x_0\\) 处做一阶Taylor展开： \\[ \\begin{array}{c}f(x)=f(x_0)+f\u0026#39;(x_0)(x-x_0)+\\displaystyle{f\u0026#39;\u0026#39;(\\xi)}{2!}(x-x_0)^2,\\quad \\xi\\in(x_0,x)\\\\ 0=f(x^*)\\approx f(x_0)+f\u0026#39;(x_0)(x-x_0)\\quad\\Rightarrow\\quad x^*\\approx x_0-\\displaystyle\\frac{f(x_0)}{f\u0026#39;(x_0)}\\\\ \\left\\{\\begin{array}{l}x_1=x_0-\\displaystyle\\frac{f(x_0)}{f\u0026#39;(x_0)}\\\\ x_{k+1}=x_k-\\displaystyle\\frac{f(x_k)}{f\u0026#39;(x_k)}\\quad\\leftarrow\\ \\textbf{Newton迭代公式}\\end{array}\\right.\\end{array} \\]\nNewton迭代法的收敛性 定理：设 \\(f\\in C^2[a,b]\\) （二阶连续可微），若 \\(x^*\\) 为 \\(f(x)=0\\) 在 \\([a,b]\\) 上的根，且 \\(f\u0026#39;(x^*)\\neq0\\) ，则Newton迭代法是二阶收敛的，且有 \\(\\displaystyle\\lim_{k\\to\\infty}\\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\\frac{f\u0026#39;\u0026#39;(x^*)}{2f\u0026#39;(x^*)}\\) 。\n初值的选取：令 \\(c=\\displaystyle\\frac{\\max|f\u0026#39;\u0026#39;(x)|}{2\\min|f\u0026#39;(x)|}\\) ，则有： \\[ c|x_{k+1}-x^*|\\le(c|x_{k}-x^*|)^2\\le(c|x_{k-1}-x^*|)^4\\le\\dots\\le\\le(c|x_{k+1}-x^*|)^{2^{k+1}} \\] 因此， \\(c|x_0-x^*|=1\\ \\Rightarrow\\ |x_0-x^*|\\le\\displaystyle\\frac{2\\min|f\u0026#39;(x)|}{\\max|f\u0026#39;\u0026#39;(x)|}\\) 时，Newton迭代法收敛。\nNewton下山法 调整 \\(x_0\\) 的选取来使得Newton迭代法满足收敛条件。\n定义：对Newton迭代过程附加单调性要求： \\(|f(x_{k+1})|\u0026lt;|x_k|\\) ，满足该条件的Newton迭代法称为Newton下山法。\n实现：若由 \\(x_k\\) 得到的 \\(x_{k+1}\\) 不能使得 \\(|f|\\) 减小，则在 \\(x_k\\) 和 \\(x_{k+1}\\) 之间找点 \\(\\overline{x_{k+1}}\\) ，使得 \\(|f(\\overline{x_{k+1}})|\u0026lt;|f(x_k)|\\) ， \\[ \\begin{aligned}\\overline{x_{k+1}}\u0026amp;=\\lambda x_{k+1}+(1-\\lambda)x_k\\\\ \u0026amp;=\\lambda[x_k-\\frac{f(x_k)}{f\u0026#39;(x_k)}]+(1-\\lambda)x_k\\\\ \u0026amp;=x_k-\\lambda\\frac{f(x_k)}{f\u0026#39;(x_k)}\\end{aligned} \\] 其中， \\(\\lambda=1\\) 时即Newton迭代法，当 \\(\\lambda=1\\) 效果不好时，将 \\(\\lambda\\) 减半计算。\nNewton迭代法的变形 Newton下山法中计算每次迭代都需要计算一阶导数，试图简化计算。\n简化Newton迭代法 采用迭代格式： \\(x_{k+1}=x_k-\\displaystyle\\frac{f(x_k)}{M},\\ k=0,1,2,\\dots\\) ，即用常数来代替一阶导，通常取 \\(M=f\u0026#39;(x_0)\\) 。一般，简化Newton迭代法只具有线性收敛。\n割线法 采用迭代格式： \\(x_{k+1}=x_k-\\displaystyle\\frac{f(x_k)}{f(x_k)-f(x_{k-1})}\\ k=0,1,2,3,\\dots\\) ，需要取两个初值 \\(x_0,x_1\\) 。收敛阶 \\(p\\approx1.618\\) 。\n求重根的Newton迭代法 重根：称 \\(x^*\\) 为方程 \\(f(x)=0\\) 的 \\(m\\) 重根时，是指 \\(f(x)=(x-x^*)^mh(x)\\) ，其中 \\(h(x)\\) 在 \\(x=x^*\\) 处连续且 \\(h(x^*)\\neq0\\) ，若 \\(h(x)\\) 在 \\(x^*\\) 处充分可微，则 \\(f(x^*)=f\u0026#39;(x^*)=\\dots=f^{(m-1)}(x^*)=0,\\ f^{(m)}(x^*)\\neq0\\) 。\n由于 \\([f(x)]^{\\frac{1}{m}}=(x-x^*)[h(x)]^{\\frac{1}{m}}\\) ，知 \\(x^*\\) 恰是方程 \\([f(x)]^{\\frac{1}{m}}\\) 的单根。应用Newton迭代法对该方程求解，得到： \\[ \\begin{aligned}x_{k+1}\u0026amp;=x_k-\\frac{[f(x_k)]^{\\frac{1}{m}}}{\\frac{1}{m}[f(x_k)]^{\\frac{1}{m}-1}f\u0026#39;(x_k)}\\\\ \u0026amp;=x_k-m\\frac{f(x_k)}{f\u0026#39;(x_k)},\\quad k=0,1,2,\\dots\\end{aligned} \\] 也称之为带参数的Newton迭代法，求方程 \\(f(x)=0\\) 的 \\(m\\) 重根时具有平方收敛。\n当 \\(m\\) 未知时：\n根据函数 \\(\\displaystyle u(x)=\\frac{f(x)}{f\u0026#39;(x)}=\\frac{(x-x^*)h(x)}{mh(x)+(x-x^*)h\u0026#39;(x)}\\) ，可见 \\(x^*\\) 恰是方程 \\(u(x)\\) 的单根。对之应用Newton迭代法有： \\[ x_{k+1}=x_k-\\frac{u(x_k)}{u\u0026#39;(x_k)}=x_k-\\frac{f(x_k)f\u0026#39;(x_k)}{[f\u0026#39;(x_k)]^2-f(x_k)f\u0026#39;\u0026#39;(x_k)},\\quad k=0,1,2,\\dots \\] 在该迭代过程中，不需要知道根的重数，具有平方收敛。\n代码：Newton迭代法（三种） // // Created by xa on 2021-03-04. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;cmath\u0026gt; //已知一阶导函数求单根 void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_1, double x_0); //已知二阶导函数求重根（重数任意） void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_1, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_2, double x_0); //未知导函数，有二初值，利用割线法求单根 void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, double x_0, double x_1); int main() { auto f = [\u0026amp;](double x) -\u0026gt; double { return pow(x,4) - 8.6*pow(x,3) - 35.51*pow(x,2) + 464.4*x - 998.46; }; auto f_1 = [\u0026amp;](double x) -\u0026gt; double { return 4*pow(x,3) - 3*8.6*pow(x,2) - 2*35.51*x + 464.4; }; auto f_2 = [\u0026amp;](double x) -\u0026gt; double { return 3*4*pow(x,2) - 2*3*8.6*x - 2*35.51; }; iterate(f, f_1, 7); iterate(f, f_1, f_2, 4); iterate(f, 7, 8); } void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_1, double x_0) { double x = x_0; double f_x = f(x); double f_1_x = f_1(x); double next_x = x - f_x / f_1_x; double lambda = 1; int count = 0; while (std::abs(next_x - x) \u0026gt;= 1e-6) { ++count; x = next_x; f_x = f(x); f_1_x = f_1(x); std::cout \u0026lt;\u0026lt; \u0026quot;第\u0026quot; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026quot;次：\u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; lambda = 1; next_x = x - f_x / f_1_x; while (std::abs(f(next_x)) \u0026gt; std::abs(f_x)) { lambda /= 2; next_x = x - lambda * f_x / f_1_x; } } } void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_1, std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f_2, double x_0) { double x = x_0; double f_x = f(x); double f_1_x = f_1(x); double f_2_x = f_2(x); double next_x = x - f_x*f_1_x/(f_1_x*f_1_x-f_x*f_2_x); double lambda = 1; int count = 0; while (std::abs(next_x - x) \u0026gt;= 1e-6) { ++count; x = next_x; f_x = f(x); f_1_x = f_1(x); f_2_x=f_2(x); std::cout \u0026lt;\u0026lt; \u0026quot;第\u0026quot; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026quot;次：\u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; lambda = 1; next_x = x - f_x*f_1_x/(f_1_x*f_1_x-f_x*f_2_x); while (std::abs(f(next_x)) \u0026gt; std::abs(f_x)) { lambda /= 2; next_x = x - lambda * f_x*f_1_x/(f_1_x*f_1_x-f_x*f_2_x); std::cout \u0026lt;\u0026lt; \u0026quot;OK\u0026quot;; } } } void iterate(std::function\u0026lt;double (double)\u0026gt; const\u0026amp; f, double x_0, double x_1) { double pre_x = x_0; double f_pre_x = f(pre_x); double x = x_1; double f_x = f(x); double g_x = f_x - f_pre_x; double next_x = x - f_x / g_x; double lambda = 1; int count = 0; while (std::abs(next_x - x) \u0026gt;= 1e-6) { ++count; pre_x = x; x = next_x; f_pre_x = f(pre_x); f_x = f(x); g_x = f_x - f_pre_x; std::cout \u0026lt;\u0026lt; \u0026quot;第\u0026quot; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026quot;次：\u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; lambda = 1; next_x = x - f_x / g_x; while (std::abs(f(next_x)) \u0026gt; std::abs(f_x)) { lambda /= 2; next_x = x - lambda * f_x / g_x; } } } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-04-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day07-newton%E8%BF%AD%E4%BB%A3%E6%B3%95/","summary":"4.11 - 15 牛顿迭代法 Newton迭代法 泰勒级数： \\(\\displaystyle f(x)=\\sum_{n=0}^{\\infty}\\frac{f^{(n)}(a)}{n!}(x-a)^n\\)\n泰勒展开公式： \\(\\displaystyle f(x)=\\sum_{n=0}^n\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)\\)\n皮亚诺型余项： \\(R_n(x)=o[(x-a)^n]\\) ，即当 \\(x\\to a\\) 时，余项为 \\((x-a)^n\\) 的高阶无穷小 拉格朗日型余项： \\(R_n(x)=\\displaystyle\\frac{f^{(n+1)}(\\theta)}{(n+1)!}(x-a)^{(n+1)},\\ \\theta\\in(a,x)\\)\n积分型余项： \\(R_{n}(x)=\\displaystyle\\int_{a}^{x}{\\frac{f^{{(n+1)}}(t)}{n!}}(x-t)^{n}\\,dt\\) 原理：将非线性方程线性化——Taylor展开\n取 \\(x_0\\) 作为初始近似值，将 \\(f(x)\\) 在 \\(x_0\\) 处做一阶Taylor展开： \\[ \\begin{array}{c}f(x)=f(x_0)+f\u0026#39;(x_0)(x-x_0)+\\displaystyle{f\u0026#39;\u0026#39;(\\xi)}{2!}(x-x_0)^2,\\quad \\xi\\in(x_0,x)\\\\ 0=f(x^*)\\approx f(x_0)+f\u0026#39;(x_0)(x-x_0)\\quad\\Rightarrow\\quad x^*\\approx x_0-\\displaystyle\\frac{f(x_0)}{f\u0026#39;(x_0)}\\\\ \\left\\{\\begin{array}{l}x_1=x_0-\\displaystyle\\frac{f(x_0)}{f\u0026#39;(x_0)}\\\\ x_{k+1}=x_k-\\displaystyle\\frac{f(x_k)}{f\u0026#39;(x_k)}\\quad\\leftarrow\\ \\textbf{Newton迭代公式}\\end{array}\\right.\\end{array} \\]\nNewton迭代法的收敛性 定理：设 \\(f\\in C^2[a,b]\\) （二阶连续可微），若 \\(x^*\\) 为 \\(f(x)=0\\) 在 \\([a,b]\\) 上的根，且 \\(f\u0026#39;(x^*)\\neq0\\) ，则Newton迭代法是二阶收敛的，且有 \\(\\displaystyle\\lim_{k\\to\\infty}\\frac{x_{k+1}-x^*}{(x_k-x^*)^2}=\\frac{f\u0026#39;\u0026#39;(x^*)}{2f\u0026#39;(x^*)}\\) 。\n初值的选取：令 \\(c=\\displaystyle\\frac{\\max|f\u0026#39;\u0026#39;(x)|}{2\\min|f\u0026#39;(x)|}\\) ，则有： \\[ c|x_{k+1}-x^*|\\le(c|x_{k}-x^*|)^2\\le(c|x_{k-1}-x^*|)^4\\le\\dots\\le\\le(c|x_{k+1}-x^*|)^{2^{k+1}} \\] 因此， \\(c|x_0-x^*|=1\\ \\Rightarrow\\ |x_0-x^*|\\le\\displaystyle\\frac{2\\min|f\u0026#39;(x)|}{\\max|f\u0026#39;\u0026#39;(x)|}\\) 时，Newton迭代法收敛。\nNewton下山法 调整 \\(x_0\\) 的选取来使得Newton迭代法满足收敛条件。","title":"2021-03-04-数值分析-Day07-Newton迭代法"},{"content":"4.1-3 非线性方程简介及二分法：略 4.4 - 10 简单迭代法的构造与收敛性 构造简单迭代法 \\[ \\begin{array}{c}\\begin{aligned} f(x)=0\\quad\u0026amp;\\Leftrightarrow\\quad x=\\varphi(x)\\\\ f(x)的根\\quad\u0026amp;\\Leftrightarrow\\quad\\varphi(x)的不动点 \\end{aligned}\\end{array} \\]\n其中 \\(x_{k+1}=\\varphi(x_k),\\quad (k=0,1,2,\\dots)\\) 称为迭代格式， \\(\\varphi(x)\\) 称为迭代函数。\n简单迭代法的收敛条件 几何解释：求方程 \\(x=\\varphi(x)\\) 的根，就是求直线 \\(y=x\\) 和曲线 \\(y=\\varphi(x)\\) 的交点的横坐标。（图略。）\n如果 \\(x_{k+1}=\\varphi(x_k)\\) 收敛，则迭代函数 \\(y=\\varphi(x)\\) 的曲线走势平坦，即 \\(\\left|\\varphi\u0026#39;(x)\\right|\u0026lt;1\\) ；\n如果 \\(x_{k+1}=\\varphi(x_k)\\) 发散，则迭代函数 \\(y=\\varphi(x)\\) 的曲线走势陡峭，即 \\(\\left|\\varphi\u0026#39;(x)\\right|\\ge1\\) ；\n迭代法收敛的判定定理：设函数 \\(\\varphi(x)\\) 满足条件： \\[ \\begin{array}{l}(1)\\quad \\forall x\\in[a,b],\\ a\\le\\varphi(x)\\le b;\\\\ (2)\\quad \\exists0\\le L\u0026lt;1,\\ \\begin{array}{l}\\forall x,y\\in[a,b],\\ |\\varphi(x)-\\varphi(y)|\\le L|x-y|\\\\或\\ |\\varphi\u0026#39;(x)\\le L\u0026lt;1|\\end{array}\\end{array} \\]\n则 \\(\\forall x_0\\in[a,b]\\) ，由 \\(x_{k+1}=\\varphi(x_K)\\) 得到的序列 \\(\\{x_k\\}_{k=0}^\\infty\\) 收敛于 \\(\\varphi(x)\\) 在 \\([a,b]\\) 上的唯一不动点。并且由误差估计式： \\(\\begin{array}{l}\\displaystyle\\left|x^*-x_k\\right|\\le\\frac{1}{1-L}\\left|x_k-x_{k-1}\\right|\\\\\\displaystyle\\left|x^*-x_k\\right|\\le\\frac{L^k}{1-L}\\left|x_1-x_0\\right|\\end{array}\\) 。由第一式分析误差；由第二式得到结论 \\(L\\) 越小，收敛越快 。\n局部收敛性 定义：若存在 \\(x^*\\) 的某个邻域 \\(S=\\{|x-x^*|\\le\\delta\\}\\subset[a,b]\\) ，使迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) 对于任一初值 \\(x_0\\in S\\) 均收敛则称迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) 在根 \\(x^*\\) 邻近具有局部收敛性。\n判定定理： \\(\\varphi(x)\\) 在方程 \\(x=\\varphi(x)\\) 的精确根 \\(x^*\\) 的邻域连续，且 \\(|\\varphi\u0026#39;(x^*)|\u0026lt;1\\) ，则迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) 在根 \\(x^*\\) 的邻域具有局部收敛性。\n不严格的准则：只要在一个不大的有根区间上， \\(|\\varphi\u0026#39;(x)|\u0026lt;1\\) 明显成立，则从该区间内一点 \\(x_0\\) 出发， \\(x_{k+1}=\\varphi(x_k)\\) 产生的迭代序列 \\(\\{x_k\\}\\) 一般是收敛的。\n收敛阶（描述收敛速度） 观察得到， \\(|\\varphi\u0026#39;(x)|\\) 越小，收敛速度越快，越大越慢。\n定义：记迭代误差 \\(e_k=x^*-x_k\\) ，对收敛于方程 \\(x=\\varphi(x)\\) 的根 \\(x^*\\) 的迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) ，若存在常数 \\(p\\ge1\\) 和非零常数 \\(C\\) ，使得 \\(\\displaystyle\\lim_{k\\to\\infty}\\frac{|e_{k+1}|}{|e_k|^p}=C\\) ，则称迭代过程是 \\(\\mathbf{p}\\) 阶收敛的， \\(C\\) 是渐进误差常数。\n其中， \\(p=1\\) 时称线性收敛， \\(p\u0026gt;1\\) 时称超线性收敛， \\(p=2\\) 时称平方收敛。 \\(p\\) 越大，收敛速度越快。\n定理：若 \\(\\varphi\u0026#39;(x)\\) 在 \\(\\varphi(x)\\) 的不动点 \\(x^*\\) 邻域连续，且 \\(\\varphi\u0026#39;(x)\\neq0\\) ，则迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) 在 \\(x^*\\) 的邻域是线性收敛的。\n\\(\\mathbf{p}\\) 阶收敛的迭代法 定理：若 \\(x^*\\) 是 \\(\\varphi(x)\\) 的不动点，对于整数 \\(p\u0026gt;1\\) ，迭代函数 \\(\\varphi(x)\\) 及其 \\(p\\) 阶导数在 \\(x^*\\) 的邻域上连续，且满足： \\(\\varphi\u0026#39;(x^*)=\\varphi\u0026#39;\u0026#39;(x^*)=\\dots=\\varphi^{(p-1)}(x^*)=0,\\quad \\varphi^{(p)}(x^*)\\neq0\\) ，则迭代过程 \\(x_{k+1}=\\varphi(x_k)\\) 在 \\(x^*\\) 的邻域是 \\(p\\) 阶收敛的。且有： \\(\\displaystyle\\lim_{k\\to\\infty}\\frac{e_{k+1}}{e_k^p}=\\frac{\\varphi^{(p)}(x^*)}{p!}\\) 。\n因此， \\(\\varphi\u0026#39;(x^*)\\neq0\\) 时，迭代过程只可能是线性的，因此绝大部分迭代方法只能是线性收敛的。\nAitken加速算法 由于 \\(\\begin{array}{l}x_{k+1}-x^*=\\varphi\u0026#39;(\\xi_1)(x_k-x^*)\\\\x_{k+2}-x^*=\\varphi\u0026#39;(\\xi_2)(x_{k+1}-x^*)\\end{array}\\) ，当 \\(k\\) 较大时，假设 \\(\\varphi\u0026#39;(\\xi_1)\\approx\\varphi\u0026#39;(\\xi_2)\\) ，则有： \\(\\displaystyle\\frac{x_{k+1}-x^*}{x_{k+2}-x^*}\\approx\\frac{x_k-x^*}{x_{k+1}-x^*}\\) 。然后解得 \\(x^*\\approx \\hat x_k=x_k-\\displaystyle\\frac{(x_{k+1}-x_k)^2}{x_{k+2}-2x_{k+1}+x_k}\\) 。\n则序列 \\(\\{\\hat x_k\\}\\) 比序列 \\(\\{x_k\\}\\) 更快地收敛于 \\(x^*\\) ，可构造如下Aitken加速算法： \\[ \\left\\{\\begin{array}{l} y_k=\\varphi(x_k)\\\\ z_k=\\varphi(y_k)\\\\ x_{k+1}=x_k-\\displaystyle\\frac{(y_k-x_k)^2}{z_k-2y_k+x_k}, \\quad k=0,1,2,\\dots \\end{array}\\right. \\] 若第 \\(k\\) 步发生 \\(z_k-2y_k+x_k=0\\) ，则中止计算，取 \\(x^*\\approx x_k\\) 。\n代码：二分法 // // Created by xa on 2021-03-03. // #include \u0026lt;iostream\u0026gt; double f(double x); double solve(double a, double b); void iterate(double \u0026amp;a, double \u0026amp;b); int main() { double x = solve(1,2); std::cout \u0026lt;\u0026lt; \u0026quot;The solve in [1, 2] is : x = \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } double f(double x) { return x * x * x + 4 * x - 7; } double solve(double a, double b) { if (f(a) * f(b) \u0026gt; 0) { std::cout \u0026lt;\u0026lt; \u0026quot;WRONG INTERVAL\u0026quot; \u0026lt;\u0026lt; std::endl; return 0; } double epsilon = 1e-5; while (std::abs(a-b) \u0026gt;= epsilon) { iterate(a, b); std::cout \u0026lt;\u0026lt; (a + b) / 2 \u0026lt;\u0026lt; std::endl; } return (a + b) / 2; } void iterate(double \u0026amp;a, double \u0026amp;b) { double f_a = f(a); double f_b = f(b); double f_c = f((a + b) / 2); if (f_c == 0) return; else if (f_a * f_c \u0026lt; 0) b = (a + b) / 2; else if (f_b * f_c \u0026lt; 0) a = (a + b) / 2; } 代码：简单迭代法与Aitken加速算法比较 // // Created by xa on 2021-03-03. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; double phi(double x); double x_simple; double next_x_simple; int count_simple; void simple(); double x_aitken; double next_x_aitken; int count_aitken; void aitken(); int main() { simple(); aitken(); } double phi(double x) { return 1.6 + 0.99 * cos(x); } void simple() { x_simple = 1.57; while (x_simple = next_x_simple, ++count_simple, std::cout \u0026lt;\u0026lt; x_simple \u0026lt;\u0026lt; \u0026quot;; \u0026quot;) { next_x_simple = phi(x_simple); if (std::abs(next_x_simple - x_simple) \u0026lt; 1e-5) break; } std::cout \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026quot;The count is \u0026quot; \u0026lt;\u0026lt; count_simple \u0026lt;\u0026lt; std::endl; } void aitken() { x_aitken = 1.57; while (x_aitken = next_x_aitken, ++count_aitken, std::cout \u0026lt;\u0026lt; x_aitken \u0026lt;\u0026lt; \u0026quot;; \u0026quot;) { double y = phi(x_aitken); double z = phi(y); next_x_aitken = x_aitken - (pow(y - x_aitken, 2) / (z - 2 * y + x_aitken) ); if (std::abs(next_x_aitken - x_aitken) \u0026lt; 1e-5) break; } std::cout \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026quot;The count is \u0026quot; \u0026lt;\u0026lt; count_aitken \u0026lt;\u0026lt; std::endl; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-03-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day06-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95%E5%8F%8A%E6%94%B6%E6%95%9B%E6%80%A7/","summary":"4.1-3 非线性方程简介及二分法：略 4.4 - 10 简单迭代法的构造与收敛性 构造简单迭代法 \\[ \\begin{array}{c}\\begin{aligned} f(x)=0\\quad\u0026amp;\\Leftrightarrow\\quad x=\\varphi(x)\\\\ f(x)的根\\quad\u0026amp;\\Leftrightarrow\\quad\\varphi(x)的不动点 \\end{aligned}\\end{array} \\]\n其中 \\(x_{k+1}=\\varphi(x_k),\\quad (k=0,1,2,\\dots)\\) 称为迭代格式， \\(\\varphi(x)\\) 称为迭代函数。\n简单迭代法的收敛条件 几何解释：求方程 \\(x=\\varphi(x)\\) 的根，就是求直线 \\(y=x\\) 和曲线 \\(y=\\varphi(x)\\) 的交点的横坐标。（图略。）\n如果 \\(x_{k+1}=\\varphi(x_k)\\) 收敛，则迭代函数 \\(y=\\varphi(x)\\) 的曲线走势平坦，即 \\(\\left|\\varphi\u0026#39;(x)\\right|\u0026lt;1\\) ；\n如果 \\(x_{k+1}=\\varphi(x_k)\\) 发散，则迭代函数 \\(y=\\varphi(x)\\) 的曲线走势陡峭，即 \\(\\left|\\varphi\u0026#39;(x)\\right|\\ge1\\) ；\n迭代法收敛的判定定理：设函数 \\(\\varphi(x)\\) 满足条件： \\[ \\begin{array}{l}(1)\\quad \\forall x\\in[a,b],\\ a\\le\\varphi(x)\\le b;\\\\ (2)\\quad \\exists0\\le L\u0026lt;1,\\ \\begin{array}{l}\\forall x,y\\in[a,b],\\ |\\varphi(x)-\\varphi(y)|\\le L|x-y|\\\\或\\ |\\varphi\u0026#39;(x)\\le L\u0026lt;1|\\end{array}\\end{array} \\]\n则 \\(\\forall x_0\\in[a,b]\\) ，由 \\(x_{k+1}=\\varphi(x_K)\\) 得到的序列 \\(\\{x_k\\}_{k=0}^\\infty\\) 收敛于 \\(\\varphi(x)\\) 在 \\([a,b]\\) 上的唯一不动点。并且由误差估计式： \\(\\begin{array}{l}\\displaystyle\\left|x^*-x_k\\right|\\le\\frac{1}{1-L}\\left|x_k-x_{k-1}\\right|\\\\\\displaystyle\\left|x^*-x_k\\right|\\le\\frac{L^k}{1-L}\\left|x_1-x_0\\right|\\end{array}\\) 。由第一式分析误差；由第二式得到结论 \\(L\\) 越小，收敛越快 。","title":"2021-03-03-数值分析-Day06-非线性方程的迭代解法及收敛性"},{"content":"续：3.1 - 6 迭代法 逐次超松弛迭代法（SOR迭代法） 选取分裂矩阵 \\(M\\) 为带参数的下三角阵： \\(M=\\displaystyle\\frac{1}{\\omega}(D-\\omega L),\\ B=I-M^{-1}A,\\ f=M^{-1}b\\) ，其中 \\(w\u0026gt;0\\) 为可选择的松弛因子。\n构造迭代法，迭代矩阵为： \\(L_\\omega=I-\\omega(D-\\omega L)^{-1}A=(D-\\omega L)^{-1}((1-\\omega)D+\\omega U)\\) 。\n则解 \\(Ax=b\\) 的SOR方法即为： \\(\\begin{array}{l}\\left\\{\\begin{array}{l}x^{(0)}\\\\x^{(k+1)}=L_\\omega x^{(k)}+f\\quad(k=0,1,\\dots)\\end{array}\\right.\\\\其中\\begin{array}{l}L_\\omega=(D-\\omega L)^{-1}((1-\\omega)D+\\omega U),\\\\f=\\omega(D-\\omega L)^{-1}b\\end{array}\\end{array}\\) 。\n推导得： \\(\\begin{array}{l}(D-\\omega L)x^{(k+1)}=((1-\\omega)D+\\omega U)x^{(k)}+\\omega b\\\\或Dx^{(k+1)}=Dx^{(k+1)}+\\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\\end{array}\\) 。\n分量计算公式为： \\(\\displaystyle x_i^{(k+1)}=x_1^{(k)}+\\omega(b_i-\\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\\) 。\n可令 \\(\\Delta x_i=\\omega(b_i-\\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\\) ，则 \\(x_i^{(k+1)}=x_i^{(k)}+\\Delta x_i\\) 。\nGauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 \\(\\omega=1\\) ）。\n当 \\(\\omega\u0026lt;1\\) 时，称为超松弛法；当 \\(\\omega\u0026gt;1\\) 时，称为低松弛法。\n计算机中，常用 \\(\\max\\limits_{1\\le i\\le n}|\\Delta x_i|=\\max\\limits_{1\\le i\\le n}\\left|x_i^{(k+1)}-x_i^{(k)}\\right|\u0026lt;\\varepsilon\\) 或者 \\(\\left\\|r^{(k)}\\right\\|=\\left\\|b-Ax^{(k)}\\right\\|\\) 作为迭代终止条件。\n迭代法的收敛性 设 \\(Ax=b\\) ，其中 \\(A\\in R^{n\\times n}\\) 为非奇异矩阵，记 \\(x^*\\) 为原方程组精确解，且设有等价的方程组： \\(Ax=b\\Leftrightarrow x=Bx+f\\) ，则 \\(x^*=Bx^*+f\\) 。设有一阶定常迭代法 \\(x^{(k+1)}=Bx^{(k)}\\) 。引进误差向量 \\(\\varepsilon^{(k)}=x^{(k)}\\) ，得到误差向量递推公式 \\(\\varepsilon^{(k+1)}=B\\varepsilon^{(k)}\\ \\Rightarrow\\ \\varepsilon^{(k)}=B^k\\varepsilon^{(0)}\\) 。则研究问题从 \\(\\varepsilon^{(k)}\\to0\\) 转换为 \\(B^k\\to0\\) 。\n定理1： \\(\\lim\\limits_{x\\to\\infty}A_k=A\\Leftrightarrow\\lim\\limits_{x\\to\\infty}\\left\\|A_k-A\\right\\|,\\ \\|\\|为任一种算子范数\\)\n定理2： \\(\\lim\\limits_{x\\to\\infty}A_k=A\\Leftrightarrow\\lim\\limits_{x\\to\\infty}A_kx=Ax,\\ x\\in R^n\\)\n定理3： \\(\\lim\\limits_{x\\to\\infty}A_k=0\\Leftrightarrow\\rho(A)\u0026lt;1,\\ \\rho\\ 谱半径\\)\n迭代法收敛基本定理：对方程组 \\(x=Bx+f\\) ，及对应一阶定常迭代法 \\(x^{(k+1)}=Bx^{(k)}+f\\) ，迭代法收敛的充要条件为矩阵 \\(B\\) 的谱半径 \\(\\rho(B)\u0026lt;1\\) 。\n由于 \\(\\rho(B)\\le\\|B\\|\\) ，因此矩阵 \\(B\\) 的范数也可用于判别迭代法的收敛性：\n迭代法收敛充分条件： \\(\\exists \\|B\\|=q\u0026lt;1\\) ，迭代法收敛，且有 \\(\\begin{array}{l}\\left\\|x^*-x^{(k)}\\right\\|\\le q^k\\left\\|x^*-x^{(0)}\\right\\|\\\\\\left\\|x^*-x^{(k)}\\right\\|\\le\\displaystyle\\frac{q}{1-q}\\left\\|x^k-x^{(k-1)}\\right\\|\\\\\\left\\|x^*-x^{(k)}\\right\\|\\le\\displaystyle\\frac{q}{1-q^k}\\left\\|x^1-x^0\\right\\|\\end{array}\\) 。根据第二式也可得到迭代法的一种终止条件参考量： \\(\\left\\|x^k-x^{(k-1)}\\right\\|\\) 。\n几种特殊迭代法的收敛性 如果矩阵 \\(A\\) 的元素满足： \\(|a_{ii}|\u0026gt;\\displaystyle\\sum_{j=1,j\\neq i}^n|a_{ij}|,\\ (i=1,2,\\dots,n)\\) ，则称 \\(A\\) 为严格对角占优阵。\n若 \\(|a_{ii}|\\ge\\displaystyle\\sum_{j=1,j\\neq i}^n|a_{ij}|,\\ (i=1,2,\\dots,n)\\) ，且至少有一个不等式严格成立，则称 \\(A\\) 为弱对角占优阵。\n对角占优定理：若矩阵 \\(A\\) 为严格对角占优矩阵，则 \\(A\\) 为非奇异矩阵。\nJacobi和Gauss迭代法收敛的充分条件：对方程 \\(Ax=b\\) ，如果 \\(A\\) 为严格对角占优阵，则解该方程的Jacobi迭代法和Gauss-Seidel迭代法均收敛。\nSOR迭代法收敛的必要条件： \\(0\u0026lt;\\omega\u0026lt;2\\) 。\nSOR迭代法收敛的充分条件1：对方程 \\(Ax=b\\) ，如果 \\(A\\) 为对称正定矩阵， \\(0\u0026lt;\\omega\u0026lt;2\\) ，则解该方程的SOR迭代法收敛。\nSOR迭代法收敛的充分条件2：对方程 \\(Ax=b\\) ，如果 \\(A\\) 为严格对角占优矩阵（或弱对角占优不可约矩阵）， \\(0\u0026lt;\\omega\\le1\\) ，则解该方程的SOR迭代法收敛。\n代码：SOR迭代与两种终止条件 // // Created by xa on 2021-03-01. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;double\u0026gt; b; vector\u0026lt;double\u0026gt; x; vector\u0026lt;double\u0026gt; next_x; int size = 0; void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_); void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_, double omega); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_{{4, -2, -4}, {-2, 17, 10}, {-4, 10, 9}}; vector\u0026lt;double\u0026gt; b_{10, 3, -7}; iterate(A_, b_, 1.46); } void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) {iterate(A_,b_,1);} void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_, double omega) { if (omega \u0026lt;= 0 || omega \u0026gt;= 1) { std::cout \u0026lt;\u0026lt; \u0026quot;SOR does not converge !\u0026quot; \u0026lt;\u0026lt; std::endl; return; } A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; next_x(size); int k = 0; while (true) { for (int i = 0; i \u0026lt; size; ++i) { double tmp = b[i]; for (int j = 0; j \u0026lt; size; ++j) { if (j \u0026lt; i) tmp -= A[i][j] * next_x[j]; if (j \u0026gt;= i) tmp -= A[i][j] * x[j]; } next_x[i] = x[i] + omega * tmp / A[i][i]; } for (int i = 0; i \u0026lt; size; ++i) { x[i] = next_x[i]; std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026quot; 第\u0026quot;\u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot;次\u0026quot; \u0026lt;\u0026lt; std::endl; double r = 0; for (int i = 0; i \u0026lt; size; ++i) { double tmp = b[i]; for (int j = 0; j \u0026lt; size; ++j) tmp -= A[i][j] * x[j]; r += tmp * tmp; } if (r \u0026lt; 1e-10) break; ++k; } } void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_, double omega) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; next_x(size); int k = 0; while (true) { for (int i = 0; i \u0026lt; size; ++i) { double tmp = b[i]; for (int j = 0; j \u0026lt; size; ++j) { if (j \u0026lt; i) tmp -= A[i][j] * next_x[j]; if (j \u0026gt;= i) tmp -= A[i][j] * x[j]; } next_x[i] = x[i] + omega * tmp / A[i][i]; } double maxDelta = std::abs(*(std::max_element(std::begin(next_x), std::end(next_x))) - *(std::max_element(std::begin(x), std::end(x)))); std::cout \u0026lt;\u0026lt; maxDelta \u0026lt;\u0026lt; \u0026quot; | \u0026quot;; for (int i = 0; i \u0026lt; size; ++i) { x[i] = next_x[i]; std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026quot; 第\u0026quot;\u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot;次\u0026quot; \u0026lt;\u0026lt; std::endl; if (maxDelta \u0026lt; 1e-3) break; ++k; } } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-02-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day05-sor-%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%94%B6%E6%95%9B%E6%80%A7/","summary":"续：3.1 - 6 迭代法 逐次超松弛迭代法（SOR迭代法） 选取分裂矩阵 \\(M\\) 为带参数的下三角阵： \\(M=\\displaystyle\\frac{1}{\\omega}(D-\\omega L),\\ B=I-M^{-1}A,\\ f=M^{-1}b\\) ，其中 \\(w\u0026gt;0\\) 为可选择的松弛因子。\n构造迭代法，迭代矩阵为： \\(L_\\omega=I-\\omega(D-\\omega L)^{-1}A=(D-\\omega L)^{-1}((1-\\omega)D+\\omega U)\\) 。\n则解 \\(Ax=b\\) 的SOR方法即为： \\(\\begin{array}{l}\\left\\{\\begin{array}{l}x^{(0)}\\\\x^{(k+1)}=L_\\omega x^{(k)}+f\\quad(k=0,1,\\dots)\\end{array}\\right.\\\\其中\\begin{array}{l}L_\\omega=(D-\\omega L)^{-1}((1-\\omega)D+\\omega U),\\\\f=\\omega(D-\\omega L)^{-1}b\\end{array}\\end{array}\\) 。\n推导得： \\(\\begin{array}{l}(D-\\omega L)x^{(k+1)}=((1-\\omega)D+\\omega U)x^{(k)}+\\omega b\\\\或Dx^{(k+1)}=Dx^{(k+1)}+\\omega(b+Lx^{(k+1)}+Ux^{(k)}-Dx^{(k)})\\end{array}\\) 。\n分量计算公式为： \\(\\displaystyle x_i^{(k+1)}=x_1^{(k)}+\\omega(b_i-\\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\\) 。\n可令 \\(\\Delta x_i=\\omega(b_i-\\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\\sum_{j=i}^{n}a_{ij}x_j^{(k)})/a_{ii}\\) ，则 \\(x_i^{(k+1)}=x_i^{(k)}+\\Delta x_i\\) 。\nGauss-Seidel迭代法是SOR迭代法的一个特殊形式（系数 \\(\\omega=1\\) ）。\n当 \\(\\omega\u0026lt;1\\) 时，称为超松弛法；当 \\(\\omega\u0026gt;1\\) 时，称为低松弛法。\n计算机中，常用 \\(\\max\\limits_{1\\le i\\le n}|\\Delta x_i|=\\max\\limits_{1\\le i\\le n}\\left|x_i^{(k+1)}-x_i^{(k)}\\right|\u0026lt;\\varepsilon\\) 或者 \\(\\left\\|r^{(k)}\\right\\|=\\left\\|b-Ax^{(k)}\\right\\|\\) 作为迭代终止条件。\n迭代法的收敛性 设 \\(Ax=b\\) ，其中 \\(A\\in R^{n\\times n}\\) 为非奇异矩阵，记 \\(x^*\\) 为原方程组精确解，且设有等价的方程组： \\(Ax=b\\Leftrightarrow x=Bx+f\\) ，则 \\(x^*=Bx^*+f\\) 。设有一阶定常迭代法 \\(x^{(k+1)}=Bx^{(k)}\\) 。引进误差向量 \\(\\varepsilon^{(k)}=x^{(k)}\\) ，得到误差向量递推公式 \\(\\varepsilon^{(k+1)}=B\\varepsilon^{(k)}\\ \\Rightarrow\\ \\varepsilon^{(k)}=B^k\\varepsilon^{(0)}\\) 。则研究问题从 \\(\\varepsilon^{(k)}\\to0\\) 转换为 \\(B^k\\to0\\) 。","title":"2021-03-02-数值分析-Day05-SOR-迭代法收敛性"},{"content":"Lecture 7-8 Real-time Global Illumination （3D GI） Introduction GI is complex\nRay tracing … Hack方法：Blinn-Phong——统一大小的Ambient项 in RTR：直接光照 + 一次间接光照\n一次间接光照：Q点接收到直接光照后，作为次级光源照射P点的结果 核心问题：\n要计算间接光照需要知道\n被直接光照照亮的表面有哪些？ / 哪些是次级光源？ 借助Shadow Map 每一个次级光源的“贡献”是多少？ 求和 每一个次级光源作为一个Area Light Reflective Shadow Maps (RSM) 获得光源的Shadow Map，存储光源“可见”的深度/世界坐标/法线/Flux等（即Reflective Shadow Maps），视作多个多个点次级光源，eg. Reflective Shadow Maps为512*512，则有512*512个点光源。 次级光源的反射方向未知——假定次级光源物体材质均为Diffuse。（不假设接收物为Diffuse） Recall 一个Patch（Reflective Shadow Maps的一个像素）的“贡献\n\\[ \\begin{array}{l}\\begin{aligned}L_o(\\mathrm p,\\omega_0)\u0026amp;=\\int_{\\Omega_\\mathrm{patch}}L_i(\\mathrm p,\\omega_i)V(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d \\omega_i\\\\ \u0026amp;=\\int_{A_\\mathrm{patch}}L_i(\\mathrm q\\rightarrow \\mathrm p)V(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\mathrm q\\rightarrow \\mathrm p,\\omega_0)\\dfrac{\\cos\\theta_p\\cos\\theta_q}{\\|q-p\\|^2}\\,\\mathrm d A \\end{aligned}\\\\\\\\ f_r=\\dfrac{\\rho}{\\pi}\\\\ L_i=f_r\\cdot\\dfrac{\\Phi}{\\mathrm d A}\\quad(\\Phi\\ \\text{is the incident flux / energy}) \\end{array} \\] 故对每个Reflective Shadow Maps的像素只需存储其 \\(\\Phi\\) ， \\(\\mathrm d A\\) 在积分中被约掉； 由于计算复杂、忽略次级光源的Visibility项。 则有：（原论文中为 \\(P\\rightarrow Q\\) ，故论文中原式为下式中 \\(q\\) 换成 \\(p\\) ） \\[ E_q(x,n)=\\Phi_q\\dfrac{\\max\\{0,\\langle n_q|x-x_q\\rangle \\}\\max\\{0,\\langle n|x_q-x\\rangle \\}}{\\|x-x_q\\|^4} \\]\nReflective Shadow Maps中不是每一个像素都可以作为次级光源有“贡献”：\nVisibility 遮挡，但该项计算复杂，影响不大，故忽略 Orientation 方向，例如下图 \\(x_{-1}\\) 对 \\(x\\) 无光照 Distance 距离 -\u0026gt; 减少计算量的方法 ↓ 假设：以Reflective Shadow Maps上的距离近似世界坐标的距离 参考PCSS，降低Shadow Map作为次级光源的采样 对一个Shadow Map，约400个采样 优势：易于实现 问题：性能开销与直接光源数量成正比 / 间接光照不考虑可见性（不真实） / 大量假设 / 采样率和质量的权衡\n非常类似离线渲染中的VPL(Virtual Point Light)方法\nLight Propagation Volumes (LPV) 关键问题：着色点收到所有方向的间接光照 关键想法：Radiance沿直线传播，且在空间中传播时不会变化 解决思路：用体素传播Radiance\n步骤：\n获取次级光源\n利用RSM，采样以减少数量 将次级光源的Radiance“注入”到空间网格/体素中\n预分割三维网格（eg. 3D texture） 对每个网格，找到接近的次级光源 求次级光源接收的直接光照Radiance分布和（空间分布） 用二阶SH函数（4个数值）压缩Radiance空间分布（近似） 在网格中传播Radiance\n空间上向周围6个面传播，周边网格也用二阶SH表示 迭代4-5次基本达到稳定 在着色点处读取对应体素的Radiance参与渲染\n问题：\n由于粒度不够小（至少比画面分辨率小一个数量级），会传播到物体背面/侧面 -\u0026gt; Light Leaking 同样不考虑Visibility Cascaded / Multiscale / LoD: 用自适应粒度的网格\nVoxel Global Illumination (VXGI) 2 Pass Algorithm Differences with RSM:\n直接光照对象 / 次级光源 pixel -\u0026gt; (hierarchical) voxels （层级结构的体素，大小层级，建立树结构存储） RSM中的采样 -\u0026gt; 对每个Shading Point作圆锥形trace，计算trace到的voxels Voxelize the scene \u0026amp; Build a hierachy\nPass 1 : Light Pass\n存储光源的入射分布、法线分布，再在trace时计算出射分布（比LPV中视作Diffuse使用SH压缩存储准确，可以支持Glossy材质） 在hiearchy中更新 Pass 2 : Camera Pass\n对Glossy材质，向反射方向作cone trace\n基于cone的大小遍历hierarchy，找到相近大小的块再求和 PS：对Diffuse材质，求能覆盖表面的多个cone trace（eg.8个，空隙可忽略） 问题：计算量较大、实时体素化开销较大\n","permalink":"https://elderlyaugustus.github.io/posts/2022-03-02-games202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-lecture7-8-3dgi/","summary":"Lecture 7-8 Real-time Global Illumination （3D GI） Introduction GI is complex\nRay tracing … Hack方法：Blinn-Phong——统一大小的Ambient项 in RTR：直接光照 + 一次间接光照\n一次间接光照：Q点接收到直接光照后，作为次级光源照射P点的结果 核心问题：\n要计算间接光照需要知道\n被直接光照照亮的表面有哪些？ / 哪些是次级光源？ 借助Shadow Map 每一个次级光源的“贡献”是多少？ 求和 每一个次级光源作为一个Area Light Reflective Shadow Maps (RSM) 获得光源的Shadow Map，存储光源“可见”的深度/世界坐标/法线/Flux等（即Reflective Shadow Maps），视作多个多个点次级光源，eg. Reflective Shadow Maps为512*512，则有512*512个点光源。 次级光源的反射方向未知——假定次级光源物体材质均为Diffuse。（不假设接收物为Diffuse） Recall 一个Patch（Reflective Shadow Maps的一个像素）的“贡献\n\\[ \\begin{array}{l}\\begin{aligned}L_o(\\mathrm p,\\omega_0)\u0026amp;=\\int_{\\Omega_\\mathrm{patch}}L_i(\\mathrm p,\\omega_i)V(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\omega_i,\\omega_0)\\cos\\theta_i\\,\\mathrm d \\omega_i\\\\ \u0026amp;=\\int_{A_\\mathrm{patch}}L_i(\\mathrm q\\rightarrow \\mathrm p)V(\\mathrm p,\\omega_i)f_r(\\mathrm p,\\mathrm q\\rightarrow \\mathrm p,\\omega_0)\\dfrac{\\cos\\theta_p\\cos\\theta_q}{\\|q-p\\|^2}\\,\\mathrm d A \\end{aligned}\\\\\\\\ f_r=\\dfrac{\\rho}{\\pi}\\\\ L_i=f_r\\cdot\\dfrac{\\Phi}{\\mathrm d A}\\quad(\\Phi\\ \\text{is the incident flux / energy}) \\end{array} \\] 故对每个Reflective Shadow Maps的像素只需存储其 \\(\\Phi\\) ， \\(\\mathrm d A\\) 在积分中被约掉； 由于计算复杂、忽略次级光源的Visibility项。 则有：（原论文中为 \\(P\\rightarrow Q\\) ，故论文中原式为下式中 \\(q\\) 换成 \\(p\\) ） \\[ E_q(x,n)=\\Phi_q\\dfrac{\\max\\{0,\\langle n_q|x-x_q\\rangle \\}\\max\\{0,\\langle n|x_q-x\\rangle \\}}{\\|x-x_q\\|^4} \\]","title":"2022-03-02-GAMES202高质量实时渲染-Lecture7-8-3DGI"},{"content":"3.1 - 6 迭代法 基本思想 对线性方程组 \\(Ax=b\\) ，当 \\(A\\) 为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。\n工程应用中 \\(A\\) 常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。\n通法：\n将 \\(Ax=b\\) 改写为 \\(x=B_0x+f\\) 任取初始值，如 \\(x^{(0)}=(0,0,0)^T\\) ，将其带入得到方程组解 \\(x^{(1)}=B_0x^{(0)}+f\\) 依次得： \\(x^{(2)}=B_0x^{(1)}+f,\\ x^{(2)}=B_0x^{(1)}+f,\\ \\dots,\\ x^{(k)}=B_0x^{(k-1)}+f,\\ \\dots\\) 即得向量序列 \\(x^{(0)},x^{(1)},\\dots,x^{(k)}\\) ，迭代公式 \\(x^{(k)}=B_0x^{(k-1)}+f\\) 迭代次数较高时，向量序列 \\(x^{(k)}\\) 有可能收敛至逼近精确解的值（不一定）。 根据 \\(x=Bx+f\\) 变形方式的不同，存在多种迭代算法。\n定义1：\n对于给定方程组 \\(x=Bx+f\\) ，用公式 \\(x^{k+1}=Bx^{(k)}+f,\\ (k=0,1,2,3,\\dots)\\) 逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 \\(B\\) 与 \\(k\\) 无关）。\n如果 \\(\\lim\\limits_{k\\to\\infty}x^{(k)}=x^*\\) ，即向量序列收敛至精确解序列，则称此迭代法收敛，否则称发散。\n由于需要研究 \\(\\{x^{(k)}\\}\\) 的收敛性，引进误差向量 \\(\\varepsilon^{(k+1)}=x^{(k+1)}-x^*\\) 。易得到： \\(\\varepsilon^{(k+1)}=B\\varepsilon^{(k)}\\) ，递推得： \\(\\varepsilon^{(k)}=B\\varepsilon^{(k-1)}=\\dots=B^k\\varepsilon^{(0)}\\) 。\nJacobi迭代 通法细节：\n将 \\(A\\) 分裂成 \\(A=M-N\\) ，其中 \\(M\\) 为可选择的非奇异矩阵，使 \\(Mx=d\\) 易解，一般选择为 \\(A\\) 的某种近似，称 \\(M\\) 为分裂矩阵。\n则原方程 \\(Ax=b\\) 转化为 \\(Mx=Nx+b\\) ，即求解： \\(x=M^{-1}Nx+M^{-1}b\\) 。\n可构造一阶定常迭代法： \\[ \\left\\{\\begin{array}{l}x^{(0)}\\\\x^{(k+1)}=Bx^{(k)}+f\\ (k=0,1,\\dots)\\end{array}\\right.\\\\ B=M^{-1}N=M^{-1}(M-A)=I-M^{-1}A,\\quad f=M^{-1}b \\] 称 \\(B=I-M^{-1}A\\) 为迭代法的迭代矩阵，选取 \\(M\\) 阵就得到 \\(Ax=b\\) 的各种迭代法。\nJacobbi迭代：\n设 \\(a_{ii}\\neq0(i=1,2,\\dots,n)\\) ，并将 \\(A\\) 写成三部分： \\[ \\begin{aligned}A\u0026amp;=\\begin{pmatrix} a_{11}\\\\ \u0026amp;a_{22}\\\\ \u0026amp;\u0026amp;\\ddots\\\\ \u0026amp;\u0026amp;\u0026amp;a_{nn} \\end{pmatrix}\\\\ \u0026amp;-\\begin{pmatrix} 0\\\\ -a_{21}\u0026amp;0\\\\ \\vdots\u0026amp;\\vdots\u0026amp;\\ddots\\\\ -a_{n-1,1}\u0026amp;-a_{n-1,2}\u0026amp;\\cdots\u0026amp;0\\\\ -a_{n,1}\u0026amp;-a_{n,2}\u0026amp;\\cdots\u0026amp;-a_{n,n-1}\u0026amp;0 \\end{pmatrix}\\\\ \u0026amp;-\\begin{pmatrix} 0\u0026amp;-a_{12}\u0026amp;\\cdots\u0026amp;-a_{1,n-1}\u0026amp;-a_{1,n}\\\\ \u0026amp;0\u0026amp;\\cdots\u0026amp;-a_{2,n-1}\u0026amp;-a_{2,n}\\\\ \u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\u0026amp;\\vdots\\\\ \u0026amp;\u0026amp;\u0026amp;0\u0026amp;-a_{n-1,n}\\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;0 \\end{pmatrix}\\\\ \u0026amp;\\equiv D-L-U \\end{aligned} \\] 由此，当 \\(a_{ii}\\neq0(i=1,2,\\dots,n)\\) 时，选取 \\(M\\) 为 \\(A\\) 的对角元素部分，即选取 \\(M=D\\) ，\\(A=D-N\\) ，即得到 \\(Ax=b\\) 的Jacobi迭代法。 \\[ \\begin{aligned}\u0026amp;\\left\\{\\begin{array}{l}x^{(0)}\\\\x^{(k+1)}=Bx^{(k)}+f\\ (k=0,1,\\dots)\\end{array}\\right.\\\\ \u0026amp;其中\\ \\begin{aligned}\u0026amp;B=D^{-1}(L+U)\\equiv J\\\\ \u0026amp;f=D^{-1}b\\end{aligned}\\end{aligned} \\] 称 \\(J\\) 为Jacobi迭代法的迭代矩阵。\nJacobi迭代法的分量计算公式： 记 \\(x^{(k)}=(x_1^{(k)},x_2^{(k)},\\dots,x_n^{(k)})\\) ，则有： \\[ \\begin{array}{l} \\begin{aligned}Dx^{k+1}\u0026amp;=(L+U)x^{(k)}+b a_{ii}x_i^{k+1}\\\\\u0026amp;=-\\sum\\limits_{j=1}^{i-1}a_{ij}x_j^{(k)}-\\sum\\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}+b_i\\quad(i=1,2,\\dots,n)\\end{aligned}\\\\ B=I-M^{-1}A,\\ f=M^{-1}b \\end{array} \\] 因此，解 \\(Ax=b\\) 的Jacobi迭代法的计算公式为： \\[ \\left\\{\\begin{array}{l} x^{(0)}=(x_1^{(0)},\\dots,x_i^{(0)},\\dots,x_n^{(0)})^T\\\\ x_i^{(k+1)}=(b_i-\\sum\\limits_{j=1,j\\neq i}^na_{ij}x_j^{(k)})/a_{ii}\\\\ i=1,2,\\dots,n\\\\ k=0,1,\\dots\\ 表示迭代次数 \\end{array}\\right. \\] 矩阵表示为： \\[ \\begin{array}{l} Ax=b\\Leftrightarrow(D-L-U)x=b\\Leftrightarrow Dx=(L+U)x+b\\\\ \\begin{aligned}Dx\u0026amp;=\\begin{pmatrix} a_{11}\\\\ \u0026amp;a_{22}\\\\ \u0026amp;\u0026amp;\\ddots\\\\ \u0026amp;\u0026amp;\u0026amp;a_{nn} \\end{pmatrix} \\begin{pmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{pmatrix}\\\\ \u0026amp;=\\begin{pmatrix} 0\u0026amp;-a_{12}\u0026amp;\\cdots\u0026amp;-a_{1,n-1}\u0026amp;-a_{1,n}\\\\ -a_{21}\u0026amp;0\u0026amp;\\cdots\u0026amp;-a_{2,n-1}\u0026amp;-a_{2,n}\\\\ \\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\u0026amp;\\vdots\\\\ -a_{n-1,1}\u0026amp;-a_{n-1,2}\u0026amp;\\cdots\u0026amp;0\u0026amp;-a_{n-1,n}\\\\ -a_{n,1}\u0026amp;-a_{n,2}\u0026amp;\\cdots\u0026amp;-a_{n,n-1}\u0026amp;0 \\end{pmatrix} \\begin{pmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{pmatrix}+b\\\\ \u0026amp;=(L+U)x+b \\end{aligned}\\end{array} \\]\nGauss-Seidel迭代法 改进Jacobi迭代法：选取分裂矩阵 \\(M\\) 为 \\(A\\) 的下三角部分，即 \\(M=D-L\\) ， \\(A=M-U\\) ，得到： \\[ \\begin{array}{l}\\left\\{\\begin{array}{l}x^{(0)}\\quad初始向量\\\\x^{(k+1)}=Bx^{(k)}+f\\quad (k=0,1,\\dots)\\end{array}\\right.\\\\ B=I-(D-L^{-1})A=(D-L)^{-1}U\\equiv G,\\quad f=(D-L)^{-1}b\\end{array} \\] 称 \\(G\\) 为Gauss-Seidel迭代法的迭代矩阵。\n分量计算公式： \\[ \\begin{array}{l}Dx^{(k+1)}=Dx^{(k)}-(Lx^{(k+1)}+Ux^{k}-Dx^{(k)}+b)\\\\\\\\ \\left\\{\\begin{array}{l} x_1^{(k+1)}=\\displaystyle-\\frac{a_{12}}{a_{11}}x_2^{(k)}-\\frac{a_{13}}{a_{11}}x_3^{(k)}-\\dots-\\frac{a_{1n}}{a_{11}}x_n^{(k)}+\\frac{b_2}{a_{22}}\\\\ x_2^{(k+1)}=\\displaystyle-\\frac{a_{21}}{a_{22}}x_2^{(k+1)}-\\frac{a_{23}}{a_{22}}x_3^{(k)}-\\dots-\\frac{a_{2n}}{a_{22}}x_n^{(k)}+\\frac{b_2}{a_{22}}\\\\ x_3^{(k+1)}=\\displaystyle-\\frac{a_{31}}{a_{33}}x_2^{(k+1)}-\\frac{a_{32}}{a_{33}}x_3^{(k+1)}-\\dots-\\frac{a_{3n}}{a_{33}}x_n^{(k)}+\\frac{b_3}{a_{33}}\\\\ \\dots\\\\ x_n^{(k+1)}=\\displaystyle-\\frac{a_{n1}}{a_{nn}}x_2^{(k+1)}-\\frac{a_{n2}}{a_{nn}}x_3^{(k+1)}-\\dots-\\frac{a_{n,n-1}}{a_{nn}}x_n^{(k+1)}+\\frac{b_n}{a_{nn}}\\\\ \\end{array}\\right.\\\\ 即\\ \\displaystyle{x_i^{k+1}=\\frac{b_n-\\sum\\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\\sum\\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}}{a_{ii}}}\\end{array} \\]\n代码：Jacobi迭代 // // Created by xa on 2021-03-01. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;double\u0026gt; b; vector\u0026lt;double\u0026gt; x; vector\u0026lt;double\u0026gt; next_x; int size = 0; void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_{{10, 3, 1}, {2, -10, 3}, {1, 3, 10}}; vector\u0026lt;double\u0026gt; b_{14, -5, 14}; iterate(A_, b_); } void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; next_x(size); int k = 0; while (true) { for (int i = 0; i \u0026lt; size; ++i) { double tmp = b[i]; for (int j = 0; j \u0026lt; size; ++j) if (j != i) tmp -= A[i][j] * x[j]; next_x[i] = tmp / A[i][i]; } for (int i = 0; i \u0026lt; size; ++i) { x[i] = next_x[i]; std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026quot; 第\u0026quot;\u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot;次\u0026quot; \u0026lt;\u0026lt; std::endl; if (k \u0026gt; 100) break; ++k; } } 代码：Gauss-Seidel迭代 /***区别***/ //Jacobi for (int j = 0; j \u0026lt; size; ++j) if (j != i) tmp -= A[i][j] * x[j]; //Gauss-Seidel for (int j = 0; j \u0026lt; size; ++j) { if (j \u0026lt; i) tmp -= A[i][j] * next_x[j]; if (j \u0026gt; i) tmp -= A[i][j] * x[j]; } // // Created by xa on 2021-03-01. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;double\u0026gt; b; vector\u0026lt;double\u0026gt; x; vector\u0026lt;double\u0026gt; next_x; int size = 0; void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_{{10, 3, 1}, {2, -10, 3}, {1, 3, 10}}; vector\u0026lt;double\u0026gt; b_{14, -5, 14}; iterate(A_, b_); } void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; next_x(size); int k = 0; while (true) { for (int i = 0; i \u0026lt; size; ++i) { double tmp = b[i]; for (int j = 0; j \u0026lt; size; ++j) { if (j \u0026lt; i) tmp -= A[i][j] * next_x[j]; if (j \u0026gt; i) tmp -= A[i][j] * x[j]; } next_x[i] = tmp / A[i][i]; } for (int i = 0; i \u0026lt; size; ++i) { x[i] = next_x[i]; std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026quot; 第\u0026quot;\u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026quot;次\u0026quot; \u0026lt;\u0026lt; std::endl; if (k \u0026gt; 100) break; ++k; } } ","permalink":"https://elderlyaugustus.github.io/posts/2021-03-01-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day04-jacobi-gaussseidel/","summary":"3.1 - 6 迭代法 基本思想 对线性方程组 \\(Ax=b\\) ，当 \\(A\\) 为低阶稠密矩阵时，选主元Gauss消去/Doolittle分解均为有效方法。\n工程应用中 \\(A\\) 常为高阶稀疏矩阵，适用迭代法求解：利好计算机存储与性能。\n通法：\n将 \\(Ax=b\\) 改写为 \\(x=B_0x+f\\) 任取初始值，如 \\(x^{(0)}=(0,0,0)^T\\) ，将其带入得到方程组解 \\(x^{(1)}=B_0x^{(0)}+f\\) 依次得： \\(x^{(2)}=B_0x^{(1)}+f,\\ x^{(2)}=B_0x^{(1)}+f,\\ \\dots,\\ x^{(k)}=B_0x^{(k-1)}+f,\\ \\dots\\) 即得向量序列 \\(x^{(0)},x^{(1)},\\dots,x^{(k)}\\) ，迭代公式 \\(x^{(k)}=B_0x^{(k-1)}+f\\) 迭代次数较高时，向量序列 \\(x^{(k)}\\) 有可能收敛至逼近精确解的值（不一定）。 根据 \\(x=Bx+f\\) 变形方式的不同，存在多种迭代算法。\n定义1：\n对于给定方程组 \\(x=Bx+f\\) ，用公式 \\(x^{k+1}=Bx^{(k)}+f,\\ (k=0,1,2,3,\\dots)\\) 逐步代入求近似解的方法称为迭代法（或称为一阶定常迭代法，这里 \\(B\\) 与 \\(k\\) 无关）。\n如果 \\(\\lim\\limits_{k\\to\\infty}x^{(k)}=x^*\\) ，即向量序列收敛至精确解序列，则称此迭代法收敛，否则称发散。\n由于需要研究 \\(\\{x^{(k)}\\}\\) 的收敛性，引进误差向量 \\(\\varepsilon^{(k+1)}=x^{(k+1)}-x^*\\) 。易得到： \\(\\varepsilon^{(k+1)}=B\\varepsilon^{(k)}\\) ，递推得： \\(\\varepsilon^{(k)}=B\\varepsilon^{(k-1)}=\\dots=B^k\\varepsilon^{(0)}\\) 。\nJacobi迭代 通法细节：\n将 \\(A\\) 分裂成 \\(A=M-N\\) ，其中 \\(M\\) 为可选择的非奇异矩阵，使 \\(Mx=d\\) 易解，一般选择为 \\(A\\) 的某种近似，称 \\(M\\) 为分裂矩阵。","title":"2021-03-01-数值分析-Day04-Jacobi-GaussSeidel"},{"content":"2.9-11 范数 为研究线性方程组近似解的误差估计和迭代法的收敛性，对 \\(R……n\\) （ \\(n\\) 维向量空间）中的向量（ \\(R^{n\\times n}\\) 中的矩阵）的“大小”引进度量——向量（或矩阵）的范数。\n向量的范数 定义1：设 \\(x=(x_1,x_2,\\dots,x_n)^T,y=(y_1,y_2,\\dots,y_n)^T\\in R^n (or\\ C^n)\\)\n将实数 \\((x,y)=y^Tx=\\sum_{i=1}^{n}x_i\\overline{y_i}\\)（或复数 \\((x,y)=y^Hx=\\sum_{i=1}^{n}x_iy_i\\) ）称为向量x,y的数量积（内积）。\n将非负实数 \\(\\|x\\|_2=(x,x)^{1\\over2}=(\\sum_{i=1}^{n}x_i^2)^{1\\over2}\\) 或 \\(\\|x\\|_2=(x,x)^{1\\over2}=(\\sum_{i=1}^{n}|x_i|^2)^{1\\over2}\\) 称为向量 \\(x\\) 的欧式范数。\n引理：向量的内积运算支持交换律、分配律、与实数乘时的结合律。\nCauchy-Schwarz不等式 \\(|(x,y)|\\le \\|x\\|_2\\cdot\\|y\\|_2\\) 当且仅当 \\(x\\) 与 \\(y\\) 线性相关时取等。\n三角不等式 \\(\\|x+y\\|_2\\le\\|x\\|_2+\\|y\\|_2\\)\n定义2-向量的范数：若向量 \\(x\\in R^n\\) （或 \\(C^n\\) ）的某个实值函数 \\(N(x)=\\|x\\|\\) ，满足条件： \\[ \\begin{aligned} \u0026amp; (1)\\ \\|x\\|\\ge 0\\ (\\|x\\|=0当且仅当x=0)\\quad\\textbf{正定条件}\\\\ \u0026amp; (2)\\ \\|\\alpha x\\|=|\\alpha|\\|x\\|,\\ \\forall\\alpha\\in R(或\\alpha\\in C)\\quad\\textbf{齐次性}\\\\ \u0026amp; (3)\\ \\|x+y\\|_2\\le\\|x\\|_2+\\|y\\|_2\\quad\\textbf{三角不等式}\\\\ \u0026amp; (3\\to 4)\\ \\|x-y\\|_2\\ge\\|x\\|_2-\\|y\\|_2 \\end{aligned} \\] 则称 \\(N(x)\\) 是 \\(R^n\\) （或 \\(C^n\\) ）上的一个向量范数（或模）\n几种常用的向量范数：\n向量的 \\(\\infty\\) -范数（最大范数）： \\(\\displaystyle{\\|x\\|_\\infty=\\max\\limits_{1\\le i\\le n}|x_i|}\\) 向量的 \\(1\\) -范数： \\(\\displaystyle{\\|x\\|_1=\\sum_{i=1}^{n}|x_i|}\\) 向量的 \\(2\\) -范数： \\(\\displaystyle{\\|x\\|_2=(x,x)^{1\\over2}=(\\sum_{i=1}^{n}x_i^2)^{1\\over2}}\\) 向量的 \\(p\\) -范数： \\(\\displaystyle{\\|x\\|_p=(\\sum_{i=1}^{n}|x_i|^p)^{1\\over p}}\\) 向量的 \\(\\infty\\) -范数（最大范数）： \\(\\displaystyle{\\|x\\|_{-\\infty}=\\min\\limits_{1\\le i\\le n}|x_i|}\\) 向量的 \\(0\\) -范数：向量的非零元素个数 向量的收敛性：设 \\(\\{x^{(k)}\\}\\) 为 \\(R^n\\) 中的一个向量序列， \\(x^*\\in R^n\\) ，记 \\(x^{(k)}=(x_1^{(k)}=(x_1^{(k)},x_2^{(k)},\\dots,x_n^{(k)})^T\\, x^*=(x_1^*,x_2^*,\\dots,x_n^*)^T\\) 。 若 \\(\\lim\\limits_{k\\to\\infty}x_i^{(k)}=x_i^*(i=1,2,\\dots,n)\\) ，则称 \\(x^{(k)}\\) 收敛于 \\(x^*\\) ，记为 \\(\\lim\\limits_{k\\to\\infty}x_i^{(k)}=x^*\\) 。\n范数的连续性：设非负函数 \\(N(x)=\\|x\\|\\) 为 \\(R^n\\) 上任一向量范数，则 \\(N(x)\\) 是 \\(x\\) 的分量 \\(x_1,x_2,\\dots,x_n\\) 的连续函数。 \\(x\\) 有很小变化时，同时 \\(N(x)\\) 亦变化不大。\n向量范数的等价性：设 \\(\\|x\\|_s,\\|x\\|_t\\) 为 \\(R^n\\) 上向量的任意两种范数，则存在常数 \\(c_1,c_2\u0026gt;0\\) ，使得对一切 \\(x\\in R^n\\) 有 \\(c_1\\|x\\|_s\\le\\|x\\|_t\\le c_2\\|x\\|_s\\) 。\n矩阵的范数 方阵 定义1：若矩阵 \\(A\\in R^{n\\times n}\\) 的某个非负实值函数 \\(N(A)=\\|A\\|\\) 满足条件：\n\\[ \\begin{aligned} \u0026amp; (1)\\ \\|A\\|\\ge 0\\ (\\|A\\|=0\\Leftrightarrow A=0)\\quad\\textbf{正定条件}\\\\ \u0026amp; (2)\\ \\|c A\\|=|c|\\|A\\|,\\ c为实数\\quad\\textbf{齐次性}\\\\ \u0026amp; (3)\\ \\|A+B\\|\\le\\|A\\|+\\|B\\|\\quad\\textbf{三角不等式}\\\\ \u0026amp; (4)\\ \\|AB\\|\\le\\|A\\|\\|B\\| \\end{aligned} \\] 则称 \\(N(A)\\) 是 \\(R^{n\\times n}\\) 上的一个矩阵范数（或模）。\n定义2-矩阵的算子范数：设 \\(x\\in R^n, A\\in R^{n\\times n}\\) ，给出一种向量范数 \\(\\|x\\|_\\nu,\\ (如\\nu=1,2,\\infty,\\dots)\\) ，相应地定义一个矩阵的非负函数： \\(\\displaystyle{\\|A\\|_\\nu=\\max\\limits_{x\\neq0}\\frac{\\|Ax\\|_\\nu}{\\|x\\|_\\nu}}\\) ，可验证该非负函数为矩阵 \\(A\\) 的范数，称之为矩阵 \\(A\\) 的算子范数。\n定理： \\(\\|Ax\\|_\\nu\\le\\|A\\|_\\nu\\|x\\|_\\nu\\)\n几种常用的矩阵范数：\nFrobenius范数（F范数）： \\(\\displaystyle{F(A)=\\|A\\|_F=\\left(\\sum\\limits_{i,j=1}^{n}a_{i,j}^2\\right)^{1\\over2}}\\) ，由向量的 \\(2\\) -范数推广而来 行范数（\\(\\infty\\) -范数）： \\(\\displaystyle{\\|A\\|_\\infty=\\max\\limits_{1\\le i\\le n}\\sum\\limits_{j=1}^{n}|a_{i,j}|}\\) 列范数（ \\(1\\) -范数）： \\(\\displaystyle{\\|A\\|_1=\\max\\limits_{1\\le j\\le n}\\sum\\limits_{i=1}^{n}|a_{i,j}|}\\) 谱范数（ \\(2\\) -范数）： \\(\\displaystyle{\\|A\\|_2=\\sqrt{\\lambda_{\\max}(A^TA)},\\ (\\lambda为特征值)}\\) 非方阵 矩阵 \\(A_{mn}\\)\nFrobenius范数（F范数）： \\(\\displaystyle{F(A)=\\|A\\|_F=\\left(\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{n}a_{i,j}^2\\right)^{1\\over2}}\\) ，由向量的 \\(2\\) -范数推广而来 行范数（\\(\\infty\\) -范数）： \\(\\displaystyle{\\|A\\|_\\infty=\\max\\limits_{1\\le i\\le n}\\sum\\limits_{j=1}^{n}|a_{i,j}|}\\) 列范数（ \\(1\\) -范数）： \\(\\displaystyle{\\|A\\|_1=\\max\\limits_{1\\le j\\le n}\\sum\\limits_{i=1}^{m}|a_{i,j}|}\\) 谱范数（ \\(2\\) -范数）： \\(\\displaystyle{\\|A\\|_2=\\sqrt{\\lambda_{\\max}(A^TA)},\\ (\\lambda为特征值)}\\) 2.12 谱半径 特征值和特征向量 \\(Ax=\\lambda x\\) 常数 \\(\\lambda\\) 为特征值，矩阵 \\(A\\) 为特征向量，且为方阵。 计算方法： \\(\\det(A-\\lambda I)=0\\)\n定义：设 \\(A\\in R^{n\\times n}\\) 的特征值为 \\(\\lambda_i(i=1,2,\\dots,n)\\) ，称 \\(\\rho(A)=\\max\\limits_{1\\le i\\le n}|\\lambda_i|\\) 为 \\(A\\) 的谱半径。\n定理：\n设 \\(A\\in R^{n\\times n}\\) ，则 \\(\\rho(A)\\le\\|A\\|\\) ，即矩阵的谱半径不超过矩阵的任何一种算子范数（对F范数也成立）。 若 \\(A\\in R^{n\\times n}\\) 为对称矩阵，则 \\(\\rho(A)=\\|A\\|_2\\) 。 若 \\(\\|B\\|\u0026lt;1\\) ，则 \\(I+B\\) 为非奇异矩阵，且 \\(\\left\\|(I\\pm B)^{-1}\\right\\|\\le\\displaystyle\\frac{1}{1-\\|B\\|}\\) ，此处 \\(\\|\\ \\|\\) 指算子范数。 2.13 - 14 方程组的条件数 定义：如果矩阵 \\(A\\) 或常数项 \\(b\\) 的微小变化，引起方程组 \\(Ax=b\\) 的解的巨大变化，则称该方程组为“病态”方程组，若矩阵 \\(A\\) 为原因则称之为该方程组的“病态”矩阵。否则称“良态”。\n设 \\(A\\) 精确， \\(b\\) 有误差 \\(\\delta b\\) ，解为 \\(x+\\delta x\\) ，则： \\[ A(x+\\delta x)=b+\\delta b\\ \\Rightarrow\\ \\delta x=A^{-1}\\delta b\\\\ \\|\\delta x\\|\\le\\|A^{-1}\\|\\|\\delta b\\|\\\\ \\] 由 \\(Ax=b\\) 得： \\[ \\|b\\|\\le\\|A\\|\\|x\\|,\\ \\frac{1}{\\|x\\|}\\le\\frac{\\|A\\|}{\\|b\\|}\\ (b\\neq0) \\] 两式相乘得到定理1：设 \\(A\\) 是非奇异矩阵， \\(Ax=b\\neq0\\) ，且 \\(A(x+\\delta x)=b+\\delta b\\) ，则 \\(\\displaystyle\\frac{\\|\\delta x\\|}{\\|x\\|}\\le\\|A^{-1}\\|\\|A\\|\\frac{\\|\\delta b\\|}{\\|b\\|}\\) 。该定理给出解的相对误差的上街，即常数项 \\(b\\) 的相对误差在解中至多放大 \\(\\|A^{-1}\\|\\|A\\|\\) 倍。\n设 \\(b\\) 精确， \\(A\\) 有微小误差（扰动） \\(\\delta A\\) ，解为 \\(x+\\delta x\\) ，则： \\[ (A+\\delta A)(x+\\delta x)=b\\ \\Rightarrow\\ (A+\\delta A)\\delta x=-(\\delta A)x\\\\ \\] 若 \\(\\delta A\\) 不受限制， \\(A+\\delta A\\) 可能奇异，而： \\[ (A+\\delta A)=A(I+A^{-1}\\delta A) \\] 当 \\(\\|A^{-1}\\delta A\\|\u0026lt;1\\) 时， \\((I+A^{-1}\\delta A)^{-1}\\) 存在。则可得： \\[ \\delta x=-(I+A^{-1}\\delta A)^{-1}A^{-1}(\\delta A)x\\\\ \\|\\delta x\\|\\le\\frac{\\|A^{-1}\\|\\|\\delta A\\|\\|x\\|}{1-\\|A^{-1}(\\delta A)\\|} \\] 设 \\(1-\\|A^{-1}(\\delta A)\\|\u0026lt;1\\) ，则有： \\[ \\frac{\\|\\delta x\\|}{\\|x\\|}\\le\\frac{\\|A^{-1}\\|\\|A\\|\\frac{\\|\\delta A\\|}{\\|A\\|}}{1-\\|A^{-1}\\|\\|A\\|\\frac{\\|\\delta A\\|}{\\|A\\|}} \\]\n综上， \\(\\|A^{-1}\\|\\|A\\|\\) 刻画了方程组的“病态”程度，称之为矩阵 \\(A\\) 的条件数： \\[ cond(A)_\\nu=\\|A^{-1}\\|_\\nu\\|A\\|_\\nu\\ (\\nu=1,2,\\infty) \\] \\(cond(A)\\) 过大时，方程组“病态”。（相对于矩阵中的元比较大小。）\n通常使用的条件数： + 无穷条件数 \\(cond(A)_\\infty=\\|A^{-1}\\|_\\infty\\|A\\|_\\infty\\) + 谱条件数 \\(cond(A)_2=\\|A^{-1}\\|_2\\|A\\|_2=\\displaystyle\\sqrt{\\frac{\\lambda_{\\max}(A^TA)}{\\lambda_{\\min}(A^TA)}}\\) 当 \\(A\\) 为对称矩阵时， \\(cond(A)_2=\\displaystyle\\frac{\\lambda_1}{\\lambda_2}\\) ，其中 \\(\\lambda_1,\\lambda_2\\) 为 \\(A\\) 的绝对值最大和绝对值最小的特征值。\n条件数的性质： + \\(cond(A)_\\nu=\\|A^{-1}\\|_\\nu\\|A\\|_\\nu\\ge\\|A^{-1}A\\|=1\\) + \\(cond(cA)_\\nu=cond(A)_\\nu, c为常数\\) + 若 \\(A\\) 为正交矩阵（ \\(A^{-1}=A^T\\) ），则 \\(cond(A)_2=1\\) 若 \\(A\\) 为非奇异矩阵， \\(R\\) 为正交矩阵，则 \\(cond(RA)_2=cond(AR)_2=cond(A)_2\\)\n2.15 事后误差估计与迭代改善算法 事后误差估计 设 \\(A\\) 为非奇异矩阵， \\(x\\) 是 \\(Ax=b\\neq0\\) 的精确解。再设 \\(\\overline x\\) 是此方程组的近似解， \\(r=b-A\\overline x\\) ，则： \\[ \\frac{\\|x-\\overline x\\|}{\\|x\\|}\\le cond(A)\\cdot\\frac{\\|r\\|}{\\|b\\|} \\]\n迭代改善算法 理论： 设 \\(Ax=b\\) ，其中 \\(A\\in R^{n\\times n}\\) 为非奇异矩阵，且为病态方程组（但不过分病态）。 + 用选主元三角分析法实现分解计算 \\(PA=LU\\) ，其中 \\(P\\) 为置换阵， \\(L\\) 为单位下三角阵， \\(U\\) 为上三角阵，求得方程组近似解 \\(x_1\\) 。 + 计算剩余向量： \\(r_1=b-Ax_1\\) + 求解 \\(Ad=r_1\\) ，得到解 \\(d_1\\) ，然后改善原解： \\(x_2=x_1+d_1\\) 。 + 递归推：\\(d_2,d_3,\\dots,\\ x_3,x_4,\\dots\\)\n实现： + 用选主元三角分解实行分解计算 \\(PA=LU\\) ，且求计算解 \\(x_1\\) 。 + 对于 \\(k=1,2,\\dots,N_0\\) : + 计算 \\(r_k=b-Ax_k\\) + 求解 \\(LUd_k=Pr_k=PAd_k\\) ，\\(\\left\\{\\begin{array}{}Ly=Pr_k\\\\Ud_k=y\\end{array}\\right.\\) + 若 \\(\\displaystyle\\frac{\\|d_k\\|_\\infty}{\\|x_k\\|_\\infty}\\le10^{-t}\\) 则输出 + 改善 \\(x_{k+1}=x_k+d_k\\)\n补充：选主元三角分解法 LU分解过程中的问题：有解问题无法LU分解（主元为0）；主元过小时引入较大误差\n解决方法：选主元\n第 \\(k\\) 列主元及主元所在列下方元素挑选绝对值最大的数 通过初等变换使该元位于主对角线上，最终将 \\(A\\) 转换为 \\(PA\\) 则 Doolittle分解转换为 \\(PA=LU\\) 代码：迭代改善算法 // // Created by xa on 2021-02-28. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; C; vector\u0026lt;double\u0026gt; b; vector\u0026lt;double\u0026gt; x; vector\u0026lt;double\u0026gt; r; int size = 0; void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_); void solve(); void getPA(); void getLU(); void refreshR(); template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b); void printX(); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_{{1.0303, 0.99030}, {0.99030, 0.95285}}; vector\u0026lt;double\u0026gt; b_{2.4944, 2.3988}; iterate(A_, b_); for (int i = 0; i \u0026lt; size; ++i) std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } void iterate(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); getPA(); C.assign(A.begin(), A.end()); r.assign(b.begin(), b.end()); getLU(); solve(); x.assign(r.begin(), r.end()); while (true) { refreshR(); solve(); if (*(std::max_element(std::begin(r), std::end(r))) / *(std::max_element(std::begin(x), std::end(x))) \u0026lt;= 1e-5) break; for (int i = 0; i \u0026lt; size; ++i) x[i] += r[i]; printX(); } } void solve() { vector\u0026lt;double\u0026gt; d(size); vector\u0026lt;double\u0026gt; y(size); // solve y y[0] = r[0]; for (int k = 1; k \u0026lt; size; ++k) { y[k] = r[k]; for (int i = 0; i \u0026lt; k; ++i) y[k] -= C[k][i] * y[i]; } // solve d d[size-1] = y[size-1] / C[size-1][size-1]; for (int i = size-2; i \u0026gt;= 0; --i) { double sum = 0; for (int j = i+1; j \u0026lt; size; ++j) sum += C[i][j] * r[j]; d[i] = (y[i] - sum) / C[i][i]; } r.assign(d.begin(), d.end()); } void getPA() { for (int k = 0; k \u0026lt; size; ++k) { int max = k; if (k \u0026lt; size-1) { for (int i = k; i \u0026lt; size; ++i) if (A[i][k] \u0026gt; A[max][k]) max = i; swap(A[k], A[max]); swap(b[k],b[max]); } } } void getLU() { for (int k = 0; k \u0026lt; size; ++k) { if (k \u0026gt; 0) for (int j = k; j \u0026lt; size; ++j) for (int m = 0; m \u0026lt; k; ++m) { C[k][j] -= C[k][m] * C[m][j]; } if (k \u0026lt; size-1) for (int i = k+1; i \u0026lt; size; ++i) { double sum = 0; for (int m = 0; m \u0026lt; k; ++m) sum += C[i][m] * A[m][k]; C[i][k] = (C[i][k] - sum) / C[k][k]; } } } void refreshR() { for (int i = 0; i \u0026lt; size; ++i) { r[i] = b[i]; for (int j = 0; j \u0026lt; size; ++j) r[i] -= A[i][j] * x[j]; } } template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { double tmp = a; a = b; b = tmp; } void printX() { for (int i = 0; i \u0026lt; size; ++i) { std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; std::endl; } 代码：选主元Doolittle算法 // // Created by xa on 2021-02-28. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;double\u0026gt; b; int size = 0; vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_); void getPA(); void getLU(); template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b); void printA(); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_ {{8, 1, 7}, {3, 7, 9}, {9, 1, 5}}; vector\u0026lt;double\u0026gt; b_ {3, 8, 6}; vector\u0026lt;double\u0026gt; x = solve(A_, b_); for (int i = 0; i \u0026lt; size; ++i) std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; y(size); getPA(); getLU(); // solve y y[0] = b[0]; for (int k = 1; k \u0026lt; size; ++k) { y[k] = b[k]; for (int i = 0; i \u0026lt; k; ++i) y[k] -= A[k][i] * y[i]; } // solve x x[size-1] = y[size-1] / A[size-1][size-1]; for (int i = size-2; i \u0026gt;= 0; --i) { double sum = 0; for (int j = i+1; j \u0026lt; size; ++j) sum += A[i][j] * x[j]; x[i] = (y[i] - sum) / A[i][i]; } return x; } void getPA() { for (int k = 0; k \u0026lt; size; ++k) { int max = k; if (k \u0026lt; size-1) { for (int i = k; i \u0026lt; size; ++i) if (A[i][k] \u0026gt; A[max][k]) max = i; swap(A[k], A[max]); swap(b[k],b[max]); } } printA(); } void getLU() { for (int k = 0; k \u0026lt; size; ++k) { if (k \u0026gt; 0) for (int j = k; j \u0026lt; size; ++j) for (int m = 0; m \u0026lt; k; ++m) { A[k][j] -= A[k][m] * A[m][j]; } if (k \u0026lt; size-1) for (int i = k+1; i \u0026lt; size; ++i) { double sum = 0; for (int m = 0; m \u0026lt; k; ++m) sum += A[i][m] * A[m][k]; A[i][k] = (A[i][k] - sum) / A[k][k]; } } printA(); } template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { double tmp = a; a = b; b = tmp; } void printA() { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size; ++j) std::cout \u0026lt;\u0026lt; A[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-02-28-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day03-%E8%8C%83%E6%95%B0-%E8%BF%AD%E4%BB%A3%E6%94%B9%E5%96%84%E7%AE%97%E6%B3%95/","summary":"2.9-11 范数 为研究线性方程组近似解的误差估计和迭代法的收敛性，对 \\(R……n\\) （ \\(n\\) 维向量空间）中的向量（ \\(R^{n\\times n}\\) 中的矩阵）的“大小”引进度量——向量（或矩阵）的范数。\n向量的范数 定义1：设 \\(x=(x_1,x_2,\\dots,x_n)^T,y=(y_1,y_2,\\dots,y_n)^T\\in R^n (or\\ C^n)\\)\n将实数 \\((x,y)=y^Tx=\\sum_{i=1}^{n}x_i\\overline{y_i}\\)（或复数 \\((x,y)=y^Hx=\\sum_{i=1}^{n}x_iy_i\\) ）称为向量x,y的数量积（内积）。\n将非负实数 \\(\\|x\\|_2=(x,x)^{1\\over2}=(\\sum_{i=1}^{n}x_i^2)^{1\\over2}\\) 或 \\(\\|x\\|_2=(x,x)^{1\\over2}=(\\sum_{i=1}^{n}|x_i|^2)^{1\\over2}\\) 称为向量 \\(x\\) 的欧式范数。\n引理：向量的内积运算支持交换律、分配律、与实数乘时的结合律。\nCauchy-Schwarz不等式 \\(|(x,y)|\\le \\|x\\|_2\\cdot\\|y\\|_2\\) 当且仅当 \\(x\\) 与 \\(y\\) 线性相关时取等。\n三角不等式 \\(\\|x+y\\|_2\\le\\|x\\|_2+\\|y\\|_2\\)\n定义2-向量的范数：若向量 \\(x\\in R^n\\) （或 \\(C^n\\) ）的某个实值函数 \\(N(x)=\\|x\\|\\) ，满足条件： \\[ \\begin{aligned} \u0026amp; (1)\\ \\|x\\|\\ge 0\\ (\\|x\\|=0当且仅当x=0)\\quad\\textbf{正定条件}\\\\ \u0026amp; (2)\\ \\|\\alpha x\\|=|\\alpha|\\|x\\|,\\ \\forall\\alpha\\in R(或\\alpha\\in C)\\quad\\textbf{齐次性}\\\\ \u0026amp; (3)\\ \\|x+y\\|_2\\le\\|x\\|_2+\\|y\\|_2\\quad\\textbf{三角不等式}\\\\ \u0026amp; (3\\to 4)\\ \\|x-y\\|_2\\ge\\|x\\|_2-\\|y\\|_2 \\end{aligned} \\] 则称 \\(N(x)\\) 是 \\(R^n\\) （或 \\(C^n\\) ）上的一个向量范数（或模）","title":"2021-02-28-数值分析-Day03-范数-迭代改善算法"},{"content":"续 2.1 - 2.4 矩阵三角分解法 初等行变换 \\(\\Leftrightarrow\\) 矩阵左乘初等矩阵 消元 \\(\\Leftrightarrow\\) 矩阵左乘 \\((n-1)\\) 个初等矩阵\n若 \\(a_{11}^{(1)}\\neq0\\) ，令 \\(l_{i1} = a_{i1}^{(1)}\\div a_{11}^{11},\\ i=2,3,\\dots,n\\) ，记： \\(L_{1}=\\begin{pmatrix} 1 \\\\ -l_{21} \u0026amp; 1 \\\\ -l_{31} \u0026amp;\u0026amp; 1 \\\\ \\vdots \u0026amp;\u0026amp;\u0026amp; \\ddots \\\\ -l_{31} \u0026amp;\u0026amp;\u0026amp;\u0026amp; 1 \\end{pmatrix}\\)\n则有 \\(A^{(2)}=L_{1}A^{(1)}=\\begin{pmatrix} a_11^{(1)} \u0026amp; a_{12}^{(1)} \u0026amp; \\cdots \u0026amp; a_{1n}^{(1)} \\\\ 0 \u0026amp; a_{22}^{(2)} \u0026amp; \\cdots \u0026amp; a_{2n}^{(2)} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; a_{n2}^{(2)} \u0026amp; \\cdots \u0026amp; a_{nn}^{(2)} \\end{pmatrix}\\)\n同理进行第二步消元 \\(A^{(3)}=L_{2}A^{(2)},\\ \\dots\\) 第 \\((n-1)\\) 步得到： \\(A^{(n)}=L_{n-1}A^{(n-1)}=\\begin{pmatrix} a_{11}^{(1)} \u0026amp; a_{12}^{(1)} \u0026amp; \\cdots \u0026amp; a_{1n}^{(1)} \\\\ \u0026amp; a_{22}^{(2)} \u0026amp; \\cdots \u0026amp; a_{2n}^{(2)} \\\\ \u0026amp;\u0026amp; \\ddots \u0026amp; \\vdots \\\\ \u0026amp;\u0026amp;\u0026amp; a_{nn}^{(n)} \\end{pmatrix}\\)\n其中： \\(L_{n-1}=\\begin{pmatrix}1\\\\\u0026amp;1\\\\\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\u0026amp;1\\\\\u0026amp;\u0026amp;\u0026amp;-l_{n,n-1}\u0026amp;1\\end{pmatrix}\\)\n也就是： \\(A^{(n)}=L_{n-1}A^{(n-1)}=L_{n-1}L_{n-2}A^{(n-2)}=\\dots=L_{n-1}L_{n-2}\\dots L_{2}L_{1}A^{(1)}\\)\n其中： \\(L_{k}=\\begin{pmatrix}1\\\\\u0026amp;\\cdots\\\\\u0026amp;\u0026amp;1\\\\\u0026amp;\u0026amp;-l_{k+1k}\u0026amp;1\\\\\u0026amp;\u0026amp;\\vdots\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;-l_{k+(n-1)k}\u0026amp;\u0026amp;\u0026amp;1\\end{pmatrix},\\ k=1,2,\\dots,n-1\\)\n\\(L_{k}^{-1}=\\begin{pmatrix}1\\\\\u0026amp;\\cdots\\\\\u0026amp;\u0026amp;1\\\\\u0026amp;\u0026amp;l_{k+1k}\u0026amp;1\\\\\u0026amp;\u0026amp;\\vdots\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;l_{k+(n-1)k}\u0026amp;\u0026amp;\u0026amp;1\\end{pmatrix}\\)\n所以有： \\(A=A^{(1)}=L_{1}^{-1}L_{2}^{-1}\\dots L_{n-1}^{-1}A^{(n)}=LU\\) ，称为 \\(A\\) 的 \\(LU\\) 三角分解。\n其中： \\(L=L_{1}^{-1}L_{2}^{-1}\\dots L_{n-1}^{-1}, U=A^{(n)}\\) \\(L=\\begin{pmatrix}1\\\\l_{21}\u0026amp;1\\\\l_{31}\u0026amp;l_{32}\u0026amp;1\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\\\\l_{n1}\u0026amp;l_{n2}\u0026amp;l_{n3}\u0026amp;\\cdots\u0026amp;1\\end{pmatrix}\\) 即一个单位下三角矩阵\n\\(U=\\begin{pmatrix} a_{11}^{(1)} \u0026amp; a_{12}^{(1)} \u0026amp; \\cdots \u0026amp; a_{1n}^{(1)} \\\\ \u0026amp; a_{22}^{(2)} \u0026amp; \\cdots \u0026amp; a_{2n}^{(2)} \\\\ \u0026amp;\u0026amp; \\ddots \u0026amp; \\vdots \\\\ \u0026amp;\u0026amp;\u0026amp; a_{nn}^{(n)} \\end{pmatrix}\\) 为一个上三角矩阵\n2.5 - 2.6 直接三角分解法 定理1：设 \\(n\\) 阶方阵 \\(A\\) 的各阶顺序主子式不为零，则存在唯一单位下三角矩阵 \\(L\\) 和上三角矩阵 \\(U\\) 使得 \\(A=LU\\) 。（条件与顺序Gauss消去法的执行条件一致。）\n由此可得： \\(Ax=b \\ \\Rightarrow\\ LUx=b\\) ，令 \\(Ux=y\\) ，得 \\(\\left\\{\\begin{aligned}Ly=b\\\\Ux=y\\end{aligned}\\right.\\) 从而将问题转换为两个三角型方程组的求解。\n直接得到 \\(L\\ U\\) 两个矩阵——Doolittle分解法 设： \\[ \\begin{pmatrix}a_{11}\u0026amp;a_{12}\u0026amp;\\cdots\u0026amp;a_{1n}\\\\a_{21}\u0026amp;a_{22}\u0026amp;\\cdots\u0026amp;a_{2n}\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\a_{n1}\u0026amp;a_{n2}\u0026amp;\\cdots\u0026amp;a_{nn}\\end{pmatrix} = \\begin{pmatrix}1\\\\l_{21}\u0026amp;1\\\\l_{31}\u0026amp;l_{32}\u0026amp;1\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\\\\l_{n1}\u0026amp;l_{n2}\u0026amp;l_{n3}\u0026amp;\\cdots\u0026amp;1\\end{pmatrix} \\begin{pmatrix}u_{11}\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\\u0026amp;u_{22}\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\\\\\u0026amp;\u0026amp;\u0026amp;u_{nn}\\end{pmatrix} \\] 则得： \\[ \\left\\{\\begin{array}{l} u_{1j}=a_{1j}\\quad j=1,2,\\dots,n\\\\ l_{i1}=a_{i1}\\div u_{11}\\quad i=2,3,\\dots,n\\\\\\vdots\\\\ 对k=2,3,\\dots,n,计算\\\\ u_{kj}=a_{kj}-\\sum_{m=1}^{k-1}{l_{km}u_{mj}}\\quad j=k,k+1,\\dots,n\\\\ l_{ik}=(a_{ik}-\\sum_{m=1}^{k-1}{l_{im}u_{mk}})\\div u_{kk}\\quad i=k+1,k+2,\\dots,n \\end{array}\\right. \\] 应用中为节省存储空间，将矩阵 \\(U\\) 覆盖矩阵 \\(A\\) 的上三角进行存放，矩阵 \\(L\\) 覆盖矩阵 \\(A\\) 除对角线的下三角进行存放，即在原位形成矩阵： \\(\\begin{pmatrix}u_{11}\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\l_{21}\u0026amp;u_{22}\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\l_{n1}\u0026amp;l_{n2}\u0026amp;\\cdots\u0026amp;u_{nn}\\end{pmatrix}\\)\n回代得到： \\[ \\begin{array}{l} \\left\\{\\begin{array}{l} \\begin{pmatrix}1\\\\l_{21}\u0026amp;1\\\\\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\\\\l_{n1}\u0026amp;l_{n2}\u0026amp;\\cdots\u0026amp;1\\end{pmatrix} \\begin{pmatrix}y_1\\\\y_2\\\\\\vdots\\\\y_n\\end{pmatrix} = \\begin{pmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_n\\end{pmatrix},\\\\ \\begin{pmatrix}u_{11}\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\\u0026amp;u_{22}\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\\\\\u0026amp;\u0026amp;\u0026amp;u_{nn}\\end{pmatrix} \\begin{pmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{pmatrix} = \\begin{pmatrix}y_1\\\\y_2\\\\\\vdots\\\\y_n\\end{pmatrix} \\end{array}\\right.\\\\ 解得\\left\\{\\begin{array}{l} y_1=b_1\\\\ y_k=b_k-\\sum_{i=1}^{k-1}{l_{ki}y_i},\\quad k=2,3,\\dots,n\\\\ x_n=y_n\\div u_{nn}\\\\ x_i=(y_i-\\sum_{j=i+1}^{n}{u_{ij}x_j})\\div u_{ii},\\quad i=n-1,n-2m\\dots,1 \\end{array}\\right. \\end{array} \\]\n2.7 平方根法 针对系数矩阵 \\(A\\) 为对称正定矩阵情况，有 \\(A=LU,u_{kk}\u0026gt;0\\) ，而：\n\\(\\begin{pmatrix}u_{11}\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\\u0026amp;u_{22}\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\\\\\u0026amp;\u0026amp;\u0026amp;u_{nn}\\end{pmatrix} = \\begin{pmatrix}u_{11}\\\\\u0026amp;u_{22}\\\\\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\u0026amp;u_{nn}\\end{pmatrix} \\begin{pmatrix}1\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\\u0026amp;1\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\\\\\u0026amp;\u0026amp;\u0026amp;1\\end{pmatrix}\\)\n令 \\(D=\\begin{pmatrix}u_{11}\\\\\u0026amp;u_{22}\\\\\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\u0026amp;u_{nn}\\end{pmatrix},\\ M=\\begin{pmatrix}1\u0026amp;u_{12}\u0026amp;\\cdots\u0026amp;u_{1n}\\\\\u0026amp;1\u0026amp;\\cdots\u0026amp;u_{2n}\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\vdots\\\\\u0026amp;\u0026amp;\u0026amp;1\\end{pmatrix}\\)\n则有： \\(A=LDM\\) ，又因为 \\((LDM)^T=M^TDL^T=LDM\\) ，所以： \\(M=L^T\\) ，则有： \\(A=LDM=LDL^T\\) 。\n令 \\(D=\\begin{pmatrix}\\sqrt{u_{11}}\\\\\u0026amp;\\sqrt{u_{22}}\\\\\u0026amp;\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\u0026amp;\\sqrt{u_{nn}}\\end{pmatrix}^2=(D^{\\frac{1}{2}})^2\\)\n则有： \\(A=LD^{\\frac{1}{2}}D^{\\frac{1}{2}}L^T=(LD^{\\frac{1}{2}})(LD^{\\frac{1}{2}})^T=GG^T,\\quad G=LD^{\\frac{1}{2}}\\)\n分解 \\(A=GG^T\\) 称为对称正定矩阵的Cholesky分解， \\(Ax=b\\) 则转换为 \\(\\left\\{\\begin{aligned}Gy=b\\\\G^Tx=y\\end{aligned}\\right.\\) ，称为平方根法。\n求解方法：\n若记 \\(G=(g_{ij})\\) ，则对 \\(k=1,2,\\dots,n\\) 有： \\(\\left\\{\\begin{array}{l}g_{kk}=(a_{kk}-\\sum_{m=1}^{k-1}{g_{km}^2})^\\frac{1}{2}\\\\g_{ik}=(a_{ik}-\\sum_{m=1}^{k-1}{g_{im}g_{km}})\\div g_{kk},\\ i=k+1,\\dots,n\\end{array}\\right.\\)\n同样将 \\(G\\) 存放在 \\(A\\) 的位置来节省存储。\n解三角方程 \\(\\left\\{\\begin{aligned}Gy=b\\\\G^Tx=y\\end{aligned}\\right.\\) 得： \\(\\left\\{\\begin{array}{l}y_k=(b_k-\\sum_{m=1}^{k-1}{g_{km}y_m})\\div g_{kk},\\quad k=1,2,\\dots,n\\\\x_k=(y_k-\\sum_{m=k+1}^{n}g_{mk})\\div g_{kk},\\quad k=n,n-1,\\dots,1\\end{array}\\right.\\)\n2.8 追赶法 追赶法是求三对角线性方程组的三角分解法： \\(\\begin{pmatrix}a_1\u0026amp;c_1\\\\d_2\u0026amp;a_2\u0026amp;c_2\\\\\u0026amp;\\ddots\u0026amp;\\ddots\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;d_{n-1}\u0026amp;a_{n-1}\u0026amp;c_{n-1}\\\\\u0026amp;\u0026amp;\u0026amp;d_n\u0026amp;a_n\\end{pmatrix} \\begin{pmatrix}x_1\\\\x_2\\\\\\vdots\\\\x_{n-1}\\\\x_n\\end{pmatrix} = \\begin{pmatrix}b_1\\\\b_2\\\\\\vdots\\\\b_{n-1}\\\\b_n\\end{pmatrix}\\)\n三对角矩阵 \\(A\\) 的各阶顺序主子式都不为零的一个充分条件是： \\(|a_1|\u0026gt;|c_1|\u0026gt;0;\\ |a_n|\u0026gt;|d_n|\u0026gt;0;\\ |a_i|\\ge|c_i|+|d_i|, c_id_i\\neq0, i=2,3,\\dots,n-1\\) 在此条件下， \\(A=LDM=TM\\) ，称为矩阵 \\(A\\) 的Crout分解。\n对三对角矩阵 \\(A\\) 进行Crout分解，有：\\(A=\\begin{pmatrix}\\alpha_1\\\\\\gamma_2\u0026amp;\\alpha_2\\\\\u0026amp;\\ddots\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\\gamma_{n-1}\u0026amp;\\alpha_{n-1}\\\\\u0026amp;\u0026amp;\u0026amp;\\gamma_n\u0026amp;\\alpha_n\\end{pmatrix} \\begin{pmatrix}1\u0026amp;\\beta_1\\\\\u0026amp;1\u0026amp;\\beta_2\\\\\u0026amp;\u0026amp;\\ddots\u0026amp;\\ddots\\\\\u0026amp;\u0026amp;\u0026amp;1\u0026amp;\\beta_{n-1}\\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\\end{pmatrix}\\)\n\\(\\left\\{\\begin{array}{l}\\alpha_1=a_1,\\ \\beta_1=c_1\\div\\alpha_1,\\ \\gamma_i=d_i,\\ i=1,2,3,\\dots,n\\\\ \\alpha_i=a_i-d_i\\beta_{i-1},\\ i=2,3,\\dots,n\\\\ \\beta_i=c_i\\div\\alpha_i,\\ i=2,3,\\dots,n-1 \\end{array}\\right.\\)\n代码：LU分解法（Doolittle） // // Created by xa on 2021-02-27. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A; vector\u0026lt;double\u0026gt; b; int size = 0; vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A, vector\u0026lt;double\u0026gt; b); void getLU(); void printA(); int main(){ vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_ {{8, 1, 7}, {3, 7, 9}, {9, 1, 5}}; vector\u0026lt;double\u0026gt; b_ {3, 8, 6}; vector\u0026lt;double\u0026gt; x = solve(A_, b_); for (int i = 0; i \u0026lt; size; ++i) std::cout \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; A_, vector\u0026lt;double\u0026gt; b_) { A.assign(A_.begin(), A_.end()); b.assign(b_.begin(), b_.end()); size = A.size(); vector\u0026lt;double\u0026gt; x(size); vector\u0026lt;double\u0026gt; y(size); getLU(); // solve y y[0] = b[0]; for (int k = 1; k \u0026lt; size; ++k) { y[k] = b[k]; for (int i = 0; i \u0026lt; k; ++i) y[k] -= A[k][i] * y[i]; } // solve x x[size-1] = y[size-1] / A[size-1][size-1]; for (int i = size-2; i \u0026gt;= 0; --i) { double sum = 0; for (int j = i+1; j \u0026lt; size; ++j) sum += A[i][j] * x[j]; x[i] = (y[i] - sum) / A[i][i]; } return x; } void getLU() { for (int k = 0; k \u0026lt; size; ++k) { if (k \u0026gt; 0) for (int j = k; j \u0026lt; size; ++j) for (int m = 0; m \u0026lt; k; ++m) { A[k][j] -= A[k][m] * A[m][j]; } if (k \u0026lt; size-1) for (int i = k+1; i \u0026lt; size; ++i) { double sum = 0; for (int m = 0; m \u0026lt; k; ++m) sum += A[i][m] * A[m][k]; A[i][k] = (A[i][k] - sum) / A[k][k]; } } printA(); } void printA() { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size; ++j) std::cout \u0026lt;\u0026lt; A[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-02-27-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day02-%E4%B8%89%E8%A7%92%E5%88%86%E8%A7%A3/","summary":"续 2.1 - 2.4 矩阵三角分解法 初等行变换 \\(\\Leftrightarrow\\) 矩阵左乘初等矩阵 消元 \\(\\Leftrightarrow\\) 矩阵左乘 \\((n-1)\\) 个初等矩阵\n若 \\(a_{11}^{(1)}\\neq0\\) ，令 \\(l_{i1} = a_{i1}^{(1)}\\div a_{11}^{11},\\ i=2,3,\\dots,n\\) ，记： \\(L_{1}=\\begin{pmatrix} 1 \\\\ -l_{21} \u0026amp; 1 \\\\ -l_{31} \u0026amp;\u0026amp; 1 \\\\ \\vdots \u0026amp;\u0026amp;\u0026amp; \\ddots \\\\ -l_{31} \u0026amp;\u0026amp;\u0026amp;\u0026amp; 1 \\end{pmatrix}\\)\n则有 \\(A^{(2)}=L_{1}A^{(1)}=\\begin{pmatrix} a_11^{(1)} \u0026amp; a_{12}^{(1)} \u0026amp; \\cdots \u0026amp; a_{1n}^{(1)} \\\\ 0 \u0026amp; a_{22}^{(2)} \u0026amp; \\cdots \u0026amp; a_{2n}^{(2)} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; a_{n2}^{(2)} \u0026amp; \\cdots \u0026amp; a_{nn}^{(2)} \\end{pmatrix}\\)","title":"2021-02-27-数值分析-Day02-三角分解"},{"content":"1.1 - 1.2 数值分析的算法要求 结构简单，易于计算机实现 理论上保证方法的收敛性和数值稳定性 计算效率高：速度快，内存开销小 经过数值实验验证 误差的来源和分类 模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免 观测误差：观测实验得到的参数带来的误差 截断误差：近似方法产生的误差 舍入误差：计算机有限位计算产生的误差 （后两者为本课程主要研究对象）\n绝对误差和相对误差\n设 \\(x\\) 是精确值 \\(x^{*}\\) 的一个近似值，则 \\(e=x^{*}-x\\) 为近似值 \\(x\\) 的绝对误差，简称误差。\n若 \\(\\varepsilon\\) 满足 \\(|e|\\le\\varepsilon\\) ，则称 \\(\\varepsilon\\) 为 \\(x\\) 的绝对误差限，简称误差限，有量纲。则满足 \\(x-\\varepsilon \\le x^{*} \\le x+\\varepsilon\\) ，简写为 \\(x^{*} = x\\pm\\varepsilon\\) 。\n\\(e_{r} = \\displaystyle\\frac{e}{x^{*}} = \\frac{x^{*}-x}{x^{*}}\\) 称相对误差。\n\\(\\varepsilon_{r} = \\displaystyle\\frac{\\varepsilon}{|x|}\\) 称相对误差限， \\(|e_{r}| \\le \\varepsilon_{r}\\) ，无量纲。\n（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）\n1.3 有效数字 定义1：设数 \\(x\\) 是数 \\(x^{*}\\) 的近似值，如果 \\(x\\) 的绝对误差限是它的某一数位的半个单位，并且从 \\(x\\) 左起第一个非零数到该数位共有 \\(n\\) 位，则称这 \\(n\\) 个数字为 \\(x\\) 的有效数字，也称用 \\(x\\) 近似 \\(x*\\) 时具有 \\(n\\) 位有效数字。\n有效数字与绝对误差限的关系： \\(x\\) 作为 \\(x^{*}\\) 的近似值，具有 \\(n\\) 位（ \\(n \\le k\\) ）有效数字当且仅当：\n\\[ \\left|x^{*}-x\\right| \\le \\frac{1}{2}\\times10 ^{m-n} \\]\n近似值的有效数字越多，其绝对误差越小。\n（PS：精确值的有效数字可认为有无限多位。）\n有效数字与相对误差限的关系：若 \\(x\\) 有 \\(n\\) 位有效数字，则其相对误差限为： \\[ \\varepsilon_{r} \\le \\frac{1}{2 a_{1}}\\times10^{-n+1} \\] 反之，若 \\(x\\) 的相对误差限： \\[ \\varepsilon_{r} \\le \\frac{1}{2(a_{1}+1)}\\times10^{-n+1} \\] 则 \\(x\\) 至少有 \\(n\\) 位有效数字。\n1.4 - 1.6 数值计算中的若干原则 为减少舍入误差\n避免两个相近的数相减\n利用对数计算法则将减法转换为除法、利用三角函数和差化积公式转换为乘除、倒用分母有理化将减法转换为分母上的乘法等方法。\n防止大数“吃掉”小数\n指参与计算的数数量级差很大时，则加减运算中，绝对值小的数往往被绝对值大的数“吃掉”（如被计算机存储位数限制舍去）。\n改变计算顺序，在求和差过程中由小到大进行计算。\n绝对值太小的数不宜作除数\n注意简化计算程序，减少计算次数\n选用数值稳定性好的算法\n计算舍入误差积累是可控制的。\n2.1 - 2.4 Gauss消去法 求解线性方程组 \\[ \\left\\{ \\begin{aligned} a_{11}x_{1} + a_{12}x_{2} + ... + a_{1n}x_{n} = b_{1}\\\\ a_{21}x_{1} + a_{22}x_{2} + ... + a_{2n}x_{n} = b_{2}\\\\ \\dots\\\\ a_{n1}x_{1} + a_{n2}x_{2} + ... + a_{nn}x_{n} = b_{n}\\\\ \\end{aligned} \\right. (1) \\] 矩阵形式 \\(Ax = b\\) \\[ A= \\begin{pmatrix} a_{11}\u0026amp; a_{12}\u0026amp; \\cdots \u0026amp; a_{1n} \\\\ a_{21}\u0026amp; a_{22}\u0026amp; \\cdots \u0026amp; a_{2n} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ a_{n1}\u0026amp; a_{n2}\u0026amp; \\cdots \u0026amp; a_{nn} \\end{pmatrix}, x= \\begin{pmatrix} x_{1} \\\\ x_{2} \\\\ \\cdots \\\\ x_{n} \\\\ \\end{pmatrix}, b= \\begin{pmatrix} b_{1} \\\\ b_{2} \\\\ \\cdots \\\\ b_{n} \\\\ \\end{pmatrix} \\\\ 矩阵A奇异，det(A)\\neq0 \\]\nCramer法则：直接方法，计算量过大，不适合实际应用\nGauss消去法：直接方法，逐次消元，转换为上三角方程组。\n顺序Gauss消去法 顺序Gauss消去法求解线性方程组 \\((1)\\)：\n记 \\(A^{(1)}=A, b^{(1)}=b, a_{ij}^{(1)}=a_{ij}, b_{i}*{(1)}=b_{i}\\)\n则，线性方程组 \\((1)\\) 的增广矩阵为： \\[ (A^{(1)},b^{(1)})= \\begin{pmatrix} a_{11}^{(1)}\u0026amp; a_{12}^{(1)}\u0026amp; a_{13}^{(1)}\u0026amp; \\dots \u0026amp; a_{1n}^{(1)}\u0026amp; b_{1}^{(1)} \\\\ a_{21}^{(1)}\u0026amp; a_{22}^{(1)}\u0026amp; a_{23}^{(1)}\u0026amp; \\dots \u0026amp; a_{2n}^{(1)}\u0026amp; b_{2}^{(1)} \\\\ a_{31}^{(1)}\u0026amp; a_{32}^{(1)}\u0026amp; a_{33}^{(1)}\u0026amp; \\dots \u0026amp; a_{3n}^{(1)}\u0026amp; b_{3}^{(1)} \\\\ \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots \\\\ a_{n1}^{(1)}\u0026amp; a_{n2}^{(1)}\u0026amp; a_{n3}^{(1)}\u0026amp; \\dots \u0026amp; a_{nn}^{(1)}\u0026amp; b_{n}^{(1)} \\\\ \\end{pmatrix}, \\]\n第 \\(1\\) 步：设 \\(a_{11}^{(1)}\\neq0\\) ，依次用 \\(-l_{i1}=-\\displaystyle\\frac{a_{i1}^{(1)}}{a_{11}^{(1)}}, (i=2,3,\\dots,n)\\) 乘以矩阵的第 \\(1\\) 行加到第 \\(i\\) 行，得到矩阵： \\[ \\begin{array}{l} (A^{(2)},b^{(2)})= \\begin{pmatrix} a_{11}^{(1)}\u0026amp; a_{12}^{(1)}\u0026amp; a_{13}^{(1)}\u0026amp; \\dots \u0026amp; a_{1n}^{(1)}\u0026amp; b_{1}^{(1)} \\\\ 0\u0026amp; a_{22}^{(2)}\u0026amp; a_{23}^{(2)}\u0026amp; \\dots \u0026amp; a_{2n}^{(2)}\u0026amp; b_{2}^{(2)} \\\\ 0\u0026amp; a_{32}^{(2)}\u0026amp; a_{33}^{(2)}\u0026amp; \\dots \u0026amp; a_{3n}^{(2)}\u0026amp; b_{3}^{(2)} \\\\ \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots \\\\ 0\u0026amp; a_{n2}^{(2)}\u0026amp; a_{n3}^{(2)}\u0026amp; \\dots \u0026amp; a_{nn}^{(2)}\u0026amp; b_{n}^{(2)} \\\\ \\end{pmatrix},\\\\ 其中：\\begin{aligned} a_{ij}^{(2)} = a_{ij}^{(1)} - l_{i1}a_{1j}^{(1)},\\quad i,j=2,3,\\dots,n \\\\ b_{i}^{(2)} = b_{i}^{(1)} - l_{i1}b_{1}^{(1)},\\qquad i=2,3,\\dots,n \\end{aligned} \\end{array} \\]\n第 \\(2\\) 步：设 \\(a_{22}^{(2)}\\neq0\\) ，依次用 \\(-l_{i2}=-\\displaystyle\\frac{a_{i2}^{(2)}}{a_{22}^{(2)}}, (i=3,4,\\dots,n)\\) 乘以矩阵的第 \\(2\\) 行加到第 \\(i\\) 行，得到矩阵： \\[ \\begin{array}{l} (A^{(2)},b^{(2)})= \\begin{pmatrix} a_{11}^{(1)}\u0026amp; a_{12}^{(1)}\u0026amp; a_{13}^{(1)}\u0026amp; \\dots \u0026amp; a_{1n}^{(1)}\u0026amp; b_{1}^{(1)} \\\\ 0\u0026amp; a_{22}^{(2)}\u0026amp; a_{23}^{(2)}\u0026amp; \\dots \u0026amp; a_{2n}^{(2)}\u0026amp; b_{2}^{(2)} \\\\ 0\u0026amp; 0\u0026amp; a_{33}^{(3)}\u0026amp; \\dots \u0026amp; a_{3n}^{(3)}\u0026amp; b_{3}^{(3)} \\\\ \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots \\\\ 0\u0026amp; 0\u0026amp; a_{n3}^{(3)}\u0026amp; \\dots \u0026amp; a_{nn}^{(3)}\u0026amp; b_{n}^{(3)} \\\\ \\end{pmatrix},\\\\ 其中：\\begin{aligned} a_{ij}^{(3)} = a_{ij}^{(2)} - l_{i2}a_{2j}^{(2)},\\quad i,j=3,4,\\dots,n \\\\ b_{i}^{(3)} = b_{i}^{(2)} - l_{i2}b_{2}^{(2)},\\qquad i=3,4,\\dots,n \\end{aligned} \\end{array} \\]\n第 \\(3\\) 步，第 \\(4\\) 步， \\(\\dots\\) ，第 \\((n-1)\\) 步后得到矩阵： \\[ (A^{(n)},b^{(n)})= \\begin{pmatrix} a_{11}^{(1)}\u0026amp; a_{12}^{(1)}\u0026amp; a_{13}^{(1)}\u0026amp; \\dots \u0026amp; a_{1n}^{(1)}\u0026amp; b_{1}^{(1)} \\\\ 0\u0026amp; a_{22}^{(2)}\u0026amp; a_{23}^{(2)}\u0026amp; \\dots \u0026amp; a_{2n}^{(2)}\u0026amp; b_{2}^{(2)} \\\\ 0\u0026amp; 0\u0026amp; a_{33}^{(3)}\u0026amp; \\dots \u0026amp; a_{3n}^{(3)}\u0026amp; b_{3}^{(3)} \\\\ \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots\u0026amp; \\dots \\\\ 0\u0026amp; 0\u0026amp; 0\u0026amp; \\dots \u0026amp; a_{nn}^{(n)}\u0026amp; b_{n}^{(n)} \\\\ \\end{pmatrix} \\]\n对应的方程组则变成： \\[ \\left\\{ \\begin{aligned} a_{11}^{(1)}x_{1} + a_{12}^{(1)}x_{2} + ... + a_{1n}^{(1)}x_{n} = b_{1}^{(1)}\\\\ a_{22}^{(2)}x_{2} + ... + a_{2n}^{(2)}x_{n} = b_{2}^{(2)}\\\\ \\dots\\\\ a_{nn}^{(n)}x_{n} = b_{n}^{(n)}\\\\ \\end{aligned} \\right. \\]\n对此方程组进行回代，就可求出方程组的解\n顺序Gauss消去法的乘除计算量：\\(\\displaystyle\\sum_{k=1}^{n}(k^{2}-1)\\ +\\ \\displaystyle\\sum_{k=1}^{n}k\\ =\\ \\displaystyle\\frac{1}{3}(n^{3}+3n^{2}-n)\\)\n顺序Gauss消去法也简称为Gauss消去法，其中 \\(a_{kk}^{(k)}(k=1,2,\\dots,n)\\) 也称为主元素，且主元素不为零（使用顺序Gauss消去法的充要条件）。\n列主元Gauss消去法 顺序Gauss消去法的局限性：主元素过小时出现“大数吃小数”情况，舍入误差较大。常采用列主元Gauss消去法和全主元Gauss消去法解决。\n线性方程组 \\(Ax=b\\)，记 \\(A^{(1)}=A, b^{(1)}=b,\\) 列主元Gauss消去法过程如下： + 在增广矩阵 \\(B^{(1)}=(A^{(1)},b^{(1)})\\) 的第一列元素中，取： \\(\\left|a_{k1}^{(1)}\\right| = \\max\\limits_{1\\le i\\le n}{\\left|a_{i1}^{(1)}\\right|}\\) 为主元素， \\(r_{k}\\leftrightarrow r_{1}\\) 。 然后进行第 \\(1\\) 步消元得到增广矩阵 \\(B^{2}=(A^{(2), b^{(2)}})\\) 。 + 再在矩阵 \\(B^{(2)}=(A^{(2)},b^{(2)})\\) 的第二列元素中，取： \\(\\left|a_{k2}^{(2)}\\right| = \\max\\limits_{2\\le i\\le n}{\\left|a_{i2}^{(2)}\\right|}\\) 为主元素， \\(r_{k}\\leftrightarrow r_{2}\\) 。 然后进行第二步消元得到增广矩阵 \\(B^{3}=(A^{(3), b^{(3)}})\\) 。 + 依此类推，经过 \\((n-1)\\) 步选主元和消元运算，得到增广矩阵 \\(B^{n}=(A^{(n), b^{(n)}})\\) 。则方程组 \\(A^{(n)}x=b^{(n)}\\) 是与原方程组等价的上三角方程组，回代求解。 + 易证：只要 \\(|A|\\neq 0\\) 列主元Gauss消去法就可顺利进行。\n全主元Gauss消去法 在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。\n代码：顺序Gauss消去法 在每一步消元前，在所有元素中选取绝对值最大的元素作为主元素。但由于运算量大增，实际应用中不经常使用。\n// // Created by xa on 2021-02-26. // #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::vector; vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; matrix; int size = 0; vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; input); void upperTriangular(); void swapRow(int index); void gauss(int index); template\u0026lt;typename T\u0026gt; void swap(T* a, T* b); void printMatrix(); int main() { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; test {{8, 1, 7, 3}, {3, 7, 9, 8}, {9, 1, 5, 6}}; vector\u0026lt;double\u0026gt; ans = solve(test); for (int i = 0; i \u0026lt; ans.size(); ++i) std::cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } vector\u0026lt;double\u0026gt; solve(vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; input) { matrix.assign(input.begin(), input.end()); size = matrix.size(); vector\u0026lt;double\u0026gt; solution(size); upperTriangular(); if (matrix[size-1][size-1] == 0) std::cout \u0026lt;\u0026lt; \u0026quot;No Solution.\u0026quot;; solution[size-1] = matrix[size-1][size]/matrix[size-1][size-1]; for (int i = size-2; i \u0026gt;= 0; --i) { double tmp = matrix[i][size]; for (int j = i+1; j \u0026lt; size; ++j) tmp -= matrix[i][j] * solution[j]; solution[i] = tmp/matrix[i][i]; } return solution; } void upperTriangular() { for (int i = 0; i \u0026lt; size; ++i) { swapRow(i); gauss(i); } printMatrix(); } void swapRow(int index) { int max = index; if (index \u0026lt; size - 1) { for (int i = index; i \u0026lt; size; ++i) if (matrix[i][index] \u0026gt; matrix[max][index]) max = i; swap(matrix[index], matrix[max]); } std::cout \u0026lt;\u0026lt; \u0026quot;swap\u0026quot; \u0026lt;\u0026lt; std::endl; printMatrix(); } void gauss(int index) { for (int i = index + 1; i \u0026lt; size; ++i) { double l = matrix[i][index] / matrix[index][index]; for (int j = 0; j \u0026lt; size + 1; ++j) { matrix[i][j] -= l * matrix[index][j]; if (matrix[i][j] \u0026lt; 1e-16 \u0026amp;\u0026amp; matrix[i][j] \u0026gt; -1e-10) matrix[i][j] = 0; } } std::cout \u0026lt;\u0026lt; \u0026quot;gauss\u0026quot; \u0026lt;\u0026lt; std::endl; printMatrix(); } template\u0026lt;typename T\u0026gt; void swap(T* a, T* b) { double tmp = a; a = b; b = tmp; } void printMatrix() { for (int i = 0; i \u0026lt; size; ++i) { for (int j = 0; j \u0026lt; size + 1; ++j) std::cout \u0026lt;\u0026lt; matrix[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; } ","permalink":"https://elderlyaugustus.github.io/posts/2021-02-26-%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-day01-%E9%A1%BA%E5%BA%8Fgauss%E6%B6%88%E5%85%83/","summary":"1.1 - 1.2 数值分析的算法要求 结构简单，易于计算机实现 理论上保证方法的收敛性和数值稳定性 计算效率高：速度快，内存开销小 经过数值实验验证 误差的来源和分类 模型误差：将实际问题抽象为数学模型过程中产生的误差，不可避免 观测误差：观测实验得到的参数带来的误差 截断误差：近似方法产生的误差 舍入误差：计算机有限位计算产生的误差 （后两者为本课程主要研究对象）\n绝对误差和相对误差\n设 \\(x\\) 是精确值 \\(x^{*}\\) 的一个近似值，则 \\(e=x^{*}-x\\) 为近似值 \\(x\\) 的绝对误差，简称误差。\n若 \\(\\varepsilon\\) 满足 \\(|e|\\le\\varepsilon\\) ，则称 \\(\\varepsilon\\) 为 \\(x\\) 的绝对误差限，简称误差限，有量纲。则满足 \\(x-\\varepsilon \\le x^{*} \\le x+\\varepsilon\\) ，简写为 \\(x^{*} = x\\pm\\varepsilon\\) 。\n\\(e_{r} = \\displaystyle\\frac{e}{x^{*}} = \\frac{x^{*}-x}{x^{*}}\\) 称相对误差。\n\\(\\varepsilon_{r} = \\displaystyle\\frac{\\varepsilon}{|x|}\\) 称相对误差限， \\(|e_{r}| \\le \\varepsilon_{r}\\) ，无量纲。\n（其中误差与相对误差用于理论分析，误差限与相对误差限用于实际应用。）\n1.3 有效数字 定义1：设数 \\(x\\) 是数 \\(x^{*}\\) 的近似值，如果 \\(x\\) 的绝对误差限是它的某一数位的半个单位，并且从 \\(x\\) 左起第一个非零数到该数位共有 \\(n\\) 位，则称这 \\(n\\) 个数字为 \\(x\\) 的有效数字，也称用 \\(x\\) 近似 \\(x*\\) 时具有 \\(n\\) 位有效数字。","title":"2021-02-26-数值分析-Day01-顺序Gauss消元"},{"content":"信号与系统 上 中 下 傅予力\n2020寒假\nhttps://mp.weixin.qq.com/s/_wx_PICiVGz896kyh6MTkg\nhttps://mp.weixin.qq.com/s/_JEL55Nfo6As3uA1RhkNyw\nhttps://mp.weixin.qq.com/s/9G3H0eNAEDn54BRH67fvrA\nGAMES101现代计算机图形学入门 闫令琪\n2020上半年-疫情在家\nhttps://mp.weixin.qq.com/s/bJn56NO8bL9y6BI3T1SHAw\n","permalink":"https://elderlyaugustus.github.io/posts/2021-02-25-%E4%B9%8B%E5%89%8D%E7%9A%84%E7%AC%94%E8%AE%B0%E9%93%BE%E6%8E%A5/","summary":"信号与系统 上 中 下 傅予力\n2020寒假\nhttps://mp.weixin.qq.com/s/_wx_PICiVGz896kyh6MTkg\nhttps://mp.weixin.qq.com/s/_JEL55Nfo6As3uA1RhkNyw\nhttps://mp.weixin.qq.com/s/9G3H0eNAEDn54BRH67fvrA\nGAMES101现代计算机图形学入门 闫令琪\n2020上半年-疫情在家\nhttps://mp.weixin.qq.com/s/bJn56NO8bL9y6BI3T1SHAw","title":"之前的笔记链接"},{"content":"上半年，一直在写800字的“议论文”，下半年则没怎么提起过笔。高考这一年，还是值得写两个字的。\n记得初一时还对曹说过，想记日记一直到高三，现在想来真是可笑。这份“年记”，肯定是会记成流水账的，也不是写给别人看的。\n2019年的前一天，18年12月31日，是我这辈子第一回到北京。晚上安顿了住处，还到电影学院转了一圈，当时的感触只有：“五分钟转完的小地方。”元旦在中传考试，父亲第一回进大学参观，告诉我：“你看这学校，比昨天那个电影学校大多了，你考这多好。”我笑了笑，像做初中题似的做完了初试。依稀记得，收卷后坐我后排的两个女生还在聊这张卷子上的数学有多难。在北京，看了天安门，可能是北京天气最好的一天。十一个小时的T31，凌晨赶回南师附中继续复习。\n艺考，对我来说是从前从来也没想过的升学途径。不过现在想想，我小学三年级的转学，小升初，初升高都远出乎意料之外，不然我现在可能真跟小学的同学在哪个工地上搬真的砖块吧。想来也是我的求学生涯过于lucky了吧。\n18年3月，陶开始建议我尝试影视技术专业。此前跟他在校社协干了两年的文宣工作，确实也在视频技术这块有些许积累。一直以来玩计算机，虽也没玩出什么名堂来，但本想走的还是微电子或者计算机科学的路子，唐突间的提议，倒也不是一时间能接受的。只是一时间对电影有了更多的关注吧。最终还是在自己的高考报名表上填了“理兼艺”。\n我的情况确实容不得考学的失误，没有复读的条件，也没有多余的出路，真真切切的“考不上回家种大田”。就像家长一直挺介意我没有按部就班去县中苦读三年而是跑到城里去读南师附中一样。所以，也算是多个路子多种可能吧，毕竟在江苏高考，什么样的岔子都不是没可能的。老师家长也只是有质疑，介于我并没有说因此在学习的安排上有任何变化，便也并不多说。\n扯了一大节前情提要，年初的几趟校考着实是艺考能让我缺掉的仅有的几堂课——毕竟都是吃老本而已。甚至说，我最后来的电影学院的两次考试，都卡在周末的节点上，完完全全没有影响到校内的课程。北电摄影系的初试，也因为跟四校联考的冲突而直接放弃了。\n艺考结束的最大感触就是，所有我考了的专业，涉及文化课和思维的部分，都太过简单，专业的知识也只能依赖此前摸爬滚打积累的一点点零散经验。这让我对艺考选拔还是充满了不信任。于是又加快了备考的步伐——按今年年初那个极不稳定的水平，到头来要是连一个985211都考不上也不是没有可能的。\n当然，在南师附中的高三生活还是很充实的。算算差不多做套卷子，差不多了还是会玩会电脑，出门转悠转悠。晚上在宿舍抱着kindle读到深夜，思索着大千世界。甚至说周末在新街口电影院见到穿着高三校服的南师附中学生，也是常有的事。个人觉得，这也正是我们对做题并没有那么抵触和恐惧的原因吧。\n四月份，最先出分的是传媒大学，摄制第七，数媒影像通过。很多同学恭喜我有学上了，那天玩得很嗨。当天晚上，差点没有睡着，一直在考虑自己的位置和这两张证对自己的意义。同一间寝室另一个一直有认真学编导类的好友，吴，拿了两张并不出彩的证。我俩也算是南师附中这一届考了影视类艺术院校的唯二两人了吧。按附中惯例，互相吹捧了一番。之后两周，一边开始期待另一所更为关注的院校，电影学院，出分，一边也确实有些许懈怠了。\n4月15日的早上，我逃了一次课间操，守在电脑面前，和远在北京的陶一块查分。他在校内帮我查，QQ里他发来那张合格证的图和几句口头禅时，我还是不得不说地很是有些激动，着实没能想到一个半吊子的文化考生，能拿影技第一的证。那一天，突然开始使用微信，加了很多很多人，直聊到深夜，最后说晚安的，是现在大三的师哥陈。唐汉卿也是从那时开始才联系上我和吴的，他是影技第二，吴拿了编导的证。\n冷静下来后，仔细衡量了再冲一冲计算机专业好的学校，拿电影学院或者传媒大学保底的想法，觉得不大现实也没有太多意义。在与家里交流后，除了一年一万的学费着实有一些高，倒也没有更多异议了。嚣张一点说，一步一步的路，还算是自己踏出来的吧。\n既然确定要来电影学院了，加之江苏高考对艺术类录取的特殊性，我开始不在教室上物理课和化学课，也不再做相关的练习。每天都在语数外的固定练习和“快乐”生活中来回切换。最后的两个月，我过得简直要比小学生更舒坦。当然，我的同学们也都在乐观和时而闲憩的状态中度过了最后的日子。\n成人礼上，没有关于高考的任何话题，母亲坐在旁边，听着邢玮依旧原始有力而温和冷静的演讲，觉得成人其实也没有那么可怕。可能是因为我从小起就常独自一人吧。就像毕业典礼一样，庄重，轻松，快乐。毕业之后的班级酒会是我第一回和那么多人一块喝酒，只是啤的，我们和邢老师来回了许多回合。也算是为电影学院的酒文化做了一点点预警。\n要说整个高三的最大收获就是，在免去了学校很多繁重的事务之后，读了比高一高二多很多的书。也赖于高三攒钱买的kindle吧。关于读书，高一高二的语文课不按着高考套路上，每学期有必读书目，考试的一半都是有关那段时间那本书的。那时读了《约翰·克里斯朵夫》这样的很多书，至今仍想重读。高二高三两年，学校语文组面向全校办了每月一场阅读讲座，我不是每本都读过，但几乎没有缺过一场。插一句大学这半年最大的遗憾就是，依然一直在囤书，但没什么时间看了。\n高考那三天对我来说已经没有太多深刻的印象了，只记得母亲特地停了一阵子缝纫机前工作，跑来好几趟南京市区送点水果什么的。语数外三门考完后，我就像平时模考一样，觉得自己的考试已经全部结束了。物理考试，30分钟，从后往前写，写完倒头就睡。化学则花了40分钟。考场上有个女生也是在物理化学考试时各睡了一觉，只是她一道题也没有写，想来也是个艺术生吧。后来查分时，说一点也不紧张倒也不现实。只是物理和化学的AB+着实惊到我了，是没想到这么水完的卷子能拿不错的分数。语文数学没达到理想的分数也意料之中了，一向势弱的英语考得还可以，最后分数加上小高考的加分倒也不难看。问题还是出在这个“不难看”上。算来算去，我那个糟糕的分数还是应该够得上一所计算机学科评估为A的985地方院校。所以，各方势力还是有让我继续原来的方向的声音，也有让选身为211的中传的意见。还是那句话，学是自己考的，最后出于各种各样的坚持吧，到了电影学院影视技术系。\n现在觉得，选择北京电影学院影视技术系，是我高中生涯做的最正确的决定之一——这里，着实有我想学的东西。\n在聊下半年的学业之前，说说我们五个人的南京小团队吧。之前陶一级就跨高中式的有一个视频媒体类的团队，Hori，当年陶招兵买马时就把我拉进了群。唐在北电出分之后，很快地找起了南京拿到电影学院证的同学，最终在所谓的传统“老四所”里凑齐了五个人。我和吴，金陵中学的唐和宋，南京一中的沈，宋拿了编导和动漫策划的证，沈子航是影技第十七，同时是摄影学院第一。我们就开始有一块学习一起接点商活的想法，高考前一起出去吃饭看电影活动了好几次。暑假拍摄南京一中毕业短片时算是把想法落了个地，起了一个挺尴尬的Team名，就不记上来了。唐和沈买了BMPCC4K，我组了一台还算强劲的台式机，也算是成了型。但暑假着实怠惰，也没什么经验，因此也没接到几个活。但我们这五个人的小团队算是一直有在活动吧。暑假雷打不动的就是在群里掷骰子了，聚了几次之后，我因住得远（在郊区），也渐渐减少了频率，吴则是徐州人，视频语音的联系更多一些。突然有一天，不知怎么聊来的，吴发现了沈和宋在一起了，也算是我们几个人里边的一桩好事吧，不过后来两人有些纠纷又合好是开学之后的事了，现在依旧祝福他们能走得长久。唐也和本来拉来团队当“秘书”“文差”的小姑娘谈了一阵子恋爱。暑假我们五人就在既没有学到什么东西，却也在异常愉快的日子里混了过去。\n说是愉快，其实这个暑假还是有些枯燥无聊的。高考出分后，就开始联系未来的同学。但直很长一段时间，只找齐了四位同学。一直一直到暑假结束时，还在进行这项工作。暑假还去了一趟杭州。最初知道图形学这个概念时，了解到浙大是中国计算机图形学最好的地方，也有过考取的幻想，只是能力有限不大可能了。是陪出国的同学钱一块去的，他录取了加州大学尔湾分校，是高一高二的两年室友，高三脱产后开始接触了视频拍摄的领域。他在杭州开始试着用a6400拍摄vlog，这方面我稍有经验一些吧。吃好喝好，算是杭州行最多的概括了，是这辈子离开南京市去的第三个地方，前两个是小时候拜访远亲的安徽，和今年年初去考试的北京。之后的暑假就一直在无聊的娱乐和懒惰中度过。没有学东西也没有学东西的动力。\n开学那几天，我们宿舍很快就熟络起来了，电影学院按专业排名分宿舍，所以四个人的相似处还是有的。因为分到了四人间，参观了师哥们新搬的701，热情高涨地布置了“智能宿舍”。就是买了很多米家的东西，最后都让小爱同学来控制寝室电器了。为了军训还是做了很多准备，军训的日子很苦，但我和唐在三连混了病号座，就那么水过了十几天。\n开学之后，先是师哥师姐集体请了一顿饭，由于之前有几个师哥挺熟，饭局上就开始向他们学习HDR的知识了，白龙老师那时发我的文档至今还没能读完。班里又找不同的借口组织了挺多次团建，甚至让我们自己戏称“团建本”。也算是十三个人的小班混得足够熟了吧。某次团建上，还因为大家起哄让室友马卓琪内部脱单了，想来很有意思。我们班有个微博超话，叫“影视杂技2077”，记录了不少影技冷笑话。\n后来渐渐地就engaged in学习和工作了，每天晚上到北邮跑四公里也没能坚持下去了。要说这学期学到了些什么，那可真的太多了，可某种意义上又没能达到学期初定的计划。是有打算同步自学计算机专业的东西的，可是C++到现在也才开始了一点点。主要是课业和各种活之外，同时在学的东西实在是太多太多了。给我最大的感触就是英语和数学实在是太重要了，永远都在遇到英语和数学的障碍，永远都在补数学基础。\n三维，色彩科学，编码，C++，OpenGL，数学，物理等等等等通通都在同步地学，一方面觉得自己这样不行，太过于乱了，一方面有忍不住地往更宽的边界探索。和军训认识的好友李明峰交流时，聊到我有对接触到的事物査根究底的冲动，可越往下挖就越是新坑，后来心态逐渐放宽了，可还是会对感兴趣的话题试图钻研几分，就导致我同时在探索的东西实在是太过繁多又难以自制。\n要说这学期学的最远的还是色彩科学。有次蹭数媒技班的高数课时，突然了解到数学老师顾老师在系里就是研究色彩科学的，之后就逐渐有了专业上的交流。也在担任系里特种影像论坛主视觉设计时，结识了硕士研究生鲁梦河师哥。就在那天，我翘了一节外出禁毒博物馆的思修课，跟着顾老师，朱老师和师哥一块去了cinity实验室，是我在我自己摸索色彩科学初有见效之后，那一天学到了这学期最多的东西。虽然老师们研究的cinity的标准，但其中涉及的色彩科学的各种概念大大丰富了我的认知和见解。之后又买了不少有关的书，看了很多文档，寒假还被顾老师布置了“作业”，让帮翻译两篇DCI的标准。想来也是一样好事，英语这一关，是不得不攻克的。\n说到cinity，十月份我在朝阳大悦城刷了两遍cinity版本的《双子杀手》，很震撼，很喜欢。第一回是0点场的首映，和大二的师哥们一起去的，看完后，一起大呼nb一起去吃海底捞聊技术细节聊未来影像，好不快活。第二轮则是班里的团建，少了一两人，但也很是激动。对于这样的高技术规格影像，也有了一些自己的见解。后来发过一句话，好像是“现在是‘强烈的视觉冲击和感官刺激’，我们探讨起其必要性，未来应该是‘之前我们是怎样忍受那样的画面的’，就不会再有异议了。”\n再回忆这学期的活动就是isfvf了，是进学校之前就被师哥陈品森内定了摄制组，也没有做很多工作，倒是一直在解决班里其他同学在其他组工作中遇到的某些问题。长城那天的拍摄，有点累，和几个老外试着聊了两句，摸了松下的s1。最后肝片子的那一夜，是较早的体会到了电影学院的不眠风格。\n谈起不眠，因为各种学业作业商单学生组，各种各样的ddl，凌晨两三点上床睡觉已经不被我们称之为“熬夜”了。可尽管如此，这一学期还是没有完成预计的学习内容，也没有赚到足够的钱。\n12月初买的mbp还借了家长几千块钱，好在几天前还上了。高中离开高淳，开始吃南师附中的贫困助学粮。来北京之前，家长动用了存着定期多年的“上大学用的”钱，我只要了每个月一千五的生活费，此外的所有额外支出，都坚持由我自己承担。所以借这笔买电脑的钱时，很是羞愧，于是在十月份的一笔单子尾款鸽了两个月后终于拿到手时，赶紧还清了。既然都离开家了，就不该再啃食他们了。选择电影学院影视技术系而没有去读一个本科要通过洗碗刷筷而不是专业知识挣钱的计算机专业，也有这方面的考量吧。\n至于跟学生组，这学期之后，我大抵是不会再跟现场了。执行的都是预先设计的流程，解决的也是熟悉的问题，片场总有让我昏昏欲睡的特质。试着带书去片场也不能让我专注于学习新的东西。我是非常非常抵触机械的劳动的，如果没有源源不断的新东西涌进我的大脑，榨取我的脑汁，我反而会无比劳累，没有精神。还有摄系美院的几个同学来拉我和李一起从事cg创作，我们对跟组有着同样的想法。\n最近常与高中好友冯聊天，他是高中时我社团的副社长，代码能力比我要强很多，最后高考不理想，在苏大被调剂到了一个不喜欢的专业，这半年都在为了转专业作努力。他说，很羡慕我这么早就能all in自己的专业的感觉。想了想，着实幸运，但很多杂七杂八的课程，和“想学的课其实自己早有了解过”的态度，还是让自己觉得其实也没有那么all in，反而课外的时间比方说深夜，才是比较能体现自己的学习状态的。和他聊到了我在学期最后两周的经典电影赏析论文中开辟新领域来了解的事情，试图找了很多相关的论文，还专程跑了一趟三维六度公司了解胶片修复流程和一些有关问题。他则为了转专业而要写一个Python的项目，我推荐了之前物理课上我在研究的opencv图像处理有关的东西，也是期待他能够到自己真正应该在的地方吧。谈到人生的一些别的方面，我们俩共同的感觉就是，现在这个节点，还是应该让学习占据最多的时间。\n19年的最后一堂课是孙老师的数字摄影的摄影分享，要找一个或几个摄影师或者画家做presentation。那天轮到的都自己班的同学，为了不错过，上午从冷到让我都发抖的房山抓紧赶回学校。我是课上最后一个讲的，说“也没什么压轴的宝贝给大家看”。讲了画家，“最早的平面设计师”穆夏。我说，穆夏不是浪漫的少女的清新的，他是民族的历史的人性的。我展示了穆夏最后的画作系列《斯拉夫史诗》，也是想表达一下自己对宏大，对伟大的盲目追求和纯粹崇敬吧。看那些画，当时就想到“无穷的远方，无数的人们，都与我有关”，我了解的着实还太少，今天人类社会好多可怕或讶人的事和现象，着实值得令人深思。但我也着实想要去看清它并继续热爱它。\n本来还想做一个有关NASA摄影集的presentation，来传达几分自己对远方对深邃浪漫的热衷。就想到下半年看的电影中，最令我喜爱的，还是《Ad Astra》。那天在英皇看了自己第一场激光IMAX，那种纯粹的孤独浪漫属实深深吸引到我了。那天回学校的地铁上，我和李乐游，唐汉卿，李明峰初步提到了人生追求的话题，就觉得人各有异，但还是“可可爱爱”。“人类的悲欢各不相同，我只觉得他们吵闹”，可“吵闹”才构成了我们纷繁的世界和社会。我还是很崇敬那种为了事业鞠躬尽瘁、死生度外的人生理想的，很希望做一个能为了某些东西保持单纯保持快乐的终生学习者，但还是要看自己的能力而定了。\n最后，聊聊我可爱的室友们吧！唐常因“嘤嘤叫”被我批判一番，给人的感觉也是一个懒洋洋的，又追求高质量生活的有几分功利的样子，对一些事物常常有夸大其词的习惯。但从我不长的了解来看，他的本质还是乐观积极，有执着有学习热情的大男孩，家庭条件好和金中也很自由的学风造就了他大大咧咧，大方又坚持着自己的态度的风格。马是一个坚持要走“创作路线”的宅男，他会在在寝室脱着裤子剪片，会为了拍照做奇怪的姿势，会在看恐怖片时偏过头去露出微微一个眼角去瞥，会和李撒娇求欢…也是一个很有趣的同学。李是我很尊敬的室友，有些方面他可以作为典范而存在，不藏不匿，自然开朗。最令我佩服的还是他的学习态度，他是真的可以全神贯注去学习的人，立志在cg行业做一些贡献，这学期他在软件和基础理论的学习上都远比我认真勤恳，也颇见成效，真的是我要学习的人物。我们寝室还是非常非常欢乐，同时也很具有学习、工作氛围的，其他同学初来我们寝室参观时，都会有几分震惊吧。更令人欣慰的一点是，大家都或多或少有几分洁癖，比起日常来我们寝室串宿的电影学系李同学的203寝室来说，207的环境着实不止好了一点点。19影技班每一个同学都可以借用白龙的形容词来说，“可可爱爱”。这半年的小记里就不多“回忆录”了。\n再回想过去的那些室友那些同学，每个人都在今年为自己的方向前进了，也算是一个旁观者同时是朋友的欣慰了吧。\n2019对我来说，真的还算得上是非常非常重要又奇幻的一年。算是补叙，再吹一下自己的神奇经历，小学三年级被校长建议转到了镇里中心小学继续念书，初中又阴差阳错通过考试免了费用在区里的民办初中读书，中考时第二次考全校前三，没去一模拿到第一定下的县中压线到了南师附中。所以，从南师附中到北京电影学院这一年，着实更显奇妙。从南京郊区农村走到现在，这一生遇到很多好人，就像这一年的lucky experience那样，充满惊喜和幸运。很感谢2019，也感谢无数的人们和自己。\n现在的我其实是在偷懒，复习数学考试的档歇，码这么又臭又长的一段裹脚布。不需要考虑“阅卷老师”的写东西的感觉真爽，算是留给多少年后的自己，一点“今生今世的证据”吧。\n","permalink":"https://elderlyaugustus.github.io/posts/2020-01-01-my2019/","summary":"上半年，一直在写800字的“议论文”，下半年则没怎么提起过笔。高考这一年，还是值得写两个字的。\n记得初一时还对曹说过，想记日记一直到高三，现在想来真是可笑。这份“年记”，肯定是会记成流水账的，也不是写给别人看的。\n2019年的前一天，18年12月31日，是我这辈子第一回到北京。晚上安顿了住处，还到电影学院转了一圈，当时的感触只有：“五分钟转完的小地方。”元旦在中传考试，父亲第一回进大学参观，告诉我：“你看这学校，比昨天那个电影学校大多了，你考这多好。”我笑了笑，像做初中题似的做完了初试。依稀记得，收卷后坐我后排的两个女生还在聊这张卷子上的数学有多难。在北京，看了天安门，可能是北京天气最好的一天。十一个小时的T31，凌晨赶回南师附中继续复习。\n艺考，对我来说是从前从来也没想过的升学途径。不过现在想想，我小学三年级的转学，小升初，初升高都远出乎意料之外，不然我现在可能真跟小学的同学在哪个工地上搬真的砖块吧。想来也是我的求学生涯过于lucky了吧。\n18年3月，陶开始建议我尝试影视技术专业。此前跟他在校社协干了两年的文宣工作，确实也在视频技术这块有些许积累。一直以来玩计算机，虽也没玩出什么名堂来，但本想走的还是微电子或者计算机科学的路子，唐突间的提议，倒也不是一时间能接受的。只是一时间对电影有了更多的关注吧。最终还是在自己的高考报名表上填了“理兼艺”。\n我的情况确实容不得考学的失误，没有复读的条件，也没有多余的出路，真真切切的“考不上回家种大田”。就像家长一直挺介意我没有按部就班去县中苦读三年而是跑到城里去读南师附中一样。所以，也算是多个路子多种可能吧，毕竟在江苏高考，什么样的岔子都不是没可能的。老师家长也只是有质疑，介于我并没有说因此在学习的安排上有任何变化，便也并不多说。\n扯了一大节前情提要，年初的几趟校考着实是艺考能让我缺掉的仅有的几堂课——毕竟都是吃老本而已。甚至说，我最后来的电影学院的两次考试，都卡在周末的节点上，完完全全没有影响到校内的课程。北电摄影系的初试，也因为跟四校联考的冲突而直接放弃了。\n艺考结束的最大感触就是，所有我考了的专业，涉及文化课和思维的部分，都太过简单，专业的知识也只能依赖此前摸爬滚打积累的一点点零散经验。这让我对艺考选拔还是充满了不信任。于是又加快了备考的步伐——按今年年初那个极不稳定的水平，到头来要是连一个985211都考不上也不是没有可能的。\n当然，在南师附中的高三生活还是很充实的。算算差不多做套卷子，差不多了还是会玩会电脑，出门转悠转悠。晚上在宿舍抱着kindle读到深夜，思索着大千世界。甚至说周末在新街口电影院见到穿着高三校服的南师附中学生，也是常有的事。个人觉得，这也正是我们对做题并没有那么抵触和恐惧的原因吧。\n四月份，最先出分的是传媒大学，摄制第七，数媒影像通过。很多同学恭喜我有学上了，那天玩得很嗨。当天晚上，差点没有睡着，一直在考虑自己的位置和这两张证对自己的意义。同一间寝室另一个一直有认真学编导类的好友，吴，拿了两张并不出彩的证。我俩也算是南师附中这一届考了影视类艺术院校的唯二两人了吧。按附中惯例，互相吹捧了一番。之后两周，一边开始期待另一所更为关注的院校，电影学院，出分，一边也确实有些许懈怠了。\n4月15日的早上，我逃了一次课间操，守在电脑面前，和远在北京的陶一块查分。他在校内帮我查，QQ里他发来那张合格证的图和几句口头禅时，我还是不得不说地很是有些激动，着实没能想到一个半吊子的文化考生，能拿影技第一的证。那一天，突然开始使用微信，加了很多很多人，直聊到深夜，最后说晚安的，是现在大三的师哥陈。唐汉卿也是从那时开始才联系上我和吴的，他是影技第二，吴拿了编导的证。\n冷静下来后，仔细衡量了再冲一冲计算机专业好的学校，拿电影学院或者传媒大学保底的想法，觉得不大现实也没有太多意义。在与家里交流后，除了一年一万的学费着实有一些高，倒也没有更多异议了。嚣张一点说，一步一步的路，还算是自己踏出来的吧。\n既然确定要来电影学院了，加之江苏高考对艺术类录取的特殊性，我开始不在教室上物理课和化学课，也不再做相关的练习。每天都在语数外的固定练习和“快乐”生活中来回切换。最后的两个月，我过得简直要比小学生更舒坦。当然，我的同学们也都在乐观和时而闲憩的状态中度过了最后的日子。\n成人礼上，没有关于高考的任何话题，母亲坐在旁边，听着邢玮依旧原始有力而温和冷静的演讲，觉得成人其实也没有那么可怕。可能是因为我从小起就常独自一人吧。就像毕业典礼一样，庄重，轻松，快乐。毕业之后的班级酒会是我第一回和那么多人一块喝酒，只是啤的，我们和邢老师来回了许多回合。也算是为电影学院的酒文化做了一点点预警。\n要说整个高三的最大收获就是，在免去了学校很多繁重的事务之后，读了比高一高二多很多的书。也赖于高三攒钱买的kindle吧。关于读书，高一高二的语文课不按着高考套路上，每学期有必读书目，考试的一半都是有关那段时间那本书的。那时读了《约翰·克里斯朵夫》这样的很多书，至今仍想重读。高二高三两年，学校语文组面向全校办了每月一场阅读讲座，我不是每本都读过，但几乎没有缺过一场。插一句大学这半年最大的遗憾就是，依然一直在囤书，但没什么时间看了。\n高考那三天对我来说已经没有太多深刻的印象了，只记得母亲特地停了一阵子缝纫机前工作，跑来好几趟南京市区送点水果什么的。语数外三门考完后，我就像平时模考一样，觉得自己的考试已经全部结束了。物理考试，30分钟，从后往前写，写完倒头就睡。化学则花了40分钟。考场上有个女生也是在物理化学考试时各睡了一觉，只是她一道题也没有写，想来也是个艺术生吧。后来查分时，说一点也不紧张倒也不现实。只是物理和化学的AB+着实惊到我了，是没想到这么水完的卷子能拿不错的分数。语文数学没达到理想的分数也意料之中了，一向势弱的英语考得还可以，最后分数加上小高考的加分倒也不难看。问题还是出在这个“不难看”上。算来算去，我那个糟糕的分数还是应该够得上一所计算机学科评估为A的985地方院校。所以，各方势力还是有让我继续原来的方向的声音，也有让选身为211的中传的意见。还是那句话，学是自己考的，最后出于各种各样的坚持吧，到了电影学院影视技术系。\n现在觉得，选择北京电影学院影视技术系，是我高中生涯做的最正确的决定之一——这里，着实有我想学的东西。\n在聊下半年的学业之前，说说我们五个人的南京小团队吧。之前陶一级就跨高中式的有一个视频媒体类的团队，Hori，当年陶招兵买马时就把我拉进了群。唐在北电出分之后，很快地找起了南京拿到电影学院证的同学，最终在所谓的传统“老四所”里凑齐了五个人。我和吴，金陵中学的唐和宋，南京一中的沈，宋拿了编导和动漫策划的证，沈子航是影技第十七，同时是摄影学院第一。我们就开始有一块学习一起接点商活的想法，高考前一起出去吃饭看电影活动了好几次。暑假拍摄南京一中毕业短片时算是把想法落了个地，起了一个挺尴尬的Team名，就不记上来了。唐和沈买了BMPCC4K，我组了一台还算强劲的台式机，也算是成了型。但暑假着实怠惰，也没什么经验，因此也没接到几个活。但我们这五个人的小团队算是一直有在活动吧。暑假雷打不动的就是在群里掷骰子了，聚了几次之后，我因住得远（在郊区），也渐渐减少了频率，吴则是徐州人，视频语音的联系更多一些。突然有一天，不知怎么聊来的，吴发现了沈和宋在一起了，也算是我们几个人里边的一桩好事吧，不过后来两人有些纠纷又合好是开学之后的事了，现在依旧祝福他们能走得长久。唐也和本来拉来团队当“秘书”“文差”的小姑娘谈了一阵子恋爱。暑假我们五人就在既没有学到什么东西，却也在异常愉快的日子里混了过去。\n说是愉快，其实这个暑假还是有些枯燥无聊的。高考出分后，就开始联系未来的同学。但直很长一段时间，只找齐了四位同学。一直一直到暑假结束时，还在进行这项工作。暑假还去了一趟杭州。最初知道图形学这个概念时，了解到浙大是中国计算机图形学最好的地方，也有过考取的幻想，只是能力有限不大可能了。是陪出国的同学钱一块去的，他录取了加州大学尔湾分校，是高一高二的两年室友，高三脱产后开始接触了视频拍摄的领域。他在杭州开始试着用a6400拍摄vlog，这方面我稍有经验一些吧。吃好喝好，算是杭州行最多的概括了，是这辈子离开南京市去的第三个地方，前两个是小时候拜访远亲的安徽，和今年年初去考试的北京。之后的暑假就一直在无聊的娱乐和懒惰中度过。没有学东西也没有学东西的动力。\n开学那几天，我们宿舍很快就熟络起来了，电影学院按专业排名分宿舍，所以四个人的相似处还是有的。因为分到了四人间，参观了师哥们新搬的701，热情高涨地布置了“智能宿舍”。就是买了很多米家的东西，最后都让小爱同学来控制寝室电器了。为了军训还是做了很多准备，军训的日子很苦，但我和唐在三连混了病号座，就那么水过了十几天。\n开学之后，先是师哥师姐集体请了一顿饭，由于之前有几个师哥挺熟，饭局上就开始向他们学习HDR的知识了，白龙老师那时发我的文档至今还没能读完。班里又找不同的借口组织了挺多次团建，甚至让我们自己戏称“团建本”。也算是十三个人的小班混得足够熟了吧。某次团建上，还因为大家起哄让室友马卓琪内部脱单了，想来很有意思。我们班有个微博超话，叫“影视杂技2077”，记录了不少影技冷笑话。\n后来渐渐地就engaged in学习和工作了，每天晚上到北邮跑四公里也没能坚持下去了。要说这学期学到了些什么，那可真的太多了，可某种意义上又没能达到学期初定的计划。是有打算同步自学计算机专业的东西的，可是C++到现在也才开始了一点点。主要是课业和各种活之外，同时在学的东西实在是太多太多了。给我最大的感触就是英语和数学实在是太重要了，永远都在遇到英语和数学的障碍，永远都在补数学基础。\n三维，色彩科学，编码，C++，OpenGL，数学，物理等等等等通通都在同步地学，一方面觉得自己这样不行，太过于乱了，一方面有忍不住地往更宽的边界探索。和军训认识的好友李明峰交流时，聊到我有对接触到的事物査根究底的冲动，可越往下挖就越是新坑，后来心态逐渐放宽了，可还是会对感兴趣的话题试图钻研几分，就导致我同时在探索的东西实在是太过繁多又难以自制。\n要说这学期学的最远的还是色彩科学。有次蹭数媒技班的高数课时，突然了解到数学老师顾老师在系里就是研究色彩科学的，之后就逐渐有了专业上的交流。也在担任系里特种影像论坛主视觉设计时，结识了硕士研究生鲁梦河师哥。就在那天，我翘了一节外出禁毒博物馆的思修课，跟着顾老师，朱老师和师哥一块去了cinity实验室，是我在我自己摸索色彩科学初有见效之后，那一天学到了这学期最多的东西。虽然老师们研究的cinity的标准，但其中涉及的色彩科学的各种概念大大丰富了我的认知和见解。之后又买了不少有关的书，看了很多文档，寒假还被顾老师布置了“作业”，让帮翻译两篇DCI的标准。想来也是一样好事，英语这一关，是不得不攻克的。\n说到cinity，十月份我在朝阳大悦城刷了两遍cinity版本的《双子杀手》，很震撼，很喜欢。第一回是0点场的首映，和大二的师哥们一起去的，看完后，一起大呼nb一起去吃海底捞聊技术细节聊未来影像，好不快活。第二轮则是班里的团建，少了一两人，但也很是激动。对于这样的高技术规格影像，也有了一些自己的见解。后来发过一句话，好像是“现在是‘强烈的视觉冲击和感官刺激’，我们探讨起其必要性，未来应该是‘之前我们是怎样忍受那样的画面的’，就不会再有异议了。”\n再回忆这学期的活动就是isfvf了，是进学校之前就被师哥陈品森内定了摄制组，也没有做很多工作，倒是一直在解决班里其他同学在其他组工作中遇到的某些问题。长城那天的拍摄，有点累，和几个老外试着聊了两句，摸了松下的s1。最后肝片子的那一夜，是较早的体会到了电影学院的不眠风格。\n谈起不眠，因为各种学业作业商单学生组，各种各样的ddl，凌晨两三点上床睡觉已经不被我们称之为“熬夜”了。可尽管如此，这一学期还是没有完成预计的学习内容，也没有赚到足够的钱。\n12月初买的mbp还借了家长几千块钱，好在几天前还上了。高中离开高淳，开始吃南师附中的贫困助学粮。来北京之前，家长动用了存着定期多年的“上大学用的”钱，我只要了每个月一千五的生活费，此外的所有额外支出，都坚持由我自己承担。所以借这笔买电脑的钱时，很是羞愧，于是在十月份的一笔单子尾款鸽了两个月后终于拿到手时，赶紧还清了。既然都离开家了，就不该再啃食他们了。选择电影学院影视技术系而没有去读一个本科要通过洗碗刷筷而不是专业知识挣钱的计算机专业，也有这方面的考量吧。\n至于跟学生组，这学期之后，我大抵是不会再跟现场了。执行的都是预先设计的流程，解决的也是熟悉的问题，片场总有让我昏昏欲睡的特质。试着带书去片场也不能让我专注于学习新的东西。我是非常非常抵触机械的劳动的，如果没有源源不断的新东西涌进我的大脑，榨取我的脑汁，我反而会无比劳累，没有精神。还有摄系美院的几个同学来拉我和李一起从事cg创作，我们对跟组有着同样的想法。\n最近常与高中好友冯聊天，他是高中时我社团的副社长，代码能力比我要强很多，最后高考不理想，在苏大被调剂到了一个不喜欢的专业，这半年都在为了转专业作努力。他说，很羡慕我这么早就能all in自己的专业的感觉。想了想，着实幸运，但很多杂七杂八的课程，和“想学的课其实自己早有了解过”的态度，还是让自己觉得其实也没有那么all in，反而课外的时间比方说深夜，才是比较能体现自己的学习状态的。和他聊到了我在学期最后两周的经典电影赏析论文中开辟新领域来了解的事情，试图找了很多相关的论文，还专程跑了一趟三维六度公司了解胶片修复流程和一些有关问题。他则为了转专业而要写一个Python的项目，我推荐了之前物理课上我在研究的opencv图像处理有关的东西，也是期待他能够到自己真正应该在的地方吧。谈到人生的一些别的方面，我们俩共同的感觉就是，现在这个节点，还是应该让学习占据最多的时间。\n19年的最后一堂课是孙老师的数字摄影的摄影分享，要找一个或几个摄影师或者画家做presentation。那天轮到的都自己班的同学，为了不错过，上午从冷到让我都发抖的房山抓紧赶回学校。我是课上最后一个讲的，说“也没什么压轴的宝贝给大家看”。讲了画家，“最早的平面设计师”穆夏。我说，穆夏不是浪漫的少女的清新的，他是民族的历史的人性的。我展示了穆夏最后的画作系列《斯拉夫史诗》，也是想表达一下自己对宏大，对伟大的盲目追求和纯粹崇敬吧。看那些画，当时就想到“无穷的远方，无数的人们，都与我有关”，我了解的着实还太少，今天人类社会好多可怕或讶人的事和现象，着实值得令人深思。但我也着实想要去看清它并继续热爱它。\n本来还想做一个有关NASA摄影集的presentation，来传达几分自己对远方对深邃浪漫的热衷。就想到下半年看的电影中，最令我喜爱的，还是《Ad Astra》。那天在英皇看了自己第一场激光IMAX，那种纯粹的孤独浪漫属实深深吸引到我了。那天回学校的地铁上，我和李乐游，唐汉卿，李明峰初步提到了人生追求的话题，就觉得人各有异，但还是“可可爱爱”。“人类的悲欢各不相同，我只觉得他们吵闹”，可“吵闹”才构成了我们纷繁的世界和社会。我还是很崇敬那种为了事业鞠躬尽瘁、死生度外的人生理想的，很希望做一个能为了某些东西保持单纯保持快乐的终生学习者，但还是要看自己的能力而定了。\n最后，聊聊我可爱的室友们吧！唐常因“嘤嘤叫”被我批判一番，给人的感觉也是一个懒洋洋的，又追求高质量生活的有几分功利的样子，对一些事物常常有夸大其词的习惯。但从我不长的了解来看，他的本质还是乐观积极，有执着有学习热情的大男孩，家庭条件好和金中也很自由的学风造就了他大大咧咧，大方又坚持着自己的态度的风格。马是一个坚持要走“创作路线”的宅男，他会在在寝室脱着裤子剪片，会为了拍照做奇怪的姿势，会在看恐怖片时偏过头去露出微微一个眼角去瞥，会和李撒娇求欢…也是一个很有趣的同学。李是我很尊敬的室友，有些方面他可以作为典范而存在，不藏不匿，自然开朗。最令我佩服的还是他的学习态度，他是真的可以全神贯注去学习的人，立志在cg行业做一些贡献，这学期他在软件和基础理论的学习上都远比我认真勤恳，也颇见成效，真的是我要学习的人物。我们寝室还是非常非常欢乐，同时也很具有学习、工作氛围的，其他同学初来我们寝室参观时，都会有几分震惊吧。更令人欣慰的一点是，大家都或多或少有几分洁癖，比起日常来我们寝室串宿的电影学系李同学的203寝室来说，207的环境着实不止好了一点点。19影技班每一个同学都可以借用白龙的形容词来说，“可可爱爱”。这半年的小记里就不多“回忆录”了。\n再回想过去的那些室友那些同学，每个人都在今年为自己的方向前进了，也算是一个旁观者同时是朋友的欣慰了吧。\n2019对我来说，真的还算得上是非常非常重要又奇幻的一年。算是补叙，再吹一下自己的神奇经历，小学三年级被校长建议转到了镇里中心小学继续念书，初中又阴差阳错通过考试免了费用在区里的民办初中读书，中考时第二次考全校前三，没去一模拿到第一定下的县中压线到了南师附中。所以，从南师附中到北京电影学院这一年，着实更显奇妙。从南京郊区农村走到现在，这一生遇到很多好人，就像这一年的lucky experience那样，充满惊喜和幸运。很感谢2019，也感谢无数的人们和自己。\n现在的我其实是在偷懒，复习数学考试的档歇，码这么又臭又长的一段裹脚布。不需要考虑“阅卷老师”的写东西的感觉真爽，算是留给多少年后的自己，一点“今生今世的证据”吧。","title":"My 2019 [补档]"},{"content":"肖翱 北京电影学院影视技术系，电影虚拟化制作实验室\n游戏引擎开发，技术美术，影视制作流程研发\n","permalink":"https://elderlyaugustus.github.io/about/","summary":"肖翱 北京电影学院影视技术系，电影虚拟化制作实验室\n游戏引擎开发，技术美术，影视制作流程研发","title":""}]