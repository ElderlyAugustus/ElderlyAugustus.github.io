<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>现代游戏引擎 on xα&#39;s blog</title>
    <link>https://elderlyaugustus.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/</link>
    <description>Recent content in 现代游戏引擎 on xα&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Oct 2022 21:00:00 +0800</lastBuildDate><atom:link href="https://elderlyaugustus.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022-10-23-GAMES104现代游戏引擎-Lecture22-GPU Driven Geometry Pipeline - Nanite</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture22-nanite/</link>
      <pubDate>Sun, 23 Oct 2022 21:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture22-nanite/</guid>
      <description>Lecture22 GPU Driven Geometry Pipeline - Nanite Research Background 传统渲染管线 CPU发起Draw Call，GPU准备State、进入漫长的Pipeline CPU、GPU不同步 存在大量的算力浪费 现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈 “曙光”: Compute Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算 Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh GPU Driven Render Pipeline 将场景完整load到显存中，完全由GPU处理：DrawPrimitive -&amp;gt; DrawScene @《刺客信条：大革命》
Mesh Cluster Rendering 将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算 不可见的Cluster不渲染；Culling流程： 尽可能裁剪掉不可见的三角形 将可见的三角形组成同一个Buffer GPU Driven Pipeline CPU端： 根据材质不同组合Instance 根据相机距离LoD 打包交给GPU做后续处理 GPU Instance Culling Instance Culling 将（64个）Cluster组成一个Chunk，再次Culling，以加速 GPU Cluster Culling Chunk -&amp;gt; Cluster -&amp;gt; Triangle 一步步裁剪，将视锥外、背面的全部裁剪 Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer 三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题 =&amp;gt; 硬件Multi-Indirect Draw Call或可解决此问题 对高精度的Mesh效率非常高 Codec Triangle Visibility in Cube : Backface Culling 每个Cluster存储每个三角形对两个方向的可见性 利用这一数据快速做Backface Culling Occlusion Culling for Camera and Shadow 利用前一帧Z-Buffer的方法： 取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer 将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处 保守估计Culling Instance -&amp;gt; Chunk -&amp;gt; Cluster -&amp;gt; Triangle 问题：高速移动物体存在一定Artifact Two-Phase Occlusion Culling 快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer 再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者 更加准确 Fast Occlusion for Shadow Shadow中生成深度时对几何细节量敏感 对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度 只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer Visibility Buffer Forward Rendering：所有互相遮挡、透明的物体需要做重复计算 Deferred Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算 G-Buffer的存储、IO开销大 复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over draw，多次绘制同一像素时开销大 Visibility Buffer： 第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID, PrimitiveID, MaterialID, …) 根据各种ID读取对应贴图，再做重心坐标插值着色 几乎没有Over Draw Cache Miss率低 Pipeline Visibility Buffer + Deferred Shading 一般来说，草丛等复杂细节情况可直接用Visibility Buffer渲染，主角等主要内容Gather到G-Buffer再渲染 注意点：MIPMAP采样时的插值平滑问题 Virtual Geometry - Nanite Overview Virtual Texture Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图 所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP 预烘焙这张“大贴图”，并做MIPMAP 根据View区域动态加载所需的部分 Idea of Nanite Virtual Geometry like Virtual Texture 挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point Cloud可以Filter） Voxel ?</description>
      <content:encoded><![CDATA[<h2 id="lecture22-gpu-driven-geometry-pipeline---nanite">Lecture22 GPU
Driven Geometry Pipeline - Nanite</h2>
<h3 id="research-background">Research Background</h3>
<h4 id="传统渲染管线">传统渲染管线</h4>
<h4
id="section"><img src="/images/games104/L22_TraditionalRenderPipeline.png" alt="L22_TraditionalRenderPipeline" style="zoom: 25%;" /></h4>
<ul>
<li>CPU发起Draw Call，GPU准备State、进入漫长的Pipeline
<img src="/images/games104/L22_CPUDrivenRenderPipeline.jpg" alt="L22_CPUDrivenRenderPipeline" style="zoom: 50%;" />
<ul>
<li>CPU、GPU不同步</li>
<li>存在大量的算力浪费</li>
</ul></li>
<li>现代游戏Draw Call越来越复杂，已经成为现代渲染管线瓶颈</li>
<li>“曙光”:
<ul>
<li>Compute
Shader：不再需要在CPU、GPU之间来回传递数据，直接在GPU中执行通用计算
<img src="/images/games104/L22_ComputeShader.jpg" alt="L22_ComputeShader" style="zoom: 33%;" /></li>
<li>Draw-Indirect Graphics API：一次Draw Call绘制多个Mesh
<img src="/images/games104/L22_DrawIndirect.jpg" alt="L22_DrawIndirect" style="zoom: 50%;" /></li>
</ul></li>
</ul>
<h4 id="gpu-driven-render-pipeline">GPU Driven Render Pipeline</h4>
<p>将场景完整load到显存中，完全由GPU处理：DrawPrimitive -&gt; DrawScene
<img src="/images/games104/L22_GPUDrivenRenderPipeline.jpg" alt="L22_GPUDrivenRenderPipeline" style="zoom: 50%;" /></p>
<p>@《刺客信条：大革命》</p>
<h5 id="mesh-cluster-rendering">Mesh Cluster Rendering</h5>
<ul>
<li>将Mesh分成同样三角形数量的Cluster，便于交给GPU做裁剪等计算</li>
<li>不可见的Cluster不渲染；Culling流程：
<img src="/images/games104/L22_ClusterCulling.jpg" alt="L22_ClusterCulling" style="zoom: 33%;" />
<ul>
<li>尽可能裁剪掉不可见的三角形</li>
<li>将可见的三角形组成同一个Buffer</li>
</ul></li>
</ul>
<h5 id="gpu-driven-pipeline">GPU Driven Pipeline</h5>
<ul>
<li>CPU端：
<ul>
<li>根据材质不同组合Instance</li>
<li>根据相机距离LoD</li>
<li>打包交给GPU做后续处理</li>
</ul></li>
<li>GPU Instance Culling
<ul>
<li>Instance Culling</li>
<li>将（64个）Cluster组成一个Chunk，再次Culling，以加速</li>
</ul></li>
<li>GPU Cluster Culling
<ul>
<li>Chunk -&gt; Cluster -&gt; Triangle
一步步裁剪，将视锥外、背面的全部裁剪</li>
</ul></li>
<li>Index Buffer Compaction 将可见三角形的依次写入备用Index Buffer
<ul>
<li>三角形顶点顺序不统一时，可能导致前后帧三角形顶点顺序不一致，由于Z-Buffer精度有限，导致Z-Fighting问题
=&gt; 硬件Multi-Indirect Draw Call或可解决此问题</li>
<li>对高精度的Mesh效率非常高</li>
</ul></li>
<li>Codec Triangle Visibility in Cube : Backface Culling
<ul>
<li>每个Cluster存储每个三角形对两个方向的可见性</li>
<li>利用这一数据快速做Backface Culling</li>
</ul></li>
</ul>
<h5 id="occlusion-culling-for-camera-and-shadow">Occlusion Culling for
Camera and Shadow</h5>
<ul>
<li>利用前一帧Z-Buffer的方法：
<ul>
<li>取当前帧的一部分（如300个）近处大Mesh作为可能的Occluder渲染Z-Buffer</li>
<li>将上一帧的深度重投影到当前帧，用于补充当前帧Z-Buffer空缺处</li>
<li>保守估计Culling Instance -&gt; Chunk -&gt; Cluster -&gt;
Triangle</li>
<li>问题：高速移动物体存在一定Artifact</li>
</ul></li>
<li><strong>Two-Phase Occlusion Culling</strong>
<ul>
<li>快速绘制通过上一帧的Z-Buffer Test的Instance的当前帧Z-Buffer</li>
<li>再利用当前帧不完整的Z-Buffer，测试剩余所有Instance，选出可见者
<img src="/images/games104/L22_TwoPhaseOcclusionCulling.jpg" alt="L22_TwoPhaseOcclusionCulling" style="zoom: 50%;" /></li>
<li>更加准确</li>
</ul></li>
<li><strong>Fast Occlusion for Shadow</strong>
<ul>
<li>Shadow中生成深度时对几何细节量敏感</li>
<li>对每个Cascade，将上一帧相机深度重投影至当前帧Shadow深度，并混合上一帧Shadow深度</li>
<li>只有摄影机可见区域内需要生成阴影：只对相机可见的Instance生成Shadow的Z-Buffer
<img src="/images/games104/L22_ShadowOcclusion.jpg" alt="L22_ShadowOcclusion" style="zoom: 33%;" /></li>
</ul></li>
</ul>
<h4 id="visibility-buffer">Visibility Buffer</h4>
<ul>
<li>Forward Rendering：所有互相遮挡、透明的物体需要做重复计算</li>
<li>Deferred
Shading：用G-Buffer存储可见Pixel的各种数据，只对G-Buffer做光照计算
<img src="/images/games104/L22_DeferredShading.jpg" alt="L22_DeferredShading" style="zoom: 25%;" />
<ul>
<li>G-Buffer的存储、IO开销大</li>
<li>复杂场景下，因为难以判断可见性，在生成G-Buffer时产生Over
draw，多次绘制同一像素时开销大</li>
</ul></li>
<li><strong>Visibility Buffer</strong>：
<ul>
<li>第一遍渲染时，只在Buffer中存储： (Alpha masked bit, DrawID,
PrimitiveID, MaterialID, …)</li>
<li>根据各种ID读取对应贴图，再做重心坐标插值着色
<ul>
<li>几乎没有Over Draw</li>
<li>Cache Miss率低</li>
</ul></li>
<li>Pipeline
<img src="/images/games104/L22_VisibilityBuffer.jpg" alt="L22_VisibilityBuffer" style="zoom: 25%;" /></li>
</ul></li>
<li>Visibility Buffer + Deferred Shading
<img src="/images/games104/L22_VisibilityBufferDeferredShading.jpg" alt="L22_VisibilityBufferDeferredShading" style="zoom: 50%;" />
<ul>
<li>一般来说，草丛等复杂细节情况可直接用Visibility
Buffer渲染，主角等主要内容Gather到G-Buffer再渲染</li>
<li>注意点：MIPMAP采样时的插值平滑问题</li>
</ul></li>
</ul>
<h3 id="virtual-geometry---nanite">Virtual Geometry - Nanite</h3>
<h4 id="overview">Overview</h4>
<h5 id="virtual-texture">Virtual Texture</h5>
<ul>
<li>Idea：将场景中所有贴图加载到内存中开销非常大，能否只加载可见部分且LoD后精度的贴图</li>
<li>所有材质加载到同一张“大贴图”中，并对整个贴图做MIPMAP</li>
<li>预烘焙这张“大贴图”，并做MIPMAP</li>
<li>根据View区域动态加载所需的部分</li>
</ul>
<h5 id="idea-of-nanite">Idea of Nanite</h5>
<ul>
<li><strong>Virtual Geometry</strong> like <strong>Virtual
Texture</strong></li>
<li>挑战：几何数据是非Uniform的、互相之间可能没有关联性、Mesh数据难以Filter（SDF、Voxel、Point
Cloud可以Filter）</li>
<li>Voxel ?
<ul>
<li>数据量非常大</li>
<li>属性Leaking</li>
<li>非常不适合目前的美术工作流</li>
</ul></li>
<li>Subdivision Surface ?
<ul>
<li>需要使用四边形面</li>
<li>Subdivision很难做Downsampling</li>
</ul></li>
<li>Maps-based Method ? 高度图、置换等
<ul>
<li>很难做非常细的几何细节</li>
<li>NVIDIA正在从硬件上做这方面的更多工作，或许还有发展的可能</li>
</ul></li>
<li>Point Cloud ?
<ul>
<li>效果不好</li>
<li>Over Draw</li>
<li>材质如何绑定</li>
</ul></li>
<li>Triangle !
<ul>
<li>绘制三角形数量恰多于屏幕像素数量 1 more triangle per pixel</li>
</ul></li>
</ul>
<h4 id="geometry-representation">Geometry Representation</h4>
<h5 id="cluster-based-lod">Cluster-based LoD</h5>
<ul>
<li>Clusters, 128 Triangles per cluster
<img src="/images/games104/L22_NaniteClusters.png" alt="L22_NaniteClusters" style="zoom: 25%;" /></li>
<li>View Dependent LoD
<img src="/images/games104/L22_NaniteLoD.png" alt="L22_NaniteLoD" style="zoom:25%;" />
用远少于LoD0的Triangle数实现1 more triangle per pixel的精度</li>
<li>Naive Solution
<ul>
<li>Cluster两两合并，减少一半三角形，得到简单的Cluster Hierarchy</li>
<li>根据View得到对Cluster的Cut Line，选择对应精度的Cluster</li>
<li>Like <strong>Virtual Texturing</strong>，流式加载数据</li>
<li>问题：不同Cluster之间的Juction问题
<ul>
<li>锁住Cluster的边：边缘处的Triangle密度过高
<ul>
<li>面片简化利用率不高</li>
<li>密度不均匀，产生画面Artifact（缝合线感）</li>
</ul></li>
</ul></li>
</ul></li>
<li>Nanite Solution
<ul>
<li>Cluster Group
<ul>
<li>将一定数量的Cluster组成一个Group</li>
<li>每个Group选择同样的LoD级别</li>
</ul></li>
<li>在Group内做简化，锁住Group的边</li>
<li>简化后重新生成Cluster
<img src="/images/games104/L22_NaniteClusterGroup.png" alt="L22_NaniteClusterGroup" style="zoom: 33%;" /></li>
<li>每一级LoD，选择不同的Group边锁住
<img src="/images/games104/L22_NaniteAlternateGroupBoundaries.jpg" alt="L22_NaniteAlternateGroupBoundaries" style="zoom: 50%;" />
类似图片降采样时的Jiltering</li>
<li>构建DAG（有向无环图）
<img src="/images/games104/L22_NaniteDAG.png" alt="L22_NaniteDAG" style="zoom:33%;" /></li>
<li>细节：QEM，保证Error计算的精确性，且Error单向向上传递</li>
<li><img src="/images/games104/L22_NaniteLoDPipeline.png" alt="L22_NaniteLoDPipeline" style="zoom: 25%;" />
##### Runtime LoD</li>
</ul></li>
<li>直接在DAG中选择？但直接在DAG中遍历非常复杂</li>
<li>同属于一个Group的Cluster用同样的LoD等级</li>
<li>并行地做View Dependent Cut
<img src="/images/games104/L22_ViewDependentCut.png" alt="L22_ViewDependentCut" style="zoom:25%;" />
<ul>
<li>规则：
<ul>
<li>Parent View Error &gt;= Child View Error</li>
</ul></li>
<li>LoD Cull 判定条件
<ul>
<li>Render : ParentErr &gt; threshold &amp;&amp; ClusterErr &lt;=
threshold</li>
<li>Cull : ParentErr &lt;= threshold || Cluster &gt; threshold</li>
<li>若Parent已经足够精确，则无需再Check Child
<ul>
<li>ParentErr &lt;= threshold</li>
</ul></li>
</ul></li>
</ul></li>
<li>每一个Cluster Group的每一次LoD
Selection是独立的，不会上一级没通过再看下一级</li>
</ul>
<h5 id="bvh-acceleration-for-lod-selection">BVH Acceleration for LoD
Selection</h5>
<ul>
<li>想法核心：把LoD0、LoD1、…每一层LoD独立组成一个BVH，最后再将所有BVH组成一个大的树
<img src="/images/games104/L22_LoDBVH.png" alt="L22_LoDBVH" style="zoom: 33%;" /></li>
<li>方便地取BVH的Bounding，做相机剔除后再Check，节省了非常多计算量</li>
</ul>
<h5 id="hierarchical-culling">Hierarchical Culling</h5>
<p>加速的Trick
<img src="/images/games104/L22_HierarchicalCulling.jpg" alt="L22_HierarchicalCulling" style="zoom: 50%;" /></p>
<h4 id="rendering">Rendering</h4>
<h5 id="software-and-hardware-rasterization">Software and Hardware
Rasterization</h5>
<ul>
<li>硬件光栅化：光栅化单元是2*2的Quad（为了算ddx和ddy），用4*4的Tile遍历加速，剔除不参与渲染的Tile</li>
<li>Triangle小到1个pixel的大小时 —— 上述优化均失效</li>
<li><strong>软件光栅化</strong>：
<ul>
<li>Compute Shader直接接管小三角形的光栅化</li>
<li>若三角形小于1pixel，则直接给pixel着色</li>
<li>直接通过三角形的UV算ddx、ddy，不用Tile计算</li>
<li>若三角形边长小于18pixel，则使用软件光栅化（Scanline），反之回到硬件光栅化</li>
<li><strong>深度测试</strong>：存储64bit的atomic数据 —— 32bit Depth +
25bit Visible Cluster Index + 7bit Triangle Index （<strong>Visibility
Buffer</strong>）</li>
</ul></li>
<li>硬件光栅化</li>
<li><strong>Imposter</strong>：对足够远、足够小的Instance，生成12*12个方向的的12*12大小的各种贴图（Aldobe、Normal、…）</li>
<li>Overdraw：
<ul>
<li>没有逐像素剔除</li>
<li>没有硬件HiZ像素剔除</li>
<li>软件HZB来自上一帧</li>
<li>大Cluster、重叠Cluser、聚合、快速移动等带来的Overdraw</li>
<li>…</li>
</ul></li>
<li>期待硬件支持更完善，不要用软件Trick完成这些ideas</li>
</ul>
<h5 id="deferred-materials">Deferred Materials</h5>
<ul>
<li>早期：
<ul>
<li>将每个Material ID转换为一个Depth值，记录为一张Depth Buffer</li>
<li>扫描整张Buffer，判断Depth与Material
ID相等时，用对应Material绘制</li>
<li>消耗较大</li>
</ul></li>
<li>Tiled Based的思想
<ul>
<li>将全屏幕分为多个Tile，标记每个材质是否在Tile中出现</li>
<li>在逐材质扫描整张Buffer时，可以直接跳过没有该材质的Tile</li>
</ul></li>
</ul>
<h4 id="shadow">Shadow</h4>
<ul>
<li>Shadow Casting的精度要求很高</li>
<li>Ray Trace？ Nanite几何表达无法兼容</li>
<li><strong>Cascaded Shadow Map</strong> 具体略 本质：View-dependent
Sampling</li>
<li><strong>Sample Distribution Shadow Maps</strong> 相当于将Cascaded
Shadow Maps中重复的、视锥外的像素去除的Shadow Maps</li>
<li>Shadow Map的本质：根据相机视空间的精度，采样光空间</li>
</ul>
<h5 id="virtual-shadow-map---a-cached-shadow-system">Virtual Shadow Map
- A Cached Shadow System</h5>
<ul>
<li>核心思想：将Shadow
Map切成足够小的块，确保每一小块与视空间的采样率高度一直，且只更新产生光照变化的块</li>
<li>实际：给每个光源一张16k的VSM（点光源为6个方向的6张），仅可见像素会被Cache</li>
<li>相机运动、光照几何变化时，更新部分Tile即可</li>
</ul>
<h4 id="streaming-and-compression">Streaming and Compression</h4>
<h5 id="streaming">Streaming</h5>
<ul>
<li>流送的核心：只Load需要的数据到内存中</li>
<li>构建成逐个Page，动态加载</li>
</ul>
<h5 id="compression">Compression</h5>
<ul>
<li>内存数据：Quantization
<ul>
<li>浮点变定点等</li>
</ul></li>
<li>硬盘数据
<ul>
<li>LZ Compression</li>
<li>显存加载自动解压缩</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-23-GAMES104现代游戏引擎-Lecture21-Dynamic Global Illumination and Lumen</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture21-lumen/</link>
      <pubDate>Sun, 23 Oct 2022 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-23-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture21-lumen/</guid>
      <description>Lecture21 Dynamic Global Illumination and Lumen Part I Dynamic Global Illumination Global Illumination - 略 Reflective Shadow Maps, RSM - 略 低分辨率间接光照加速：
计算低分辨率间接光照 对全分辨率图像的每个像素 获得周围四个低分辨率采样 通过法线和世界坐标位置判断，采样间差异过大时剔除 双线性插值 以全分辨率重新计算剔除的像素 Light Propagation Volumes, LPV - 略 Sparse Voxel Octree for Real-time Global Illumination, SVOGI 如何组织voxel的分布？
硬件保守光栅化：对很小的三角形，保证其至少有一个voxel 八叉树存储 Shading with Cone Tracing in Voxel Tree 着色点根据BRDF发射Diffuse和Specular的Cone 根据Cone尺寸查询树结构获取光照 - 非常适合Hierarchy结构存储的光照数据 NVIDIA的工作，GPU表达非常复杂 Voxelization Based Global Illumination, VXGI 更关注相机视锥内的区域、更关注近处的区域 Clipmap，voxel版的Mipmap 利用Clipmaps存储voxel数据 重心区域使用更高分辨率voxel 更适合Cone Tracing 建构简单、读取简单、GPU Friendly… Voxel Update：空间网格位置固定，只需要更新相机周围的Voxel Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向 对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine Specular） 问题： 错误的遮挡关系，简单使用Opacity来表示 Light Leaking：遮挡物薄于Voxel时 Screen Space Global Illumination, SSGI Reuse screen space data &amp;lt;- Screen Space Reflection, SSR SSR：单根光线，构建反射 -&amp;gt; 多方向多根光线，构建GI 对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记 Reuse近邻像素 做Cone Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering 优势：快，质量高，没有遮挡问题 问题：缺少屏外信息，重用近邻像素带来的错误Visibility 独特优势： 易于处理非常近的接近阴影 准确的Hit点计算 对场景复杂度不敏感 可以处理动态物体 Part II Lumen Real-time Ray Tracing的问题：</description>
      <content:encoded><![CDATA[<h2 id="lecture21-dynamic-global-illumination-and-lumen">Lecture21
Dynamic Global Illumination and Lumen</h2>
<h3 id="part-i-dynamic-global-illumination">Part I Dynamic Global
Illumination</h3>
<h4 id="global-illumination---略">Global Illumination - 略</h4>
<h4 id="reflective-shadow-maps-rsm---略">Reflective Shadow Maps, RSM -
略</h4>
<p><strong>低分辨率间接光照加速</strong>：</p>
<ul>
<li>计算低分辨率间接光照</li>
<li>对全分辨率图像的每个像素
<ul>
<li>获得周围四个低分辨率采样</li>
<li>通过法线和世界坐标位置判断，采样间差异过大时剔除</li>
<li>双线性插值</li>
</ul></li>
<li>以全分辨率重新计算剔除的像素</li>
</ul>
<h4 id="light-propagation-volumes-lpv---略">Light Propagation Volumes,
LPV - 略</h4>
<h4
id="sparse-voxel-octree-for-real-time-global-illumination-svogi">Sparse
Voxel Octree for Real-time Global Illumination, SVOGI</h4>
<p>如何组织voxel的分布？</p>
<ul>
<li>硬件保守光栅化：对很小的三角形，保证其至少有一个voxel</li>
<li>八叉树存储</li>
<li><strong>Shading with Cone Tracing in Voxel Tree</strong>
<ul>
<li>着色点根据BRDF发射Diffuse和Specular的Cone</li>
<li>根据Cone尺寸查询树结构获取光照 -
非常适合Hierarchy结构存储的光照数据</li>
</ul></li>
<li>NVIDIA的工作，GPU表达非常复杂</li>
</ul>
<h4 id="voxelization-based-global-illumination-vxgi">Voxelization Based
Global Illumination, VXGI</h4>
<ul>
<li>更关注相机视锥内的区域、更关注近处的区域</li>
<li>Clipmap，voxel版的Mipmap
<img src="/images/games104/L21_Clipmap.jpg" alt="L21_Clipmap" style="zoom: 50%;" />
利用Clipmaps存储voxel数据
<ul>
<li>重心区域使用更高分辨率voxel
<img src="/images/games104/L21_VXGI.jpg" alt="L21_VXGI" style="zoom: 67%;" /></li>
<li>更适合Cone Tracing</li>
</ul></li>
<li>建构简单、读取简单、GPU Friendly…</li>
<li><strong>Voxel
Update</strong>：空间网格位置固定，只需要更新相机周围的Voxel</li>
<li>Voxel具有Opacity（透明度），表征Voxel内有多少Surface可以阻挡光线，需要计算三个方向</li>
<li>对屏幕空间每个像素做Cone Tracing（Diffuse、Rough Specular、Fine
Specular）
<img src="/images/games104/L21_VXGIConeTracing.png" alt="L21_VXGIConeTracing" style="zoom: 25%;" /></li>
<li>问题：
<ul>
<li>错误的遮挡关系，简单使用Opacity来表示</li>
<li><strong>Light Leaking</strong>：遮挡物薄于Voxel时</li>
</ul></li>
</ul>
<h4 id="screen-space-global-illumination-ssgi">Screen Space Global
Illumination, SSGI</h4>
<ul>
<li>Reuse screen space data &lt;- Screen Space Reflection, SSR</li>
<li>SSR：单根光线，构建反射 -&gt; 多方向多根光线，构建GI</li>
<li>对Depth Buffer做Raymarching，Hierarchical Tracing 参考SSR笔记</li>
<li>Reuse近邻像素
<img src="/images/games104/L21_SSGIReuseNeighbor.jpg" alt="L21_SSGIReuseNeighbor" style="zoom: 25%;" /></li>
<li>做Cone
Tracing，相当于对Tracing到的屏幕范围的像素做一次Filtering</li>
<li>优势：快，质量高，没有遮挡问题</li>
<li>问题：缺少屏外信息，重用近邻像素带来的错误Visibility</li>
<li>独特优势：
<ul>
<li>易于处理非常近的接近阴影</li>
<li>准确的Hit点计算</li>
<li>对场景复杂度不敏感</li>
<li>可以处理动态物体</li>
</ul></li>
</ul>
<h3 id="part-ii-lumen">Part II Lumen</h3>
<p>Real-time Ray Tracing的问题：</p>
<ul>
<li>1/2 ray per pixel</li>
<li>Sampling</li>
</ul>
<p><strong>Idea：低分辨率的屏幕空间的Probe，采样简介光照</strong></p>
<h4 id="phase-1-fast-ray-trace-in-any-hardware">Phase 1 : Fast Ray Trace
in Any Hardware</h4>
<h5 id="signed-distance-function-sdf">Signed Distance Function, SDF</h5>
<ul>
<li>Per-Mesh SDF 对每个Mesh构建SDF，所有SDF组合成场景
<ul>
<li>对于薄于SDF分辨率的Mesh，将其加厚</li>
</ul></li>
<li>Ray Tracing with SDF
<img src="/images/games104/L21_SDFSphereTracing.jpg" alt="L21_SDFSphereTracing" style="zoom: 50%;" /></li>
<li>Cone Tracing with SDF (eg. SDF Soft Shadow)
<img src="/images/games104/L21_SDFConeTracing1.jpg" alt="L21_SDFConeTracing1" style="zoom: 80%;" /><img src="/images/games104/L21_SDFConeTracing2.png" alt="L21_SDFConeTracing2" style="zoom: 25%;" /></li>
<li>对SDF稀疏化存储，但可能导致Raymarch迭代步长变长
<img src="/images/games104/L21_SDFSparse.jpg" alt="L21_SDFSparse" style="zoom: 67%;" /></li>
<li>对SDF做LoD</li>
<li>SDF可导，导数为法线方向</li>
<li>可以根据相机远近方便地切换SDF分辨率</li>
</ul>
<h5 id="从mesh-sdf合成低分辨率的场景的global-sdf">从Mesh
SDF合成低分辨率的场景的Global SDF</h5>
<ul>
<li>场景Tracing非常快</li>
<li>精度相对低</li>
<li>在Lumen中结合对Global SDF的Tracing和对Mesh SDF的Tracing</li>
<li>4 Clipmaps Global SDF, 根据相机距离</li>
</ul>
<h4 id="phase-2-radiance-injection-and-caching">Phase 2 : Radiance
Injection and Caching</h4>
<h5 id="mesh-card">Mesh Card</h5>
<ul>
<li>为场景中的Mesh“拍快照”，对六个面采样
<img src="/images/games104/L21_MeshCard.png" alt="L21_MeshCard" style="zoom: 25%;" /></li>
<li>对场景以AABB方式生成
<img src="/images/games104/L21_MeshCardScene.jpg" alt="L21_MeshCardScene" style="zoom: 67%;" /></li>
<li>对每个Card，存储其六个面的：
<ul>
<li>Albedo</li>
<li>Normal</li>
<li>Depth</li>
<li>Emissive</li>
<li>…</li>
</ul></li>
<li>根据物体大小、相机远近，对Card应用不同的分辨率</li>
</ul>
<h5 id="surface-cache">Surface Cache</h5>
<ul>
<li>从Mesh Card生成Surface Cache
<img src="/images/games104/L21_SurfaceCache.jpg" alt="L21_SurfaceCache" style="zoom: 67%;" />
<ul>
<li>Pass 1 : Card capture</li>
<li>Pass 2 : Copy cards to Surface Cache and compress</li>
</ul></li>
<li>“Freeze” lighting on Surface Cache
<ul>
<li>Surface Cache上的像素是否在阴影中？ 如何处理多次Bounce？</li>
<li>Lighting Cache Pipeline 最终生成<strong>Surface Cache Final
Lighting</strong>
<img src="/images/games104/L21_LightingCachePipeline.png" alt="L21_LightingCachePipeline" style="zoom: 25%;" />
计算当前帧的一次Bounce，利用前一帧的一次Bounce作为次级光源照亮场景，则相当于二次Bounce，依次累计，相当于同一场景下Bounce越积越多（Temporal思路）</li>
<li><strong>1. Direct Lighting</strong>
<img src="/images/games104/L21_DirectLighting.png" alt="L21_DirectLighting" style="zoom: 25%;" />
<ul>
<li>直接累加多光源</li>
<li>对近处物体，直接取得精确的Instance，从Surface Cache上计算光照</li>
<li>对远处物体，因为Global
SDF无法标记具体Instance，则对全场景光照做Voxelize表达，建构Clipmaps，对每个Voxel存储六个面的光照</li>
</ul></li>
<li><strong>2. World Space Voxel Lighting</strong>
<ul>
<li>由Final
Lighting照亮计算得到的Voxel光照存储，用于下一帧的间接光照计算</li>
<li>与后面会提到的Light
Probe区分：只存储Voxel六个面的亮度（被照亮的亮度）</li>
</ul></li>
<li><strong>3. Surface Cache Indirect Lighting</strong>
<ul>
<li>Light Probe</li>
<li>用SH存储间接光照，方便做插值</li>
</ul></li>
<li><strong>Combine Lighting</strong> FinalLighting = (DirectLighting +
InDirectLighting) * Diffuse_Lambert(Albedo) + Emissive</li>
<li>光照更新策略，保障性能开销稳定
<ul>
<li>固定的更新预算</li>
<li>桶排序更新优先级</li>
</ul></li>
</ul></li>
</ul>
<h4 id="phase-3-build-a-lot-of-probes-with-different-kinds">Phase 3 :
Build a lot of Probes with Different Kinds</h4>
<h5 id="screen-space-probe">Screen Space Probe</h5>
<ul>
<li>只在Screen Space分布Probe，每16*16像素一个</li>
<li>Octahedron Mapping，使用8*8的Texture存储Probe
<img src="/images/games104/L21_OctahedronMapping.png" alt="L21_OctahedronMapping" style="zoom: 33%;" />
<img src="/images/games104/L21_OctahedronMappingCode.jpg" alt="L21_OctahedronMappingCode" style="zoom: 33%;" /></li>
<li>对于高频细节部分，进一步细化增加Probe，至8*8或4*4每个
<ul>
<li>判定是否需要增加Probe
<ul>
<li>Probe之间很近、着色点之间实际距离较远时（深度差异过大）</li>
<li>取一些着色点，邻近四个Probe作着色点法平面投影，投影距离的权重超出阈值时，判定为无效采样，增加Probe</li>
</ul></li>
<li>Screen Probe Atlas
<img src="/images/games104/L21_ScreenProbeAtlas.png" alt="L21_ScreenProbeAtlas" style="zoom: 25%;" />
依次往下存储，因此不会造成过多额外开销</li>
</ul></li>
</ul>
<h5 id="importance-sampling">Importance Sampling</h5>
<ul>
<li><p>蒙特卡罗采样： <span class="math display">\[
\lim_{N\to\infty}\dfrac{1}{N}\sum_{k=1}^{N}\dfrac{L_i(l)f_s(l\to
v)\cos(\theta l)}{P_k}
\]</span> 重要性采样即取 <span class="math inline">\(P_k\)</span>
使其尽可能符合分子分布</p>
<ul>
<li>对光源：尽可能符合 <span class="math inline">\(L_i\)</span>
分布</li>
<li>对BRDF：尽可能符合 <span class="math inline">\(f_s\)</span>
分布</li>
</ul></li>
<li><p>对光源做重要性采样，如何估计光源</p>
<ul>
<li>利用前一帧的光照数据</li>
<li>对前一帧邻近四个Probe的Radiance做插值</li>
<li>若邻近Probe被遮挡则fallback到世界空间Probe</li>
<li>得到插值后8*8的光照分布，作为Light PDF</li>
</ul></li>
<li><p>对BRDF的法线分布做重要性采样</p>
<ul>
<li>法线分布不能用高频的着色点Normal指代</li>
<li>在32*32范围内取64点采样，保证深度权重的情况下，将每个Normal的SH累加得到法线分布，作为BRDF
PDF</li>
</ul></li>
<li><p><strong>Structured Importance Sampling</strong></p>
<ul>
<li>每个Probe采样64根ray</li>
<li>将BRDF PDF与Lighting PDF卷积，得到重要的采样方向</li>
<li>对重要的方向做Supersampling，对不重要的方向忽略
<img src="/images/games104/L21_ImportanceSampling.png" alt="L21_ImportanceSampling" style="zoom: 25%;" /></li>
</ul></li>
</ul>
<h5 id="denoising-and-spatial-probe-filtering">Denoising and Spatial
Probe Filtering</h5>
<ul>
<li>取Probe周围3*3，做filtering</li>
<li>但不同Probe的ray方向不同时，差异过大 -&gt;
判断，若邻近Probe的ray着色点与当前Probe连线，与当前ray角度差大于阈值（10°）时则丢弃不用
<img src="/images/games104/L21_ProbeFiltering1.png" alt="L21_ProbeFiltering1" style="zoom: 25%;" /></li>
<li>邻近Probe的ray方向接近时，但Hit点差异过大 -&gt; Clamp ray深度
<img src="/images/games104/L21_ProbeFiltering2.png" alt="L21_ProbeFiltering2" style="zoom: 25%;" /></li>
</ul>
<h5 id="world-space-radiance-cache">World Space Radiance Cache</h5>
<ul>
<li>Screen Space Probe采样较近的物体</li>
<li>World Space预先放置Probe，记录远处光照，Screen
Space在采样远处时直接读取World Space Probe
<img src="/images/games104/L21_WorldSpaceRadianceCache.png" alt="L21_WorldSpaceRadianceCache" style="zoom: 25%;" /></li>
<li>Clipmaps存储，分布分辨率48*48*48，每个Probe Atlas分辨率32*32</li>
<li>连接Screen Space Probe和World Space Probe的ray
<ul>
<li>取Screen Space Probe邻近8个World Space Probe，距离权重插值。
<img src="/images/games104/L21_ConnectRays.png" alt="L21_ConnectRays" style="zoom: 25%;" />
（Cube半径两倍范围内已采样，向更远处raycast时可以skip这段距离）</li>
<li>插值后产生与原方向的偏差，跳过遮挡物，产生漏光
<img src="/images/games104/L21_ConnectRaysLeaking1.png" alt="L21_ConnectRaysLeaking1" style="zoom: 25%;" />
球面parallax，如图修改光线，导致光线转弯，但Hack可接受
<img src="/images/games104/L21_ConnectRaysLeaking2.png" alt="L21_ConnectRaysLeaking2" style="zoom: 25%;" /></li>
<li>World Space Probe当且仅当有Screen Space
Probe有采样需求时，才做Trace并更新光照</li>
</ul></li>
</ul>
<h4 id="phase-4-shading-full-pixels-with-screen-space-probes">Phase 4 :
Shading Full Pixels with Screen Space Probes</h4>
<h5 id="将probe-radiance转换为三阶sh">将Probe Radiance转换为三阶SH</h5>
<ul>
<li>相当于对Radiance做低通滤波，效果更柔和</li>
<li>SH积分更快速友好，质量也更高</li>
<li>最后利用SH着色</li>
</ul>
<h4 id="overall-performance-and-result">Overall, Performance and
Result</h4>
<ul>
<li>核心思想：利用对不同数据结构、不同采样对象做Ray
Tracing的硬件开销不一样
<img src="/images/games104/L21_SpeedOfDifferentTracingMethods.jpg" alt="L21_SpeedOfDifferentTracingMethods" style="zoom: 67%;" /></li>
<li>根据具体情况应用不同的方式
<img src="/images/games104/L21_LumenOverall1.png" alt="L21_LumenOverall1" style="zoom: 25%;" /></li>
<li>Fallback过程
<img src="/images/games104/L21_LumenOverall2.png" alt="L21_LumenOverall2" style="zoom: 50%;" /></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-22-GAMES104现代游戏引擎-Lecture16-Gameplay Systems - Basic Artificial Intelligence</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture16-gameplaybasicartificialintelligence/</link>
      <pubDate>Sat, 22 Oct 2022 21:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture16-gameplaybasicartificialintelligence/</guid>
      <description>PS: Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记
Lecture16 Gameplay Systems - Basic Artificial Intelligence Navigation 三个步骤： Map Representation 地图表达 Walkable Area
需要考虑：
Physical Collision Climbing Slope/Height Jumping Distance … 难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI Agents和Player的可行区域相同
Waypoint Network
路网，类似地铁线路图 寻找最近的路点 易于实现，快速寻路不够灵活，路网需要手工标注 Grid
Square / Triangle / Hexagon 其中Square相对易于存储 易于实现、均匀数据结构、动态可更新 精确性依赖分辨率 密集网格降低寻路性能 内存消耗大 难以处理3D地图（桥梁、隧道等） Navigation Mesh
用简化的凸多边形表示场景 若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域 优势：
支持3D可行区域 精确 快速寻路 灵活选择起始地、目的地 动态 缺陷：
复杂的生成算法 不支持3D空间，例如空中飞行 Sparse Voxel Octree
空间八叉树 存储量大 寻路复杂 Path Finding 寻找路径 所有表达，都可归为图结构
即在图上找到一个路径，尽可能找到最优（短）路径
深度优先搜索 / 广度优先搜索 消耗比较高，广度优先适合找到最短路径</description>
      <content:encoded><![CDATA[<blockquote>
<p>PS:
Lecture17-20主要涉及[机器学习]、[网络架构]、[面向数据编程]，与本人图形方向相离较多，故仅浏览学习，暂无笔记</p>
</blockquote>
<h3
id="lecture16-gameplay-systems---basic-artificial-intelligence">Lecture16
Gameplay Systems - Basic Artificial Intelligence</h3>
<h4 id="navigation">Navigation</h4>
<p>三个步骤：
<img src="/images/games104/L16_NavigationSteps.png" alt="L16_NavigationSteps" style="zoom: 25%;" /></p>
<h5 id="map-representation-地图表达">Map Representation 地图表达</h5>
<ul>
<li><p>Walkable Area</p>
<ul>
<li><p>需要考虑：</p>
<ul>
<li>Physical Collision</li>
<li>Climbing Slope/Height</li>
<li>Jumping Distance</li>
<li>…</li>
</ul>
<p>难以完全模拟人的可行路线，需要一定的限制，类似“空气墙”； AI
Agents和Player的可行区域相同</p></li>
<li><p>Waypoint Network</p>
<ul>
<li>路网，类似地铁线路图
<img src="/images/games104/L16_WaypointNetwork.png" alt="L16_WaypointNetwork" style="zoom: 25%;" /></li>
<li>寻找最近的路点</li>
<li>易于实现，快速寻路不够灵活，路网需要手工标注</li>
</ul></li>
<li><p>Grid</p>
<ul>
<li>Square / Triangle / Hexagon 其中Square相对易于存储</li>
<li><img src="/images/games104/L16_GridPathFinding.gif" alt="L16_GridPathFinding" style="zoom: 33%;" /></li>
<li>易于实现、均匀数据结构、动态可更新</li>
<li>精确性依赖分辨率</li>
<li>密集网格降低寻路性能</li>
<li>内存消耗大</li>
<li>难以处理3D地图（桥梁、隧道等）</li>
</ul></li>
<li><p>Navigation Mesh</p>
<ul>
<li><p>用简化的凸多边形表示场景
<img src="/images/games104/L16_NavMesh.jpg" alt="L16_NavMesh" style="zoom:33%;" /></p>
<blockquote>
<p>若出现凹多边形，寻路时可能跨越凹边出现在Mesh外区域
<img src="/images/games104/L16_NavMeshConvex.png" alt="L16_NavMeshConvex" style="zoom:25%;" /></p>
</blockquote></li>
<li><p>优势：</p>
<ul>
<li>支持3D可行区域</li>
<li>精确</li>
<li>快速寻路</li>
<li>灵活选择起始地、目的地</li>
<li>动态</li>
</ul></li>
<li><p>缺陷：</p>
<ul>
<li>复杂的生成算法</li>
<li>不支持3D空间，例如空中飞行</li>
</ul></li>
</ul></li>
<li><p>Sparse Voxel Octree</p>
<ul>
<li>空间八叉树</li>
<li>存储量大</li>
<li>寻路复杂</li>
</ul></li>
</ul></li>
</ul>
<h5 id="path-finding-寻找路径">Path Finding 寻找路径</h5>
<ul>
<li><p>所有表达，都可归为图结构</p></li>
<li><p>即在图上找到一个路径，尽可能找到最优（短）路径</p></li>
<li><p>深度优先搜索 / 广度优先搜索
消耗比较高，广度优先适合找到最短路径</p></li>
<li><p>Dijkstra Algorithm</p>
<pre class="pseudocode"><code>for each vertex v:
  dist[v] = ∞
  prev[v] = none
dist[source] = 0
set all vertices to unexplored
while destination not explored:
  v = least - valued unexplored vertex
  set v to explored
  for each edge(v, w):
      if dist[v] +len(v, w) &lt; dist[w]:
          dist[w] = dist[v] + len(v, w)
          prev[w] = v</code></pre></li>
<li><p>A Star （A*） 一种启发式算法，不用精确的最短路径</p>
<ul>
<li>启发函数：预估当前点到终点的距离 <span
class="math inline">\(h(n)\)</span>
<ul>
<li>例如：欧拉距离 / 曼哈顿距离</li>
<li><span class="math inline">\(h(n)\)</span> 的精确性影响性能表现</li>
</ul></li>
<li>则每一个当前点消耗为 <span class="math inline">\(f(n)= g(n) +
h(n)\)</span></li>
<li>优先搜索 <span class="math inline">\(f(n)\)</span> 最小的情况</li>
<li>走到终点就停止，不追求完全最短</li>
</ul></li>
</ul>
<h5 id="path-smoothing-路径平滑">Path Smoothing 路径平滑</h5>
<ul>
<li>Funnel Algorithm
<ul>
<li>“走路时看前面”</li>
<li>当前点和所在三角形两端点组成一个扇形（漏斗，Funnel），下一个目标点是否在扇形中，来决定行走路线</li>
<li>寻找扇形两端点比较复杂</li>
</ul></li>
</ul>
<h5 id="navmesh-generation">NavMesh Generation</h5>
<ul>
<li>先将整个场景体素化</li>
<li>Region Segmentation
<ul>
<li>寻找Edge Voxel，生成Distance
Field，找到区块的中心区域（离Edge最远的）</li>
<li>”洪水“算法，类似Voroni算法，找到空间划分</li>
<li>处理Overlap问题</li>
</ul></li>
<li>生成分割区域，凸多边形</li>
<li>可以为不同的凸多边形打上不同的标记 Polygon Flag
<ul>
<li>AI寻路逻辑</li>
<li>AI移动速度</li>
<li>…</li>
</ul></li>
</ul>
<h5 id="advanced-features">Advanced Features</h5>
<ul>
<li>基于Tile的分区域NavMesh，易于更新</li>
<li>Off-Mesh Link建立不同Mesh之间的连接，手动，实现攀爬等动作</li>
</ul>
<h4 id="steering-转向系统">Steering 转向系统</h4>
<p>寻路中，车辆无法严格执行路径（受到物理限制），需要转向系统</p>
<ul>
<li>Seek / Flee 追着目标点
<ul>
<li>Pursue 追踪</li>
<li>Path Following</li>
<li>Wander</li>
<li>Flow Field Following 方向场</li>
</ul></li>
<li>Velocity Match
<ul>
<li>目标点速度，反向算每步加速度</li>
</ul></li>
<li>Align 保证朝向一致
<ul>
<li>目标点角速度，反向算每步角加速度</li>
</ul></li>
</ul>
<h4 id="crowd-simulation-群集模拟">Crowd Simulation 群集模拟</h4>
<p>参考《基于物理的动画-粒子系统》</p>
<ul>
<li>“Boids”</li>
<li>三种力
<ul>
<li>Separation</li>
<li>Cohesion</li>
<li>Alignment</li>
</ul></li>
<li>行人，沿着一定的Line运动</li>
<li>避障、避免碰撞</li>
<li>对每个个体做寻路消耗非常大 —— Distance Field</li>
</ul>
<h5 id="velocity-based-models">Velocity-based Models</h5>
<ul>
<li>核心想法：个体相遇时，产生速度的障碍，调整速度</li>
<li><strong>Reciprocal Velocity Obstacle</strong></li>
<li>两个以上个体相遇时产生冲突，如何优化？ <strong>Optimal Reciprocal
Collision Avoidance</strong></li>
<li>结果最优，但开销大，根据需求自主选择（基于力的方式效果较差但开销小）</li>
</ul>
<h4 id="sensing-or-perception">Sensing or Perception</h4>
<ul>
<li>AI所获得的信息
<ul>
<li>内部：位置、HP、子弹、Buff等</li>
<li>外部：
<ul>
<li>静态空间信息
<ul>
<li>Navigation Data</li>
<li>Tactical Map 战术地图（更具有战术价值的位置）</li>
<li>Smart Object eg.可打破的墙等</li>
<li>Cover Point 掩体点</li>
<li>…</li>
</ul></li>
<li>动态空间信息
<ul>
<li>Influence Map 战场态势感知的热力图，避开危险系数高的区域</li>
<li>Navigation Data上更新的标记</li>
<li>Sight Area 视野区域</li>
<li>…</li>
</ul></li>
<li>Game Object</li>
</ul></li>
</ul></li>
<li>Sensing Simulation 模仿人类的感知
<ul>
<li>考虑开销</li>
<li>共享Influence Map等方式</li>
</ul></li>
<li>引擎侧提供充足的接口和自定义性</li>
</ul>
<h4 id="classic-decision-making-algorithms">Classic Decision Making
Algorithms</h4>
<ul>
<li><strong>Finite State Machine</strong></li>
<li><strong>Behavior Tree</strong></li>
<li>Hierarchical Tasks Network</li>
<li>Goal Oriented Action Planning</li>
<li>Monte Carlo Tree Search</li>
<li>Deep Learning</li>
</ul>
<h5 id="finite-state-machine">Finite State Machine</h5>
<p><img src="/images/games104/L16_FiniteStateMachine.png" alt="L16_FiniteStateMachine" style="zoom:20%;" /></p>
<ul>
<li>State</li>
<li>Transition</li>
<li>Condition</li>
<li>问题：
<ul>
<li>复杂情形下State过于多，网络过于复杂</li>
<li>解决方法：Hierarchical Finite State Machine
<img src="/images/games104/L16_HierarchicalFiniteStateMachine.png" alt="L16_HierarchicalFiniteStateMachine" style="zoom:15%;" />
子状态之间切换变得复杂</li>
</ul></li>
</ul>
<h5 id="behavior-tree">Behavior Tree</h5>
<ul>
<li>状态机是对AI逻辑的抽象，并不符合人的知觉系统</li>
<li>将AI的行为Pattern从状态机的“飞线”转换为更符合人的<strong>决策树</strong>结构</li>
<li>Execution Node 执行节点（叶子节点）：
<ul>
<li>Condition Node 条件节点</li>
<li>Action Node 动作节点 三种状态：
<ul>
<li>Success</li>
<li>Failure</li>
<li>Running</li>
</ul></li>
</ul></li>
<li>Control Node
<ul>
<li>Sequence 依次执行</li>
<li>Selector
按优先级选择执行：A不行执行B，B不行执行C，有一个可执行就继续执行下去
<img src="/images/games104/L16_BTSelector.png" alt="L16_BTSelector" style="zoom:20%;" /></li>
<li>Parallel 并行执行</li>
<li>Decorator 修饰器，例如增加延时等</li>
</ul></li>
<li>如何Tick行为树？
<ul>
<li>每一次从根节点开始Tick，防止动作保持在某一叶子节点</li>
<li>行为树同时在Running的节点不一定只有一个</li>
</ul></li>
<li>Blackboard 记录环境变量，环境信息，与Gameplay交换信息的介质</li>
<li>缺点：Tick的消耗较大</li>
</ul>
<h4 id="upcoming-ai-planning-and-goals">Upcoming: AI Planning and
Goals</h4>
<p>上述提到的AI方法，均为条件-执行逻辑，AI是没有计划和目的的，期待下一课…</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-10-22-GAMES104现代游戏引擎-Lecture15-Gameplay Complexity and Building Blocks</title>
      <link>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture15-gameplaycomplexityandbuildingblocks/</link>
      <pubDate>Sat, 22 Oct 2022 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-10-22-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture15-gameplaycomplexityandbuildingblocks/</guid>
      <description>Lecture15 Gameplay Complexity and Building Blocks Overview Gameplay的挑战 多个系统之间的合作 同一个游戏中Gameplay的多样性 快速迭代 Event Mechanism Hard Code写在函数中：无数的if/else、非常难以修改 Event/Message Mechanism：GO之间的“通讯协议” Publish-subscribe Pattern 发行-订阅设计模式 Event Definition 信息的定义 方法1：Event作为类设计 -&amp;gt; 不适合交给设计师修改 方法2：允许定义任意的Event 再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦 在引擎核心代码之外定义 dll注入 用脚本层语言实现 Callback Registration 响应注册 注册和调用不在同一处 –&amp;gt; 对象的生命周期和回调函数安全性问题 Strong Reference 强引用：引用关系绑定 Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多 Event Dispatching 信息分发 遍历每个GO，逐个分发调用函数 —— 效率过低 Immediate：发送消息立即调用函数 会打断前一任务，等待Callback执行后再继续 单次打断引发连锁Callback，易导致Callstack非常深，难以Debug 难以并行 Event Queue 把Event存储至队列，依次执行 Event Queue的序列化和反序列化 实现：利用反射，获取每个对象的描述结构 存储结构：Ring Buffer 不用重复申请新内存 Batching，将多个独立系统分开处理 问题： 无法保证多个系统间的执行顺序 =&amp;gt; 保留一定的Immediate处理能力 同时具备Pre、Post、Immediate处理方式 有系统延迟，削弱动作游戏打击感 =&amp;gt; 经常Hardcode绕过Delay Script System Game Logic 直接在游戏引擎代码内，使用编译语言编写 （C/C++） 每次修改Gameplay，需要重新编译游戏引擎 极难支持热更新 对设计师极不友好 脚本语言 Script System 支持快速迭代 易于学习、编写 支持热更新 沙盒运行，稳定、更少Crash 如何运行 基于虚拟机 Script Text -&amp;gt; [Compiler] -&amp;gt; Bytecode [Virtual Machine] 速度略慢 如何管理GO 强调效率：引擎内核管理，脚本触发引擎执行 编写难度大 执行过程非常复杂 直接交给脚本系统管理 脚本如何处理GO的生命周期：GC, Garbage Collection 优势：不需要手动管理对象生命周期，自动处理 问题：每次需要扫描内存，处理效率低 对于玩法相对简单的单机游戏，大多交给引擎管理； MMORPG等玩法非常复杂的游戏，大多脚本系统管理 架构 引擎调用脚本 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture15-gameplay-complexity-and-building-blocks">Lecture15
Gameplay Complexity and Building Blocks</h3>
<h4 id="overview">Overview</h4>
<ul>
<li>Gameplay的挑战
<ul>
<li>多个系统之间的合作</li>
<li>同一个游戏中Gameplay的多样性</li>
<li>快速迭代</li>
</ul></li>
</ul>
<h4 id="event-mechanism">Event Mechanism</h4>
<ul>
<li>Hard Code写在函数中：无数的if/else、非常难以修改</li>
<li><strong>Event/Message Mechanism：GO之间的“通讯协议”</strong>
Publish-subscribe Pattern 发行-订阅设计模式
<ul>
<li>Event Definition 信息的定义
<ul>
<li>方法1：Event作为类设计 -&gt; 不适合交给设计师修改</li>
<li>方法2：允许定义任意的Event
<ul>
<li>再通过代码渲染系统编译，但每次修改都需要重新编译过于麻烦</li>
<li>在引擎核心代码之外定义
<ul>
<li>dll注入</li>
<li>用脚本层语言实现</li>
</ul></li>
</ul></li>
</ul></li>
<li>Callback Registration 响应注册
<ul>
<li>注册和调用不在同一处 –&gt; 对象的生命周期和回调函数安全性问题
<ul>
<li>Strong Reference 强引用：引用关系绑定</li>
<li>Weak Reference 弱引用：引用关系弱，可手动进行逻辑判断，使用较多</li>
</ul></li>
</ul></li>
<li>Event Dispatching 信息分发
<ul>
<li>遍历每个GO，逐个分发调用函数 —— 效率过低</li>
<li>Immediate：发送消息立即调用函数
<ul>
<li>会打断前一任务，等待Callback执行后再继续
<img src="/images/games104/L15_EventDispatchImmediate.jpg" alt="L15_EventDispatchImmediate" style="zoom: 50%;" /></li>
<li>单次打断引发连锁Callback，易导致Callstack非常深，难以Debug</li>
<li>难以并行</li>
</ul></li>
<li><strong>Event Queue</strong>
<ul>
<li>把Event存储至队列，依次执行</li>
<li>Event Queue的序列化和反序列化
<img src="/images/games104/L15_EventSerializingAndDeserializing.png" alt="L15_EventSerializingAndDeserializing" style="zoom: 25%;" />
实现：利用反射，获取每个对象的描述结构</li>
<li>存储结构：Ring Buffer 不用重复申请新内存
<img src="/images/games104/L15_RingBuffer.jpg" alt="L15_RingBuffer" style="zoom: 67%;" /></li>
<li>Batching，将多个独立系统分开处理
<img src="/images/games104/L15_EventQueueBatching.png" alt="L15_EventQueueBatching" style="zoom: 25%;" /></li>
<li>问题：
<ul>
<li>无法保证多个系统间的执行顺序 =&gt; 保留一定的Immediate处理能力
同时具备Pre、Post、Immediate处理方式</li>
<li>有系统延迟，削弱动作游戏打击感 =&gt; 经常Hardcode绕过Delay</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="script-system">Script System</h4>
<ul>
<li>Game Logic
<ul>
<li>直接在游戏引擎代码内，使用编译语言编写 （C/C++）
<ul>
<li>每次修改Gameplay，需要重新编译游戏引擎</li>
<li>极难支持热更新</li>
<li>对设计师极不友好</li>
</ul></li>
<li>脚本语言 Script System
<ul>
<li>支持快速迭代</li>
<li>易于学习、编写</li>
<li>支持热更新</li>
<li>沙盒运行，稳定、更少Crash</li>
</ul></li>
</ul></li>
<li>如何运行
<ul>
<li>基于虚拟机</li>
<li>Script Text -&gt; [Compiler] -&gt; Bytecode [Virtual Machine]</li>
<li>速度略慢</li>
</ul></li>
<li>如何管理GO
<img src="/images/games104/L15_GOManagement.png" alt="L15_GOManagement" style="zoom: 25%;" />
<ul>
<li>强调效率：引擎内核管理，脚本触发引擎执行
<ul>
<li>编写难度大</li>
<li>执行过程非常复杂</li>
</ul></li>
<li>直接交给脚本系统管理
<ul>
<li>脚本如何处理GO的生命周期：GC, Garbage Collection
<ul>
<li>优势：不需要手动管理对象生命周期，自动处理</li>
<li>问题：每次需要扫描内存，处理效率低</li>
</ul></li>
</ul></li>
<li>对于玩法相对简单的单机游戏，大多交给引擎管理；
MMORPG等玩法非常复杂的游戏，大多脚本系统管理</li>
</ul></li>
<li>架构
<ul>
<li>引擎调用脚本 eg. UE / Unity</li>
<li>脚本包引擎，引擎相当于一系列SDK库，目前应用相对少</li>
</ul></li>
<li>热更新
<ul>
<li>直接修改对应位置的脚本
<img src="/images/games104/L15_ScriptHotUpdate.png" alt="L15_ScriptHotUpdate" style="zoom: 25%;" /></li>
<li>可能会导致Crash</li>
<li>需要保障鲁棒性</li>
</ul></li>
<li>脚本语言的问题
<ul>
<li>弱类型语言难以编译优化</li>
<li>需要虚拟机运行</li>
<li>JIT，一边解释执行一边编译，可以优化</li>
</ul></li>
<li>根据情况选择脚本语言
<ul>
<li>Lua 轻量，效率高，缺少拓展</li>
<li>Python 支持反射，面向对象，丰富的拓展库，虚拟机较重</li>
<li>C# Mono等库/.NET官方支持，将原生编译语言变成脚本语言</li>
</ul></li>
</ul>
<h4 id="visual-script">Visual Script</h4>
<ul>
<li>eg. UE Blueprint, Unity Visual Script</li>
<li>对设计师和艺术家更友好</li>
<li>作为编程语言的要素：
<ul>
<li>Variable 变量</li>
<li>Statement and Expression 声明和表达式</li>
<li>Control Flow 控制语句</li>
<li>Function 函数</li>
<li>Class 类（对于面向对象的语言）</li>
</ul></li>
<li>可视化Debug</li>
<li>问题：
<ul>
<li>多人编辑的Merge问题</li>
<li>复杂度高后难以阅读</li>
</ul></li>
<li>Visual Script和脚本本质同类 Script Graph -&gt; Graph Compiler -&gt;
Bytecode -&gt; Virtual Machine</li>
</ul>
<h4 id="character-control-and-camera">Character, Control and Camera</h4>
<h5 id="character">Character</h5>
<ul>
<li>Movement
<ul>
<li>Idle, Start, Walk, Accelerate, Run, Brake, …</li>
<li>与环境交互 Hanging, Skating, Diving, …</li>
<li>与其它系统互动</li>
<li>基于物理的运动</li>
<li><strong>Movement State Machine</strong> 状态机</li>
</ul></li>
<li>Skills</li>
<li>…</li>
</ul>
<h5 id="control">Control</h5>
<ul>
<li>不同的输入设备，输入设备 -&gt; 游戏逻辑
<img src="/images/games104/L15_Control.png" alt="L15_Control" style="zoom: 15%;" /></li>
<li>Zoom in and out</li>
<li>Aim Assist 吸附操作等（尤其主机游戏）</li>
<li>Feedback 力反馈、声音反馈、光效反馈、…</li>
<li>Context Awareness 不同的游戏片段，输入响应不同</li>
<li>Chord &amp; Key Sequences 按键触发、多个按键序列触发</li>
</ul>
<h5 id="camera">Camera</h5>
<ul>
<li>基础：POV和FOV Point of View, Field of View</li>
<li>相机绑定
<ul>
<li>Spring Arm</li>
</ul></li>
<li>Camera Track</li>
<li>Camera Effect</li>
<li>Camera Manager 多相机管理，视角切换等 eg.枪械瞄准、赛车</li>
<li>Subjective Feelings 强调主观感受</li>
</ul>
<p>引擎针对3C系统要公开足够多的接口到 Script / Visual Script
提供给设计师、艺术家</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-07-03-GAMES104现代游戏引擎-Lecture14-Tool Chains Applications &amp; Advanced Topic</title>
      <link>https://elderlyaugustus.github.io/posts/2022-07-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture14-applicationsadvancedtopic/</link>
      <pubDate>Sun, 03 Jul 2022 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-07-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture14-applicationsadvancedtopic/</guid>
      <description>Lecture14 Tool Chains Applications &amp;amp; Advanced Topic Architecture of A World Editor A hub for everything to build the world
Editor Viewport 运行一个完整游戏，“Editor Mode” 代码存在Editor Only -&amp;gt; 避免编译到最终游戏中 Everything is an Editable Object Objects Views Tree View Layer View Categories and groups 通过Schema系统编辑Object参数，参数编辑面板 Content Browser Editing Utilities in World Editor 鼠标选取
Ray casting 不需要缓存，支持同时选取多个物体 遍历性能差 RTT 在G-Buffer中存储Object ID 根据点击像素直接对应Object ID 其他Trick来选取无Mesh的Object Object Transform Editing
Terrain
Heightmap Texture 植被、水体等 Brush Height Brush 笔刷边缘的过渡、笔刷的可拓展性 Instance Brush eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture14-tool-chains-applications-advanced-topic">Lecture14
Tool Chains Applications &amp; Advanced Topic</h3>
<h4 id="architecture-of-a-world-editor">Architecture of A World
Editor</h4>
<p><strong>A hub for everything to build the world</strong></p>
<ul>
<li>Editor Viewport
<ul>
<li>运行一个完整游戏，“Editor Mode”</li>
<li>代码存在Editor Only -&gt; 避免编译到最终游戏中</li>
</ul></li>
<li>Everything is an Editable Object
<ul>
<li>Objects Views
<ul>
<li>Tree View</li>
<li>Layer View</li>
<li>Categories and groups</li>
</ul></li>
<li>通过Schema系统编辑Object参数，参数编辑面板</li>
</ul></li>
<li>Content Browser</li>
<li>Editing Utilities in World Editor
<ul>
<li><p>鼠标选取</p>
<ul>
<li>Ray casting
<ul>
<li>不需要缓存，支持同时选取多个物体</li>
<li>遍历性能差</li>
</ul></li>
<li>RTT
<ul>
<li>在G-Buffer中存储Object ID</li>
<li>根据点击像素直接对应Object ID</li>
<li>其他Trick来选取无Mesh的Object</li>
</ul></li>
</ul></li>
<li><p>Object Transform Editing</p></li>
<li><p>Terrain</p>
<ul>
<li>Heightmap</li>
<li>Texture</li>
<li>植被、水体等</li>
<li>Brush
<ul>
<li>Height Brush 笔刷边缘的过渡、笔刷的可拓展性</li>
<li>Instance Brush eg.刷植被</li>
</ul></li>
</ul></li>
<li><p>Environment</p>
<ul>
<li>Sky</li>
<li>Light</li>
<li>Roads</li>
<li>Rivers</li>
<li>…</li>
</ul></li>
<li><p>Rule System in Environment</p>
<ul>
<li>eg. 路上不能有植被</li>
<li>保证局部修改而不是全部重新生成</li>
</ul></li>
</ul></li>
</ul>
<h4 id="plugin-architecture">Plugin Architecture</h4>
<ul>
<li>系统和对象的功能“矩阵”
<img src="/images/games104/L14_MatrixOfSystemsAndObjects.jpg" alt="L14_MatrixOfSystemsAndObjects" style="zoom: 33%;" />
插件既需要在横向上拓展对象，也需要在纵向上拓展系统</li>
<li>插件的Combination
<ul>
<li>Covered：覆盖原有逻辑 eg.地形编辑系统
<img src="/images/games104/L14_PluginsCombinationCoverd.jpg" alt="L14_PluginsCombinationCoverd" style="zoom: 67%;" /></li>
<li>Distributed：分布式，最终混合输出 eg.大部分编辑系统
<img src="/images/games104/L14_PluginsCombinationDistributed.jpg" alt="L14_PluginsCombinationDistributed" style="zoom: 67%;" /></li>
<li>Pipeline：串联，前者输出作为后者输入 eg.资产预处理、物理几何体
<img src="/images/games104/L14_PluginsCombinationPipeline.jpg" alt="L14_PluginsCombinationPipeline" style="zoom: 67%;" /></li>
<li>Onion rings：洋葱圈，如图 eg.地形插件的道路编辑插件
<img src="/images/games104/L14_PluginsCombinationOnionRings.jpg" alt="L14_PluginsCombinationOnionRings" style="zoom: 67%;" /></li>
</ul></li>
<li>版本控制
<ul>
<li>理想情况：版本更新 with 插件版本更新</li>
<li>插件使用SDK的方式不确定，保持SDK相同的输入输出并不一定代表稳定迭代更新</li>
</ul></li>
</ul>
<h4 id="design-narrative-tools-设计叙事工具">Design Narrative Tools
设计叙事工具</h4>
<h5 id="eg.-sequencer-in-ue">eg. Sequencer in UE</h5>
<ul>
<li>Track</li>
<li>Property Track</li>
<li>Timeline</li>
<li>Key Frame</li>
<li>Sequence</li>
</ul>
<h4 id="reflection-and-gameplay">Reflection and Gameplay</h4>
<h5 id="反射">反射</h5>
<ul>
<li>反射是Sequencer的基础，修改参数怎样应用到Runtime的对象上。Schema架构，反射系统执行</li>
<li>Visual Scripting System eg.UE蓝图 ——
核心解决问题：底层代码的可扩展性
<ul>
<li>eg.
底层增加一个新的Function，表层也需要跟着增加相应的调用，非常麻烦（可以通过继承减少一部分工作）</li>
<li>利用反射解决</li>
</ul></li>
<li>反射：构建代码和工具之间的桥梁
<ul>
<li>使用反射生成代码元数据map，包括class_name、func_name</li>
<li>生成accessor（gettor、setter、invoker、…）</li>
</ul></li>
</ul>
<h5 id="c如何实现反射">C++如何实现反射</h5>
<ul>
<li>生成Schema
<ul>
<li>GPL编译规范
<img src="/images/games104/L14_GPL.jpg" alt="L14_GPL" style="zoom: 67%;" /></li>
<li>从AST（Abstract Syntax
Tree）可以很方便得到类型信息，生成Schema大量开源的编译器可以生成AST eg.
gcc clang</li>
<li>Piccolo
<ul>
<li>clang生成AST，得到Schema数据结构</li>
<li>利用宏定义精确控制反射范围（不是所有变量、函数都需要被反射）
<ul>
<li>clang可以定义<code>__attribute__</code>，控制编译器行为</li>
</ul></li>
</ul></li>
</ul></li>
<li>生成Accessor
<ul>
<li>get / set / invoke</li>
<li>代码渲染
<ul>
<li>自动化生成代码</li>
<li>节约人力</li>
<li>很难出错</li>
<li>数据和逻辑分离</li>
</ul></li>
<li>Piccolo
<ul>
<li>利用Mustache生成代码</li>
</ul></li>
</ul></li>
</ul>
<h4 id="collaborative-editing-协同编辑">Collaborative Editing
协同编辑</h4>
<ul>
<li>核心问题：多人协作发生冲突</li>
<li>文件区分方式
<ul>
<li>分层方
<ul>
<li>按照资产分成多层，各自编辑单独层，最后Merge</li>
<li>分层难以完全分离，层之间经常存在相互关联</li>
</ul></li>
<li>分块
<ul>
<li>将世界分成多块，各自单独编辑，最后Merge</li>
<li>难以解决块之间的连接</li>
<li>单独有Artist处理边界</li>
</ul></li>
<li><strong>OFPA, One File Per Actor</strong> <span class="citation"
data-cites="UE5">@UE5</span>
<ul>
<li>每个对象都有独立的文件</li>
<li>很好地解决冲突</li>
<li>但最终文件提交量非常大</li>
<li>cooking时打包小文件开销大</li>
</ul></li>
</ul></li>
<li>基于网络同时编辑，互相可见
<ul>
<li>问题
<ul>
<li>需要处理网络架构</li>
<li>操作之间相互同步，要将操作原子化</li>
<li>怎么解决Undo&amp;Redo</li>
</ul></li>
<li>方案
<ul>
<li>使用“锁定”机制固定部分资产不可修改</li>
<li>OT, Operation Transform</li>
<li>CRDT, Conflict-free Replicated Data Type</li>
</ul></li>
<li>现在大部分网络方案：客户端提交，由服务器决策分发
<ul>
<li>Client Crash： Nothing</li>
<li>Server Crash： Boom</li>
</ul></li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-26-GAMES104现代游戏引擎-Lecture13-Tool Chains</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-26-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture13-toolchain/</link>
      <pubDate>Sun, 26 Jun 2022 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-26-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture13-toolchain/</guid>
      <description>Lecture13 Tool Chains 游戏引擎工具链的地位：
用户和引擎Runtime层的桥梁 引擎和DCC软件的桥梁：Asset Conditioning Pipeline 调和不同思维方式的平台：策划 / 美术 / 程序 GUI Immediate Mode 逐帧直接绘制，由引擎逻辑绘制，简单轻量直接 扩展性有限，性能有限，将业务压力交给了引擎逻辑 eg. Unity UGUI / Omniverse GUI / Piccolo GUI Retained Mode 将需要绘制的图形内容存储成Buffer，再交由GUI绘制 将引擎逻辑和GUI工具隔离，扩展性强，性能表现好 对开发者来说相对复杂 eg. Unreal UMG / WPF GUI / QT GUI Design Pattern MVC MVP：在MVC基础上的变化，View进一步与Model分离 MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View 平台兼容性问题，eg. 在Windows下WPF表现较好 数据处理 Serialization and Deserialization 序列化与反序列化：文件、数据库、内存、网络之间的数据转换
存储数据 - Serialization 文件格式 最简单的数据格式：文本文件 易读易处理，但缺乏安全性 纯文本信息 eg. txt/obj/… -&amp;gt; 结构化 eg. XML/… -&amp;gt; 更简单的结构 eg. json/… eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture13-tool-chains">Lecture13 Tool Chains</h3>
<p><strong>游戏引擎工具链的地位</strong>：</p>
<ul>
<li>用户和引擎Runtime层的桥梁</li>
<li>引擎和DCC软件的桥梁：Asset Conditioning Pipeline</li>
<li>调和不同思维方式的平台：策划 / 美术 / 程序</li>
</ul>
<h4 id="gui">GUI</h4>
<h5 id="immediate-mode">Immediate Mode</h5>
<ul>
<li>逐帧直接绘制，由引擎逻辑绘制，简单轻量直接</li>
<li>扩展性有限，性能有限，将业务压力交给了引擎逻辑</li>
<li>eg. Unity UGUI / Omniverse GUI / Piccolo GUI</li>
</ul>
<h5 id="retained-mode">Retained Mode</h5>
<ul>
<li>将需要绘制的图形内容存储成Buffer，再交由GUI绘制</li>
<li>将引擎逻辑和GUI工具隔离，扩展性强，性能表现好</li>
<li>对开发者来说相对复杂</li>
<li>eg. Unreal UMG / WPF GUI / QT GUI</li>
<li><strong>Design Pattern</strong>
<ul>
<li>MVC
<img src="/images/games104/L13_MVC.png" alt="L13_MVC" style="zoom: 25%;" /></li>
<li>MVP：在MVC基础上的变化，View进一步与Model分离
<img src="/images/games104/L13_MVP.jpg" alt="L13_MVP" style="zoom: 50%;" /></li>
<li>MVVM：把Presenter换成ViewModel——用Binding将ViewModel和View绑定，用HTML/XAML等简单逻辑表示View
<img src="/images/games104/L13_MVVM1.jpg" alt="L13_MVVM1" style="zoom: 67%;" />
<img src="/images/games104/L13_MVVM2.png" alt="L13_MVVM2" style="zoom: 33%;" />
<ul>
<li>平台兼容性问题，eg. 在Windows下WPF表现较好</li>
</ul></li>
</ul></li>
</ul>
<h4 id="数据处理">数据处理</h4>
<h5 id="serialization-and-deserialization">Serialization and
Deserialization</h5>
<p>序列化与反序列化：文件、数据库、内存、网络之间的数据转换</p>
<h5 id="存储数据---serialization">存储数据 - Serialization</h5>
<ul>
<li><strong>文件格式</strong>
<ul>
<li>最简单的数据格式：文本文件
<ul>
<li>易读易处理，但缺乏安全性</li>
<li>纯文本信息 eg. txt/obj/… -&gt; 结构化 eg. XML/… -&gt; 更简单的结构
eg. json/…</li>
<li>eg. Unity YAML / Piccolo json / Cryengine XML json</li>
</ul></li>
<li>二进制文件
<ul>
<li>体积小，读取时无需语义处理，加载速度快</li>
</ul></li>
</ul></li>
<li><strong>Asset Reference</strong>
<ul>
<li>大量重用的资产 -&gt; 多个Instance引用同一个Asset</li>
<li>Object Instance Variance：为Asset提供各种可变性，例如更换贴图
<ul>
<li>低效方法：copy一份直接修改</li>
<li>Data Inheritance，数据继承，override修改部分</li>
</ul></li>
</ul></li>
</ul>
<h5 id="加载数据---deserialization">加载数据 - Deserialization</h5>
<ul>
<li>Parse Asset File
<img src="/images/games104/L13_ParseAssetFile.png" alt="L13_ParseAssetFile" style="zoom: 20%;" />
<ul>
<li>语义解析，生成 &lt;field-value&gt; tree
<ul>
<li>文本格式需要较为复杂的parse得到树</li>
<li>二进制文件则一般直接按树的顺序，field name + field data
存成表格</li>
<li>二进制文件需要考虑 Endianness，大端小端序
<ul>
<li>引擎本身保持同一字节序</li>
<li>根据不同平台判断提前处理</li>
</ul></li>
</ul></li>
</ul></li>
<li>Asset Version Compatibility
<ul>
<li>eg. 增删field
<ul>
<li>强制判断version number，将缺失field设为默认值</li>
<li>Protocol buffer：要求在增删field时标记UID，UID按新增顺序增加</li>
</ul></li>
</ul></li>
</ul>
<h4 id="如何增强工具链鲁棒性">如何增强工具链鲁棒性</h4>
<ul>
<li>Undo &amp; Redo
<ul>
<li>Command Pattern
<ul>
<li>原子化操作，存储用户command，Undo/Redo时重新加载command</li>
<li>Command类设计
<ul>
<li>UID（及get/set）</li>
<li>Data（及get/set）</li>
<li>Invoke()</li>
<li>Revoke()</li>
<li>Serialize()</li>
<li>Deserialize()</li>
</ul></li>
<li>三类Command
<ul>
<li>增加对象
<ul>
<li>数据：通常使用runtime instance的拷贝</li>
<li>Invoke：根据数据创建runtime instance</li>
<li>Revoke：删除runtime instance</li>
</ul></li>
<li>删除对象
<ul>
<li>数据：通常使用runtime instance的拷贝</li>
<li>Invoke：删除runtime instance</li>
<li>Revoke：根据数据创建runtime instance</li>
</ul></li>
<li>更新对象
<ul>
<li>数据：通常使用对runtime instance的修改属性的属性名和新值旧值</li>
<li>Invoke：设置runtime instance的属性为新值</li>
<li>Revoke：设置runtime instance的属性为旧值</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="如何形成工具链">如何形成工具链</h4>
<ul>
<li>Building Blocks —— 从不同数据中找出共性，原子化</li>
<li>Schema —— 一种描述结构，描述Building Blocks的组合
<ul>
<li>用Schema构建各种高级数据</li>
<li>Schema需要支持继承
<img src="/images/games104/L13_SchemaInheritance.jpg" alt="L13_SchemaInheritance" style="zoom: 50%;" /></li>
<li>两种Schema的定义方式
<ul>
<li>用独立的Schema定义文件
<ul>
<li>解耦性好，易于理解</li>
<li>需要用parser创建代码，难以debug</li>
</ul></li>
<li>在代码中直接定义</li>
</ul></li>
</ul></li>
<li>引擎数据的三种视角
<ul>
<li>Runtime内存：强调性能</li>
<li>硬盘：强调节约空间</li>
<li>用户视角/工具视角：强调易于理解</li>
</ul></li>
</ul>
<h4 id="what-you-sees-is-what-you-get-所见即所得">What you sees is what
you get “所见即所得”</h4>
<ul>
<li>创作视图和运行时一致</li>
<li>Stand-alone Tools 工具层和runtime层分开，难以实现所见即所得</li>
<li>In Game Tools
工具层直接架在runtime层之上，直接使用runtime层运行创作窗口</li>
<li>Play in Editor, PIE
<ul>
<li>直接在Editor World内运行
<ul>
<li>简单</li>
<li>会污染runtime层模式</li>
<li>编译成游戏Release版本时可能会出bug</li>
</ul></li>
<li>拷贝所有数据运行单独的PIE World
<ul>
<li>复杂度高，内存开销大</li>
<li>可以较好地保证编译结果一致</li>
<li>eg. Unreal Engine</li>
</ul></li>
</ul></li>
</ul>
<h4 id="plugin">Plugin</h4>
<ul>
<li>提供大量的API</li>
<li>尽可能把各种功能API化，自己实现引擎工具链时也使用API实现</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-18-GAMES104现代游戏引擎-Lecture12-Effects</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-18-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture12-effects/</link>
      <pubDate>Sat, 18 Jun 2022 18:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-18-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture12-effects/</guid>
      <description>Lecture12 Effects Particle 一个粒子 @PBA 粒子形态 Billboard Particle 永远朝向相机的面片 Mesh Particle eg. 碎石 Ribbon Particle 光带 eg. 刀的尾迹 样条插值，一般用Catmull 粒子渲染 透明混合顺序 全局排序 精确但开销大 层级结构 系统 -&amp;gt; Emitter -&amp;gt; Within emitter 分辨率，性能开销爆炸 Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合 GPU粒子 定义Particle Pool
管理Dead list和Alive list
在Compute Shader上计算
Visualization Culling，管理Alive list
Depth Buffer
Sorting
GPU并行Merge sort
双指针合并排序，读写会跳来跳去 优化：单指针遍历待写位置，找该写入的数值写入 Depth Buffer Collision 利用Depth Buffer做碰撞
Advanced Particle Animated Particle Mesh 动画可以编码成Texture：Particle Animation Texture 状态机可以通过切换贴图实现 Navigation Texture 从SDF计算Direction Texture（RG通道贴图） 实现群集运动的运动方向 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture12-effects">Lecture12 Effects</h3>
<h4 id="particle">Particle</h4>
<h5 id="一个粒子-pba">一个粒子 <span class="citation"
data-cites="PBA">@PBA</span></h5>
<h5 id="粒子形态">粒子形态</h5>
<ul>
<li>Billboard Particle 永远朝向相机的面片</li>
<li>Mesh Particle eg. 碎石</li>
<li>Ribbon Particle 光带 eg. 刀的尾迹
<ul>
<li>样条插值，一般用Catmull</li>
</ul></li>
</ul>
<h5 id="粒子渲染">粒子渲染</h5>
<ul>
<li>透明混合顺序
<ul>
<li>全局排序 精确但开销大</li>
<li>层级结构 系统 -&gt; Emitter -&gt; Within emitter</li>
</ul></li>
<li>分辨率，性能开销爆炸
<ul>
<li>Low-Resolution Particles 低分辨率渲染粒子，再与普通画面混合</li>
</ul></li>
</ul>
<h5 id="gpu粒子">GPU粒子</h5>
<ul>
<li><p>定义Particle Pool</p></li>
<li><p>管理Dead list和Alive list</p></li>
<li><p>在Compute Shader上计算</p></li>
<li><p>Visualization Culling，管理Alive list</p></li>
<li><p>Depth Buffer</p></li>
<li><p>Sorting</p>
<blockquote>
<p>GPU并行Merge sort</p>
<ul>
<li>双指针合并排序，读写会跳来跳去</li>
<li>优化：单指针遍历待写位置，找该写入的数值写入</li>
</ul>
</blockquote></li>
<li><p>Depth Buffer Collision 利用Depth Buffer做碰撞</p></li>
</ul>
<h5 id="advanced-particle">Advanced Particle</h5>
<ul>
<li>Animated Particle Mesh
<ul>
<li>动画可以编码成Texture：Particle Animation Texture
状态机可以通过切换贴图实现</li>
<li>Navigation Texture
<ul>
<li>从SDF计算Direction Texture（RG通道贴图）</li>
<li>实现群集运动的运动方向</li>
</ul></li>
</ul></li>
<li>eg. Mesh变成粒子再编程Mesh
<ul>
<li>Skeleton mesh emitter</li>
<li>Dynamic procedural splines</li>
<li>Reactions to other players</li>
<li>…</li>
</ul></li>
<li>群集模拟</li>
</ul>
<h5 id="游戏中的粒子系统工具">游戏中的粒子系统工具</h5>
<ul>
<li>早期：设定emitter参数，增加各种效果</li>
<li>现代：节点式，更复杂的处理</li>
<li>eg. Niagara</li>
</ul>
<h4 id="sound-system">Sound System</h4>
<ul>
<li>声音基础知识（略）</li>
<li>Panning</li>
<li>Attenuation 衰减
<ul>
<li>Attenuation Shape 在区域内不衰减
<ul>
<li>溪流沿岸 圆柱体</li>
<li>空间内 长方体</li>
<li>喇叭 锥体</li>
</ul></li>
<li>Obstruction and Occlusion
<ul>
<li>Raycast</li>
</ul></li>
</ul></li>
<li>Reverb 混响
<ul>
<li>分类
<ul>
<li>Direct (Dry) 干音</li>
<li>Early reflection (Echo) 回音</li>
<li>Late reverberations (Tail) 尾音</li>
<li>回音 + 尾音 == Wet 湿音</li>
</ul></li>
<li>Absorption
<ul>
<li>Pre-delay (seconds)</li>
<li>HF ratio</li>
<li>Dry level</li>
<li>Wet level</li>
</ul></li>
</ul></li>
<li>The Dopppler Effect 多普勒效应</li>
<li>Spatialization - Soundfield</li>
<li>引擎中间件 eg. Wwise</li>
<li>建模整个声音世界</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-06-04-GAMES104现代游戏引擎-Lecture11-Physics System - Applications</title>
      <link>https://elderlyaugustus.github.io/posts/2022-06-04-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture11-physicssystemapplications/</link>
      <pubDate>Sat, 04 Jun 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-06-04-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture11-physicssystemapplications/</guid>
      <description>Lecture11 Physics System - Applications Character Controller 一个反物理的系统：符合玩家感知 + 实现反物理运动 没有Character Controller时，大量Hack Kinematic Actor 不受物理规律控制 Push其他Actor Shape （人类角色时） Capsule 主要使用，一般设计两层 内层：碰撞 外层：防止角色与物体（墙面）太近 高速移动时容易卡进墙体 相机穿透导致看到墙后物体 Box Convex Collide with environment Sweep Test 判断 Sliding：撞到墙上时左右滑动 Auto Stepping：台阶 每帧尝试抬升高度前进 Slope 斜坡 坡度大于多少时，冲上去会滑下来 改变Controller形状/体积 eg.蹲下站起的变化 限制在环境大小不够时不可站起（eg.在隧道中） 更新前重叠测试，阻止形状更新 Push Objects (Dynamic Actors) Controller站在运动平台上时 不作处理就会平台动、Controller在原地 Ray Cast检测所站物体上，绑定，运动时也相对于平台 进一步精细：平台运动过快时的趔趄等 Ragdoll 不适用Ragdoll：播放死亡动画 =&amp;gt; 死亡环境并不一定与动画一致 eg. 在悬崖边，悬空挂在坡面上甚至插入地形 用Rigid Body将关键的Joint连结起来 考虑Constraints 将Ragdoll中较少Joints的运动映射到Skeleton Animation Retargeting 三种Joints Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据 Leaf Joints：一般不动，例如手掌脚掌 Intermediate Joints：Active Joints之间的Joints，利用邻近Active Joints插值 死亡动画到Ragdoll的过渡 一个问题：游戏中动画与物理的边界在哪里？ Powered Ragdoll - Physics-Animation Blending 纯Ragdoll：效果不像人类 纯动画：循环播放，有模式感 两种混合 Cloth 传统：Bake动画，随着运动方向更换动画，移动端常用</description>
      <content:encoded><![CDATA[<h3 id="lecture11-physics-system---applications">Lecture11 Physics
System - Applications</h3>
<h4 id="character-controller">Character Controller</h4>
<ul>
<li>一个反物理的系统：符合玩家感知 + 实现反物理运动</li>
<li>没有Character Controller时，大量Hack</li>
<li>Kinematic Actor
<ul>
<li>不受物理规律控制</li>
<li>Push其他Actor</li>
</ul></li>
<li>Shape （人类角色时）
<ul>
<li><strong>Capsule</strong> 主要使用，一般设计两层
<ul>
<li>内层：碰撞</li>
<li>外层：防止角色与物体（墙面）太近
<ul>
<li>高速移动时容易卡进墙体</li>
<li>相机穿透导致看到墙后物体</li>
</ul></li>
</ul></li>
<li>Box</li>
<li>Convex</li>
</ul></li>
<li>Collide with environment
<ul>
<li>Sweep Test 判断</li>
<li>Sliding：撞到墙上时左右滑动
<img src="/images/games104/L11_Sliding.png" alt="L11_Sliding" style="zoom: 25%;" /></li>
<li>Auto Stepping：台阶 每帧尝试抬升高度前进
<img src="/images/games104/L11_AutoStepping.gif" alt="L11_AutoStepping" style="zoom:25%;" /></li>
<li>Slope 斜坡
<ul>
<li>坡度大于多少时，冲上去会滑下来</li>
</ul></li>
<li>改变Controller形状/体积 eg.蹲下站起的变化
<ul>
<li>限制在环境大小不够时不可站起（eg.在隧道中）
更新前重叠测试，阻止形状更新</li>
</ul></li>
<li>Push Objects (Dynamic Actors)</li>
<li>Controller站在运动平台上时
<ul>
<li>不作处理就会平台动、Controller在原地</li>
<li>Ray Cast检测所站物体上，绑定，运动时也相对于平台</li>
<li>进一步精细：平台运动过快时的趔趄等</li>
</ul></li>
</ul></li>
</ul>
<h4 id="ragdoll">Ragdoll</h4>
<ul>
<li>不适用Ragdoll：播放死亡动画 =&gt; 死亡环境并不一定与动画一致 eg.
在悬崖边，悬空挂在坡面上甚至插入地形</li>
<li>用Rigid Body将关键的Joint连结起来
<img src="/images/games104/L11_RigdollJoints.jpg" alt="L11_RigdollJoints" style="zoom:30%;" />
<ul>
<li>考虑Constraints</li>
<li>将Ragdoll中较少Joints的运动映射到Skeleton
<ul>
<li><strong>Animation Retargeting</strong></li>
<li>三种Joints
<img src="/images/games104/L11_RagdollAnimation.png" alt="L11_RagdollAnimation" style="zoom:25%;" />
<ul>
<li>Active Joints：与Ragdoll相同的Joints，直接使用Ragdoll数据</li>
<li>Leaf Joints：一般不动，例如手掌脚掌</li>
<li>Intermediate Joints：Active Joints之间的Joints，利用邻近Active
Joints插值</li>
</ul></li>
</ul></li>
<li>死亡动画到Ragdoll的过渡
<ul>
<li>一个问题：游戏中动画与物理的边界在哪里？</li>
<li>Powered Ragdoll - Physics-Animation Blending
<ul>
<li>纯Ragdoll：效果不像人类</li>
<li>纯动画：循环播放，有模式感</li>
<li>两种混合
<img src="/images/games104/L11_PoweredRagdoll.jpg" alt="L11_PoweredRagdoll" style="zoom:25%;" /></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h4 id="cloth">Cloth</h4>
<ul>
<li><p>传统：Bake动画，随着运动方向更换动画，移动端常用</p></li>
<li><p>动力学骨骼模拟：精度较低</p></li>
<li><p>Mesh-based Cloth Simulation ##### Mesh-based Cloth
Simulation</p></li>
<li><p>Physical Mesh远低于Render Mesh，模拟完再用重心坐标插值到Render
Mesh</p></li>
<li><p>Constraints：</p>
<ul>
<li>划定布料每个顶点的运动范围</li>
<li>一般离人体越近，运动范围越小 eg.披风脖子处运动幅度小</li>
<li>解决衣料穿模问题</li>
</ul></li>
<li><p>布料物理材质（丝绸/棉布等）</p></li>
</ul>
<h5 id="cloth-solver---mass-spring-system">Cloth Solver - Mass Spring
System</h5>
<ul>
<li><p>质点弹簧系统</p>
<ul>
<li><p>Spring force 胡克力 <span class="math display">\[
\vec F^S=k_{\rm spring}\Delta\vec x
\]</span></p></li>
<li><p>Spring damping force （damping
衰减，空气阻力所致/提高迭代稳定性） <span class="math display">\[
\vec F^d=-k_{\rm damping}\vec v
\]</span></p></li>
</ul></li>
<li><p>横向、纵向、斜向、跨越质点加弹簧，提高精度
<img src="/images/games104/L11_MassSpringCloth.png" alt="L11_MassSpringCloth" style="zoom:20%;" /></p></li>
<li><p>受力</p>
<ul>
<li>重力</li>
<li>风力</li>
<li>空气阻力</li>
<li>周围弹簧弹力（胡克力 + damping） <span class="math display">\[
\vec F_{\rm net}^{\rm vertex}=M\vec g+\vec F_{\rm wind}(t)+\vec F_{\rm
air\ resistance}(t)+\sum_{\rm springs\in v}(k_{\rm spring}\Delta \vec
x(t)-k_{\rm damping}\vec v(t))=M\vec a(t)
\]</span></li>
</ul></li>
<li><p>Verlet数值积分 <span class="math display">\[
\vec x(t+\Delta t)=2\vec x(t)-\vec x(t-\Delta t)+\vec a(t)(\Delta t)^2
\]</span></p>
<ul>
<li>半隐式欧拉积分 <span class="math display">\[
\vec v(t+\Delta t)=\vec v(t)+\vec a(t)\Delta t \\ \vec x(t+\Delta
t)=\vec x(t)+\vec v(t+\Delta t)\Delta t
\]</span></li>
<li>Observation <span class="math display">\[
\left\{\begin{array}{l}\vec v(t+\Delta t)=\vec v(t)+\vec a(t)\Delta t \\
\vec x(t+\Delta t)=\vec x(t)+\vec v(t+\Delta t)\Delta t\\
\vec x(t)=\vec x(t-\Delta t)+\vec v(t)\Delta t
\end{array}\right.\ \Rightarrow\
\left\{\begin{array}{l}
\vec x(t+\Delta t)=\vec x(t)+(\vec v(t)+\vec a(t)\Delta t)\Delta t\\
\vec x(t)=\vec x(t-\Delta t)+\vec v(t)\Delta t
\end{array}\right.
\]</span></li>
<li>得到 <span class="math display">\[
\vec x(t+\Delta t)=2\vec x(t)-\vec x(t-\Delta t)+\vec a(t)(\Delta t)^2
\]</span></li>
<li>与半隐式欧拉积分数学等价，但实现上因为排除了不稳定的速度因素，更加稳定</li>
</ul></li>
</ul>
<h5 id="cloth-solver---position-based-dynamics">Cloth Solver - Position
Based Dynamics</h5>
<ul>
<li>区别
<ul>
<li>传统Simulation：Constrains =&gt; Force =&gt; Velocity =&gt;
Position</li>
<li>PBD：Constrains ==&gt; Position</li>
</ul></li>
<li>用约束描述物理属性</li>
<li>Solver更稳定</li>
<li>后面会再进一步解释</li>
</ul>
<h5 id="self-collision">Self Collision</h5>
<p>包括布料与布料、布料与刚体的碰撞，精度较低时极易发生</p>
<ul>
<li>暴力方法：加厚布料（渲染时），发生自穿插时不会渲染出来</li>
<li>提高迭代精度，减小迭代Step</li>
<li>Maximal velocity 这样每次穿插不会过深，可以在下次迭代时弹回</li>
<li>增加一个负向力场，负向SDF实现</li>
</ul>
<h4 id="destruction">Destruction</h4>
<ul>
<li><p>Chunk Hierarchy，组织未破碎物体的碎片</p></li>
<li><p>Connectivity Graph，生成连接关系，每个Edge有Connectivity
Value</p></li>
<li><p>Damage Calculation，受力超过Connectivity Value则破坏连接</p>
<ul>
<li>Impact Point向外扩散
<img src="/images/games104/L11_DamageRange.png" alt="L11_DamageRange" style="zoom:15%;" />
<span class="math display">\[
D_d=\left\{\begin{aligned}
&amp;D &amp;&amp;d\le R_\min\\
&amp;D\cdot\left(\dfrac{R_\max-d}{R_\max-R_\min}\right)^K
&amp;&amp;R_\min&lt;d&lt;R_\max\\
&amp;0 &amp;&amp;d\ge R_\max\quad
\end{aligned}\right.
\]</span></li>
</ul></li>
<li><p>Pin住某些与世界的连接</p></li>
<li><p>Voronoi生成Chunk</p>
<ul>
<li><span class="citation" data-cites="PBA">@PBA</span>
随机取点，等距垂平面</li>
<li>断面纹理生成
<ul>
<li>实时的3D Texture生成</li>
<li>离线生成，runtime切换</li>
</ul></li>
<li>Chunk的分布 =&gt; 取点的分布</li>
</ul></li>
<li><p>Pipeline
<img src="/images/games104/L11_DestructionPipeline.jpg" alt="L11_DestructionPipeline" style="zoom: 50%;" /></p></li>
<li><p>增加其他真实感效果</p>
<ul>
<li>音效</li>
<li>粒子</li>
<li>Navigation更新</li>
</ul></li>
<li><p>谨慎使用，增加了大量Mesh，对算力要求很高</p></li>
</ul>
<h4 id="vehicle">Vehicle</h4>
<ul>
<li><p>A rigidbody actor
<img src="/images/games104/L11_RigidbodyVehicle.jpg" alt="L11_RigidbodyVehicle" style="zoom: 50%;" /></p></li>
<li><p>驱动力 Traction Force
<img src="/images/games104/L11_TractionForce1.png" alt="L11_TractionForce1" style="zoom: 20%;" /></p>
<ul>
<li>扭矩 Torque <span class="math inline">\(T=T_{\rm
engine}X_gX_dn\)</span>
<img src="/images/games104/L11_TractionForce2.png" alt="L11_TractionForce2" style="zoom:20%;" /></li>
<li>驱动力 Traction <span class="math inline">\(\vec F_{\rm
Traction}=\dfrac{T}{R_w}\vec u\)</span></li>
</ul></li>
<li><p>悬挂力 Suspension Force
<img src="/images/games104/L11_SuspensionForce1.png" alt="L11_SuspensionForce1" style="zoom:20%;" />
<span class="math display">\[
|\vec F_{\rm suspension}|=k(L_{\rm rest}-(L_{
\rm hit}-R_W))
\]</span>
<img src="/images/games104/L11_SuspensionForce2.png" alt="L11_SuspensionForce2" style="zoom:20%;" /></p></li>
<li><p>轮胎力 Tire Forces</p>
<ul>
<li>径向力 Longitudinal force <span class="math inline">\(F_{\rm
long}=F_{\rm traction}+F_{\rm drag}+F_{rr}\)</span>
<img src="/images/games104/L11_TireForce1.png" alt="L11_TireForce1" style="zoom:20%;" /></li>
<li>切向力 Lateral force <span class="math inline">\(F_{\rm
lateral}=C_c*a\)</span>
<img src="/images/games104/L11_TireForce2.png" alt="L11_TireForce2" style="zoom:20%;" />
<img src="/images/games104/L11_TireForce3.png" alt="L11_TireForce3" style="zoom:20%;" /></li>
</ul></li>
<li><p>重心 Center of Mass
<img src="/images/games104/L11_CenterOfMass1.png" alt="L11_CenterOfMass1" style="zoom:20%;" />
<span class="math display">\[
M=M_1+M_2\quad \vec x_{cm}=\dfrac{M_1\vec x_1+M_2\vec x_2}{M}
\]</span>
<img src="/images/games104/L11_CenterOfMass2.png" alt="L11_CenterOfMass2" style="zoom:20%;" /></p>
<ul>
<li>重心太靠前在飞跃时容易栽，重心准确则稳定</li>
<li>重心靠前转向力不足，靠后转向力过大</li>
<li>变速时重心会有偏移 Weight Transfer
加速时车身后仰重心靠后，刹车时车身前倾重心靠前</li>
</ul></li>
<li><p>转向角</p>
<ul>
<li><p>转向时，若内外侧轮转向角相同，则外侧轮打滑空转</p></li>
<li><p>转向时，外侧轮转向角要大于内侧轮</p></li>
<li><p>根据旋转中心计算
<img src="/images/games104/L11_SteeringAngles1.png" alt="L11_SteeringAngles1" style="zoom:20%;" />
<span class="math display">\[
\alpha_l=\tan^{-1}\dfrac{L_{wb}}{R_t+\frac{L_r}{2}}\\
\alpha_r=\tan^{-1}\dfrac{L_{wb}}{R_t-\frac{L_r}{2}}
\]</span>
<img src="/images/games104/L11_SteeringAngles2.png" alt="L11_SteeringAngles2" style="zoom:20%;" /></p></li>
</ul></li>
<li><p>轮胎接触
<img src="/images/games104/L11_WheelContact.gif" alt="L11_WheelContact" style="zoom:20%;" /></p>
<ul>
<li>单方向垂直向下的 Single Raycast 效果不真实，易发生穿插</li>
<li>球面 Spherecast 实现真实的接触</li>
</ul></li>
</ul>
<h4 id="advanced-physics-pbd-xpbd">Advanced Physics : PBD / XPBD</h4>
<ul>
<li>拉格朗日力学：用约束描述所有运动，把力学计算改变为求解约束问题</li>
<li>eg. 匀速圆周运动
<ul>
<li>位置约束 <span class="math inline">\(C(\mathbf x)=\|\mathbf
x\|-r=0\)</span></li>
<li>速度约束 <span class="math inline">\(\dfrac{\mathrm d}{\mathrm
dt}C(\mathbf x)=\dfrac{\mathrm dC}{\mathrm d\mathbf x}\cdot
\dfrac{d\mathbf x}{\mathrm dt}=\mathbf J\cdot\mathbf v=0\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathbf J\)</span> Jacobian
<ul>
<li><span class="math inline">\(\mathbf J^T\)</span> 与 <span
class="math inline">\(\mathbf v\)</span> 垂直 <span
class="math inline">\(\mathbf J^T\cdot\mathbf v=0\)</span></li>
<li>把速度转换成速度约束</li>
</ul></li>
<li>弹簧质点等系统也都可用约束表示 eg. 弹簧质点系统拉伸时：<span
class="math inline">\(C_{\rm stretch}(\mathbf x_1, \mathbf
x_2)=\|\mathbf x_1-\mathbf x_2\|-d\)</span>
<img src="/images/games104/L11_StringConstraints2.png" alt="L11_StringConstraints2" style="zoom:15%;" /><img src="/images/games104/L11_StringConstraints1.png" alt="L11_StringConstraints1" style="zoom:15%;" /></li>
</ul>
<h5 id="pbd-position-based-dynamics">PBD, Position Based Dynamics</h5>
<ul>
<li>约束投影</li>
<li>求解约束的方法：迭代法</li>
<li>Jacobi矩阵指向正确的方向，反复迭代直到满足约束（接近）</li>
<li>收敛相对稳定</li>
<li>布料应用广泛</li>
<li>NVIDIA Flex</li>
</ul>
<p><img src="/images/games104/L11_PBD2.png" alt="L11_PBD2" style="zoom:25%;" /></p>
<p><img src="/images/games104/L11_PBD1.png" alt="L11_PBD1" style="zoom:25%;" /></p>
<p><img src="/images/games104/L11_PBD3.jpg" alt="L11_PBD3" style="zoom: 67%;" /></p>
<h5 id="xpbd-extended-position-based-dynamics">XPBD, Extended Position
Based Dynamics</h5>
<ul>
<li><p>在PBD基础上引入stiffness量，表示硬约束还是软约束</p></li>
<li><p>硬约束：stiffness非常大，易爆炸</p></li>
<li><p>软约束：stiffness较小，布料等软体</p></li>
<li><p><span class="math display">\[
U(\mathbf x)=\dfrac{1}{2}\mathbf C(\mathbf x)^T\alpha^{-1}\mathbf
C(\mathbf x)\quad \alpha:\text{stiffness}
\]</span></p>
<p>将约束转换为服从性矩阵 Compliance Matrix</p></li>
<li><p>Unreal Engine Chaos</p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-25-GAMES104现代游戏引擎-Lecture10-Physics System - Basic Concepts</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-25-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture10-physicssystemconcepts/</link>
      <pubDate>Wed, 25 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-25-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture10-physicssystemconcepts/</guid>
      <description>Lecture10 Physics System - Basic Concepts 物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 + 环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料
Physics Actors and Shapes Actor Static Actor 静态固定的，不受物理影响 Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动 Trigger 根据碰撞触发Message从而产生Event Kinematic 反物理的自发运动（游戏设计师设计的运动） &amp;gt; Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉” Shape : 复杂形状物理计算过于复杂 Sphere Capsule 胶囊体 Box Convex Mesh 凸多面体 Trangle Mesh （一般只用于静态） Height Field ！尽量使用简单的Shape（从前到后越来越复杂）
Shape Properties Mass / Density 质量 / 密度 Center of Mass 质心 Friction / Restitution 摩擦力 / 弹力 (and more …) Forces Force eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture10-physics-system---basic-concepts">Lecture10 Physics
System - Basic Concepts</h3>
<p>物理的作用： + 物理直觉 + 动态环境，《彩六》破坏环境 +
环境交互，VR等《Alyx》 + 艺术效果，粒子、流体、布料</p>
<h4 id="physics-actors-and-shapes">Physics Actors and Shapes</h4>
<h5 id="actor">Actor</h5>
<ul>
<li>Static Actor 静态固定的，不受物理影响</li>
<li>Dynamic Actor 按照动力学原理运动的，受力/动量/冲量驱动</li>
<li>Trigger 根据碰撞触发Message从而产生Event</li>
<li>Kinematic 反物理的自发运动（游戏设计师设计的运动） &gt;
Kinematic与受物理约束的Actor碰撞时，可能会产生“飞掉”</li>
</ul>
<h5 id="shape-复杂形状物理计算过于复杂">Shape :
复杂形状物理计算过于复杂</h5>
<ul>
<li>Sphere</li>
<li>Capsule 胶囊体</li>
<li>Box</li>
<li>Convex Mesh 凸多面体</li>
<li>Trangle Mesh （一般只用于静态）</li>
<li>Height Field</li>
</ul>
<p><img src="/images/games104/L10_ActorShapes.png" alt="L10_ActorShapes" style="zoom: 25%;" /></p>
<p>！尽量使用简单的Shape（从前到后越来越复杂）</p>
<h5 id="shape-properties">Shape Properties</h5>
<ul>
<li>Mass / Density 质量 / 密度</li>
<li>Center of Mass 质心</li>
<li>Friction / Restitution 摩擦力 / 弹力 (and more …)</li>
</ul>
<h4 id="forces">Forces</h4>
<ul>
<li><strong>Force</strong> eg. Gravity / Drag / Friction / …</li>
<li><strong>Impulse</strong> 冲量 eg. simulating an explosion</li>
</ul>
<h4 id="movements">Movements</h4>
<p>（略，<span class="citation"
data-cites="GAMES201/103">@GAMES201/103</span>）</p>
<h4 id="rigid-body-dynamics">Rigid Body Dynamics</h4>
<p>（略，<span class="citation"
data-cites="GAMES103">@GAMES103</span>）</p>
<h4 id="collision-detection">Collision Detection</h4>
<ul>
<li><p>Two phase
<img src="/images/games104/L10_TwoPhase.jpg" alt="L10_TwoPhase" style="zoom: 33%;" /></p></li>
<li><p>Broad Phase 方法</p>
<ul>
<li><strong>Space
partitioning</strong>：利用BVH查询，非常适合动态更新，但没有↓方法快</li>
<li><strong>Sort and Sweep</strong>
<ul>
<li>对所有Actor的AABB按<code>pmin</code>或<code>pmax</code>的x轴、y轴排序，查询重叠</li>
<li>排序后动态更新，局部调整计算量也很低</li>
</ul></li>
</ul></li>
<li><p>Narrow Phase 方法</p>
<ul>
<li><p><strong>Basic Shape Intersection Test</strong></p>
<ul>
<li>Sphere-Sphere 极易求</li>
<li>Sphere-Capsule 把Capsule拆成两端球和圆柱</li>
<li>Capsule-Capsule 同上</li>
</ul></li>
<li><p><strong>Minkowski Difference-based Methods</strong></p>
<ul>
<li><p>A形状中无穷多点坐标 + B形状中无穷多点坐标 = Minkowski Sum
<img src="/images/games104/L10_MinkowskiSum1.png" alt="L10_MinkowskiSum1" style="zoom:25%;" /><img src="/images/games104/L10_MinkowskiSum2.png" alt="L10_MinkowskiSum2" style="zoom: 25%;" />
<span class="math display">\[
A\oplus B=\{\vec a+\vec b:\vec a\in A,\vec b\in B\}
\]</span></p></li>
<li><p>A形状中无穷多点坐标 - B形状中无穷多点坐标 = Minkowski Difference
（将B关于原点对称得到-B，再求Minkowski Sum）
<img src="/images/games104/L10_MinkowskiDifference.png" alt="L10_MinkowskiDifference" style="zoom: 25%;" />
<span class="math display">\[
A\ominus B=\{\vec a-\vec b:\vec a\in A,\vec b\in B\}\\
A\ominus B=A \oplus(-B)
\]</span></p></li>
<li><p>观察：若AB有交点，则其Minkowski Difference一定过原点
<img src="/images/games104/L10_MinkowskiSumAndOrigin.png" alt="L10_MinkowskiSumAndOrigin" style="zoom: 25%;" /></p></li>
<li><p>GJK Algorithm</p>
<ul>
<li>分别取AB中Y轴方向最大最小的点，作差得到新的点C必为Minkowski
Difference上一顶点，判断O是否在C上，若否则下一步
<img src="/images/games104/L10_GJK1.png" alt="L10_GJK1" style="zoom: 25%;" /></li>
<li>连接点C和原点O，以OC方向取AB中最大最小的点，作差得到点D，判断O是否在CD上，若否则下一步
<img src="/images/games104/L10_GJK2.png" alt="L10_GJK2" style="zoom: 25%;" /></li>
<li>再作O到CD的垂线，以垂线方向取AB中最大最小的点，作差得到点E，判断O是否在CDE内，若否则下一步
<img src="/images/games104/L10_GJK3.png" alt="L10_GJK3" style="zoom: 25%;" /></li>
<li>Next
<img src="/images/games104/L10_GJK4.png" alt="L10_GJK4" style="zoom: 25%;" /></li>
<li>Next
<img src="/images/games104/L10_GJK5.png" alt="L10_GJK5" style="zoom: 25%;" /></li>
<li>…</li>
</ul></li>
</ul></li>
<li><p><strong>Separating Axis Theorem, SAT</strong></p>
<ul>
<li>定理：对两个分离的几何体，一定能找到分离轴将两者完全分开 =&gt;
2D情况下，对凸多边形而言，其中一个几何体的一条边可作为分离轴</li>
<li>2D情形：分别遍历AB的每条边，判断另一图形是否相交。若有任一分离轴，则两者不相交；否则相交
<img src="/images/games104/L10_SAT.png" alt="L10_SAT" style="zoom: 25%;" /><img src="/images/games104/L10_SATOptimized.png" alt="L10_SATOptimized" style="zoom: 25%;" /></li>
<li>3D情形：遍历AB的每个面，遍历AB的任两条边的叉积构成的平面</li>
</ul></li>
</ul></li>
</ul>
<h4 id="collision-resolution">Collision Resolution</h4>
<ul>
<li>Penalty Force （略，<span class="citation"
data-cites="PBA">@PBA</span>）</li>
<li>Constraints （略，<span class="citation"
data-cites="PBA">@PBA</span>）
<img src="/images/games104/L10_Constraints.png" alt="L10_Constraints" style="zoom:25%;" /></li>
</ul>
<h4 id="scene-query">Scene Query</h4>
<ul>
<li>Raycast
<ul>
<li>Multiple hits 返回所有交点</li>
<li>Closet hit 返回最近的交点</li>
<li>Any hit 返回交点，不需要排序</li>
</ul></li>
<li>Sweep 用几何体扫描</li>
<li>Overlap 重叠</li>
</ul>
<blockquote>
<p><strong>Collision Group</strong></p>
<ul>
<li>对Actor分组</li>
<li>Pawn / Static / Dynamic / Trigger</li>
<li>作判断时忽略无关的Actor</li>
</ul>
</blockquote>
<h4 id="efficiency-accuracy-and-determinism">Efficiency, Accuracy, and
Determinism</h4>
<h5 id="simulation-optimization">Simulation Optimization</h5>
<ul>
<li>Island 把一个个需要模拟的单元分离</li>
<li>Sleeping Island在不施加力的时候可以Sleep</li>
</ul>
<h5 id="continuous-collision-detection-ccd">Continuous Collision
Detection, CCD</h5>
<ul>
<li>部分Actor需开启CCD</li>
<li>移动速度过快时，下一时间步直接穿过碰撞物碰撞检测失效，Tunneling隧穿
Solution：
<ul>
<li>加厚碰撞物</li>
<li>CCD</li>
</ul></li>
<li>一种方法：Time-of-Impact, TOI
<ul>
<li>评估两步之间的“安全时间”</li>
<li>以“安全时间步”迭代</li>
<li>重复直到距离在碰撞物厚度之内</li>
</ul></li>
</ul>
<h5 id="deterministic-simulation-确定性模拟">Deterministic Simulation
确定性模拟</h5>
<ul>
<li>多人在线游戏中，各方须表现一致</li>
<li>same old states + same inputs = same new states</li>
<li>时间步、算法顺序、浮点数精度等等须保持一致</li>
<li>目前很难解决，大部分在线游戏中不用物理做游戏逻辑，而只做表现效果</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-19-GAMES104现代游戏引擎-Lecture9-Animation System - Advanced</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-19-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture9-advancedanimationsystem/</link>
      <pubDate>Thu, 19 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-19-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture9-advancedanimationsystem/</guid>
      <description>Lecture09 Animation System - Advanced Animation Blending LERP LERP / NLERP / SLERP 两个动画clip之间的LERP 权重 eg. 走路与跑步动画，依据运动速度切换 \[ {\rm weight_1=\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\ {\rm weight_2=\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\ \]
对齐时间线 eg.走路和跑步的步频不同，怎样对齐混合的帧 每一段动画为一步，对每一段动画时间线做归一化 Blend Space eg. 左右前后走/跑
1D Blend Space： eg. 左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）
2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置 双线性插值 Delaunay Triangulation 常用 根据设置的动画点，生成三角形划分 在空间内一点，由周围三角形插值 插值利用重心坐标 Skeleton Masked Blending 针对只应用于半身或身体局部的动画，实现多种动画的混合 eg.各种姿态下的鼓掌
绘制一个Mask，只应用于部分Joints Additive Blending eg. 向着摄影机点头
存储动画的变化量，在基础动画上叠加一层动画 需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果 Animation State Machine 状态机 两种核心元素 Node Clip Blend Space 脚本串接的单套动画系统 Translation 激活条件 Cross Fade Smooth transition 慢慢过渡，插值（各种插值曲线） Frozen transition 先停住动画A，再播放动画B 多层状态机 Animation Blend Tree 多层状态机在复杂动画中非常复杂 用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树 两种节点 Terminal Node 执行节点 (叶节点) Clip Blend Space ASM Non-terminal Node （非叶节点） LERP Blend Node Additive Blend Node Layered ASM to Blend Tree Blend Tree Control Parameters Variable 暴露变量，根据变量切换运动状态 eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture09-animation-system---advanced">Lecture09 Animation
System - Advanced</h3>
<h4 id="animation-blending">Animation Blending</h4>
<h5 id="lerp">LERP</h5>
<ul>
<li>LERP / NLERP / SLERP</li>
<li>两个动画clip之间的LERP</li>
</ul>
<h5 id="权重">权重</h5>
<p>eg. 走路与跑步动画，依据运动速度切换 <span class="math display">\[
{\rm weight_1=\dfrac{speed_{current}-speed_2}{speed_1-speed_2}}\\
{\rm weight_2=\dfrac{speed_{current}-speed_1}{speed_2-speed_1}}\\
\]</span></p>
<h5 id="对齐时间线">对齐时间线</h5>
<ul>
<li>eg.走路和跑步的步频不同，怎样对齐混合的帧</li>
<li>每一段动画为一步，对每一段动画时间线做归一化</li>
</ul>
<h5 id="blend-space">Blend Space</h5>
<p>eg. 左右前后走/跑</p>
<ul>
<li><p>1D Blend Space： eg.
左走、正走、右走三个动画，根据左右方向的速度插值（可以有分布不均匀的多个动画）</p></li>
<li><p>2D Blend Space： eg. 左右前后全部加入2D空间，由动画师指定动画位置
<img src="/images/games104/L09_2DBlendSpace.jpg" alt="L09_2DBlendSpace" style="zoom:33%;" /></p>
<ul>
<li><p>双线性插值
<img src="/images/games104/L09_Bilinear.jpg" alt="L09_Bilinear" style="zoom:33%;" /></p></li>
<li><p>Delaunay Triangulation 常用
<img src="/images/games104/L09_DelaunayTriangulation.jpg" alt="L09_DelaunayTriangulation" style="zoom:33%;" /></p>
<ul>
<li>根据设置的动画点，生成三角形划分</li>
<li>在空间内一点，由周围三角形插值</li>
<li>插值利用重心坐标</li>
</ul></li>
</ul></li>
</ul>
<h5 id="skeleton-masked-blending">Skeleton Masked Blending</h5>
<p>针对只应用于半身或身体局部的动画，实现多种动画的混合
eg.各种姿态下的鼓掌</p>
<ul>
<li>绘制一个Mask，只应用于部分Joints</li>
</ul>
<h5 id="additive-blending">Additive Blending</h5>
<p>eg. 向着摄影机点头</p>
<ul>
<li>存储动画的变化量，在基础动画上叠加一层动画</li>
<li>需要非常谨慎，易出现两个动画叠加后产生不自然的运动结果</li>
</ul>
<h5 id="animation-state-machine-状态机">Animation State Machine
状态机</h5>
<p><img src="/images/games104/L09_ASM1.jpg" alt="L09_ASM1" style="zoom: 67%;" /><img src="/images/games104/L09_ASM2.jpg" alt="L09_ASM2" style="zoom: 40%;" /></p>
<ul>
<li>两种核心元素
<ul>
<li>Node
<ul>
<li>Clip</li>
<li>Blend Space</li>
<li>脚本串接的单套动画系统</li>
</ul></li>
<li>Translation
<ul>
<li>激活条件</li>
<li>Cross Fade
<ul>
<li>Smooth transition 慢慢过渡，插值（各种插值曲线）</li>
<li>Frozen transition 先停住动画A，再播放动画B</li>
</ul></li>
</ul></li>
</ul></li>
<li>多层状态机
<img src="/images/games104/L09_LayeredASM.jpg" alt="L09_LayeredASM" style="zoom: 50%;" /></li>
</ul>
<h5 id="animation-blend-tree">Animation Blend Tree</h5>
<ul>
<li>多层状态机在复杂动画中非常复杂</li>
<li>用树结构表示动画之间的Blend方式（LERP/Additive），类似表达式树
<img src="/images/games104/L09_ExpressionTree.png" alt="L09_ExpressionTree" style="zoom: 25%;" /></li>
<li>两种节点
<ul>
<li>Terminal Node 执行节点 (叶节点)
<ul>
<li>Clip</li>
<li>Blend Space</li>
<li>ASM</li>
</ul></li>
<li>Non-terminal Node （非叶节点）
<ul>
<li>LERP Blend Node
<img src="/images/games104/L09_ABTLERP.png" alt="L09_ABTLERP" style="zoom: 25%;" /></li>
<li>Additive Blend Node
<img src="/images/games104/L09_ABTAdditive.png" alt="L09_ABTAdditive" style="zoom: 25%;" /></li>
</ul></li>
</ul></li>
<li>Layered ASM to Blend Tree
<img src="/images/games104/L09_LayeredASM2ABT.png" alt="L09_LayeredASM2ABT" style="zoom: 25%;" /></li>
<li>Blend Tree Control Parameters
<ul>
<li>Variable
<ul>
<li>暴露变量，根据变量切换运动状态</li>
<li>eg. 速度、HP</li>
</ul></li>
<li>Event
<ul>
<li>外部传入激活状态的指令</li>
<li>eg. 持枪、开枪</li>
</ul></li>
</ul></li>
</ul>
<h4 id="inverse-kinematics">Inverse Kinematics</h4>
<ul>
<li>Forward Kinematics 前向传递动画</li>
<li>Inverse Kinematics 对末端Joint Key动画 eg.
崎岖地面走路，脚步顶点反向传递</li>
</ul>
<h5 id="two-bones-ik">Two Bones IK</h5>
<ul>
<li><p>2根Bone组成三角形的两边
<img src="/images/games104/L09_2BonesIK1.jpg" alt="L09_2BonesIK1" style="zoom:25%;" /></p></li>
<li><p>大腿根部的Joint到地面接触点距离为第三边</p></li>
<li><p>即可得到两根Bone的夹角 <span
class="math inline">\(\cos\theta=\dfrac{a^2+c^2-b^2}{2ac}\)</span>
<img src="/images/games104/L09_2BonesIK2.jpg" alt="L09_2BonesIK2" style="zoom: 25%;" /></p></li>
<li><p>问题：在3D空间，解有无数个，构成一个圆
<img src="/images/games104/L09_2BonesIK3.jpg" alt="L09_2BonesIK3" style="zoom:33%;" /></p>
<ul>
<li>设定Reference Vector</li>
<li>朝着Reference Vector方向取解
<img src="/images/games104/L09_2BonesIK4.jpg" alt="L09_2BonesIK4" style="zoom:20%;" /></li>
</ul></li>
<li><p>更多复杂的IK</p>
<ul>
<li>Look At</li>
<li>Hand</li>
<li>Foot</li>
<li>Full Body</li>
</ul></li>
</ul>
<h5 id="multi-joint-ik-solving">Multi-Joint IK Solving</h5>
<ul>
<li>更多种可能性
<img src="/images/games104/L09_MultiJointIK1.jpg" alt="L09_MultiJointIK1" style="zoom:33%;" /></li>
<li>首先检查是否能到达目标（最长、最短的触及范围）
<ul>
<li>最长（拉直）
<img src="/images/games104/L09_MultiJointIK2.jpg" alt="L09_MultiJointIK2" style="zoom: 25%;" /></li>
<li>最短（最长的单根Bone减去其他Bone）
<img src="/images/games104/L09_MultiJointIK3.jpg" alt="L09_MultiJointIK3" style="zoom:20%;" /><img src="/images/games104/L09_MultiJointIK4.jpg" alt="L09_MultiJointIK4" style="zoom:20%;" /></li>
</ul></li>
<li>约束 Constraints
关节有运动的约束，不能超出约束范围（比如依据人体的骨骼结构）</li>
<li>解法
<ul>
<li><strong>CCD, Cyclic Coordinate Decent</strong>
<img src="/images/games104/L09_CCD.gif" alt="L09_CCD" style="zoom: 25%;" />
<ul>
<li>逐个Joint遍历，每个Joint朝下一个Joint与目标点连线方向旋转</li>
<li>上述过程反复迭代，不断接近结果</li>
<li>优化：
<ul>
<li>每次旋转时，使用Tolerance region进行缩小或限制
<img src="/images/games104/L09_OptimizedCCD1.png" alt="L09_OptimizedCCD1" style="zoom: 20%;" /></li>
<li>越靠近根节点的限制越大，运动幅度越小（处理约束同理）
<img src="/images/games104/L09_OptimizedCCD2.png" alt="L09_OptimizedCCD2" style="zoom:20%;" /></li>
</ul></li>
</ul></li>
<li><strong>FABRIK, Forward And Backward Reaching Inverse
Kinematics</strong>
<img src="/images/games104/L09_FABRIK.gif" alt="L09_FABRIK" style="zoom:25%;" />
<ul>
<li>逐个Joint遍历，每个Joint朝目标点或上一个Joint位移，再将Bone还原设定下一个Joint</li>
<li>从末端Joint出发、从Root出发反复迭代</li>
<li>同样需要Tolerance优化</li>
<li>处理约束：将约束区域投影到Target所在平面，取可运动到的点
<img src="/images/games104/L09_FABRIKConstraint.gif" alt="L09_FABRIKConstraint" style="zoom:25%;" /></li>
</ul></li>
</ul></li>
</ul>
<h5 id="ik-with-multiple-end-effects">IK with Multiple End-Effects</h5>
<p>eg. 爬墙、攀岩灯多个目标点的IK
<img src="/images/games104/L09_IKwithMultipleEnd-Effectors.png" alt="L09_IKwithMultipleEnd-Effectors" style="zoom:20%;" /></p>
<ul>
<li><p>利用Jacobi矩阵求解：</p>
<p><img src="/images/games104/L09_Jacobi1.png" alt="L09_Jacobi1" style="zoom:20%;" /></p>
<p><img src="/images/games104/L09_Jacobi2.png" alt="L09_Jacobi2" style="zoom:15%;" /></p></li>
<li><p>其他解法</p>
<ul>
<li>基于物理的解法</li>
<li>PBD, Position Based Dynamics</li>
<li>Fullbody IK in UE5 (XPBD, Extended PBD)</li>
</ul></li>
</ul>
<h5 id="ik的挑战">IK的挑战</h5>
<ul>
<li>蒙皮后的自我穿插、交叠</li>
<li>对环境的感知</li>
<li>更自然的人类行为，例如平衡
<ul>
<li>基于数据的、AI的方法</li>
</ul></li>
</ul>
<h4 id="animation-pipeline-with-blending-and-ik">Animation Pipeline with
Blending and IK</h4>
<p><img src="/images/games104/L09_AnimationPipelineWithBlendingAndIK.png" alt="L09_AnimationPipelineWithBlendingAndIK" style="zoom: 25%;" /></p>
<h4 id="facial-animation">Facial Animation</h4>
<h5 id="facial-action-coding-system">Facial Action Coding System</h5>
<ul>
<li>把表情分成46种，并进行编码</li>
<li>多种表情可以进行组合</li>
<li>Apple归纳了28个核心的表情，其中有23个是有对称性的，可以压缩</li>
<li>混合时如果线性叠加：合到一起后效果折半 -&gt; 存储表情相对于“Neutral
Face”的Offset，实现Additive Blending 即<strong>Morph Target
Animation</strong></li>
</ul>
<h5 id="morph-target-animation">Morph Target Animation</h5>
<h5 id="facial-skeleton">Facial Skeleton</h5>
<p>骨骼非常复杂
<img src="/images/games104/L09_FacialSkeleton.png" alt="L09_FacialSkeleton" style="zoom: 15%;" /></p>
<h5 id="uv-texture-facial-animation">UV Texture Facial Animation</h5>
<p>简单用贴图实现</p>
<h5 id="muscle-model-animation">Muscle Model Animation</h5>
<p>前沿研究，如果运动脸部肌肉（影视行业开始使用）
<img src="/images/games104/L09_MuscleModelAnimation.jpg" alt="L09_MuscleModelAnimation" style="zoom: 50%;" /></p>
<h4 id="animation-retargeting">Animation Retargeting</h4>
<h5 id="skeleton-retargeting">Skeleton Retargeting</h5>
<ul>
<li>把同一个骨骼动画应用到不同角色</li>
<li>Source Character + Target Character Source Animation + Target
Animation</li>
<li>两幅骨骼比例、位置不同 -&gt; 一一对应</li>
<li>保持Binding Pose的旋转，Retarget相对运动，而不是绝对运动</li>
<li>Translation和Scale动画：考虑Bone的长度之比，进行动画的放缩</li>
<li>问题：腿部不同长度时出现浮空
<ul>
<li>以Pelvis到地面的距离之比为放缩比例，对动画、移动速度做放缩</li>
<li>Foot IK</li>
</ul></li>
<li>离线方法完成</li>
<li>对不同骨骼结构的Retargeting
<ul>
<li>以骨骼名字做对应</li>
<li>把有对应骨骼之间的部分做归一化
<img src="/images/games104/L09_DifferentSkeletonRetargeting.gif" alt="L09_DifferentSkeletonRetargeting" style="zoom: 33%;" /></li>
</ul></li>
<li>问题：
<ul>
<li>角色的自穿插</li>
<li>有语义动作偏移带来语义偏移，例如鼓掌动画，Retargeting后掌合不起来</li>
</ul></li>
</ul>
<h5 id="morph-animation-retargeting">Morph Animation Retargeting</h5>
<p>eg. 表情动画 + 直接存储的是相对于Neutral
Face的相对位移，直接Apply到Target上 + 有语义动作 eg.
闭眼，眼睛大小不同时，直接Apply可能无法闭上 + 增加约束条件 eg.
闭眼动画限制眼睛必须闭上 +
手动调整，利用拉普拉斯算子计算，拉眼睑使相近脸部一起运动</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-13-GAMES104现代游戏引擎-Lecture8-Animation System - Basics</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-13-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture8-basicanimationsystem/</link>
      <pubDate>Fri, 13 May 2022 17:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-13-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture8-basicanimationsystem/</guid>
      <description>Lecture08 Animation System - Basics 挑战：
不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互 实时，计算和存储开销 真实感（表情、Ragdoll、Motion Matching …） 2D Animation Sprite Animation 逐帧绘制，循环播放 Sprite-like animation technique in pseudo-3D game 《Doom》 绘制各个视角的sprite，做伪3D Sprite Animation in Modern Game Live2D 把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴 仿射变换 图元的前后遮挡由深度决定 每一个图元有控制网格 Key frame 2D Skinned Animation 2D蒙皮动画 3D Animation DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation Pan/Yaw Tilt/Pitch Roll Rigid Hierarchical Animation 基于刚体的层次结构动画 “皮影戏” 直接连接Mesh，会导致Mesh互相产生穿插 Per-vertex Animation 旗帜、布料、流体等（从物理烘焙而来的顶点动画实现） VAT, Virtual Animation Texture：用贴图存储顶点 Morph Target Animation 顶点动画的变种 顶点带有权重，邻近顶点相互影响 3D Skinned Animation 2D蒙皮动画 （见下章） Physics-based Animation Ragdoll 布料和流体 IK, Inverse kinematics 反向动力学 Animation 创作方式 Key frame 动作捕捉 Skinned Animation Implementation 怎样将Mesh运动起来 创建一个绑定姿态的Mesh 创建绑定骨骼Skeleton 刷定点权重（蒙皮） 骨骼动画 顶点按骨骼动画和蒙皮权重运动 Different Spaces</description>
      <content:encoded><![CDATA[<h3 id="lecture08-animation-system---basics">Lecture08 Animation System
- Basics</h3>
<p>挑战：</p>
<ul>
<li>不能预设玩家的行为，考虑动画与Gameplay的互动，与环境的交互</li>
<li>实时，计算和存储开销</li>
<li>真实感（表情、Ragdoll、Motion Matching …）</li>
</ul>
<h4 id="d-animation">2D Animation</h4>
<h5 id="sprite-animation">Sprite Animation</h5>
<ul>
<li>逐帧绘制，循环播放</li>
<li>Sprite-like animation technique in pseudo-3D game
<ul>
<li>《Doom》 绘制各个视角的sprite，做伪3D</li>
</ul></li>
<li>Sprite Animation in Modern Game</li>
</ul>
<h5 id="live2d">Live2D</h5>
<ul>
<li>把角色/主体的每个元素作为独立图元 eg.眼睛、鼻子、嘴巴
<img src="/images/games104/L08_Live2D1.jpg" alt="L08_Live2D1" style="zoom: 50%;" /></li>
<li>仿射变换
<img src="/images/games104/L08_Live2D2.jpg" alt="L08_Live2D2" style="zoom: 67%;" /></li>
<li>图元的前后遮挡由深度决定</li>
<li>每一个图元有控制网格
<img src="/images/games104/L08_Live2D3.jpg" alt="L08_Live2D3" style="zoom: 50%;" /></li>
<li>Key frame</li>
</ul>
<h5 id="d-skinned-animation-2d蒙皮动画">2D Skinned Animation
2D蒙皮动画</h5>
<h4 id="d-animation-1">3D Animation</h4>
<blockquote>
<p>DoF, Degrees of Freedom 自由度 6DoF + Translation X Y Z + Rotation
Pan/Yaw Tilt/Pitch Roll
<img src="/images/games104/L08_DoF.jpg" alt="L08_DoF" style="zoom: 67%;" /></p>
</blockquote>
<h5 id="rigid-hierarchical-animation-基于刚体的层次结构动画">Rigid
Hierarchical Animation 基于刚体的层次结构动画</h5>
<ul>
<li>“皮影戏”</li>
<li>直接连接Mesh，会导致Mesh互相产生穿插</li>
</ul>
<h5 id="per-vertex-animation">Per-vertex Animation</h5>
<ul>
<li>旗帜、布料、流体等（从物理烘焙而来的顶点动画实现）</li>
<li>VAT, Virtual Animation Texture：用贴图存储顶点</li>
</ul>
<h5 id="morph-target-animation">Morph Target Animation</h5>
<ul>
<li>顶点动画的变种</li>
<li>顶点带有权重，邻近顶点相互影响</li>
</ul>
<h5 id="d-skinned-animation-2d蒙皮动画-见下章">3D Skinned Animation
2D蒙皮动画 （见下章）</h5>
<h5 id="physics-based-animation">Physics-based Animation</h5>
<ul>
<li>Ragdoll</li>
<li>布料和流体</li>
<li>IK, Inverse kinematics 反向动力学</li>
</ul>
<h5 id="animation-创作方式">Animation 创作方式</h5>
<ul>
<li>Key frame</li>
<li>动作捕捉</li>
</ul>
<h4 id="skinned-animation-implementation">Skinned Animation
Implementation</h4>
<h5 id="怎样将mesh运动起来">怎样将Mesh运动起来</h5>
<ul>
<li>创建一个绑定姿态的Mesh</li>
<li>创建绑定骨骼Skeleton</li>
<li>刷定点权重（蒙皮）</li>
<li>骨骼动画</li>
<li>顶点按骨骼动画和蒙皮权重运动</li>
</ul>
<blockquote>
<p><strong>Different Spaces</strong></p>
<ul>
<li><strong>Local Space</strong> 每一个骨骼节点</li>
<li>Model Space</li>
<li>World Space</li>
</ul>
</blockquote>
<h5 id="骨骼">骨骼</h5>
<ul>
<li><p>Humanoid 两足动物
<img src="/images/games104/L08_HumanoidSkeleton.jpg" alt="L08_HumanoidSkeleton" style="zoom: 50%;" /></p></li>
<li><p>Non-humanoid 四足动物
<img src="/images/games104/L08_Non-humanoidSkeleton.jpg" alt="L08_Non-humanoidSkeleton" style="zoom: 50%;" /></p></li>
<li><p>Joint 和 Bone 关节和骨段，存储/处理的是Joint
<img src="/images/games104/L08_JointVsBone.png" alt="L08_JointVsBone" style="zoom: 25%;" /></p></li>
<li><p>真实情况中的附加骨骼</p>
<ul>
<li>复杂的表情</li>
<li>披风、翅膀、武器等外饰</li>
<li>eg. 武器可能是单个Joint绑定在手上</li>
</ul></li>
<li><p>Root节点 一般在地面
<img src="/images/games104/L08_RootJoint1.png" alt="L08_RootJoint1" style="zoom: 25%;" /><img src="/images/games104/L08_RootJoint2.png" alt="L08_RootJoint2" style="zoom: 25%;" /></p></li>
<li><p>物体之间的骨骼Attach，骑马/开车等情况
<img src="/images/games104/L08_AttachJoint.png" alt="L08_AttachJoint" style="zoom: 15%;" /></p></li>
<li><p>绑定初始状态 T-Pose和A-Pose</p>
<ul>
<li>T-Pose肩部受到挤压，精度不够</li>
<li>目前大多采用A-Pose
<img src="/images/games104/L08_TA-Pose.png" alt="L08_TA-Pose" style="zoom: 25%;" /></li>
</ul></li>
<li><p>Pose：一个骨骼的状态</p>
<ul>
<li><p>Joint Pose (9DoF)</p>
<ul>
<li>Position</li>
<li>Orientation</li>
<li>Scale &gt; Math of 3D Rotation （略）</li>
</ul></li>
<li><p>Affine Matrix 仿射矩阵 <span class="math display">\[
M=R_{HM}T_{HM}S_{HM}=\begin{bmatrix}SR &amp; T\\0&amp;1\end{bmatrix}
\]</span></p></li>
<li><p>从Local Space到Model Space <span class="math display">\[
M_J^{\rm Model}=\prod_{j=J}^0 M_{p(J)}^{\rm Local}
\]</span></p></li>
<li><p>Interpolation
<img src="/images/games104/L08_JointInterpolation.png" alt="L08_JointInterpolation" style="zoom: 25%;" />
左：Local Space 右：Model Space 故在Local Space进行插值，再转换至Model
Space</p></li>
</ul></li>
</ul>
<h5 id="skin---蒙皮怎样运动">Skin - 蒙皮怎样运动</h5>
<ul>
<li><p><strong>Skinning Matrix</strong></p>
<ul>
<li><p><span class="math inline">\(V^{\rm Local}(t)\)</span>：顶点 <span
class="math inline">\(V\)</span> 在Local Space，<span
class="math inline">\(t\)</span> 时间的位置： <span
class="math display">\[
V^{\rm Local}(t)\equiv V_b^{\rm Local}=(M_{b(j)}^{\rm Model})^{-1}\cdot
V_b^{\rm Model}
\]</span>
<img src="/images/games104/L08_SkinningMatrix.jpg" alt="L08_SkinningMatrix" style="zoom: 33%;" /></p></li>
<li><p><span class="math inline">\(M_J^{\rm Model}(t)\)</span>：Joint
<span class="math inline">\(J\)</span> 在Model Space，<span
class="math inline">\(t\)</span> 时间的pose： <span
class="math display">\[
M_J^{\rm Model}(t)=\prod_{j=J}^0 M_{p(j)}^{\rm Local}(t)
\]</span></p></li>
<li><p><span class="math inline">\(V^{\rm Model}(t)\)</span>：顶点 <span
class="math inline">\(V\)</span> 在Model Space，<span
class="math inline">\(t\)</span> 时间的位置： <span
class="math display">\[
V^{\rm Model}(t)=M_J^{\rm Model}(t)\cdot V_J^{\rm Local}=M_J^{\rm
Model}(t)\cdot(M_{b(j)}^{\rm Model})^{-1}\cdot V_b^{\rm Model}
\]</span></p></li>
<li><p><strong>Skinning Matrix</strong> <span class="math display">\[
K_J=M_J^{\rm Model}(t)\cdot(M_{b(j)}^{\rm Model})^{-1}
\]</span></p></li>
</ul></li>
<li><p>Skinning Matrix Palette</p>
<ul>
<li><p>存储每个Joint的Skinning Matrix</p></li>
<li><p>Model Space to World Space <span class="math display">\[
K_J&#39;=M^{\rm World}\cdot M_J^{\rm Model}(t)\cdot(M_{b(j)}^{\rm
Model})^{-1}
\]</span> 存储该Skinning Matrix’</p></li>
<li><p>Bind Pose Matrix的逆需提前计算存储，以提高效率
<img src="/images/games104/L08_InverseBindPoseMatrix.jpg" alt="L08_InverseBindPoseMatrix" style="zoom: 50%;" /></p></li>
</ul></li>
<li><p><strong>Weighted Skinning with Multi-joints</strong></p>
<ul>
<li><p>加权平均（一般不超过4个），加权总和为1</p></li>
<li><p>Weighted Skinned Blend</p>
<ul>
<li><p>顶点 <span class="math inline">\(V\)</span> 关于Joint <span
class="math inline">\(J_i\)</span> 的Local Space to Model Space： <span
class="math display">\[
V_{J_i}^M(t)=K_{J_i}(t)\cdot V_{b_{J_i}}^M
\]</span></p></li>
<li><p>顶点 <span class="math inline">\(V\)</span> 在Model Space： <span
class="math display">\[
V^M(t)=\sum_{i=0}^{N-1}W_i\cdot V_{J_i}^M(t)
\]</span></p></li>
</ul></li>
</ul></li>
</ul>
<h5 id="clips-动画片段">Clips 动画片段</h5>
<ul>
<li><p>Interpolation</p>
<ul>
<li><p>LERP - Translation / Scale <span class="math display">\[
f(x)=(1-\alpha)f(x_1)+\alpha f(x_2)\\
\alpha=\dfrac{x-x_1}{x_2-x_1},\,x_1&lt;x_2,\,x\in[x_1,x_2];\quad
f(x):T(t),S(t)
\]</span></p></li>
<li><p>NLERP for Quaternion - Rotation
<img src="/images/games104/L08_LerpVsNLerp.png" alt="L08_LerpVsNLerp" style="zoom: 25%;" /></p>
<ul>
<li><p>Linear Interpolation <span class="math display">\[
q_t={\rm Lerp}(q_{t_1},q_{t_2},t)=(1-\alpha)q_{t_1}+\alpha q_{t_2}\\
\]</span></p></li>
<li><p>Normalization <span class="math display">\[
q_t&#39;={\rm NLerp}(q_{t_1},q_{t_2},t)=\dfrac{(1-\alpha)q_{t_1}+\alpha
q_{t_2}}{\|(1-\alpha)q_{t_1}+\alpha q_{t_2}\|}
\]</span></p></li>
<li><p>最短路径
<img src="/images/games104/L08_ShortestPath.png" alt="L08_ShortestPath" style="zoom: 33%;" /></p></li>
</ul></li>
<li><p>SLERP for Quaternion - Rotation</p>
<ul>
<li><p>NLERP在弦上插值，故旋转不均匀；SLERP在球面上插值，但开销较大</p></li>
<li><p><span class="math display">\[
q_t={\rm
SLerp}(q_{t_1},q_{t_2},t)=\dfrac{\sin((1-t)\theta)}{\sin\theta}\cdot
q_{t_1}+\dfrac{\sin(t\theta)}{\sin\theta}\cdot q_{t_2}\\
\theta=\arccos(q_{t_1}\cdot q_{t_2})
\]</span>
<img src="/images/games104/L08_SLERP.jpg" alt="L08_SLERP" style="zoom: 25%;" /></p></li>
<li><p>一般设置阈值，插值角度小，则NLerp，插值角度非常大时使用SLerp</p></li>
</ul></li>
</ul></li>
</ul>
<h5 id="simple-animation-runtime-pipeline">Simple Animation Runtime
Pipeline</h5>
<p><img src="/images/games104/L08_SimpleAnimationRuntimePipeline.png" alt="L08_SimpleAnimationRuntimePipeline" style="zoom: 33%;" /></p>
<h4 id="animation-compression">Animation Compression</h4>
<ul>
<li><p>大部分数据不变</p>
<ul>
<li>部分Joint整个固定</li>
<li>部分Joint的Translation/Rotation/Scale有部分保持不变（尤其是Translation和Scale）</li>
</ul></li>
<li><p>DoF Reduction 减少不变的自由度</p></li>
<li><p>Keyframe 记录关键帧，其他帧插值</p>
<ul>
<li><p>使用插值方法测试</p>
<ul>
<li>若插值结果与真实结果差异小于阈值，则不记录为关键帧</li>
<li>若插值结果与真实结果差异较大，则以真实结果为关键帧
<img src="/images/games104/L08_Keyframe1.jpg" alt="L08_Keyframe1" style="zoom: 80%;" />
<img src="/images/games104/L08_Keyframe2.png" alt="L08_Keyframe2" style="zoom: 33%;" /></li>
</ul></li>
<li><p>采用Catmull-Rom Spline插值 ——
比线性插值更平滑（开销大但这里不是Runtime） <span
class="math display">\[
P(t)=\begin{bmatrix}1&amp;t&amp;t^2&amp;t^3\end{bmatrix}
\begin{bmatrix}0&amp;1&amp;0&amp;0\\
-\alpha&amp;0&amp;\alpha&amp;0\\
2\alpha&amp;\alpha-3&amp;3-2\alpha&amp;-\alpha\\
-\alpha&amp;2-\alpha&amp;\alpha-2&amp;\alpha
\end{bmatrix}
\begin{bmatrix}P_0\\P_1\\P_2\\P_3\end{bmatrix}
\]</span>
<img src="/images/games104/L08_Catmull-RomSpline.png" alt="L08_Catmull-RomSpline" style="zoom: 33%;" /></p>
<ul>
<li>减少了关键帧</li>
</ul></li>
</ul></li>
<li><p>Float Quantization</p>
<ul>
<li>32bit浮点存储量大</li>
<li>将关键帧中数据的最小值、最大值mapping到 <span
class="math inline">\([0, 1]\)</span></li>
<li>所有数值mapping到16bit unsigned int来存储</li>
<li>四元数的特性： <span class="math display">\[
a^2+b^2+c^2+d^2=1,\,|a|\ge\max(|b|,|c|,|d|)\\
\Rightarrow b,c,d\in[-\frac{\sqrt 2}{2}, \frac{\sqrt 2}{2}]
\]</span> 因此，经验证四元数中除模最大的数 <span
class="math inline">\(a\)</span> 以外的三个数 <span
class="math inline">\(b,c,d\)</span>
可以用15bit精度表示，另有2bit表示哪个数最大；三个元共用48bit表示
<img src="/images/games104/L08_QuaternionQuantization.jpg" alt="L08_QuaternionQuantization" style="zoom: 67%;" /></li>
<li>经过压缩：
<img src="/images/games104/L08_SizeReduction.png" alt="L08_SizeReduction" style="zoom: 20%;" /></li>
</ul></li>
<li><p>误差传播
<img src="/images/games104/L08_ErrorPropagation.png" alt="L08_ErrorPropagation" style="zoom: 25%;" /></p>
<ul>
<li><p>结果会导致人物手部、手上武器等末端Joint发生抖动</p></li>
<li><p>特殊情况需要高精度存储</p>
<ul>
<li>最简单的判定方法 —— 直接给误差设定阈值</li>
<li>Visual Error 视觉误差
<ul>
<li>为Joint在两个垂直方向设定两个Fake Vertex，计算运动后Fake
Vertex的距离
<img src="/images/games104/L08_FakeVertex.png" alt="L08_FakeVertex" style="zoom: 25%;" /></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>误差补偿</p>
<ul>
<li>处理方法：
<ul>
<li>除Root外，每根bone上选一个点</li>
<li>计算每根压缩后的bone的旋转，使标记点在Model Space中接近实际位置</li>
<li>增加一个旋转来补偿误差
<img src="/images/games104/L08_ErrorCompensation.png" alt="L08_ErrorCompensation" style="zoom: 25%;" /></li>
</ul></li>
<li>问题：末端骨骼的信息变成高频</li>
<li>更新的方法：FIK, Forward Inverse Kinematics</li>
</ul></li>
</ul>
<h4 id="animation-dcc">Animation DCC</h4>
<ul>
<li>Mesh
<ul>
<li>关节处Mesh更细分</li>
</ul></li>
<li>Skeleton Binding 骨骼绑定
<ul>
<li>DCC的基础骨架</li>
<li>增加武器等Gameplay中特殊的Joint</li>
</ul></li>
<li>Skinning 蒙皮，刷权重
<ul>
<li>自动计算 —— 结果会像橡皮</li>
<li>手动部分校正权重</li>
</ul></li>
<li>设计关键帧动画</li>
<li>Root要保持在Model Space中不变</li>
<li>FBX File</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-05-03-GAMES104现代游戏引擎-Lecture7-Rendering Pipeline, Post-Process and Everything</title>
      <link>https://elderlyaugustus.github.io/posts/2022-05-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture7-postprocessingandothers/</link>
      <pubDate>Mon, 03 May 2021 11:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-05-03-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture7-postprocessingandothers/</guid>
      <description>Lecture07 Rendering Pipeline, Post-Process and Everything Ambient Occlusion 接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。
AO：单目视觉中形成3D感的重要元素
不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。
Precomputed AO 使用Ray Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。
效果好，计算复杂，且无法处理多物体之间的AO。
SSAO, Screen Space AO @GAMES202 SSAO
HBAO, Horizon-based Ambient Occlusion 在法线方向半球空间内积分 \[ A=1-\dfrac{1}{2\pi}\int_{\theta=-\pi}^\pi\int_{\alpha=t(\theta)}^h(\theta)W(\vec\omega)\cos\alpha\,\mathrm d\alpha\mathrm d\theta \] 利用深度图做Ray Marching GTAO, Ground Truth - based AO SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)
\[ \hat A(x)=\dfrac{1}{\pi}\int_0^\pi\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\,\mathrm d\theta\mathrm d\phi\\\gamma={\rm angle}(\vec n, \vec v) \]
根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO
Ray-Tracing AO @GAMES202 RTRT
Fog Depth Fog 随着深度透明度下降
Linear fog: factor = (end-z) / (end - start) Exp fog: factor = exp(- density * z) Exp Squared fog: factor = exp(- (density * z) ^ 2) Height Fog 设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减</description>
      <content:encoded><![CDATA[<h3
id="lecture07-rendering-pipeline-post-process-and-everything">Lecture07
Rendering Pipeline, Post-Process and Everything</h3>
<h4 id="ambient-occlusion">Ambient Occlusion</h4>
<p>接触阴影，满足渲染方程，但在渲染过程中直接渲染很难做到，因为计算尺度小（称为中尺度）。</p>
<blockquote>
<p>AO：单目视觉中形成3D感的重要元素</p>
</blockquote>
<p><img src="/images/games104/L07_AO.png" alt="L07_AO" style="zoom: 33%;" /></p>
<p>不考虑尺度差异，AO和BRDF中的Geometry项（Shadowing-Masking）非常相似。</p>
<h5 id="precomputed-ao">Precomputed AO</h5>
<p>使用Ray
Tracing预计算成AO贴图。最为传统，但目前在角色等高精度需求中仍应用广泛。</p>
<p>效果好，计算复杂，且无法处理多物体之间的AO。</p>
<h5 id="ssao-screen-space-ao">SSAO, Screen Space AO</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
SSAO</p>
<h5 id="hbao-horizon-based-ambient-occlusion">HBAO, Horizon-based
Ambient Occlusion</h5>
<ul>
<li><p>在法线方向半球空间内积分 <span class="math display">\[
A=1-\dfrac{1}{2\pi}\int_{\theta=-\pi}^\pi\int_{\alpha=t(\theta)}^h(\theta)W(\vec\omega)\cos\alpha\,\mathrm
d\alpha\mathrm d\theta
\]</span>
<img src="/images/games104/L07_HBAO2.jpg" alt="L07_HBAO2" style="zoom:30%;" /><img src="/images/games104/L07_HBAO1.jpg" alt="L07_HBAO1" style="zoom:23%;" /></p></li>
<li><p>利用深度图做Ray Marching
<img src="/images/games104/L07_HBAO3.png" alt="L07_HBAO3" style="zoom: 50%;" /></p></li>
</ul>
<h5 id="gtao-ground-truth---based-ao">GTAO, Ground Truth - based AO</h5>
<p>SSAO和HBAO假定了各方向射入的光贡献相同，因此物理上错误。(法线方向照射来的光贡献更多。)</p>
<ul>
<li><p><img src="/images/games104/L07_GTAO.jpg" alt="L07_GTAO" style="zoom: 50%;" />
<span class="math display">\[
\hat
A(x)=\dfrac{1}{\pi}\int_0^\pi\int_{\theta_1(\phi)}^{\theta_2(\phi)}\cos(\theta-\gamma)^+|\sin(\theta)|\,\mathrm
d\theta\mathrm d\phi\\\gamma={\rm angle}(\vec n, \vec v)
\]</span></p></li>
<li><p>根据大量的AO数据，拟合了一个三阶多项式，实现了有颜色的AO</p></li>
</ul>
<h5 id="ray-tracing-ao">Ray-Tracing AO</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
RTRT</p>
<h4 id="fog">Fog</h4>
<h5 id="depth-fog">Depth Fog</h5>
<p>随着深度透明度下降</p>
<ul>
<li>Linear fog: <code>factor = (end-z) / (end - start)</code></li>
<li>Exp fog: <code>factor = exp(- density * z)</code></li>
<li>Exp Squared fog: <code>factor = exp(- (density * z) ^ 2)</code></li>
</ul>
<p><img src="/images/games104/L07_DepthFog.png" alt="L07_DepthFog" style="zoom: 50%;" /></p>
<h5 id="height-fog">Height Fog</h5>
<p>设定某一高度阈值，阈值以下恒定Fog强度，阈值以上指数递减</p>
<ul>
<li><p>观察方向的Height Fog积分 <span class="math display">\[
\begin{array}{c}D(h)=D_\max\cdot e^{-\sigma\cdot\max(h-H_s, 0)}\\
\begin{aligned}{\rm FogDensityIntegration}=&amp;\ D_\max\cdot d\int_0^1
e^{-\sigma\cdot\max(v_z+t\cdot d_z-H_s, 0)}\,\mathrm dt\\=&amp;\
D_\max\cdot de^{-\sigma\cdot\max(v_z-H_s, 0)}\dfrac{1-e^{-\sigma\cdot
d_z}}{\sigma\cdot d_z}
\end{aligned}\end{array}
\]</span>
<img src="/images/games104/L07_HeightFog.png" alt="L07_HeightFog" style="zoom: 33%;" /></p></li>
<li><p>Fog颜色 <span class="math display">\[
{\rm FogInscatter}=1-\exp^{- \rm FogDensityIntegration}\\
{\rm FinalColor} = {\rm FogColor}\cdot{\rm FogInscatter}
\]</span></p></li>
</ul>
<h5 id="voxel-based-volumetric-fog">Voxel-based Volumetric Fog</h5>
<p>现代的雾效，可以实现丁达尔效应</p>
<ul>
<li>对整个相机空间Voxelize，以不同大小的四棱台作Voxel
<img src="/images/games104/L07_VoxelFog1.jpg" alt="L07_VoxelFog1" style="zoom: 67%;" /></li>
<li>计算方法与Atmosphere计算相似</li>
<li>用一个3D Texture存储，长宽尽量与屏幕成整数倍（eg. 160*90）</li>
</ul>
<h4 id="anti-aliasing">Anti-aliasing</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> AA</p>
<p>三种走样：Edge Sampling, Texture Sampling（MIPMAP可解决）, Specular
Sampling</p>
<h4 id="post-process">Post-process</h4>
<h5 id="bloom-光晕">Bloom 光晕</h5>
<ul>
<li>检测提取高光区域（计算灰度，比较阈值）</li>
<li>对高光区域作Gaussian Blur（横向/纵向各一轮减少计算） -&gt;
<strong>Pyramid Gaussian Blur</strong>
<img src="/images/games104/L07_PyramidGuassianBlur.png" alt="L07_PyramidGuassianBlur" style="zoom: 33%;" /></li>
<li>将模糊完的图像叠加到图像上</li>
</ul>
<h5 id="tone-mapping">Tone Mapping</h5>
<p>HDR to SDR</p>
<ul>
<li>flimic s-curve
<img src="/images/games104/L07_Filmic.png" alt="L07_Filmic" style="zoom: 33%;" /></li>
<li>ACES</li>
</ul>
<h5 id="color-grading">Color Grading</h5>
<ul>
<li>LUT</li>
</ul>
<blockquote>
<p>Tone Mapping and Color Grading is my area hhhhh (at DFTT of BFA)</p>
</blockquote>
<h4 id="rendering-pipeline">Rendering Pipeline</h4>
<h5 id="forward-rendering">Forward Rendering</h5>
<ul>
<li>Shadow Pass -&gt; Shading -&gt; Post-process</li>
<li>逐物体绘制</li>
<li>透明材质排序，由远及近绘制 -&gt; 各种问题</li>
<li>多光源绘制复杂</li>
</ul>
<h5 id="deferred-rendering">Deferred Rendering</h5>
<ul>
<li><p>Pass 1</p>
<pre class="pseudocode"><code>for each object:
  write G-Buffer;</code></pre></li>
<li><p>Pass 2</p>
<pre class="pseudocode"><code>for each pixel:
  gbuffer = readGBuffer(G-Buffer);
  for each light:
      computeShading(gbuffer, light);</code></pre></li>
</ul>
<h5 id="tiled-based-rendering">Tiled-based Rendering</h5>
<ul>
<li><p>移动端读写能耗大</p></li>
<li><p>切成小块，小块渲染、小块读写</p></li>
<li><p>光源也可以被切割成Tile</p></li>
<li><p>深度上也可对光源优化</p></li>
<li><h5 id="tiled-deferred-rendering">Tiled Deferred Rendering</h5></li>
<li><h5 id="forward-tiled-forward-rendering">Forward+ (Tiled Forward)
Rendering</h5></li>
</ul>
<h5 id="cluster-based-rendering">Cluster-based Rendering</h5>
<p><img src="/images/games104/L07_ClusterBasedRendering.png" alt="L07_ClusterBasedRendering" style="zoom: 50%;" /></p>
<h5 id="visibility-buffer">Visibility Buffer</h5>
<ul>
<li>V-Buffer
<ul>
<li>Depth</li>
<li>PrimitiveID</li>
<li>Barycentrics</li>
</ul></li>
<li><img src="/images/games104/L07_VisibilityBuffer.jpg" alt="L07_VisibilityBuffer" style="zoom: 67%;" /></li>
</ul>
<blockquote>
<p><strong>Unreal Engine Rendering Pipeline</strong> <img
src="/images/games104/L07_UnrealRenderingPipeline.png"
alt="L07_UnrealRenderingPipeline" /></p>
</blockquote>
<h5 id="v-sync-freesync-vrr">V-Sync / FreeSync / VRR</h5>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-30-GAMES104现代游戏引擎-Lecture6.2-Sky and Atmosphere</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-30-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.2-atmospherecloud/</link>
      <pubDate>Fri, 30 Apr 2021 14:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-30-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.2-atmospherecloud/</guid>
      <description>Lecture06-2 Sky and Atmosphere Atmosphere 大气 Analytic Atmosphere Appearance Modeling 不必按照物理模拟，根据观察找模型拟合
两个参数
观察向量与垂直向上向量的夹角 \(\theta\) 观察向量与太阳方向的夹角 \(\gamma\) \[ \mathbb{F}(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})\cdot(C+De^{E\gamma}+F\cos^2\gamma+G\cdot\chi(H,\gamma)+I\cdot\cos^{\frac{1}{2}}\theta)\\ L_\lambda = \mathbb{F}(\theta,\gamma)\cdot L_{M\lambda} \]
优势：简单快捷，直接代入计算即可
劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气
Participating Media 物理属性 大气中：空气、气溶胶，形成各种折射和反射
光在Participating Media中：
Absorption 吸收 \[ \dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm x}=-\sigma_\alpha\cdot L(\mathrm x,\omega)\\ \sigma_\alpha:\text{Absorption Coeffcient} \]
Out-scattering 对外散射 \[ -\sigma_sL(\mathrm x,\omega)\\ \sigma_s:\text{Scattering Coeffcient} \]
Emission 自发光（火焰、辉光等） \[ \sigma_\alpha L_e(\mathrm x,\omega) \]
In-Scattering 对内散射 接收周围分子的Out-Scattering \[ \sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&amp;#39;)L(\mathrm x,\omega&amp;#39;)\,\mathrm d\omega&amp;#39;\\ f_p(\mathrm x,\omega,\omega&amp;#39;):\text{Phase Function} \]</description>
      <content:encoded><![CDATA[<h3 id="lecture06-2-sky-and-atmosphere">Lecture06-2 Sky and
Atmosphere</h3>
<h4 id="atmosphere-大气">Atmosphere 大气</h4>
<h5 id="analytic-atmosphere-appearance-modeling">Analytic Atmosphere
Appearance Modeling</h5>
<ul>
<li><p>不必按照物理模拟，根据观察找模型拟合</p></li>
<li><p>两个参数</p>
<ul>
<li>观察向量与垂直向上向量的夹角 <span
class="math inline">\(\theta\)</span></li>
<li>观察向量与太阳方向的夹角 <span
class="math inline">\(\gamma\)</span></li>
</ul>
<p><img src="/images/games104/L06_AtmosphereAngles.jpg" alt="L06_AtmosphereAngles" style="zoom: 50%;" /></p></li>
<li><p><span class="math display">\[
\mathbb{F}(\theta,\gamma)=(1+Ae^{\frac{B}{\cos\theta+0.01}})\cdot(C+De^{E\gamma}+F\cos^2\gamma+G\cdot\chi(H,\gamma)+I\cdot\cos^{\frac{1}{2}}\theta)\\
L_\lambda = \mathbb{F}(\theta,\gamma)\cdot L_{M\lambda}
\]</span></p></li>
<li><p>优势：简单快捷，直接代入计算即可</p></li>
<li><p>劣势：只能在地表观察，无法完成空中观察视角；参数固定，无法完成各种天气</p></li>
</ul>
<h5 id="participating-media">Participating Media</h5>
<h6 id="物理属性">物理属性</h6>
<ul>
<li><p>大气中：空气、气溶胶，形成各种折射和反射</p></li>
<li><p>光在Participating Media中：</p>
<ul>
<li><p><strong>Absorption 吸收</strong> <span class="math display">\[
\dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm
x}=-\sigma_\alpha\cdot L(\mathrm x,\omega)\\
\sigma_\alpha:\text{Absorption Coeffcient}
\]</span></p></li>
<li><p><strong>Out-scattering 对外散射</strong> <span
class="math display">\[
-\sigma_sL(\mathrm x,\omega)\\
\sigma_s:\text{Scattering Coeffcient}
\]</span></p></li>
<li><p><strong>Emission 自发光（火焰、辉光等）</strong> <span
class="math display">\[
\sigma_\alpha L_e(\mathrm x,\omega)
\]</span></p></li>
<li><p><strong>In-Scattering 对内散射</strong>
接收周围分子的Out-Scattering <span class="math display">\[
\sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&#39;)L(\mathrm
x,\omega&#39;)\,\mathrm d\omega&#39;\\
f_p(\mathrm x,\omega,\omega&#39;):\text{Phase Function}
\]</span></p></li>
</ul></li>
<li><p><strong>Radiative Transfer Equation, RTE</strong> <span
class="math display">\[
\sigma_t(\mathrm x)=\sigma_\alpha(\mathrm x)+\sigma_s(\mathrm x)\\
\dfrac{\mathrm dL(\mathrm x,\omega)}{\mathrm d\mathrm x}=-\sigma_t\cdot
L(\mathrm x,\omega)+\sigma_\alpha L_e(\mathrm
x,\omega)+\sigma_s\int_{S^2}f_p(\mathrm x,\omega,\omega&#39;)L(\mathrm
x,\omega&#39;)\,\mathrm d\omega&#39;
\]</span></p></li>
<li><p><strong>Volume Rendering Equation, VRE</strong>
<img src="/images/games104/L06_VRE.png" alt="L06_VRE" style="zoom: 25%;" />
对RTE梯度的路径积分 <span class="math display">\[
L(P,\omega)=\int_{\mathrm x=0}^\mathrm d T(\mathrm x)[\sigma_\alpha\cdot
L_e(\mathrm x,\omega)+\sigma_s\cdot L_i(\mathrm x,\omega)]\,\mathrm
d\mathrm x + T(M)L(M,\omega)\\
T(\mathrm x)=e^{-\int_\mathrm x ^P\sigma_t(s)\,\mathrm d s}\\
L_i(\mathrm x,\omega)=\int_{S^2}f_p(\mathrm
x,\omega,\omega&#39;)L(\mathrm x,\omega&#39;)\,\mathrm d\omega&#39;
\]</span></p>
<p>两个关键部分</p>
<ul>
<li>Transmitters：远处物体有多少能透视到眼睛</li>
<li>光打到空气中的散射、折射后，沿观察方向的光路有多少能进入眼睛</li>
</ul></li>
<li><p><strong>Rayleigh Scattering 瑞利散射</strong>
空气中介质尺寸远小于光的波长时，光形成较为均匀的散射；波长越短（蓝紫色）散射越强，波长越长（红色）散射越弱</p>
<p><img src="/images/games104/L06_RayleighScatteringDistribution.jpg" alt="L06_RayleighScatteringDistribution" style="zoom: 80%;" />
<span class="math display">\[
S(\lambda,\theta,h)=\dfrac{\pi^2(n^2-1)}{2}\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1}{\lambda^4}\cdot(1+\cos^2\theta)\\
\lambda\,\text{波长}\ h\,\text{海拔高度}\ N\,\text{标准大气压}\
\theta\,\text{观察方向与光传播方向夹角}
\]</span> 左半边固定，只需求右半边Phase Function部分</p>
<ul>
<li>Scattering Coefficient <span
class="math inline">\(\sigma_s^\text{Rayleigh}(\lambda,h)=\dfrac{8\pi^3(n^2-1)}{3}\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1}{\lambda^4}\)</span></li>
<li>Phase Function 腰果形函数 <span
class="math inline">\(F_\text{Rayleigh}(\theta)=\dfrac{3}{16\pi}(1+\cos^2\theta)\)</span></li>
</ul></li>
<li><p><strong>Mie Scattering 米氏散射</strong>
主要针对气溶胶，介质尺寸接近或大于光的波长时，光形成有一定方向性的散射、沿着光的方向较强；但对波长不敏感</p>
<p><img src="/images/games104/L06_MieScatteringDistribution.jpg" alt="L06_MieScatteringDistribution" style="zoom: 80%;" />
<span class="math display">\[
S(\lambda,\theta,h)=\pi^2(n^2-1)\cdot\dfrac{\rho(h)}{N}\cdot\dfrac{1-g}{2+g^2}\cdot\dfrac{(1+\cos^2\theta)}{(1-g^2-2g\cos\theta)^\frac{3}{2}}\\
g\,\text{几何参数，一般由艺术家控制}
\]</span></p>
<ul>
<li>Scattering Coefficient <span
class="math inline">\(\sigma_s^\text{Mie}(\lambda,h)=\dfrac{8\pi^3(n^2-1)}{3}\cdot\dfrac{\rho(h)}{N}\)</span></li>
<li>Phase Function <span
class="math inline">\(F_\text{Mie}(\theta)=\dfrac{3}{8\pi}\cdot\dfrac{1-g}{2+g^2}\cdot\dfrac{(1+\cos^2\theta)}{(1-g^2-2g\cos\theta)^\frac{3}{2}}\)</span></li>
<li><span class="math inline">\(g=0\)</span>
时，退化成与瑞利散射分布相同的形状（类似花生豆）； <span
class="math inline">\(g&gt;0\)</span> 时，沿米氏散射方向更多 <span
class="math inline">\(g&lt;0\)</span> 时，反向更多</li>
</ul>
<blockquote>
<p>eg. 雾：即一种气溶胶，对太阳光不同波长无差别散射，故呈白色</p>
<p>eg. 日晕也是米氏散射带来的</p>
</blockquote></li>
<li><p><strong>光的吸收</strong></p>
<ul>
<li>臭氧吸收长波，红橙黄；甲烷吸收红光</li>
<li>假设：臭氧和甲烷均匀分布在大气中</li>
</ul></li>
<li><p><strong>单次散射和多次散射 Single Scattering &amp; Multiple
Scattering</strong></p>
<p><img src="/images/games104/L06_SingleScatteringMultiScattering.jpg" alt="L06_SingleScatteringMultiScattering" style="zoom:67%;" /></p>
<ul>
<li><p>Single Scattering <span class="math display">\[
L_1=\int_A^BL_{P\to A}\,\mathrm ds
\]</span></p></li>
<li><p>Multiple Scattering <span class="math display">\[
L_{n+1}=\int_A^B\int_{4\pi}L_n(P,v&#39;)\cdot S(\lambda,\theta,h)\cdot
T(P\to A)\,\mathrm dv&#39;\mathrm ds
\]</span></p></li>
<li><p>Single Scattering的背阳面呈现死黑，Multi Scattering有亮度
<img src="/images/games104/L06_SingleScatteringMultiScatteringComparison.png" alt="L06_SingleScatteringMultiScatteringComparison" style="zoom: 25%;" /></p></li>
</ul></li>
</ul>
<h6 id="解决方法">解决方法</h6>
<ul>
<li><p>Ray Marching：沿着观察视线，一步一步积分</p></li>
<li><p><strong>Precomputed Atmospheric Scattering</strong></p>
<ul>
<li>把大气散射用Ray Marching预计算成 <span
class="math inline">\(\cos\theta\)</span> 和 <span
class="math inline">\(h\)</span> 为维度的LUT，计算时直接查表（<span
class="math inline">\(\theta\)</span>
为观察视角与垂直向上方向夹角）</li>
<li>大气散射的两个部分：通透度Transmittance、散射度Scattering</li>
<li><strong>通透度 Transmittance</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringT.png" alt="L06_PrecomputedAtmosphericScatteringT" style="zoom: 25%;" />
<ul>
<li>预计算 <span class="math inline">\(T(\mathrm x)=e^{-\int_\mathrm
x^P\sigma_t(s)\,\mathrm ds}\)</span></li>
<li>查表 <span class="math inline">\(T(\mathrm x_\mathrm v\to \mathrm
x_\mathrm m)=\dfrac{T(\mathrm x_\mathrm v\to B)}{T(\mathrm x_\mathrm
m\to B)}\)</span></li>
<li>二维LUT</li>
</ul></li>
<li><strong>Single Scattering</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringSingleScattering.png" alt="L06_PrecomputedAtmosphericScatteringSingleScattering" style="zoom:25%;" />
<ul>
<li>预计算 <span
class="math inline">\(L_\text{sun}\displaystyle\int_A^BS(\lambda,\theta,h)\cdot(T(\text{sun}\to
P)+T(P\to A))\,\mathrm ds\)</span></li>
<li>查表 <span class="math inline">\(L(\mathrm x_\mathrm v\to \mathrm
x_\mathrm m)=L(\mathrm x_\mathrm v\to B)-L(\mathrm x_\mathrm m\to
B)\cdot T(\mathrm x_\mathrm v\to \mathrm x_\mathrm m)\)</span></li>
<li>四维LUT，但数值平滑，可以低精度插值，用Virtual
Texture放在一张图上</li>
</ul></li>
<li><strong>Multi Scattering</strong>
<img src="/images/games104/L06_PrecomputedAtmosphericScatteringMultiScattering.png" alt="L06_PrecomputedAtmosphericScatteringMultiScattering" style="zoom:25%;" />
<ul>
<li>利用前面两张LUT，积分预计算得Multi Scattering
LUT（一般计算3-4次结果即可）</li>
</ul></li>
<li>问题
<ul>
<li>预计算开销大</li>
<li>天气变化时难以均匀过渡</li>
<li>查表插值计算开销也不够小</li>
</ul></li>
</ul></li>
<li><p><a
href="https://diglib.eg.org/bitstream/handle/10.1111/cgf14050/v39i4pp013-022.pdf">A
Scalable and Production Ready Sky and Atmosphere Rendering
Technique</a></p>
<p>核心思想：</p>
<ul>
<li><p>假设：对于空气中的一个分子，来自各个方向的散射是等同的</p>
<p>问题转换为能量衰减问题，每次衰减百分之多少，Multi
Scattering计算衰减百分比的级数求和即可</p></li>
<li><p>取消海拔高度和太阳位置两个参数，不计算全部情况；只保留天顶角和环方向角两个维度</p></li>
<li><p>Ray marching预计算LUT</p></li>
</ul>
<p>不物理正确，但效率高、效果好，符合艺术家需要</p></li>
</ul>
<h4 id="cloud-云">Cloud 云</h4>
<p>云的种类：层云、积云、卷云</p>
<p><img src="/images/games104/L06_Clouds.jpg" alt="L06_Clouds" style="zoom:50%;" /></p>
<p>早期：Mesh、Billboard 片状贴图</p>
<h5 id="volumetric-cloud-modeling">Volumetric Cloud Modeling</h5>
<ul>
<li><p>优势：全动态，runtime生成 劣势：算法复杂开销大</p></li>
<li><p><strong>Weather Texture</strong>
<img src="/images/games104/L06_WeatherTexture.jpg" alt="L06_WeatherTexture" style="zoom: 67%;" /></p>
<ul>
<li><p>是否有值表示云的分布 0-1值表示当前位置云的厚度</p></li>
<li><p>云的运动：Texture位移、扰动</p></li>
</ul></li>
<li><p>Noise Function</p>
<ul>
<li>Perlin Noise
<img src="/images/games104/L06_PerlinNoise.png" alt="L06_PerlinNoise" style="zoom:33%;" /></li>
<li>Worley Noise
<img src="/images/games104/L06_WorleyNoise.png" alt="L06_WorleyNoise" style="zoom:33%;" /></li>
</ul></li>
<li><ol type="1">
<li>先用Weather Texture生成柱状图</li>
<li>再用低频Noise Map腐蚀</li>
<li>最后加以高频Noise Map增加细节</li>
</ol>
<p><img src="/images/games104/L06_CloudDensityModel.png" alt="L06_CloudDensityModel" style="zoom:33%;" /></p></li>
<li><p>Ray Marching渲染云</p>
<p><img src="/images/games104/L06_CloudRendering.png" alt="L06_CloudRendering" style="zoom:33%;" /></p></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-28-GAMES104现代游戏引擎-Lecture6.1-Terrain Rendering</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-28-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.1-terrain/</link>
      <pubDate>Wed, 28 Apr 2021 15:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-28-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture6.1-terrain/</guid>
      <description>Lecture06 Rendering of Mother Nature Lecture06-1 Terrain Rendering 地形渲染 Simple Idea - Heightfield Height Map Contour Map
符合分形原则 渲染 均匀网格，依据Heightfield位移每一个顶点 问题：世界过大时过于复杂
解决方法：LoD -&amp;gt; 非均匀网格 -&amp;gt; 保证场景连续，保证LoD过渡均匀 Adaptive Mesh Tessellation
优化原则
依据Distance to Camera和FoV做LoD Error Bound：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小） Tessellation Triangle-Based Subdivision 在等腰直角三角形的长边切割 -&amp;gt; 得到两个新的等腰直角三角形 二叉树结构，因此又称Binary Triangle-Based Subdivision T-Junctions 解决方法：判断若邻边切分更密，则当前边也需同样进行切分 实际应用中不广泛 QuadTree-Based Subdivision 四叉树分割 优势 易于建构 易于管理几何分区数据，Objects Culling和Data Streaming 符合Texture存储规范 劣势 Mesh细分没有三角形细分灵活 叶子节点的网格层级锁定 符合直觉，应用主流 T-Junctions 与三角形分割类似的问题，细分层级边界处产生 解决方法：Stitching 吸附 吸附生成的三角形：退化三角形 Triangulated Irregular Network (TIN) 几何细节不丰富处，用较粗的三角形 优势 易于Runtime渲染 更少的三角形 劣势 需要预计算 不够通用 特殊的游戏会用 GPU-Based Tessellation DX11开始： Hull-Shader Stage：生成Subdivision用的Patch，告诉Control point数据和Tessellation数量 Tessellator Stage：做Tessellation Domain-Shader Stage：根据高度图移动顶点 Geometry Shader Stage：算Vertex Mesh Shader Pipeline (DX12) GPU-Based Tessellation -&amp;gt; Runtime Tessellation -&amp;gt; Real-Time Deformable Terrain 假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation</description>
      <content:encoded><![CDATA[<h2 id="lecture06-rendering-of-mother-nature">Lecture06 Rendering of
Mother Nature</h2>
<h3 id="lecture06-1-terrain-rendering-地形渲染">Lecture06-1 Terrain
Rendering 地形渲染</h3>
<h4 id="simple-idea---heightfield">Simple Idea - Heightfield</h4>
<p>Height
Map<img src="/images/games104/L06_HeightMap.jpg" alt="L06_HeightMap" style="zoom:22.5%;" />
Contour
Map<img src="/images/games104/L06_ContourMap.jpg" alt="L06_ContourMap" style="zoom:15%;" /></p>
<ul>
<li>符合分形原则</li>
<li>渲染
<ul>
<li><p>均匀网格，依据Heightfield位移每一个顶点
问题：世界过大时过于复杂</p></li>
<li><p>解决方法：LoD -&gt; 非均匀网格 -&gt;
保证场景连续，保证LoD过渡均匀 <strong>Adaptive Mesh
Tessellation</strong></p>
<p><img src="/images/games104/L06_AdaptiveMeshTessellation.jpg" alt="L06_AdaptiveMeshTessellation" style="zoom: 33%;" /></p></li>
<li><p>优化原则</p>
<ul>
<li>依据Distance to Camera和FoV做LoD</li>
<li><strong>Error
Bound</strong>：简化后的误差小于阈值（一般为呈现在屏幕上一个像素大小）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="tessellation">Tessellation</h4>
<h5 id="triangle-based-subdivision">Triangle-Based Subdivision</h5>
<p><img src="/images/games104/L06_TriangleBasedSubdivision.jpg" alt="L06_TriangleBasedSubdivision" style="zoom: 33%;" /></p>
<ul>
<li>在等腰直角三角形的长边切割 -&gt; 得到两个新的等腰直角三角形
<img src="/images/games104/L06_TriangleBasedSubdivisionLevels.jpg" alt="L06_TriangleBasedSubdivisionLevels" style="zoom:30%;" /></li>
<li>二叉树结构，因此又称<strong>Binary Triangle-Based
Subdivision</strong></li>
<li><strong>T-Junctions</strong>
<img src="/images/games104/L06_T-Junction.jpg" alt="L06_T-Junction" style="zoom: 20%;" />
解决方法：判断若邻边切分更密，则当前边也需同样进行切分
<img src="/images/games104/L06_T-JunctionSolution.jpg" alt="L06_T-JunctionSolution" style="zoom: 50%;" /></li>
<li>实际应用中不广泛</li>
</ul>
<h5 id="quadtree-based-subdivision-四叉树分割">QuadTree-Based
Subdivision 四叉树分割</h5>
<p><img src="/images/games104/L06_QuadTreeBasedSubdivision.jpg" alt="L06_QuadTreeBasedSubdivision" style="zoom: 33%;" /></p>
<ul>
<li>优势
<ul>
<li>易于建构</li>
<li>易于管理几何分区数据，Objects Culling和Data Streaming</li>
<li>符合Texture存储规范</li>
</ul></li>
<li>劣势
<ul>
<li>Mesh细分没有三角形细分灵活</li>
<li>叶子节点的网格层级锁定</li>
</ul></li>
<li>符合直觉，应用主流
<img src="/images/games104/L06_QuadTreeTerrain.png" alt="L06_QuadTreeTerrain" style="zoom:25%;" /></li>
<li><strong>T-Junctions</strong>
<ul>
<li>与三角形分割类似的问题，细分层级边界处产生</li>
<li>解决方法：<strong>Stitching 吸附</strong>
<img src="/images/games104/L06_Stitching.png" alt="L06_Stitching" style="zoom: 25%;" />
吸附生成的三角形：<strong>退化三角形</strong></li>
</ul></li>
<li><strong>Triangulated Irregular Network (TIN)</strong>
<img src="/images/games104/L06_TIN.jpg" alt="L06_TIN" style="zoom:33%;" />
<ul>
<li>几何细节不丰富处，用较粗的三角形</li>
<li>优势
<ul>
<li>易于Runtime渲染</li>
<li>更少的三角形</li>
</ul></li>
<li>劣势
<ul>
<li>需要预计算</li>
<li>不够通用</li>
</ul></li>
<li>特殊的游戏会用</li>
</ul></li>
</ul>
<h5 id="gpu-based-tessellation">GPU-Based Tessellation</h5>
<ul>
<li><p>DX11开始：
<img src="/images/games104/L06_GPUBasedTessllation.jpg" alt="L06_GPUBasedTessllation" style="zoom: 33%;" /></p>
<ul>
<li>Hull-Shader Stage：生成Subdivision用的Patch，告诉Control
point数据和Tessellation数量</li>
<li>Tessellator Stage：做Tessellation</li>
<li>Domain-Shader Stage：根据高度图移动顶点</li>
<li>Geometry Shader Stage：算Vertex
<img src="/images/games104/L06_DX11TerrainShaders.png" alt="L06_DX11TerrainShaders" style="zoom: 50%;" /></li>
</ul></li>
<li><p><strong>Mesh Shader Pipeline</strong> (DX12)
<img src="/images/games104/L06_MeshShaderPipeline.jpg" alt="L06_MeshShaderPipeline" style="zoom: 80%;" /></p></li>
<li><p>GPU-Based Tessellation -&gt; Runtime Tessellation -&gt;
<strong>Real-Time Deformable Terrain</strong>
假定地面上每一个Texel是一个“弹簧”，逐Tick更新高度，并实时Tessellation</p></li>
</ul>
<h4 id="non-heightfield-terrain-悬崖山洞等">Non-Heightfield Terrain
悬崖、山洞等</h4>
<ul>
<li>传统做法：在悬崖、山洞处悬空插入物体</li>
<li>一种Trick：山洞处的顶点做标记，GPU处理退化消除；再向山洞中加入物体</li>
<li>目前用的较少一种的方法——体素化
<ul>
<li>体素化表达世界，在每个体素上存当前空间物质密度</li>
<li><strong>Marching Cube</strong>：14种方法把cube切分成三角面
<img src="/images/games104/L06_MarchingCube.jpg" alt="L06_MarchingCube" style="zoom:50%;" /></li>
<li>问题：Marching Cube怎么解决近密远疏并保证密封，LUT方法解决</li>
<li>全动态地形——支持打洞</li>
</ul></li>
</ul>
<h4 id="paint-terrain-materials">Paint Terrain Materials</h4>
<h5 id="混合贴图">混合贴图</h5>
<ul>
<li><p>问题：边缘过渡羽化
<img src="/images/games104/L06_SimpleTextureSplatting.jpg" alt="L06_SimpleTextureSplatting" style="zoom: 67%;" /></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> a1 <span class="op">+</span> texture2<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> a2<span class="op">;</span></span></code></pre></div></li>
<li><p>解决：Height作为Alpha
<img src="/images/games104/L06_HeightMapsAlphaBlending.png" alt="L06_HeightMapsAlphaBlending" style="zoom: 33%;" /></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> height1 <span class="op">&gt;</span> height2 <span class="op">?</span> texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">:</span> texture2<span class="op">.</span><span class="fu">rgb</span></span></code></pre></div></li>
<li><p>问题：0-1切换信息高频，在远观时过于Sharp 解决：Biased 扰动
<img src="/images/games104/L06_HeightMapsAlphaBlendingBiased.png" alt="L06_HeightMapsAlphaBlendingBiased" style="zoom: 33%;" /></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode glsl"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> depth <span class="op">=</span> <span class="fl">0.2</span><span class="op">;</span> <span class="co">//Height Bias</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> ma <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture1<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height1<span class="op">,</span> texture2<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height2<span class="op">)</span> <span class="op">-</span> depth<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b1 <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture1<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height1 <span class="op">-</span> ma<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b2 <span class="op">=</span> <span class="bu">max</span><span class="op">(</span>texture2<span class="op">.</span><span class="fu">a</span> <span class="op">+</span> height2 <span class="op">-</span> ma<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> <span class="op">(</span>texture1<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> b1 <span class="op">+</span> texture2<span class="op">.</span><span class="fu">rgb</span> <span class="op">*</span> b2<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>b1 <span class="op">+</span> b2<span class="op">);</span></span></code></pre></div></li>
<li><p>实战中：更多Texture -&gt; <strong>Texture Array</strong>
<code>TextureArray[Index]</code></p></li>
<li><p><strong>Parallax and Displacement Mapping</strong>
由于表面高度，看到位置B而非A
<img src="/images/games104/L06_ParallaxMapping.jpg" alt="L06_ParallaxMapping" style="zoom: 33%;" />
更彻底的方法：Displacement Mapping，直接改变Mesh
<img src="/images/games104/L06_ParallaxAndDisplacementMapping.png" alt="L06_ParallaxAndDisplacementMapping" style="zoom: 33%;" /></p></li>
<li><p>大量材质图读写的性能开销 -&gt; <strong>Virture
Texture</strong></p>
<ul>
<li>核心思想：把用到的部分装载在内存中，不用的放在硬盘上</li>
<li>把地形分成块（2的幂次切割），只加载能看到的地形</li>
<li><img src="/images/games104/L06_VirtualTexture.jpg" alt="L06_VirtualTexture" style="zoom: 50%;" /></li>
</ul></li>
</ul>
<h5 id="virtual-texture-implementation-directstorage-dma">Virtual
Texture Implementation, DirectStorage &amp; DMA</h5>
<ul>
<li>GPU cache管理
<img src="/images/games104/L06_GPUCacheManagement.jpg" alt="L06_GPUCacheManagement" style="zoom: 25%;" /></li>
<li>DirectStorage
<img src="/images/games104/L06_DirectStorage.jpg" alt="L06_DirectStorage" style="zoom: 67%;" /></li>
<li>DMA
<img src="/images/games104/L06_DMA.jpg" alt="L06_DMA" style="zoom: 50%;" /></li>
</ul>
<h5 id="浮点数精度溢出">浮点数精度溢出</h5>
<ul>
<li><p>浮点数数值小时精度高、数值大时精度低</p></li>
<li><p>摄影机离物体过远时，出现严重抖动与闪烁</p></li>
<li><p><strong>Camera-Relative Rendering 相机相对性渲染</strong>
在MVP变换之前，将相机位置设为世界坐标系原点；重新计算MVP矩阵</p></li>
<li><p>其他方法 eg. UE Sublevels，每个Sublevel重置坐标系</p></li>
</ul>
<h4 id="tree-rendering">Tree Rendering</h4>
<h4 id="decorator-rendering-装饰物草灌木等">Decorator Rendering
装饰物，草、灌木等</h4>
<h4 id="road-and-decals-rendering">Road and Decals Rendering</h4>
<ul>
<li>Road
<ul>
<li>Spline</li>
<li>Spline to Mesh，放置在地形上</li>
<li>路面侵蚀地形，处理高度场</li>
</ul></li>
<li>Decal 贴片，贴花</li>
<li>全部直接Bake到Virtual Texture上</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture5-Lighting, Materials and Shaders</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/</link>
      <pubDate>Sat, 17 Apr 2021 12:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture5-lightingmaterialsshaders/</guid>
      <description>Lecture05 Lighting, Materials and Shaders The Rendering Equation \[ {\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int _{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n} )\operatorname {d} \omega _{\text{i}}} \]
多重挑战：
如何得到入射光 Visibility to Lights, Shadow Light Source Complexity, 尤其面光源 如何快速地积分 如何计算次级光源，全局光照，无限递归 从简单开始 Ambient + Simple Light == Result
环境光贴图反射
相当于Rendering Equation特例化
Blinn-Phong \[ \begin{aligned}L&amp;amp;=L_{\text{ambient}}+L_{\text{diffuse}}+L_{\text{specular}}\\ &amp;amp;=k_{\text{ambient}}I_{\text{ambient}}+k_{\text{diffuse}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)+k_{\text{specular}}(I/r^2)\max(0,\mathbf n\cdot\mathbf l)^p \end{aligned} \] 问题：</description>
      <content:encoded><![CDATA[<h3 id="lecture05-lighting-materials-and-shaders">Lecture05 Lighting,
Materials and Shaders</h3>
<h4 id="the-rendering-equation">The Rendering Equation</h4>
<p><span class="math display">\[
{\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda
,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int
_{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega
_{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega
_{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n}
)\operatorname {d} \omega _{\text{i}}}
\]</span></p>
<p><img src="/images/games104/L05_Rendering.jpg" alt="L05_Rendering" style="zoom:50%;" /></p>
<p>多重挑战：</p>
<ul>
<li>如何得到入射光
<ul>
<li>Visibility to Lights, Shadow</li>
<li>Light Source Complexity, 尤其面光源</li>
</ul></li>
<li>如何快速地积分</li>
<li>如何计算次级光源，全局光照，无限递归</li>
</ul>
<h4 id="从简单开始">从简单开始</h4>
<ul>
<li><p>Ambient + Simple Light == Result</p></li>
<li><p>环境光贴图反射</p></li>
<li><p>相当于Rendering Equation特例化</p></li>
<li><p><strong>Blinn-Phong</strong> <span class="math display">\[
\begin{aligned}L&amp;=L_{\text{ambient}}+L_{\text{diffuse}}+L_{\text{specular}}\\
&amp;=k_{\text{ambient}}I_{\text{ambient}}+k_{\text{diffuse}}(I/r^2)\max(0,\mathbf
n\cdot\mathbf l)+k_{\text{specular}}(I/r^2)\max(0,\mathbf n\cdot\mathbf
l)^p
\end{aligned}
\]</span> 问题：</p>
<ul>
<li>能量不守恒/保守（离线渲染时能量会超出）</li>
<li>质感太塑料</li>
</ul></li>
<li><p><strong>Shadow Map</strong> 从灯光位置渲染深度Buffer</p>
<p>问题：</p>
<ul>
<li>采样问题 -&gt; 自遮挡</li>
<li>加入阈值 -&gt; 阴影与实体有距离</li>
</ul></li>
</ul>
<h4 id="预计算gi">预计算GI</h4>
<ul>
<li><p><span class="citation" data-cites="GAME202">@GAME202</span>
PRT</p></li>
<li><p>利用SH，用24bit就可以存储一个点的光场</p></li>
</ul>
<h5 id="sh-lightmap">SH Lightmap</h5>
<ul>
<li>UV Atlas
<img src="/images/games104/L05_UVAtlas.jpg" alt="L05_UVAtlas" style="zoom:50%;" /></li>
<li>烘焙光照</li>
<li>优点：高效、细节
缺点：预计算量大；只能处理静态（动态物体可以有Hack方法，但有问题）；GPU存储量大</li>
</ul>
<h5 id="light-probe">Light Probe</h5>
<ul>
<li>在空间中撒采样点（Probe）</li>
<li>每个Probe计算其光照</li>
<li>自动均匀撒采样点</li>
<li>反射Probe 一种特殊的Probe
<ul>
<li>采样精度高</li>
<li>分布密度低</li>
<li>提供非常好的反射效果</li>
</ul></li>
<li>优点：高效，静态动态均可用，可以处理diffuse和specular
缺点：效果没有Lightmap好（采样稀疏）</li>
</ul>
<h4 id="physical-based-material">Physical-Based Material</h4>
<p><span class="citation" data-cites="GAME202">@GAME202</span>
Physically-Based Material</p>
<ul>
<li><p>Microfacet BRDF</p></li>
<li><p>Disney Principled BRDF</p></li>
<li><p>主流应用：Specular Glossiness模型</p>
<ul>
<li>Diffuse - RGB - sRGB</li>
<li>Specular - RGB - sRGB</li>
<li>Glossiness - Grayscale - Linear</li>
<li>问题：过于灵活，Specular项易导致Fresnel项错乱</li>
</ul>
<p><img src="/images/games104/L05_SG.png" alt="L05_SG" style="zoom: 33%;" /></p></li>
<li><p>主流应用：Metallic Roughness模型</p>
<ul>
<li>Base Color - RGB - sRGB</li>
<li>Roughness - Grayscale - Linear</li>
<li>Metallic - Grayscale - Linear</li>
<li>在SG基础上封装，Metallic限制Specular的应用</li>
<li>非金属和金属过渡时可能有白边</li>
</ul>
<p><img src="/images/games104/L05_MR.png" alt="L05_MR" style="zoom: 33%;" /></p></li>
</ul>
<h4 id="image-based-lighting">Image-Based Lighting</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span>
Environment Lighting</p>
<ul>
<li>Diffuse Irradiance Map</li>
<li>Specular : Split Sum</li>
</ul>
<h4 id="classic-shadow-solution">Classic Shadow Solution</h4>
<h5 id="cascaded-shadow-map">Cascaded Shadow Map</h5>
<p><img src="/images/games104/L05_CSM.png" alt="L05_CSM" style="zoom: 25%;" /></p>
<p>挑战：不同层级之间的Blend</p>
<p>缺点：计算开销大（4ms）</p>
<h5 id="软阴影">软阴影</h5>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> Soft
Shadow</p>
<ul>
<li>PCF -&gt; PCSS</li>
<li>Variance Soft Shadow Map</li>
</ul>
<h4 id="上一世代的3a游戏渲染">上一世代的3A游戏渲染</h4>
<ul>
<li>Lightmap + Lightprobe</li>
<li>PBR + IBL</li>
<li>CSM + VSSM</li>
</ul>
<h4 id="现代3a游戏渲染">现代3A游戏渲染</h4>
<p><span class="citation" data-cites="GAMES202">@GAMES202</span> GI
&amp; RTRT</p>
<ul>
<li>RTRT</li>
<li>Real-Time GI
<ul>
<li>SSGI</li>
<li>SDF GI</li>
<li>VXGI</li>
<li>RSM</li>
<li>RTXGI</li>
<li>…</li>
</ul></li>
<li>更复杂的材质模型
<ul>
<li>BSDF 头发</li>
<li>BSSRDF</li>
</ul></li>
<li>Virtual Shadow Maps 把Shadow Maps放到一个巨大的Shadow
Map上（类似Virtual Texture）</li>
</ul>
<h4 id="shader管理">Shader管理</h4>
<ul>
<li>Uber Shader 宏定义做分支，GPU不适合分支，再将Uber
Shader编译成大量Shader。需要修改时，只需要修改Uber
Shader，一次编译所有结果。</li>
<li>跨平台的Shader编译
<ul>
<li>SPIR-V</li>
</ul></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture4-Rendering in Game Engine</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/</link>
      <pubDate>Sat, 17 Apr 2021 09:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture4-rendering/</guid>
      <description>Lecture04 Rendering in Game Engine 挑战
场景极其复杂 实时，帧率稳定 大纲
基础 硬件架构 渲染数据结构 可见性 材质、Shader、光照 PBR Shader Permutation 光照 点/方向光照 IBL / Simple GI 特殊的渲染 地形 天空 / 雾 后处理 Pipeline 前向渲染 Forward、延迟渲染 Deferred、Forward Plus Ring buffer and V-Sync Tiled-based Rendering @GAMES101
Vertex Data -&amp;gt; Triangle Data -&amp;gt; Material Parameters -&amp;gt; Textures
投影 -&amp;gt; 光栅化
eg. Computation - Texture Sampling
Step 1 : 使用相邻两层MIPMAP Step 2 : 在两层MIPMAP之间双线性插值 Step 3 : 结果像素之间的线性插值 GPU SIMD and SIMT SIMD : Single Instruction Multiple Data eg.</description>
      <content:encoded><![CDATA[<h3 id="lecture04-rendering-in-game-engine">Lecture04 Rendering in Game
Engine</h3>
<p><strong>挑战</strong></p>
<ul>
<li>场景极其复杂</li>
<li>实时，帧率稳定</li>
</ul>
<p><strong>大纲</strong></p>
<ul>
<li>基础
<ul>
<li>硬件架构</li>
<li>渲染数据结构</li>
<li>可见性</li>
</ul></li>
<li>材质、Shader、光照
<ul>
<li>PBR</li>
<li>Shader Permutation</li>
<li>光照</li>
<li>点/方向光照</li>
<li>IBL / Simple GI</li>
</ul></li>
<li>特殊的渲染
<ul>
<li>地形</li>
<li>天空 / 雾</li>
<li>后处理</li>
</ul></li>
<li>Pipeline
<ul>
<li>前向渲染 Forward、延迟渲染 Deferred、Forward Plus</li>
<li>Ring buffer and V-Sync</li>
<li>Tiled-based Rendering</li>
</ul></li>
</ul>
<blockquote>
<p><span class="citation" data-cites="GAMES101">@GAMES101</span></p>
<p>Vertex Data -&gt; Triangle Data -&gt; Material Parameters -&gt;
Textures</p>
<p>投影 -&gt; 光栅化</p>
</blockquote>
<p>eg. Computation - Texture Sampling</p>
<ul>
<li>Step 1 : 使用相邻两层MIPMAP</li>
<li>Step 2 : 在两层MIPMAP之间双线性插值</li>
<li>Step 3 : 结果像素之间的线性插值</li>
</ul>
<h4 id="gpu">GPU</h4>
<h5 id="simd-and-simt">SIMD and SIMT</h5>
<ul>
<li><p>SIMD : Single Instruction Multiple Data
eg.四维向量同时加减</p></li>
<li><p>SIMT : Single Instruction Multiple Threads
同时处理大量SIMD任务</p></li>
</ul>
<h5 id="计算单元">计算单元</h5>
<ul>
<li>GPC Graphics Processing Cluster</li>
<li>SM Streaming Multiprocessor</li>
<li>Texture Units</li>
<li>CUDA Core</li>
<li>Warp (a collection of threads)</li>
</ul>
<p>Application Performance is limited by:</p>
<ul>
<li>Memory Bounds</li>
<li>ALU Bounds</li>
<li>TMU(Texture Mapping Unit) Bound</li>
<li>BW(Bandwidth) Bound</li>
</ul>
<h4 id="renderable---可渲染的内容component">Renderable -
可渲染的内容（Component）</h4>
<ul>
<li>Mesh
<ul>
<li>Mesh Primitives</li>
<li>Vertex and Index Buffer &gt;
每顶点存储法向：避免有两个顶点重合时法向错乱</li>
</ul></li>
<li>Material
<ul>
<li>Textures</li>
<li>Shaders</li>
</ul></li>
</ul>
<p><img src="/images/games104/L04_Renderable1.png" alt="L04_Renderable1" style="zoom:33%;" /></p>
<p>一个Mesh有多种材质 —— SubMesh</p>
<p><img src="/images/games104/L04_Renderable2.png" alt="L04_Renderable2" style="zoom: 25%;" /></p>
<p>节约空间：Mesh / Shader / Texture 各存储一个Pool，使用时用索引 ——
<strong>Instance</strong></p>
<p><img src="/images/games104/L04_Renderable3.png" alt="L04_Renderable3" style="zoom: 25%;" /></p>
<p>对场景按场景排序渲染 —— 对GPU友好，可以加速</p>
<p>GPU Batch Rendering 渲染一次，再做Offset</p>
<h5 id="visibility-culling">Visibility Culling</h5>
<ul>
<li>View Frustum之外的不渲染</li>
<li>对空间做划分（前文介绍，四叉树 / <strong>BVH</strong>）
BVH构建块，应用多</li>
<li>PVS, Potential Visibility Set 根据房间门是否可见裁剪
<img src="/images/games104/L04_PVS.png" alt="L04_PVS" style="zoom: 25%;" />
现在已应用不广，但思想可以用于资源加载等场景</li>
<li>GPU Culling 利用G-Buffer，延迟渲染</li>
</ul>
<h5 id="纹理压缩">纹理压缩</h5>
<ul>
<li>不能用JPG/PNG等复杂压缩</li>
<li>Block Compression：将图片切分为一个个小块（例如4*4）压缩 eg.
在小块中保留最大值最小值，其他值使用这两值的线性插值</li>
</ul>
<h5 id="authoring-tools-of-modeling">Authoring Tools of Modeling</h5>
<ul>
<li><strong>Polygon</strong> : MAX / MAYA / Blender</li>
<li><strong>Sculpting</strong> : Zbrush</li>
<li><strong>Scanning</strong></li>
<li><strong>Procedural</strong> : Houdini</li>
</ul>
<h5 id="cluster-based-mesh-pipeline">Cluster-Based Mesh Pipeline</h5>
<ul>
<li>核心思想：对于非常精细的模型，将其分成无数一组面片组成的Cluster</li>
<li>提供Mesh Shader：GPU处理同样的Cluster，实现更精细的细节</li>
<li>可以基于Cluster做裁剪</li>
<li>Nanite in UE5</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022-04-17-GAMES104现代游戏引擎-Lecture2-3-游戏引擎架构</title>
      <link>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/</link>
      <pubDate>Sat, 17 Apr 2021 08:00:00 +0800</pubDate>
      
      <guid>https://elderlyaugustus.github.io/posts/2022-04-17-games104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E-lecture2-3-gameenginearchitechure/</guid>
      <description>Lecture02 游戏引擎分层结构 工具层 Tool Layer 编辑器
功能层 Function Layer 渲染/模拟/玩法/交互/…
资源层 Resource Layer 数据和文件
核心层 Core Layer 内存管理/资源分配/数学模块
平台层 Platform Layer 硬件设备的调用
PS：中间件/第三方库
情景：制作一个动画角色
Resource 怎么获取数据
Offline Importing resource -&amp;gt; assets 将resource转换为asset的文件格式 asset读取更快 建构所有资产的关联关系（reference） GUID 实时/运行时（Runtime）资产管理器 基于路径加载/卸载asset 通过Handle系统管理asset的生命周期和参考 Function 怎么使世界动起来
tick() tickLogic() tickRender() 有大量系统组成 必定属于引擎功能层的：渲染/模拟等 引擎功能层/游戏Gameplay有时有一定冲突 多线程 固定线程：不同线程作不同功能 主流用法，Job join：将模拟/动画等适合多线程的任务平均分配 原子化/任务系统：转换为一个个Job分配给所有线程 Core
数学库
线性代数
为什么要单独写数学库 - 效率
eg. 卡马克快速平方根（牛顿迭代）
SIMD 一条指令完成四个数操作（非常适合齐次坐标运算）
数据结构
vector / map / tree / … 为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作 内存管理 - 追求最高效率</description>
      <content:encoded><![CDATA[<h3 id="lecture02-游戏引擎分层结构">Lecture02 游戏引擎分层结构</h3>
<ul>
<li><p><strong>工具层 Tool Layer</strong> 编辑器</p></li>
<li><p><strong>功能层 Function Layer</strong>
渲染/模拟/玩法/交互/…</p></li>
<li><p><strong>资源层 Resource Layer</strong> 数据和文件</p></li>
<li><p><strong>核心层 Core Layer</strong>
内存管理/资源分配/数学模块</p></li>
<li><p><strong>平台层 Platform Layer</strong> 硬件设备的调用</p></li>
<li><p>PS：<strong>中间件/第三方库</strong></p></li>
</ul>
<p>情景：制作一个动画角色</p>
<ul>
<li><p>Resource 怎么获取数据</p>
<ul>
<li>Offline Importing resource -&gt; assets
<ul>
<li>将resource转换为asset的文件格式</li>
<li>asset读取更快</li>
<li>建构所有资产的关联关系（reference）</li>
<li>GUID</li>
</ul></li>
<li>实时/运行时（Runtime）资产管理器
<ul>
<li>基于路径加载/卸载asset</li>
<li>通过Handle系统管理asset的生命周期和参考</li>
</ul></li>
</ul></li>
<li><p>Function 怎么使世界动起来</p>
<ul>
<li>tick()
<ul>
<li>tickLogic()</li>
<li>tickRender()</li>
</ul></li>
<li>有大量系统组成
<ul>
<li>必定属于引擎功能层的：渲染/模拟等</li>
<li>引擎功能层/游戏Gameplay有时有一定冲突</li>
</ul></li>
<li>多线程
<ul>
<li>固定线程：不同线程作不同功能</li>
<li>主流用法，Job join：将模拟/动画等适合多线程的任务平均分配</li>
<li>原子化/任务系统：转换为一个个Job分配给所有线程</li>
</ul></li>
</ul></li>
<li><p>Core</p>
<ul>
<li><p>数学库</p>
<ul>
<li><p>线性代数</p></li>
<li><p>为什么要单独写数学库 - 效率</p>
<ul>
<li><p>eg. 卡马克快速平方根（牛顿迭代）</p></li>
<li><p>SIMD 一条指令完成四个数操作（非常适合齐次坐标运算）</p></li>
</ul></li>
</ul></li>
<li><p>数据结构</p>
<ul>
<li>vector / map / tree / …</li>
<li>为什么要在STL外单独写 - 效率 STL中经常有浪费内存的操作</li>
</ul></li>
<li><p>内存管理 - 追求最高效率</p>
<ul>
<li>性能的主要瓶颈
<ul>
<li>内存池 / 分配器</li>
<li>减少cache浪费</li>
<li>内存对齐</li>
</ul></li>
<li>PMR 多种内存资源 cache level 1 / 2 / 3 / RAM / Storage</li>
<li>优化核心思路
<ul>
<li>把数据放一起</li>
<li>按顺序读取数据</li>
<li>按块分配/释放内存</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Platform</p>
<ul>
<li>文件系统（路径）</li>
<li>图形API
<ul>
<li>OpenGL / Vulkan / DirectX / Metal</li>
<li>RHI (Render Haraware Interface) 实现一套“API”，封装各种底层API</li>
</ul></li>
<li>硬件架构
<ul>
<li>PC / PlayStation / 手机 / …</li>
<li>多核逻辑（大小核）</li>
</ul></li>
</ul></li>
<li><p>Tool 允许他人创作游戏</p>
<ul>
<li>开发相对灵活，根据用户需求，工具层的代码量和工作量可能比其他四层还大</li>
<li>DCC, Asset Conditioning Pipeline
引擎工具层的编辑器和DCC的编辑器要数据通畅</li>
</ul></li>
</ul>
<p>为什么游戏引擎要分层</p>
<ul>
<li>解耦并减少复杂度
<ul>
<li>上下层相互独立</li>
<li>上层不需要知道底层怎样实现</li>
</ul></li>
<li>迎合不断变化的需求
<ul>
<li>上层变化大，底层较稳定</li>
</ul></li>
</ul>
<h3 id="lecture03-如何构建游戏世界">Lecture03 如何构建游戏世界</h3>
<h4 id="game-object-go-游戏对象">Game Object (GO) 游戏对象</h4>
<ul>
<li>动态游戏对象 eg.坦克、飞机…</li>
<li>静态游戏对象 eg.建筑、陈设…</li>
<li>环境 eg.场景、天空、植被（随风运动，也可以是动态游戏对象）…</li>
<li>其他对象 eg.空气墙、规则区…</li>
</ul>
<p>以一个无人机为例</p>
<ul>
<li>Property 属性
<ul>
<li>外形</li>
<li>位置</li>
<li>血量</li>
<li>电池量</li>
<li>…</li>
</ul></li>
<li>Behaviors 行为
<ul>
<li>运动</li>
<li>侦察</li>
<li>…</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Drone <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Properties */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    vec3 position<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> health<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fuel<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Behavior */</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> move<span class="op">();</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> scout<span class="op">();</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>拓展一个武装无人机：继承</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ArmedDrone <span class="op">:</span> <span class="kw">public</span> Drone <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> ammo<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> fire<span class="op">();</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>游戏复杂后，没有那么清晰的从属关系——<strong>组件化</strong></p>
<p><img src="/images/games104/L03_Component.png" alt="L03_Component" style="zoom:25%;" /></p>
<h4 id="如何让世界动起来">如何让世界动起来</h4>
<p>Tick()</p>
<ul>
<li>每个物体、每个组件Tick()</li>
<li>工程中，以系统为单位Tick()：Gameplay、模拟、渲染…</li>
</ul>
<p>GO之间的交互 eg.坦克击中人</p>
<ul>
<li>Hardcode：坦克发射，生成新的子弹GO，逐个碰撞对象判断、处理。但工程复杂后非常难用。</li>
<li><strong>Events事件机制</strong>：用Event标记伤害，Tick()时读取Event作出响应执行回调函数
——解耦合，可扩展的消息系统，每个component对接消息进行处理</li>
</ul>
<p>如何管理GO</p>
<ul>
<li>在场景中标记GO
<ul>
<li>UID</li>
<li>空间位置</li>
</ul></li>
<li>场景管理方法
<ul>
<li>不分割 效率低，适合小游戏</li>
<li>Grid分割 适合不是特别大的游戏</li>
<li>GO分布不均匀时 -&gt; <strong>层级结构</strong>
<ul>
<li><strong>BVH</strong></li>
<li><strong>BSP Binary Space Partitioning</strong></li>
<li><strong>四叉/八叉树</strong></li>
<li><strong>Scene Graph</strong></li>
</ul></li>
</ul></li>
</ul>
<p>还有很多问题…</p>
<ul>
<li><p>GO的绑定 eg.人在车上时，人和车应共同移动</p></li>
<li><p>Event系统GO互相发消息的问题：多个消息冲突，引入中心发信机构，“邮局”</p></li>
<li><p>GO之间的循环依赖</p></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
